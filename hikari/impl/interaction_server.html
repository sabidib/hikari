<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.impl.interaction_server API documentation</title>
<meta name="description" content="Standard implementation of a REST based interactions server.">
<meta property="og:title" content="hikari.impl.interaction_server module list">
<meta property="og:type" content="website">
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png">
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions">
<meta property="theme-color" content="#ff029a">
<link rel="shortcut icon" type="image/png" href="../../logo.png">
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
text-indent: 100%;
white-space: nowrap;
overflow: hidden;
}
small.smaller {
font-size: 0.50em;
}
html {
height: 100%;
scroll-behavior: smooth;
scrollbar-color: #202324 #454a4d;
}
body {
background-color: #181A1B;
color: #C9C5C0;
height: fit-content;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.container > li {
margin-left: 1em;
margin-top: 2.5em;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
.anchor:target {
background-color: var(--dark);
}
@media screen and (max-width: 990px) {
.anchor:target {
margin-left: -2em;
padding-left: 2em;
}
}
@media screen and (min-width: 990px) {
.anchor:target {
border-radius: 0.5em; !important
margin-right: -2em;
padding-right: 2em;
margin-top: -1em;
padding-top: 1em;
}
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="../../logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small class="smaller">2.0.0.dev102</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
<li class="nav-item"><a class="nav-link active" href="../../hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" action="../../hikari/search.html">
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search" name="q"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.impl -- Basic implementations of application components …" href="index.html"
>impl</a></li>
<li class="breadcrumb-item active"><a href="#">interaction_server</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Standard implementation of a REST based interactions server.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="InteractionServer -- Standard implementation of `hikari.api.interaction_server.InteractionServer` …" href="#hikari.impl.interaction_server.InteractionServer"
>InteractionServer</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="aiohttp_hook -- Handle an AIOHTTP interaction request …" href="#hikari.impl.interaction_server.InteractionServer.aiohttp_hook"
>aiohttp_hook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="close -- Gracefully close the server and any open connections." href="#hikari.impl.interaction_server.InteractionServer.close"
>close</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_listener -- Get the listener registered for an interaction …" href="#hikari.impl.interaction_server.InteractionServer.get_listener"
>get_listener</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_alive -- Whether this interaction server is active …" href="#hikari.impl.interaction_server.InteractionServer.is_alive"
>is_alive</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="join -- Wait for the process to halt before continuing." href="#hikari.impl.interaction_server.InteractionServer.join"
>join</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="on_interaction -- Handle an interaction received from Discord as a REST server …" href="#hikari.impl.interaction_server.InteractionServer.on_interaction"
>on_interaction</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_listener -- Set the listener callback for this interaction server …" href="#hikari.impl.interaction_server.InteractionServer.set_listener"
>set_listener</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="start -- Start the bot and wait for the internal server to startup then return …" href="#hikari.impl.interaction_server.InteractionServer.start"
>start</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/interaction_server.py#L1-L552" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
# Copyright (c) 2021 davfsa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Standard implementation of a REST based interactions server.&#34;&#34;&#34;
from __future__ import annotations

__all__: typing.List[str] = [&#34;InteractionServer&#34;]

import asyncio
import logging
import typing

import aiohttp.web
import aiohttp.web_runner

from hikari import applications
from hikari import errors
from hikari.api import interaction_server
from hikari.api import special_endpoints
from hikari.interactions import base_interactions
from hikari.internal import data_binding
from hikari.internal import ed25519

if typing.TYPE_CHECKING:
    import socket as socket_
    import ssl

    import aiohttp.typedefs

    from hikari.api import entity_factory as entity_factory_api
    from hikari.api import rest as rest_api
    from hikari.interactions import command_interactions
    from hikari.interactions import component_interactions

    _InteractionT_co = typing.TypeVar(&#34;_InteractionT_co&#34;, bound=base_interactions.PartialInteraction, covariant=True)
    _ResponseT_co = typing.TypeVar(&#34;_ResponseT_co&#34;, bound=special_endpoints.InteractionResponseBuilder, covariant=True)
    _MessageResponseBuilderT = typing.Union[
        special_endpoints.InteractionDeferredBuilder, special_endpoints.InteractionMessageBuilder
    ]

_LOGGER: typing.Final[logging.Logger] = logging.getLogger(&#34;hikari.interaction_server&#34;)

# Internal interaction and interaction response types.
_PING_INTERACTION_TYPE: typing.Final[int] = 1
_PONG_RESPONSE_TYPE: typing.Final[int] = 1

# HTTP status codes.
_OK_STATUS: typing.Final[int] = 200
_BAD_REQUEST_STATUS: typing.Final[int] = 400
_PAYLOAD_TOO_LARGE_STATUS: typing.Final[int] = 413
_UNSUPPORTED_MEDIA_TYPE_STATUS: typing.Final[int] = 415
_INTERNAL_SERVER_ERROR_STATUS: typing.Final[int] = 500
_NOT_IMPLEMENTED: typing.Final[int] = 501

_UTF_8_CHARSET: typing.Final[str] = &#34;UTF-8&#34;

# Header keys and values
_X_SIGNATURE_ED25519_HEADER: typing.Final[str] = &#34;X-Signature-Ed25519&#34;
_X_SIGNATURE_TIMESTAMP_HEADER: typing.Final[str] = &#34;X-Signature-Timestamp&#34;
_CONTENT_TYPE_KEY: typing.Final[str] = &#34;Content-Type&#34;
_USER_AGENT_KEY: typing.Final[str] = &#34;User-Agent&#34;
_JSON_CONTENT_TYPE: typing.Final[str] = &#34;application/json&#34;
_JSON_TYPE_WITH_CHARSET: typing.Final[str] = f&#34;{_JSON_CONTENT_TYPE}; charset={_UTF_8_CHARSET}&#34;
_TEXT_CONTENT_TYPE: typing.Final[str] = &#34;text/plain&#34;
_TEXT_TYPE_WITH_CHARSET: typing.Final[str] = f&#34;{_TEXT_CONTENT_TYPE}; charset={_UTF_8_CHARSET}&#34;


class _Response:
    __slots__: typing.Sequence[str] = (&#34;_headers&#34;, &#34;_payload&#34;, &#34;_status_code&#34;)

    def __init__(
        self,
        status_code: int,
        payload: typing.Optional[bytes] = None,
        *,
        content_type: typing.Optional[str] = None,
    ) -&gt; None:
        self._headers = None
        if payload or content_type:
            self._headers = {_CONTENT_TYPE_KEY: content_type or _TEXT_TYPE_WITH_CHARSET}

        self._payload = payload
        self._status_code = status_code

    @property
    def headers(self) -&gt; typing.Optional[typing.Mapping[str, str]]:
        return self._headers

    @property
    def payload(self) -&gt; typing.Optional[bytes]:
        return self._payload

    @property
    def status_code(self) -&gt; int:
        return self._status_code


# Constant response
_PONG_RESPONSE: typing.Final[_Response] = _Response(
    _OK_STATUS, data_binding.dump_json({&#34;type&#34;: _PONG_RESPONSE_TYPE}).encode(), content_type=_JSON_TYPE_WITH_CHARSET
)


class InteractionServer(interaction_server.InteractionServer):
    &#34;&#34;&#34;Standard implementation of `hikari.api.interaction_server.InteractionServer`.

    Parameters
    ----------
    entity_factory : hikari.api.entity_factory.EntityFactory
        The entity factory instance this server should use.

    Other Parameters
    ----------------
    dumps : aiohttp.typedefs.JSONEncoder
        The JSON encoder this server should use. Defaults to `json.dumps`.
    loads : aiohttp.typedefs.JSONDecoder
        The JSON decoder this server should use. Defaults to `json.loads`.
    public_key : builtins.bytes
        The public key this server should use for verifying request payloads from
        Discord. If left as `builtins.None` then the client will try to work this
        out using `rest_client`.
    rest_client : hikari.api.rest.RESTClient
        The client this should use for making REST requests.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_application_fetch_lock&#34;,
        &#34;_close_event&#34;,
        &#34;_dumps&#34;,
        &#34;_entity_factory&#34;,
        &#34;_is_closing&#34;,
        &#34;_listeners&#34;,
        &#34;_loads&#34;,
        &#34;_rest_client&#34;,
        &#34;_server&#34;,
        &#34;_verify&#34;,
    )

    def __init__(
        self,
        *,
        dumps: aiohttp.typedefs.JSONEncoder = data_binding.dump_json,
        entity_factory: entity_factory_api.EntityFactory,
        loads: aiohttp.typedefs.JSONDecoder = data_binding.load_json,
        rest_client: rest_api.RESTClient,
        public_key: typing.Optional[bytes] = None,
    ) -&gt; None:
        # Building asyncio.Lock when there isn&#39;t a running loop may lead to runtime errors.
        self._application_fetch_lock: typing.Optional[asyncio.Lock] = None
        # Building asyncio.Event when there isn&#39;t a running loop may lead to runtime errors.
        self._close_event: typing.Optional[asyncio.Event] = None
        self._dumps = dumps
        self._entity_factory = entity_factory
        self._is_closing = False
        self._listeners: typing.Dict[typing.Type[base_interactions.PartialInteraction], typing.Any] = {}
        self._loads = loads
        self._rest_client = rest_client
        self._server: typing.Optional[aiohttp.web_runner.AppRunner] = None
        self._verify = ed25519.build_ed25519_verifier(public_key) if public_key is not None else None

    @property
    def is_alive(self) -&gt; bool:
        &#34;&#34;&#34;Whether this interaction server is active.

        Returns
        -------
        builtins.bool
            Whether this interaction server is active
        &#34;&#34;&#34;
        return self._server is not None

    async def _fetch_public_key(self) -&gt; ed25519.VerifierT:
        if self._application_fetch_lock is None:
            self._application_fetch_lock = asyncio.Lock()

        application: typing.Union[applications.Application, applications.AuthorizationApplication]
        async with self._application_fetch_lock:
            if self._verify:
                return self._verify

            if self._rest_client.token_type == applications.TokenType.BOT:
                application = await self._rest_client.fetch_application()

            else:
                application = (await self._rest_client.fetch_authorization()).application

            self._verify = ed25519.build_ed25519_verifier(application.public_key)
            return self._verify

    async def aiohttp_hook(self, request: aiohttp.web.Request) -&gt; aiohttp.web.Response:
        &#34;&#34;&#34;Handle an AIOHTTP interaction request.

        This method handles aiohttp specific detail before calling
        `InteractionServer.on_interaction` with the data extracted from the
        request if it can and handles building an aiohttp response.

        Parameters
        ----------
        request : aiohttp.web.Request
            The received request.

        Returns
        -------
        aiohtttp.web.Response
            The aiohttp response.
        &#34;&#34;&#34;
        if request.content_type.lower() != _JSON_CONTENT_TYPE:
            _LOGGER.debug(&#34;Payload with invalid media type %r received&#34;, request.content_type)
            return aiohttp.web.Response(
                status=_UNSUPPORTED_MEDIA_TYPE_STATUS,
                body=b&#34;Unsupported Media Type&#34;,
                content_type=_TEXT_CONTENT_TYPE,
                charset=_UTF_8_CHARSET,
            )

        try:
            signature_header = bytes.fromhex(request.headers[_X_SIGNATURE_ED25519_HEADER])
            timestamp_header = request.headers[_X_SIGNATURE_TIMESTAMP_HEADER].encode()

        except (KeyError, ValueError):
            user_agent = request.headers.get(_USER_AGENT_KEY, &#34;NONE&#34;)
            _LOGGER.debug(&#34;Received a request with a missing or invalid signature header (UA %r)&#34;, user_agent)
            return aiohttp.web.Response(
                status=_BAD_REQUEST_STATUS,
                body=b&#34;Missing or invalid required request signature header(s)&#34;,
                content_type=_TEXT_CONTENT_TYPE,
                charset=_UTF_8_CHARSET,
            )

        try:
            body = await request.read()

        except aiohttp.web.HTTPRequestEntityTooLarge:
            _LOGGER.debug(&#34;Received a request with a payload that&#39;s too large to process&#34;)
            return aiohttp.web.Response(
                status=_PAYLOAD_TOO_LARGE_STATUS,
                body=b&#34;Payload too large&#34;,
                content_type=_TEXT_CONTENT_TYPE,
                charset=_UTF_8_CHARSET,
            )

        if not body:
            user_agent = request.headers.get(_USER_AGENT_KEY, &#34;NONE&#34;)
            _LOGGER.debug(&#34;Received a body-less request (UA %r)&#34;, user_agent)
            return aiohttp.web.Response(
                status=_BAD_REQUEST_STATUS,
                body=b&#34;POST request must have a body&#34;,
                content_type=_TEXT_CONTENT_TYPE,
                charset=_UTF_8_CHARSET,
            )

        response = await self.on_interaction(body=body, signature=signature_header, timestamp=timestamp_header)
        return aiohttp.web.Response(status=response.status_code, headers=response.headers, body=response.payload)

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Gracefully close the server and any open connections.&#34;&#34;&#34;
        if not self._server or not self._close_event:
            raise errors.ComponentStateConflictError(&#34;Cannot close an inactive interaction server&#34;)

        if self._is_closing:
            await self.join()
            return

        self._is_closing = True
        self._application_fetch_lock = None
        # This shutdown then cleanup ordering matters.
        await self._server.shutdown()
        await self._server.cleanup()
        self._close_event.set()
        self._close_event = None
        self._server = None

    async def join(self) -&gt; None:
        &#34;&#34;&#34;Wait for the process to halt before continuing.&#34;&#34;&#34;
        if not self._close_event:
            raise errors.ComponentStateConflictError(&#34;Cannot wait for an inactive interaction server to join&#34;)

        await self._close_event.wait()

    async def on_interaction(self, body: bytes, signature: bytes, timestamp: bytes) -&gt; interaction_server.Response:
        &#34;&#34;&#34;Handle an interaction received from Discord as a REST server.

        !!! note
            If this server instance is alive then this will be called internally
            by the server but if the instance isn&#39;t alive then this may still be
            called externally to trigger interaction dispatch.

        Parameters
        ----------
        body : builtins.bytes
            The interaction payload.
        signature : builtins.bytes
            Value of the `&#34;X-Signature-Ed25519&#34;` header used to verify the body.
        timestamp : builtins.bytes
            Value of the `&#34;X-Signature-Timestamp&#34;` header used to verify the body.

        Returns
        -------
        hikari.api.interaction_server.Response
            Instructions on how the REST server calling this should respond to
            the interaction request.
        &#34;&#34;&#34;
        verify = self._verify or await self._fetch_public_key()

        if not verify(body, signature, timestamp):
            _LOGGER.error(&#34;Received a request with an invalid signature&#34;)
            return _Response(_BAD_REQUEST_STATUS, b&#34;Invalid request signature&#34;)

        try:
            payload = self._loads(body.decode(&#34;utf-8&#34;))
            interaction_type = int(payload[&#34;type&#34;])

        except (data_binding.JSONDecodeError, ValueError, TypeError) as exc:
            _LOGGER.error(&#34;Received a request with an invalid JSON body&#34;, exc_info=exc)
            return _Response(_BAD_REQUEST_STATUS, b&#34;Invalid JSON body&#34;)

        except KeyError as exc:
            _LOGGER.error(&#34;Missing &#39;type&#39; field in received JSON payload&#34;, exc_info=exc)
            return _Response(_BAD_REQUEST_STATUS, b&#34;Missing required &#39;type&#39; field in payload&#34;)

        if interaction_type == _PING_INTERACTION_TYPE:
            _LOGGER.debug(&#34;Responding to ping interaction&#34;)
            return _PONG_RESPONSE

        try:
            interaction = self._entity_factory.deserialize_interaction(payload)

        except errors.UnrecognisedEntityError:
            _LOGGER.debug(&#34;Ignoring unknown interaction type %s&#34;, interaction_type)
            return _Response(_NOT_IMPLEMENTED, b&#34;Interaction type not implemented&#34;)

        except Exception as exc:
            asyncio.get_running_loop().call_exception_handler(
                {&#34;message&#34;: &#34;Exception occurred during interaction deserialization&#34;, &#34;exception&#34;: exc}
            )
            return _Response(_INTERNAL_SERVER_ERROR_STATUS, b&#34;Exception occurred during interaction deserialization&#34;)

        if listener := self._listeners.get(type(interaction)):
            _LOGGER.debug(&#34;Dispatching interaction %s&#34;, interaction.id)
            try:
                result = await listener(interaction)
                payload = self._dumps(result.build(self._entity_factory))

            except Exception as exc:
                asyncio.get_running_loop().call_exception_handler(
                    {&#34;message&#34;: &#34;Exception occurred during interaction dispatch&#34;, &#34;exception&#34;: exc}
                )
                return _Response(_INTERNAL_SERVER_ERROR_STATUS, b&#34;Exception occurred during interaction dispatch&#34;)

            return _Response(_OK_STATUS, payload.encode(), content_type=_JSON_TYPE_WITH_CHARSET)

        _LOGGER.debug(
            &#34;Ignoring interaction %s of type %s without registered listener&#34;, interaction.id, interaction.type
        )
        return _Response(_NOT_IMPLEMENTED, b&#34;Handler not set for this interaction type&#34;)

    async def start(
        self,
        backlog: int = 128,
        enable_signal_handlers: bool = True,
        host: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        port: typing.Optional[int] = None,
        path: typing.Optional[str] = None,
        reuse_address: typing.Optional[bool] = None,
        reuse_port: typing.Optional[bool] = None,
        socket: typing.Optional[socket_.socket] = None,
        shutdown_timeout: float = 60.0,
        ssl_context: typing.Optional[ssl.SSLContext] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Start the bot and wait for the internal server to startup then return.

        Other Parameters
        ----------------
        backlog : builtins.int
            The number of unaccepted connections that the system will allow before
            refusing new connections.
        enable_signal_handlers : builtins.bool
            Defaults to `builtins.True`. If on a __non-Windows__ OS with builtin
            support for kernel-level POSIX signals, then setting this to
            `builtins.True` will allow treating keyboard interrupts and other
            OS signals to safely shut down the application as calls to
            shut down the application properly rather than just killing the
            process in a dirty state immediately. You should leave this disabled
            unless you plan to implement your own signal handling yourself.
        host : typing.Optional[typing.Union[builtins.str, aiohttp.web.HostSequence]]
            TCP/IP host or a sequence of hosts for the HTTP server.
        port : typing.Optional[builtins.int]
            TCP/IP port for the HTTP server.
        path : typing.Optional[builtins.str]
            File system path for HTTP server unix domain socket.
        reuse_address : typing.Optional[builtins.bool]
            Tells the kernel to reuse a local socket in TIME_WAIT state, without
            waiting for its natural timeout to expire.
        reuse_port : typing.Optional[builtins.bool]
            Tells the kernel to allow this endpoint to be bound to the same port
            as other existing endpoints are also bound to.
        socket : typing.Optional[socket.socket]
            A pre-existing socket object to accept connections on.
        shutdown_timeout : builtins.float
            A delay to wait for graceful server shutdown before forcefully
            disconnecting all open client sockets. This defaults to 60 seconds.
        ssl_context : typing.Optional[ssl.SSLContext]
            SSL context for HTTPS servers.

        !!! note
            For more information on the other parameters such as defaults see
            AIOHTTP&#39;s documentation.
        &#34;&#34;&#34;
        if self._server:
            raise errors.ComponentStateConflictError(&#34;Cannot start an already active interaction server&#34;)

        self._close_event = asyncio.Event()
        self._is_closing = False
        aio_app = aiohttp.web.Application()
        aio_app.add_routes([aiohttp.web.post(&#34;/&#34;, self.aiohttp_hook)])
        self._server = aiohttp.web_runner.AppRunner(aio_app, handle_signals=enable_signal_handlers, access_log=_LOGGER)
        await self._server.setup()
        sites: typing.List[aiohttp.web.BaseSite] = []

        if host is not None:
            if isinstance(host, str):
                host = [host]

            for h in host:
                sites.append(
                    aiohttp.web.TCPSite(
                        self._server,
                        h,
                        port,
                        shutdown_timeout=shutdown_timeout,
                        ssl_context=ssl_context,
                        backlog=backlog,
                        reuse_address=reuse_address,
                        reuse_port=reuse_port,
                    )
                )

        elif path is None and socket is None or port is None:
            sites.append(
                aiohttp.web.TCPSite(
                    self._server,
                    port=port,
                    shutdown_timeout=shutdown_timeout,
                    ssl_context=ssl_context,
                    backlog=backlog,
                    reuse_address=reuse_address,
                    reuse_port=reuse_port,
                )
            )

        if path is not None:
            sites.append(
                aiohttp.web.UnixSite(
                    self._server, path, shutdown_timeout=shutdown_timeout, ssl_context=ssl_context, backlog=backlog
                )
            )

        if socket is not None:
            sites.append(
                aiohttp.web.SockSite(
                    self._server, socket, shutdown_timeout=shutdown_timeout, ssl_context=ssl_context, backlog=backlog
                )
            )

        for site in sites:
            _LOGGER.info(&#34;Starting site on %s&#34;, site.name)
            await site.start()

    @typing.overload
    def get_listener(
        self, interaction_type: typing.Type[command_interactions.CommandInteraction], /
    ) -&gt; typing.Optional[
        interaction_server.ListenerT[command_interactions.CommandInteraction, _MessageResponseBuilderT]
    ]:
        ...

    @typing.overload
    def get_listener(
        self, interaction_type: typing.Type[component_interactions.ComponentInteraction], /
    ) -&gt; typing.Optional[
        interaction_server.ListenerT[component_interactions.ComponentInteraction, _MessageResponseBuilderT]
    ]:
        ...

    def get_listener(
        self, interaction_type: typing.Type[_InteractionT_co], /
    ) -&gt; typing.Optional[interaction_server.ListenerT[_InteractionT_co, special_endpoints.InteractionResponseBuilder]]:
        return self._listeners.get(interaction_type)

    @typing.overload
    def set_listener(
        self,
        interaction_type: typing.Type[command_interactions.CommandInteraction],
        listener: typing.Optional[
            interaction_server.ListenerT[command_interactions.CommandInteraction, _MessageResponseBuilderT]
        ],
        /,
        *,
        replace: bool = False,
    ) -&gt; None:
        ...

    @typing.overload
    def set_listener(
        self,
        interaction_type: typing.Type[component_interactions.ComponentInteraction],
        listener: typing.Optional[
            interaction_server.ListenerT[component_interactions.ComponentInteraction, _MessageResponseBuilderT]
        ],
        /,
        *,
        replace: bool = False,
    ) -&gt; None:
        ...

    def set_listener(
        self,
        interaction_type: typing.Type[_InteractionT_co],
        listener: typing.Optional[
            interaction_server.ListenerT[_InteractionT_co, special_endpoints.InteractionResponseBuilder]
        ],
        /,
        *,
        replace: bool = False,
    ) -&gt; None:
        if listener:
            if not replace and interaction_type in self._listeners:
                raise TypeError(f&#34;Listener already set for {interaction_type.__name__}&#34;)

            self._listeners[interaction_type] = listener

        else:
            self._listeners.pop(interaction_type, None)</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.impl.interaction_server.InteractionServer" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="InteractionServer -- Standard implementation of `hikari.api.interaction_server.InteractionServer` …" href="#hikari.impl.interaction_server.InteractionServer"
>InteractionServer</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.interaction_server.InteractionServer" class="hljs python"><abbr title='A standard Python type.'>class</abbr> InteractionServer (
    *,
    dumps: aiohttp.typedefs.JSONEncoder = &lt;function dumps&gt;,
    entity_factory: <a href='../api/entity_factory.html#hikari.api.entity_factory.EntityFactory'>entity_factory_api.EntityFactory</a>,
    loads: aiohttp.typedefs.JSONDecoder = &lt;function loads&gt;,
    rest_client: <a href='../api/rest.html#hikari.api.rest.RESTClient'>rest_api.RESTClient</a>,
    public_key: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>] = None,
): ...</code></pre>
<p>Standard implementation of <code><a href='../api/interaction_server.html#hikari.api.interaction_server.InteractionServer'>InteractionServer</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entity_factory</code></strong> :&ensp;<code><a href='../api/entity_factory.html#hikari.api.entity_factory.EntityFactory'>EntityFactory</a></code></dt>
<dd>The entity factory instance this server should use.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dumps</code></strong> :&ensp;<code>aiohttp.typedefs.JSONEncoder</code></dt>
<dd>The JSON encoder this server should use. Defaults to <code><a href='https://docs.python.org/3/library/json.html#json.dumps'>json.dumps</a></code>.</dd>
<dt><strong><code>loads</code></strong> :&ensp;<code>aiohttp.typedefs.JSONDecoder</code></dt>
<dd>The JSON decoder this server should use. Defaults to <code><a href='https://docs.python.org/3/library/json.html#json.loads'>json.loads</a></code>.</dd>
<dt><strong><code>public_key</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></dt>
<dd>The public key this server should use for verifying request payloads from
Discord. If left as <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then the client will try to work this
out using <code>rest_client</code>.</dd>
<dt><strong><code>rest_client</code></strong> :&ensp;<code><a href='../api/rest.html#hikari.api.rest.RESTClient'>RESTClient</a></code></dt>
<dd>The client this should use for making REST requests.</dd>
</dl>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/interaction_server.py#L123-L552" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class InteractionServer(interaction_server.InteractionServer):
    &#34;&#34;&#34;Standard implementation of `hikari.api.interaction_server.InteractionServer`.

    Parameters
    ----------
    entity_factory : hikari.api.entity_factory.EntityFactory
        The entity factory instance this server should use.

    Other Parameters
    ----------------
    dumps : aiohttp.typedefs.JSONEncoder
        The JSON encoder this server should use. Defaults to `json.dumps`.
    loads : aiohttp.typedefs.JSONDecoder
        The JSON decoder this server should use. Defaults to `json.loads`.
    public_key : builtins.bytes
        The public key this server should use for verifying request payloads from
        Discord. If left as `builtins.None` then the client will try to work this
        out using `rest_client`.
    rest_client : hikari.api.rest.RESTClient
        The client this should use for making REST requests.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_application_fetch_lock&#34;,
        &#34;_close_event&#34;,
        &#34;_dumps&#34;,
        &#34;_entity_factory&#34;,
        &#34;_is_closing&#34;,
        &#34;_listeners&#34;,
        &#34;_loads&#34;,
        &#34;_rest_client&#34;,
        &#34;_server&#34;,
        &#34;_verify&#34;,
    )

    def __init__(
        self,
        *,
        dumps: aiohttp.typedefs.JSONEncoder = data_binding.dump_json,
        entity_factory: entity_factory_api.EntityFactory,
        loads: aiohttp.typedefs.JSONDecoder = data_binding.load_json,
        rest_client: rest_api.RESTClient,
        public_key: typing.Optional[bytes] = None,
    ) -&gt; None:
        # Building asyncio.Lock when there isn&#39;t a running loop may lead to runtime errors.
        self._application_fetch_lock: typing.Optional[asyncio.Lock] = None
        # Building asyncio.Event when there isn&#39;t a running loop may lead to runtime errors.
        self._close_event: typing.Optional[asyncio.Event] = None
        self._dumps = dumps
        self._entity_factory = entity_factory
        self._is_closing = False
        self._listeners: typing.Dict[typing.Type[base_interactions.PartialInteraction], typing.Any] = {}
        self._loads = loads
        self._rest_client = rest_client
        self._server: typing.Optional[aiohttp.web_runner.AppRunner] = None
        self._verify = ed25519.build_ed25519_verifier(public_key) if public_key is not None else None

    @property
    def is_alive(self) -&gt; bool:
        &#34;&#34;&#34;Whether this interaction server is active.

        Returns
        -------
        builtins.bool
            Whether this interaction server is active
        &#34;&#34;&#34;
        return self._server is not None

    async def _fetch_public_key(self) -&gt; ed25519.VerifierT:
        if self._application_fetch_lock is None:
            self._application_fetch_lock = asyncio.Lock()

        application: typing.Union[applications.Application, applications.AuthorizationApplication]
        async with self._application_fetch_lock:
            if self._verify:
                return self._verify

            if self._rest_client.token_type == applications.TokenType.BOT:
                application = await self._rest_client.fetch_application()

            else:
                application = (await self._rest_client.fetch_authorization()).application

            self._verify = ed25519.build_ed25519_verifier(application.public_key)
            return self._verify

    async def aiohttp_hook(self, request: aiohttp.web.Request) -&gt; aiohttp.web.Response:
        &#34;&#34;&#34;Handle an AIOHTTP interaction request.

        This method handles aiohttp specific detail before calling
        `InteractionServer.on_interaction` with the data extracted from the
        request if it can and handles building an aiohttp response.

        Parameters
        ----------
        request : aiohttp.web.Request
            The received request.

        Returns
        -------
        aiohtttp.web.Response
            The aiohttp response.
        &#34;&#34;&#34;
        if request.content_type.lower() != _JSON_CONTENT_TYPE:
            _LOGGER.debug(&#34;Payload with invalid media type %r received&#34;, request.content_type)
            return aiohttp.web.Response(
                status=_UNSUPPORTED_MEDIA_TYPE_STATUS,
                body=b&#34;Unsupported Media Type&#34;,
                content_type=_TEXT_CONTENT_TYPE,
                charset=_UTF_8_CHARSET,
            )

        try:
            signature_header = bytes.fromhex(request.headers[_X_SIGNATURE_ED25519_HEADER])
            timestamp_header = request.headers[_X_SIGNATURE_TIMESTAMP_HEADER].encode()

        except (KeyError, ValueError):
            user_agent = request.headers.get(_USER_AGENT_KEY, &#34;NONE&#34;)
            _LOGGER.debug(&#34;Received a request with a missing or invalid signature header (UA %r)&#34;, user_agent)
            return aiohttp.web.Response(
                status=_BAD_REQUEST_STATUS,
                body=b&#34;Missing or invalid required request signature header(s)&#34;,
                content_type=_TEXT_CONTENT_TYPE,
                charset=_UTF_8_CHARSET,
            )

        try:
            body = await request.read()

        except aiohttp.web.HTTPRequestEntityTooLarge:
            _LOGGER.debug(&#34;Received a request with a payload that&#39;s too large to process&#34;)
            return aiohttp.web.Response(
                status=_PAYLOAD_TOO_LARGE_STATUS,
                body=b&#34;Payload too large&#34;,
                content_type=_TEXT_CONTENT_TYPE,
                charset=_UTF_8_CHARSET,
            )

        if not body:
            user_agent = request.headers.get(_USER_AGENT_KEY, &#34;NONE&#34;)
            _LOGGER.debug(&#34;Received a body-less request (UA %r)&#34;, user_agent)
            return aiohttp.web.Response(
                status=_BAD_REQUEST_STATUS,
                body=b&#34;POST request must have a body&#34;,
                content_type=_TEXT_CONTENT_TYPE,
                charset=_UTF_8_CHARSET,
            )

        response = await self.on_interaction(body=body, signature=signature_header, timestamp=timestamp_header)
        return aiohttp.web.Response(status=response.status_code, headers=response.headers, body=response.payload)

    async def close(self) -&gt; None:
        &#34;&#34;&#34;Gracefully close the server and any open connections.&#34;&#34;&#34;
        if not self._server or not self._close_event:
            raise errors.ComponentStateConflictError(&#34;Cannot close an inactive interaction server&#34;)

        if self._is_closing:
            await self.join()
            return

        self._is_closing = True
        self._application_fetch_lock = None
        # This shutdown then cleanup ordering matters.
        await self._server.shutdown()
        await self._server.cleanup()
        self._close_event.set()
        self._close_event = None
        self._server = None

    async def join(self) -&gt; None:
        &#34;&#34;&#34;Wait for the process to halt before continuing.&#34;&#34;&#34;
        if not self._close_event:
            raise errors.ComponentStateConflictError(&#34;Cannot wait for an inactive interaction server to join&#34;)

        await self._close_event.wait()

    async def on_interaction(self, body: bytes, signature: bytes, timestamp: bytes) -&gt; interaction_server.Response:
        &#34;&#34;&#34;Handle an interaction received from Discord as a REST server.

        !!! note
            If this server instance is alive then this will be called internally
            by the server but if the instance isn&#39;t alive then this may still be
            called externally to trigger interaction dispatch.

        Parameters
        ----------
        body : builtins.bytes
            The interaction payload.
        signature : builtins.bytes
            Value of the `&#34;X-Signature-Ed25519&#34;` header used to verify the body.
        timestamp : builtins.bytes
            Value of the `&#34;X-Signature-Timestamp&#34;` header used to verify the body.

        Returns
        -------
        hikari.api.interaction_server.Response
            Instructions on how the REST server calling this should respond to
            the interaction request.
        &#34;&#34;&#34;
        verify = self._verify or await self._fetch_public_key()

        if not verify(body, signature, timestamp):
            _LOGGER.error(&#34;Received a request with an invalid signature&#34;)
            return _Response(_BAD_REQUEST_STATUS, b&#34;Invalid request signature&#34;)

        try:
            payload = self._loads(body.decode(&#34;utf-8&#34;))
            interaction_type = int(payload[&#34;type&#34;])

        except (data_binding.JSONDecodeError, ValueError, TypeError) as exc:
            _LOGGER.error(&#34;Received a request with an invalid JSON body&#34;, exc_info=exc)
            return _Response(_BAD_REQUEST_STATUS, b&#34;Invalid JSON body&#34;)

        except KeyError as exc:
            _LOGGER.error(&#34;Missing &#39;type&#39; field in received JSON payload&#34;, exc_info=exc)
            return _Response(_BAD_REQUEST_STATUS, b&#34;Missing required &#39;type&#39; field in payload&#34;)

        if interaction_type == _PING_INTERACTION_TYPE:
            _LOGGER.debug(&#34;Responding to ping interaction&#34;)
            return _PONG_RESPONSE

        try:
            interaction = self._entity_factory.deserialize_interaction(payload)

        except errors.UnrecognisedEntityError:
            _LOGGER.debug(&#34;Ignoring unknown interaction type %s&#34;, interaction_type)
            return _Response(_NOT_IMPLEMENTED, b&#34;Interaction type not implemented&#34;)

        except Exception as exc:
            asyncio.get_running_loop().call_exception_handler(
                {&#34;message&#34;: &#34;Exception occurred during interaction deserialization&#34;, &#34;exception&#34;: exc}
            )
            return _Response(_INTERNAL_SERVER_ERROR_STATUS, b&#34;Exception occurred during interaction deserialization&#34;)

        if listener := self._listeners.get(type(interaction)):
            _LOGGER.debug(&#34;Dispatching interaction %s&#34;, interaction.id)
            try:
                result = await listener(interaction)
                payload = self._dumps(result.build(self._entity_factory))

            except Exception as exc:
                asyncio.get_running_loop().call_exception_handler(
                    {&#34;message&#34;: &#34;Exception occurred during interaction dispatch&#34;, &#34;exception&#34;: exc}
                )
                return _Response(_INTERNAL_SERVER_ERROR_STATUS, b&#34;Exception occurred during interaction dispatch&#34;)

            return _Response(_OK_STATUS, payload.encode(), content_type=_JSON_TYPE_WITH_CHARSET)

        _LOGGER.debug(
            &#34;Ignoring interaction %s of type %s without registered listener&#34;, interaction.id, interaction.type
        )
        return _Response(_NOT_IMPLEMENTED, b&#34;Handler not set for this interaction type&#34;)

    async def start(
        self,
        backlog: int = 128,
        enable_signal_handlers: bool = True,
        host: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        port: typing.Optional[int] = None,
        path: typing.Optional[str] = None,
        reuse_address: typing.Optional[bool] = None,
        reuse_port: typing.Optional[bool] = None,
        socket: typing.Optional[socket_.socket] = None,
        shutdown_timeout: float = 60.0,
        ssl_context: typing.Optional[ssl.SSLContext] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Start the bot and wait for the internal server to startup then return.

        Other Parameters
        ----------------
        backlog : builtins.int
            The number of unaccepted connections that the system will allow before
            refusing new connections.
        enable_signal_handlers : builtins.bool
            Defaults to `builtins.True`. If on a __non-Windows__ OS with builtin
            support for kernel-level POSIX signals, then setting this to
            `builtins.True` will allow treating keyboard interrupts and other
            OS signals to safely shut down the application as calls to
            shut down the application properly rather than just killing the
            process in a dirty state immediately. You should leave this disabled
            unless you plan to implement your own signal handling yourself.
        host : typing.Optional[typing.Union[builtins.str, aiohttp.web.HostSequence]]
            TCP/IP host or a sequence of hosts for the HTTP server.
        port : typing.Optional[builtins.int]
            TCP/IP port for the HTTP server.
        path : typing.Optional[builtins.str]
            File system path for HTTP server unix domain socket.
        reuse_address : typing.Optional[builtins.bool]
            Tells the kernel to reuse a local socket in TIME_WAIT state, without
            waiting for its natural timeout to expire.
        reuse_port : typing.Optional[builtins.bool]
            Tells the kernel to allow this endpoint to be bound to the same port
            as other existing endpoints are also bound to.
        socket : typing.Optional[socket.socket]
            A pre-existing socket object to accept connections on.
        shutdown_timeout : builtins.float
            A delay to wait for graceful server shutdown before forcefully
            disconnecting all open client sockets. This defaults to 60 seconds.
        ssl_context : typing.Optional[ssl.SSLContext]
            SSL context for HTTPS servers.

        !!! note
            For more information on the other parameters such as defaults see
            AIOHTTP&#39;s documentation.
        &#34;&#34;&#34;
        if self._server:
            raise errors.ComponentStateConflictError(&#34;Cannot start an already active interaction server&#34;)

        self._close_event = asyncio.Event()
        self._is_closing = False
        aio_app = aiohttp.web.Application()
        aio_app.add_routes([aiohttp.web.post(&#34;/&#34;, self.aiohttp_hook)])
        self._server = aiohttp.web_runner.AppRunner(aio_app, handle_signals=enable_signal_handlers, access_log=_LOGGER)
        await self._server.setup()
        sites: typing.List[aiohttp.web.BaseSite] = []

        if host is not None:
            if isinstance(host, str):
                host = [host]

            for h in host:
                sites.append(
                    aiohttp.web.TCPSite(
                        self._server,
                        h,
                        port,
                        shutdown_timeout=shutdown_timeout,
                        ssl_context=ssl_context,
                        backlog=backlog,
                        reuse_address=reuse_address,
                        reuse_port=reuse_port,
                    )
                )

        elif path is None and socket is None or port is None:
            sites.append(
                aiohttp.web.TCPSite(
                    self._server,
                    port=port,
                    shutdown_timeout=shutdown_timeout,
                    ssl_context=ssl_context,
                    backlog=backlog,
                    reuse_address=reuse_address,
                    reuse_port=reuse_port,
                )
            )

        if path is not None:
            sites.append(
                aiohttp.web.UnixSite(
                    self._server, path, shutdown_timeout=shutdown_timeout, ssl_context=ssl_context, backlog=backlog
                )
            )

        if socket is not None:
            sites.append(
                aiohttp.web.SockSite(
                    self._server, socket, shutdown_timeout=shutdown_timeout, ssl_context=ssl_context, backlog=backlog
                )
            )

        for site in sites:
            _LOGGER.info(&#34;Starting site on %s&#34;, site.name)
            await site.start()

    @typing.overload
    def get_listener(
        self, interaction_type: typing.Type[command_interactions.CommandInteraction], /
    ) -&gt; typing.Optional[
        interaction_server.ListenerT[command_interactions.CommandInteraction, _MessageResponseBuilderT]
    ]:
        ...

    @typing.overload
    def get_listener(
        self, interaction_type: typing.Type[component_interactions.ComponentInteraction], /
    ) -&gt; typing.Optional[
        interaction_server.ListenerT[component_interactions.ComponentInteraction, _MessageResponseBuilderT]
    ]:
        ...

    def get_listener(
        self, interaction_type: typing.Type[_InteractionT_co], /
    ) -&gt; typing.Optional[interaction_server.ListenerT[_InteractionT_co, special_endpoints.InteractionResponseBuilder]]:
        return self._listeners.get(interaction_type)

    @typing.overload
    def set_listener(
        self,
        interaction_type: typing.Type[command_interactions.CommandInteraction],
        listener: typing.Optional[
            interaction_server.ListenerT[command_interactions.CommandInteraction, _MessageResponseBuilderT]
        ],
        /,
        *,
        replace: bool = False,
    ) -&gt; None:
        ...

    @typing.overload
    def set_listener(
        self,
        interaction_type: typing.Type[component_interactions.ComponentInteraction],
        listener: typing.Optional[
            interaction_server.ListenerT[component_interactions.ComponentInteraction, _MessageResponseBuilderT]
        ],
        /,
        *,
        replace: bool = False,
    ) -&gt; None:
        ...

    def set_listener(
        self,
        interaction_type: typing.Type[_InteractionT_co],
        listener: typing.Optional[
            interaction_server.ListenerT[_InteractionT_co, special_endpoints.InteractionResponseBuilder]
        ],
        /,
        *,
        replace: bool = False,
    ) -&gt; None:
        if listener:
            if not replace and interaction_type in self._listeners:
                raise TypeError(f&#34;Listener already set for {interaction_type.__name__}&#34;)

            self._listeners[interaction_type] = listener

        else:
            self._listeners.pop(interaction_type, None)</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="InteractionServer -- Standard implementation of `hikari.api.interaction_server.InteractionServer` …" href="#hikari.impl.interaction_server.InteractionServer"
>InteractionServer</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class that has EMPTY slots, and only methods/properties. Can safely be used in multiple inheritance without side effects.'>abstract trait</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="InteractionServer -- Interface for an implementation of a Interactions compatible REST server." href="../api/interaction_server.html#hikari.api.interaction_server.InteractionServer"
>InteractionServer</a></dt>
<dd class="nested"><p>Interface for an implementation of a Interactions compatible REST server.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.impl.interaction_server.InteractionServer.is_alive" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_alive -- Whether this interaction server is active …" href="#hikari.impl.interaction_server.InteractionServer.is_alive"  >is_alive</a> : <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></pre>
</dt>
<dd><p>Whether this interaction server is active.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Whether this interaction server is active</dd>
</dl></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.impl.interaction_server.InteractionServer.aiohttp_hook" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="aiohttp_hook" href="#hikari.impl.interaction_server.InteractionServer.aiohttp_hook" id="hikari.impl.interaction_server.InteractionServer.aiohttp_hook">aiohttp_hook</a>(
    request: <a href='https://docs.aiohttp.org/en/stable/web_reference.html#aiohttp.web.Request'>aiohttp.web.Request</a>,
) -> aiohttp.web_response.Response: ...</code></pre>
</dt>
<dd>
<p>Handle an AIOHTTP interaction request.</p>
<p>This method handles aiohttp specific detail before calling
<code><a href='#hikari.impl.interaction_server.InteractionServer.on_interaction'>on_interaction</a></code> with the data extracted from the
request if it can and handles building an aiohttp response.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code><a href='https://docs.aiohttp.org/en/stable/web_reference.html#aiohttp.web.Request'>aiohttp.web.Request</a></code></dt>
<dd>The received request.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>aiohtttp.web.Response</code></dt>
<dd>The aiohttp response.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/interaction_server.py#L209-L272" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def aiohttp_hook(self, request: aiohttp.web.Request) -&gt; aiohttp.web.Response:
    &#34;&#34;&#34;Handle an AIOHTTP interaction request.

    This method handles aiohttp specific detail before calling
    `InteractionServer.on_interaction` with the data extracted from the
    request if it can and handles building an aiohttp response.

    Parameters
    ----------
    request : aiohttp.web.Request
        The received request.

    Returns
    -------
    aiohtttp.web.Response
        The aiohttp response.
    &#34;&#34;&#34;
    if request.content_type.lower() != _JSON_CONTENT_TYPE:
        _LOGGER.debug(&#34;Payload with invalid media type %r received&#34;, request.content_type)
        return aiohttp.web.Response(
            status=_UNSUPPORTED_MEDIA_TYPE_STATUS,
            body=b&#34;Unsupported Media Type&#34;,
            content_type=_TEXT_CONTENT_TYPE,
            charset=_UTF_8_CHARSET,
        )

    try:
        signature_header = bytes.fromhex(request.headers[_X_SIGNATURE_ED25519_HEADER])
        timestamp_header = request.headers[_X_SIGNATURE_TIMESTAMP_HEADER].encode()

    except (KeyError, ValueError):
        user_agent = request.headers.get(_USER_AGENT_KEY, &#34;NONE&#34;)
        _LOGGER.debug(&#34;Received a request with a missing or invalid signature header (UA %r)&#34;, user_agent)
        return aiohttp.web.Response(
            status=_BAD_REQUEST_STATUS,
            body=b&#34;Missing or invalid required request signature header(s)&#34;,
            content_type=_TEXT_CONTENT_TYPE,
            charset=_UTF_8_CHARSET,
        )

    try:
        body = await request.read()

    except aiohttp.web.HTTPRequestEntityTooLarge:
        _LOGGER.debug(&#34;Received a request with a payload that&#39;s too large to process&#34;)
        return aiohttp.web.Response(
            status=_PAYLOAD_TOO_LARGE_STATUS,
            body=b&#34;Payload too large&#34;,
            content_type=_TEXT_CONTENT_TYPE,
            charset=_UTF_8_CHARSET,
        )

    if not body:
        user_agent = request.headers.get(_USER_AGENT_KEY, &#34;NONE&#34;)
        _LOGGER.debug(&#34;Received a body-less request (UA %r)&#34;, user_agent)
        return aiohttp.web.Response(
            status=_BAD_REQUEST_STATUS,
            body=b&#34;POST request must have a body&#34;,
            content_type=_TEXT_CONTENT_TYPE,
            charset=_UTF_8_CHARSET,
        )

    response = await self.on_interaction(body=body, signature=signature_header, timestamp=timestamp_header)
    return aiohttp.web.Response(status=response.status_code, headers=response.headers, body=response.payload)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.interaction_server.InteractionServer.close" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="close" href="#hikari.impl.interaction_server.InteractionServer.close" id="hikari.impl.interaction_server.InteractionServer.close">close</a>() -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Gracefully close the server and any open connections.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/interaction_server.py#L274-L290" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    &#34;&#34;&#34;Gracefully close the server and any open connections.&#34;&#34;&#34;
    if not self._server or not self._close_event:
        raise errors.ComponentStateConflictError(&#34;Cannot close an inactive interaction server&#34;)

    if self._is_closing:
        await self.join()
        return

    self._is_closing = True
    self._application_fetch_lock = None
    # This shutdown then cleanup ordering matters.
    await self._server.shutdown()
    await self._server.cleanup()
    self._close_event.set()
    self._close_event = None
    self._server = None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.interaction_server.InteractionServer.get_listener" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_listener" href="#hikari.impl.interaction_server.InteractionServer.get_listener" id="hikari.impl.interaction_server.InteractionServer.get_listener">get_listener</a>(
    interaction_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[_InteractionT_co],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../api/interaction_server.html#hikari.api.interaction_server.ListenerT'>interaction_server.ListenerT</a>[_InteractionT_co, <a href='../api/special_endpoints.html#hikari.api.special_endpoints.InteractionResponseBuilder'>special_endpoints.InteractionResponseBuilder</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="InteractionServer -- Interface for an implementation of a Interactions compatible REST server." href="../api/interaction_server.html#hikari.api.interaction_server.InteractionServer"
>InteractionServer</a></code>.<code><a title="get_listener -- Get the listener registered for an interaction …" href="../api/interaction_server.html#hikari.api.interaction_server.InteractionServer.get_listener"
>get_listener</a></code>
</p>
<p>Get the listener registered for an interaction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>interaction_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.PartialInteraction'>PartialInteraction</a>]</code></dt>
<dd>Type of the interaction to get the registered listener for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[ListenersT[<a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.PartialInteraction'>PartialInteraction</a>, <a href='../api/special_endpoints.html#hikari.api.special_endpoints.InteractionResponseBuilder'>InteractionResponseBuilder</a>]</code></dt>
<dd>The callback registered for the provided interaction type if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/interaction_server.py#L504-L507" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_listener(
    self, interaction_type: typing.Type[_InteractionT_co], /
) -&gt; typing.Optional[interaction_server.ListenerT[_InteractionT_co, special_endpoints.InteractionResponseBuilder]]:
    return self._listeners.get(interaction_type)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.interaction_server.InteractionServer.join" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="join" href="#hikari.impl.interaction_server.InteractionServer.join" id="hikari.impl.interaction_server.InteractionServer.join">join</a>() -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Wait for the process to halt before continuing.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/interaction_server.py#L292-L297" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def join(self) -&gt; None:
    &#34;&#34;&#34;Wait for the process to halt before continuing.&#34;&#34;&#34;
    if not self._close_event:
        raise errors.ComponentStateConflictError(&#34;Cannot wait for an inactive interaction server to join&#34;)

    await self._close_event.wait()</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.interaction_server.InteractionServer.on_interaction" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="on_interaction" href="#hikari.impl.interaction_server.InteractionServer.on_interaction" id="hikari.impl.interaction_server.InteractionServer.on_interaction">on_interaction</a>(
    body: <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>,
    signature: <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>,
    timestamp: <a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a>,
) -> <a href='../api/interaction_server.html#hikari.api.interaction_server.Response'>Response</a>: ...</code></pre>
</dt>
<dd>
<p>Handle an interaction received from Discord as a REST server.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>If this server instance is alive then this will be called internally
by the server but if the instance isn't alive then this may still be
called externally to trigger interaction dispatch.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>body</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></dt>
<dd>The interaction payload.</dd>
<dt><strong><code>signature</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></dt>
<dd>Value of the <code>"X-Signature-Ed25519"</code> header used to verify the body.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code></dt>
<dd>Value of the <code>"X-Signature-Timestamp"</code> header used to verify the body.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/interaction_server.html#hikari.api.interaction_server.Response'>Response</a></code></dt>
<dd>Instructions on how the REST server calling this should respond to
the interaction request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/interaction_server.py#L299-L374" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def on_interaction(self, body: bytes, signature: bytes, timestamp: bytes) -&gt; interaction_server.Response:
    &#34;&#34;&#34;Handle an interaction received from Discord as a REST server.

    !!! note
        If this server instance is alive then this will be called internally
        by the server but if the instance isn&#39;t alive then this may still be
        called externally to trigger interaction dispatch.

    Parameters
    ----------
    body : builtins.bytes
        The interaction payload.
    signature : builtins.bytes
        Value of the `&#34;X-Signature-Ed25519&#34;` header used to verify the body.
    timestamp : builtins.bytes
        Value of the `&#34;X-Signature-Timestamp&#34;` header used to verify the body.

    Returns
    -------
    hikari.api.interaction_server.Response
        Instructions on how the REST server calling this should respond to
        the interaction request.
    &#34;&#34;&#34;
    verify = self._verify or await self._fetch_public_key()

    if not verify(body, signature, timestamp):
        _LOGGER.error(&#34;Received a request with an invalid signature&#34;)
        return _Response(_BAD_REQUEST_STATUS, b&#34;Invalid request signature&#34;)

    try:
        payload = self._loads(body.decode(&#34;utf-8&#34;))
        interaction_type = int(payload[&#34;type&#34;])

    except (data_binding.JSONDecodeError, ValueError, TypeError) as exc:
        _LOGGER.error(&#34;Received a request with an invalid JSON body&#34;, exc_info=exc)
        return _Response(_BAD_REQUEST_STATUS, b&#34;Invalid JSON body&#34;)

    except KeyError as exc:
        _LOGGER.error(&#34;Missing &#39;type&#39; field in received JSON payload&#34;, exc_info=exc)
        return _Response(_BAD_REQUEST_STATUS, b&#34;Missing required &#39;type&#39; field in payload&#34;)

    if interaction_type == _PING_INTERACTION_TYPE:
        _LOGGER.debug(&#34;Responding to ping interaction&#34;)
        return _PONG_RESPONSE

    try:
        interaction = self._entity_factory.deserialize_interaction(payload)

    except errors.UnrecognisedEntityError:
        _LOGGER.debug(&#34;Ignoring unknown interaction type %s&#34;, interaction_type)
        return _Response(_NOT_IMPLEMENTED, b&#34;Interaction type not implemented&#34;)

    except Exception as exc:
        asyncio.get_running_loop().call_exception_handler(
            {&#34;message&#34;: &#34;Exception occurred during interaction deserialization&#34;, &#34;exception&#34;: exc}
        )
        return _Response(_INTERNAL_SERVER_ERROR_STATUS, b&#34;Exception occurred during interaction deserialization&#34;)

    if listener := self._listeners.get(type(interaction)):
        _LOGGER.debug(&#34;Dispatching interaction %s&#34;, interaction.id)
        try:
            result = await listener(interaction)
            payload = self._dumps(result.build(self._entity_factory))

        except Exception as exc:
            asyncio.get_running_loop().call_exception_handler(
                {&#34;message&#34;: &#34;Exception occurred during interaction dispatch&#34;, &#34;exception&#34;: exc}
            )
            return _Response(_INTERNAL_SERVER_ERROR_STATUS, b&#34;Exception occurred during interaction dispatch&#34;)

        return _Response(_OK_STATUS, payload.encode(), content_type=_JSON_TYPE_WITH_CHARSET)

    _LOGGER.debug(
        &#34;Ignoring interaction %s of type %s without registered listener&#34;, interaction.id, interaction.type
    )
    return _Response(_NOT_IMPLEMENTED, b&#34;Handler not set for this interaction type&#34;)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.interaction_server.InteractionServer.set_listener" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_listener" href="#hikari.impl.interaction_server.InteractionServer.set_listener" id="hikari.impl.interaction_server.InteractionServer.set_listener">set_listener</a>(
    interaction_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[_InteractionT_co],
    listener: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../api/interaction_server.html#hikari.api.interaction_server.ListenerT'>interaction_server.ListenerT</a>[_InteractionT_co, <a href='../api/special_endpoints.html#hikari.api.special_endpoints.InteractionResponseBuilder'>special_endpoints.InteractionResponseBuilder</a>]],
    /,
    *,
    replace: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="InteractionServer -- Interface for an implementation of a Interactions compatible REST server." href="../api/interaction_server.html#hikari.api.interaction_server.InteractionServer"
>InteractionServer</a></code>.<code><a title="set_listener -- Set the listener callback for this interaction server …" href="../api/interaction_server.html#hikari.api.interaction_server.InteractionServer.set_listener"
>set_listener</a></code>
</p>
<p>Set the listener callback for this interaction server.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>interaction_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.PartialInteraction'>PartialInteraction</a>]</code></dt>
<dd>The type of interaction this listener should be registered for.</dd>
<dt><strong><code>listener</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[ListenerT[<a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.PartialInteraction'>PartialInteraction</a>, <a href='../api/special_endpoints.html#hikari.api.special_endpoints.InteractionResponseBuilder'>InteractionResponseBuilder</a>]]</code></dt>
<dd>The asynchronous listener callback to set or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> to
unset the previous listener.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>replace</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Whether this call should replace the previously set listener or not.
This call will raise a <code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code> if set to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
when a listener is already set.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If <code>replace</code> is <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> when a listener is already set.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/interaction_server.py#L535-L552" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_listener(
    self,
    interaction_type: typing.Type[_InteractionT_co],
    listener: typing.Optional[
        interaction_server.ListenerT[_InteractionT_co, special_endpoints.InteractionResponseBuilder]
    ],
    /,
    *,
    replace: bool = False,
) -&gt; None:
    if listener:
        if not replace and interaction_type in self._listeners:
            raise TypeError(f&#34;Listener already set for {interaction_type.__name__}&#34;)

        self._listeners[interaction_type] = listener

    else:
        self._listeners.pop(interaction_type, None)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.interaction_server.InteractionServer.start" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="start" href="#hikari.impl.interaction_server.InteractionServer.start" id="hikari.impl.interaction_server.InteractionServer.start">start</a>(
    backlog: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 128,
    enable_signal_handlers: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = True,
    host: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]]] = None,
    port: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = None,
    path: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
    reuse_address: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = None,
    reuse_port: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = None,
    socket: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/socket.html#socket.socket'>socket_.socket</a>] = None,
    shutdown_timeout: <a href='https://docs.python.org/3/library/functions.html#float'>float</a> = 60.0,
    ssl_context: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/ssl.html#ssl.SSLContext'>ssl.SSLContext</a>] = None,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Start the bot and wait for the internal server to startup then return.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>backlog</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The number of unaccepted connections that the system will allow before
refusing new connections.</dd>
<dt><strong><code>enable_signal_handlers</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Defaults to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>. If on a <strong>non-Windows</strong> OS with builtin
support for kernel-level POSIX signals, then setting this to
<code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> will allow treating keyboard interrupts and other
OS signals to safely shut down the application as calls to
shut down the application properly rather than just killing the
process in a dirty state immediately. You should leave this disabled
unless you plan to implement your own signal handling yourself.</dd>
<dt><strong><code>host</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, aiohttp.web.HostSequence]]</code></dt>
<dd>TCP/IP host or a sequence of hosts for the HTTP server.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>TCP/IP port for the HTTP server.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>File system path for HTTP server unix domain socket.</dd>
<dt><strong><code>reuse_address</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>Tells the kernel to reuse a local socket in TIME_WAIT state, without
waiting for its natural timeout to expire.</dd>
<dt><strong><code>reuse_port</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>Tells the kernel to allow this endpoint to be bound to the same port
as other existing endpoints are also bound to.</dd>
<dt><strong><code>socket</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/socket.html#socket.socket'>socket.socket</a>]</code></dt>
<dd>A pre-existing socket object to accept connections on.</dd>
<dt><strong><code>shutdown_timeout</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#float'>float</a></code></dt>
<dd>A delay to wait for graceful server shutdown before forcefully
disconnecting all open client sockets. This defaults to 60 seconds.</dd>
<dt><strong><code>ssl_context</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/ssl.html#ssl.SSLContext'>ssl.SSLContext</a>]</code></dt>
<dd>SSL context for HTTPS servers.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>For more information on the other parameters such as defaults see
AIOHTTP's documentation.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/interaction_server.py#L376-L486" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def start(
    self,
    backlog: int = 128,
    enable_signal_handlers: bool = True,
    host: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
    port: typing.Optional[int] = None,
    path: typing.Optional[str] = None,
    reuse_address: typing.Optional[bool] = None,
    reuse_port: typing.Optional[bool] = None,
    socket: typing.Optional[socket_.socket] = None,
    shutdown_timeout: float = 60.0,
    ssl_context: typing.Optional[ssl.SSLContext] = None,
) -&gt; None:
    &#34;&#34;&#34;Start the bot and wait for the internal server to startup then return.

    Other Parameters
    ----------------
    backlog : builtins.int
        The number of unaccepted connections that the system will allow before
        refusing new connections.
    enable_signal_handlers : builtins.bool
        Defaults to `builtins.True`. If on a __non-Windows__ OS with builtin
        support for kernel-level POSIX signals, then setting this to
        `builtins.True` will allow treating keyboard interrupts and other
        OS signals to safely shut down the application as calls to
        shut down the application properly rather than just killing the
        process in a dirty state immediately. You should leave this disabled
        unless you plan to implement your own signal handling yourself.
    host : typing.Optional[typing.Union[builtins.str, aiohttp.web.HostSequence]]
        TCP/IP host or a sequence of hosts for the HTTP server.
    port : typing.Optional[builtins.int]
        TCP/IP port for the HTTP server.
    path : typing.Optional[builtins.str]
        File system path for HTTP server unix domain socket.
    reuse_address : typing.Optional[builtins.bool]
        Tells the kernel to reuse a local socket in TIME_WAIT state, without
        waiting for its natural timeout to expire.
    reuse_port : typing.Optional[builtins.bool]
        Tells the kernel to allow this endpoint to be bound to the same port
        as other existing endpoints are also bound to.
    socket : typing.Optional[socket.socket]
        A pre-existing socket object to accept connections on.
    shutdown_timeout : builtins.float
        A delay to wait for graceful server shutdown before forcefully
        disconnecting all open client sockets. This defaults to 60 seconds.
    ssl_context : typing.Optional[ssl.SSLContext]
        SSL context for HTTPS servers.

    !!! note
        For more information on the other parameters such as defaults see
        AIOHTTP&#39;s documentation.
    &#34;&#34;&#34;
    if self._server:
        raise errors.ComponentStateConflictError(&#34;Cannot start an already active interaction server&#34;)

    self._close_event = asyncio.Event()
    self._is_closing = False
    aio_app = aiohttp.web.Application()
    aio_app.add_routes([aiohttp.web.post(&#34;/&#34;, self.aiohttp_hook)])
    self._server = aiohttp.web_runner.AppRunner(aio_app, handle_signals=enable_signal_handlers, access_log=_LOGGER)
    await self._server.setup()
    sites: typing.List[aiohttp.web.BaseSite] = []

    if host is not None:
        if isinstance(host, str):
            host = [host]

        for h in host:
            sites.append(
                aiohttp.web.TCPSite(
                    self._server,
                    h,
                    port,
                    shutdown_timeout=shutdown_timeout,
                    ssl_context=ssl_context,
                    backlog=backlog,
                    reuse_address=reuse_address,
                    reuse_port=reuse_port,
                )
            )

    elif path is None and socket is None or port is None:
        sites.append(
            aiohttp.web.TCPSite(
                self._server,
                port=port,
                shutdown_timeout=shutdown_timeout,
                ssl_context=ssl_context,
                backlog=backlog,
                reuse_address=reuse_address,
                reuse_port=reuse_port,
            )
        )

    if path is not None:
        sites.append(
            aiohttp.web.UnixSite(
                self._server, path, shutdown_timeout=shutdown_timeout, ssl_context=ssl_context, backlog=backlog
            )
        )

    if socket is not None:
        sites.append(
            aiohttp.web.SockSite(
                self._server, socket, shutdown_timeout=shutdown_timeout, ssl_context=ssl_context, backlog=backlog
            )
        )

    for site in sites:
        _LOGGER.info(&#34;Starting site on %s&#34;, site.name)
        await site.start()</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
</dl>
</section>
</div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>