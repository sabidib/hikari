<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.impl.rest API documentation</title>
<meta name="description" content="Implementation of a V8 compatible REST API for Discord …">
<meta property="og:title" content="hikari.impl.rest module list">
<meta property="og:type" content="website">
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png">
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions">
<meta property="theme-color" content="#ff029a">
<link rel="shortcut icon" type="image/png" href="../../logo.png">
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
text-indent: 100%;
white-space: nowrap;
overflow: hidden;
}
small.smaller {
font-size: 0.50em;
}
html {
height: 100%;
scroll-behavior: smooth;
scrollbar-color: #202324 #454a4d;
}
body {
background-color: #181A1B;
color: #C9C5C0;
height: fit-content;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.container > li {
margin-left: 1em;
margin-top: 2.5em;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
.anchor:target {
background-color: var(--dark);
}
@media screen and (max-width: 990px) {
.anchor:target {
margin-left: -2em;
padding-left: 2em;
}
}
@media screen and (min-width: 990px) {
.anchor:target {
border-radius: 0.5em; !important
margin-right: -2em;
padding-right: 2em;
margin-top: -1em;
padding-top: 1em;
}
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="../../logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small class="smaller">2.0.0.dev102</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
<li class="nav-item"><a class="nav-link active" href="../../hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" action="../../hikari/search.html">
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search" name="q"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.impl -- Basic implementations of application components …" href="index.html"
>impl</a></li>
<li class="breadcrumb-item active"><a href="#">rest</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Implementation of a V8 compatible REST API for Discord.</p>
<p>This also includes implementations designed towards providing
RESTful functionality.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="ClientCredentialsStrategy -- Strategy class for handling client credential OAuth2 authorization …" href="#hikari.impl.rest.ClientCredentialsStrategy"
>ClientCredentialsStrategy</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="acquire -- Acquire an authorization token (including the prefix) …" href="#hikari.impl.rest.ClientCredentialsStrategy.acquire"
>acquire</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="client_id -- ID of the application this token strategy authenticates with …" href="#hikari.impl.rest.ClientCredentialsStrategy.client_id"
>client_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="invalidate -- Invalidate the cached token in this handler …" href="#hikari.impl.rest.ClientCredentialsStrategy.invalidate"
>invalidate</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="scopes -- Scopes this token strategy authenticates for …" href="#hikari.impl.rest.ClientCredentialsStrategy.scopes"
>scopes</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="token_type -- Type of token this strategy returns …" href="#hikari.impl.rest.ClientCredentialsStrategy.token_type"
>token_type</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTApp -- The base for a HTTP-only Discord application …" href="#hikari.impl.rest.RESTApp"
>RESTApp</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="acquire -- Acquire an instance of this REST client …" href="#hikari.impl.rest.RESTApp.acquire"
>acquire</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="executor -- Return the executor to use for blocking operations …" href="#hikari.impl.rest.RESTApp.executor"
>executor</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- " href="#hikari.impl.rest.RESTApp.http_settings"
>http_settings</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="proxy_settings -- " href="#hikari.impl.rest.RESTApp.proxy_settings"
>proxy_settings</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClientImpl -- Implementation of the V8-compatible Discord HTTP API …" href="#hikari.impl.rest.RESTClientImpl"
>RESTClientImpl</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="add_reaction -- Add a reaction emoji to a message in a given channel …" href="#hikari.impl.rest.RESTClientImpl.add_reaction"
>add_reaction</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="add_role_to_member -- Add a role to a member …" href="#hikari.impl.rest.RESTClientImpl.add_role_to_member"
>add_role_to_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="add_user_to_guild -- Add a user to a guild …" href="#hikari.impl.rest.RESTClientImpl.add_user_to_guild"
>add_user_to_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="authorize_access_token -- Authorize an OAuth2 token using the authorize code grant type …" href="#hikari.impl.rest.RESTClientImpl.authorize_access_token"
>authorize_access_token</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="authorize_client_credentials_token -- Authorize a client credentials token for an application …" href="#hikari.impl.rest.RESTClientImpl.authorize_client_credentials_token"
>authorize_client_credentials_token</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="ban_member -- Ban a member from a guild …" href="#hikari.impl.rest.RESTClientImpl.ban_user"
>ban_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="ban_user -- Ban a member from a guild …" href="#hikari.impl.rest.RESTClientImpl.ban_user"
>ban_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="begin_guild_prune -- Begin the guild prune …" href="#hikari.impl.rest.RESTClientImpl.begin_guild_prune"
>begin_guild_prune</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="build_action_row -- Build an action row message component for use in message create and REST calls …" href="#hikari.impl.rest.RESTClientImpl.build_action_row"
>build_action_row</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="close -- Close the HTTP client and any open HTTP connections." href="#hikari.impl.rest.RESTClientImpl.close"
>close</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="command_builder -- Create a command builder for use in `RESTClient.set_application_commands` …" href="#hikari.impl.rest.RESTClientImpl.command_builder"
>command_builder</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_application_command -- Create an application command …" href="#hikari.impl.rest.RESTClientImpl.create_application_command"
>create_application_command</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_dm_channel -- Create a DM channel with a user …" href="#hikari.impl.rest.RESTClientImpl.create_dm_channel"
>create_dm_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_emoji -- Create an emoji in a guild …" href="#hikari.impl.rest.RESTClientImpl.create_emoji"
>create_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_category -- Create a category in a guild …" href="#hikari.impl.rest.RESTClientImpl.create_guild_category"
>create_guild_category</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_from_template -- Make a guild from a template …" href="#hikari.impl.rest.RESTClientImpl.create_guild_from_template"
>create_guild_from_template</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_news_channel -- Create a news channel in a guild …" href="#hikari.impl.rest.RESTClientImpl.create_guild_news_channel"
>create_guild_news_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_stage_channel -- Create a stage channel in a guild …" href="#hikari.impl.rest.RESTClientImpl.create_guild_stage_channel"
>create_guild_stage_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_text_channel -- Create a text channel in a guild …" href="#hikari.impl.rest.RESTClientImpl.create_guild_text_channel"
>create_guild_text_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_voice_channel -- Create a voice channel in a guild …" href="#hikari.impl.rest.RESTClientImpl.create_guild_voice_channel"
>create_guild_voice_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_interaction_response -- Create the initial response for a interaction …" href="#hikari.impl.rest.RESTClientImpl.create_interaction_response"
>create_interaction_response</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_invite -- Create an invite to the given guild channel …" href="#hikari.impl.rest.RESTClientImpl.create_invite"
>create_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_message -- Create a message in the given channel …" href="#hikari.impl.rest.RESTClientImpl.create_message"
>create_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_role -- Create a role …" href="#hikari.impl.rest.RESTClientImpl.create_role"
>create_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_sticker -- Create a sticker in a guild …" href="#hikari.impl.rest.RESTClientImpl.create_sticker"
>create_sticker</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_template -- Create a guild template …" href="#hikari.impl.rest.RESTClientImpl.create_template"
>create_template</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_webhook -- Create webhook in a channel …" href="#hikari.impl.rest.RESTClientImpl.create_webhook"
>create_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="crosspost_message -- Broadcast an announcement message …" href="#hikari.impl.rest.RESTClientImpl.crosspost_message"
>crosspost_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_all_reactions -- Delete all reactions from a message …" href="#hikari.impl.rest.RESTClientImpl.delete_all_reactions"
>delete_all_reactions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_all_reactions_for_emoji -- Delete all reactions for a single emoji on a given message …" href="#hikari.impl.rest.RESTClientImpl.delete_all_reactions_for_emoji"
>delete_all_reactions_for_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_application_command -- Delete a registered application command …" href="#hikari.impl.rest.RESTClientImpl.delete_application_command"
>delete_application_command</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_channel -- Delete a channel in a guild, or close a DM …" href="#hikari.impl.rest.RESTClientImpl.delete_channel"
>delete_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_emoji -- Delete an emoji in a guild …" href="#hikari.impl.rest.RESTClientImpl.delete_emoji"
>delete_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_guild -- Delete a guild …" href="#hikari.impl.rest.RESTClientImpl.delete_guild"
>delete_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_interaction_response -- Delete the initial response of an interaction …" href="#hikari.impl.rest.RESTClientImpl.delete_interaction_response"
>delete_interaction_response</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_invite -- Delete an existing invite …" href="#hikari.impl.rest.RESTClientImpl.delete_invite"
>delete_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_message -- Delete a given message in a given channel …" href="#hikari.impl.rest.RESTClientImpl.delete_message"
>delete_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_messages -- Bulk-delete messages from the channel …" href="#hikari.impl.rest.RESTClientImpl.delete_messages"
>delete_messages</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_my_reaction -- Delete a reaction that your application user created …" href="#hikari.impl.rest.RESTClientImpl.delete_my_reaction"
>delete_my_reaction</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_permission_overwrite -- Delete a custom permission for an entity in a given guild channel …" href="#hikari.impl.rest.RESTClientImpl.delete_permission_overwrite"
>delete_permission_overwrite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_reaction -- Delete a reaction from a message …" href="#hikari.impl.rest.RESTClientImpl.delete_reaction"
>delete_reaction</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_role -- Delete a role …" href="#hikari.impl.rest.RESTClientImpl.delete_role"
>delete_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_sticker -- Delete a sticker in a guild …" href="#hikari.impl.rest.RESTClientImpl.delete_sticker"
>delete_sticker</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_template -- Delete a guild template …" href="#hikari.impl.rest.RESTClientImpl.delete_template"
>delete_template</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_webhook -- Delete a webhook …" href="#hikari.impl.rest.RESTClientImpl.delete_webhook"
>delete_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_webhook_message -- Delete a given message in a given channel …" href="#hikari.impl.rest.RESTClientImpl.delete_webhook_message"
>delete_webhook_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_application_command -- Edit a registered application command …" href="#hikari.impl.rest.RESTClientImpl.edit_application_command"
>edit_application_command</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_channel -- Edit a channel …" href="#hikari.impl.rest.RESTClientImpl.edit_channel"
>edit_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_emoji -- Edit an emoji in a guild …" href="#hikari.impl.rest.RESTClientImpl.edit_emoji"
>edit_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_guild -- Edit a guild …" href="#hikari.impl.rest.RESTClientImpl.edit_guild"
>edit_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_interaction_response -- Edit the initial response to a command interaction …" href="#hikari.impl.rest.RESTClientImpl.edit_interaction_response"
>edit_interaction_response</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_member -- Edit a guild member …" href="#hikari.impl.rest.RESTClientImpl.edit_member"
>edit_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_message -- Edit an existing message in a given channel …" href="#hikari.impl.rest.RESTClientImpl.edit_message"
>edit_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_my_nick -- Edit the associated token's member nick …" href="#hikari.impl.rest.RESTClientImpl.edit_my_nick"
>edit_my_nick</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_my_user -- Edit the token's associated user …" href="#hikari.impl.rest.RESTClientImpl.edit_my_user"
>edit_my_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_my_voice_state -- Edit the current user's voice state in a stage channel …" href="#hikari.impl.rest.RESTClientImpl.edit_my_voice_state"
>edit_my_voice_state</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_permission_overwrites -- Edit permissions for a specific entity in the given guild channel …" href="#hikari.impl.rest.RESTClientImpl.edit_permission_overwrites"
>edit_permission_overwrites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_role -- Edit a role …" href="#hikari.impl.rest.RESTClientImpl.edit_role"
>edit_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_sticker -- Edit a sticker in a guild …" href="#hikari.impl.rest.RESTClientImpl.edit_sticker"
>edit_sticker</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_template -- Modify a guild template …" href="#hikari.impl.rest.RESTClientImpl.edit_template"
>edit_template</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_voice_state -- Edit an existing voice state in a stage channel …" href="#hikari.impl.rest.RESTClientImpl.edit_voice_state"
>edit_voice_state</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_webhook -- Edit a webhook …" href="#hikari.impl.rest.RESTClientImpl.edit_webhook"
>edit_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_webhook_message -- Edit a message sent by a webhook …" href="#hikari.impl.rest.RESTClientImpl.edit_webhook_message"
>edit_webhook_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_welcome_screen -- Edit the welcome screen of a community guild …" href="#hikari.impl.rest.RESTClientImpl.edit_welcome_screen"
>edit_welcome_screen</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_widget -- Fetch a guilds's widget …" href="#hikari.impl.rest.RESTClientImpl.edit_widget"
>edit_widget</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="estimate_guild_prune_count -- Estimate the guild prune count …" href="#hikari.impl.rest.RESTClientImpl.estimate_guild_prune_count"
>estimate_guild_prune_count</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="execute_webhook -- Execute a webhook …" href="#hikari.impl.rest.RESTClientImpl.execute_webhook"
>execute_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_application -- Fetch the token's associated application …" href="#hikari.impl.rest.RESTClientImpl.fetch_application"
>fetch_application</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_application_command -- Fetch a command set for an application …" href="#hikari.impl.rest.RESTClientImpl.fetch_application_command"
>fetch_application_command</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_application_command_permissions -- Fetch the permissions registered for a specific command in a guild …" href="#hikari.impl.rest.RESTClientImpl.fetch_application_command_permissions"
>fetch_application_command_permissions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_application_commands -- Fetch the commands set for an application …" href="#hikari.impl.rest.RESTClientImpl.fetch_application_commands"
>fetch_application_commands</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_application_guild_commands_permissions -- Fetch the command permissions registered in a guild …" href="#hikari.impl.rest.RESTClientImpl.fetch_application_guild_commands_permissions"
>fetch_application_guild_commands_permissions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_audit_log -- Fetch the guild's audit log …" href="#hikari.impl.rest.RESTClientImpl.fetch_audit_log"
>fetch_audit_log</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_authorization -- Fetch the token's authorization information …" href="#hikari.impl.rest.RESTClientImpl.fetch_authorization"
>fetch_authorization</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_available_sticker_packs -- Fetch the available sticker packs …" href="#hikari.impl.rest.RESTClientImpl.fetch_available_sticker_packs"
>fetch_available_sticker_packs</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_ban -- Fetch the guild's ban info for a user …" href="#hikari.impl.rest.RESTClientImpl.fetch_ban"
>fetch_ban</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_bans -- Fetch the bans of a guild …" href="#hikari.impl.rest.RESTClientImpl.fetch_bans"
>fetch_bans</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel -- Fetch a channel …" href="#hikari.impl.rest.RESTClientImpl.fetch_channel"
>fetch_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel_invites -- Fetch all invites pointing to the given guild channel …" href="#hikari.impl.rest.RESTClientImpl.fetch_channel_invites"
>fetch_channel_invites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel_webhooks -- Fetch all channel webhooks …" href="#hikari.impl.rest.RESTClientImpl.fetch_channel_webhooks"
>fetch_channel_webhooks</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_emoji -- Fetch a guild emoji …" href="#hikari.impl.rest.RESTClientImpl.fetch_emoji"
>fetch_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_gateway_bot_info -- Fetch the gateway gateway info for the bot …" href="#hikari.impl.rest.RESTClientImpl.fetch_gateway_bot_info"
>fetch_gateway_bot_info</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_gateway_url -- Fetch the gateway url …" href="#hikari.impl.rest.RESTClientImpl.fetch_gateway_url"
>fetch_gateway_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild -- Fetch a guild …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild"
>fetch_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_channels -- Fetch the channels in a guild …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_channels"
>fetch_guild_channels</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_emojis -- Fetch the emojis of a guild …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_emojis"
>fetch_guild_emojis</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_invites -- Fetch the guild's invites …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_invites"
>fetch_guild_invites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_preview -- Fetch a guild preview …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_preview"
>fetch_guild_preview</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_sticker -- Fetch a guild sticker …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_sticker"
>fetch_guild_sticker</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_stickers -- Fetch a standard sticker …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_stickers"
>fetch_guild_stickers</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_templates -- Fetch the templates for a guild …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_templates"
>fetch_guild_templates</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_voice_regions -- Fetch the available voice regions for a guild …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_voice_regions"
>fetch_guild_voice_regions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_webhooks -- Fetch all guild webhooks …" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_webhooks"
>fetch_guild_webhooks</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_integrations -- Fetch the guild's integrations …" href="#hikari.impl.rest.RESTClientImpl.fetch_integrations"
>fetch_integrations</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_interaction_response -- Fetch the initial response for an interaction …" href="#hikari.impl.rest.RESTClientImpl.fetch_interaction_response"
>fetch_interaction_response</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_invite -- Fetch an existing invite …" href="#hikari.impl.rest.RESTClientImpl.fetch_invite"
>fetch_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_member -- Fetch a guild member …" href="#hikari.impl.rest.RESTClientImpl.fetch_member"
>fetch_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_members -- Fetch the members from a guild …" href="#hikari.impl.rest.RESTClientImpl.fetch_members"
>fetch_members</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_message -- Fetch a specific message in the given text channel …" href="#hikari.impl.rest.RESTClientImpl.fetch_message"
>fetch_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_messages -- Browse the message history for a given text channel …" href="#hikari.impl.rest.RESTClientImpl.fetch_messages"
>fetch_messages</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_my_connections -- Fetch the token's associated connections …" href="#hikari.impl.rest.RESTClientImpl.fetch_my_connections"
>fetch_my_connections</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_my_guilds -- Fetch the token's associated guilds …" href="#hikari.impl.rest.RESTClientImpl.fetch_my_guilds"
>fetch_my_guilds</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_my_user -- Fetch the token's associated user …" href="#hikari.impl.rest.RESTClientImpl.fetch_my_user"
>fetch_my_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_pins -- Fetch the pinned messages in this text channel …" href="#hikari.impl.rest.RESTClientImpl.fetch_pins"
>fetch_pins</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_reactions_for_emoji -- Fetch reactions for an emoji from a message …" href="#hikari.impl.rest.RESTClientImpl.fetch_reactions_for_emoji"
>fetch_reactions_for_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_roles -- Fetch the roles of a guild …" href="#hikari.impl.rest.RESTClientImpl.fetch_roles"
>fetch_roles</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_sticker -- Fetch a sticker …" href="#hikari.impl.rest.RESTClientImpl.fetch_sticker"
>fetch_sticker</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_template -- Fetch a guild template …" href="#hikari.impl.rest.RESTClientImpl.fetch_template"
>fetch_template</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_user -- Fetch a user …" href="#hikari.impl.rest.RESTClientImpl.fetch_user"
>fetch_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_vanity_url -- Fetch a guild's vanity url …" href="#hikari.impl.rest.RESTClientImpl.fetch_vanity_url"
>fetch_vanity_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_voice_regions -- Fetch available voice regions …" href="#hikari.impl.rest.RESTClientImpl.fetch_voice_regions"
>fetch_voice_regions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_webhook -- Fetch an existing webhook …" href="#hikari.impl.rest.RESTClientImpl.fetch_webhook"
>fetch_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_webhook_message -- Fetch an old message sent by the webhook …" href="#hikari.impl.rest.RESTClientImpl.fetch_webhook_message"
>fetch_webhook_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_welcome_screen -- Fetch a guild's welcome screen …" href="#hikari.impl.rest.RESTClientImpl.fetch_welcome_screen"
>fetch_welcome_screen</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_widget -- Fetch a guilds's widget …" href="#hikari.impl.rest.RESTClientImpl.fetch_widget"
>fetch_widget</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="follow_channel -- Follow a news channel to send messages to a target channel …" href="#hikari.impl.rest.RESTClientImpl.follow_channel"
>follow_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="guild_builder -- Make a guild builder to create a guild with …" href="#hikari.impl.rest.RESTClientImpl.guild_builder"
>guild_builder</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- Return the HTTP settings in use by this component …" href="#hikari.impl.rest.RESTClientImpl.http_settings"
>http_settings</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="interaction_deferred_builder -- Create a builder for a deferred message interaction response …" href="#hikari.impl.rest.RESTClientImpl.interaction_deferred_builder"
>interaction_deferred_builder</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="interaction_message_builder -- Create a builder for a message interaction response …" href="#hikari.impl.rest.RESTClientImpl.interaction_message_builder"
>interaction_message_builder</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_alive -- Whether this component is alive." href="#hikari.impl.rest.RESTClientImpl.is_alive"
>is_alive</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="kick_member -- Kick a member from a guild …" href="#hikari.impl.rest.RESTClientImpl.kick_user"
>kick_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="kick_user -- Kick a member from a guild …" href="#hikari.impl.rest.RESTClientImpl.kick_user"
>kick_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="leave_guild -- Leave a guild …" href="#hikari.impl.rest.RESTClientImpl.leave_guild"
>leave_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="pin_message -- Pin an existing message in the given text channel …" href="#hikari.impl.rest.RESTClientImpl.pin_message"
>pin_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="proxy_settings -- Return the proxy settings in use by this component …" href="#hikari.impl.rest.RESTClientImpl.proxy_settings"
>proxy_settings</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="refresh_access_token -- Refresh an access token …" href="#hikari.impl.rest.RESTClientImpl.refresh_access_token"
>refresh_access_token</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="remove_role_from_member -- Remove a role from a member …" href="#hikari.impl.rest.RESTClientImpl.remove_role_from_member"
>remove_role_from_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="reposition_channels -- Reposition the channels in a guild …" href="#hikari.impl.rest.RESTClientImpl.reposition_channels"
>reposition_channels</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="reposition_roles -- Reposition the roles in a guild …" href="#hikari.impl.rest.RESTClientImpl.reposition_roles"
>reposition_roles</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="revoke_access_token -- Revoke an OAuth2 token …" href="#hikari.impl.rest.RESTClientImpl.revoke_access_token"
>revoke_access_token</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="search_members -- Search the members in a guild by nickname and username …" href="#hikari.impl.rest.RESTClientImpl.search_members"
>search_members</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="set_application_command_permissions -- Set permissions for a specific command …" href="#hikari.impl.rest.RESTClientImpl.set_application_command_permissions"
>set_application_command_permissions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="set_application_commands -- Set the commands for an application …" href="#hikari.impl.rest.RESTClientImpl.set_application_commands"
>set_application_commands</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="set_application_guild_commands_permissions -- Set permissions in a guild for multiple commands …" href="#hikari.impl.rest.RESTClientImpl.set_application_guild_commands_permissions"
>set_application_guild_commands_permissions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="start -- Start the HTTP client …" href="#hikari.impl.rest.RESTClientImpl.start"
>start</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="sync_guild_template -- Create a guild template …" href="#hikari.impl.rest.RESTClientImpl.sync_guild_template"
>sync_guild_template</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="token_type -- Type of token this client is using for most requests …" href="#hikari.impl.rest.RESTClientImpl.token_type"
>token_type</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="trigger_typing -- Trigger typing in a text channel …" href="#hikari.impl.rest.RESTClientImpl.trigger_typing"
>trigger_typing</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="unban_member -- Unban a member from a guild …" href="#hikari.impl.rest.RESTClientImpl.unban_user"
>unban_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="unban_user -- Unban a member from a guild …" href="#hikari.impl.rest.RESTClientImpl.unban_user"
>unban_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="unpin_message -- Unpin a given message from a given text channel …" href="#hikari.impl.rest.RESTClientImpl.unpin_message"
>unpin_message</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1-L3471" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
# Copyright (c) 2021 davfsa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Implementation of a V8 compatible REST API for Discord.

This also includes implementations designed towards providing
RESTful functionality.
&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.List[str] = [&#34;ClientCredentialsStrategy&#34;, &#34;RESTApp&#34;, &#34;RESTClientImpl&#34;]

import asyncio
import base64
import collections
import contextlib
import copy
import datetime
import http
import logging
import math
import os
import platform
import sys
import typing

import aiohttp
import attr

from hikari import _about as about
from hikari import applications
from hikari import channels as channels_
from hikari import colors
from hikari import config
from hikari import embeds as embeds_
from hikari import emojis
from hikari import errors
from hikari import files
from hikari import guilds
from hikari import iterators
from hikari import permissions as permissions_
from hikari import snowflakes
from hikari import traits
from hikari import undefined
from hikari import urls
from hikari import users
from hikari.api import rest as rest_api
from hikari.impl import buckets as buckets_
from hikari.impl import entity_factory as entity_factory_impl
from hikari.impl import rate_limits
from hikari.impl import special_endpoints as special_endpoints_impl
from hikari.internal import data_binding
from hikari.internal import mentions
from hikari.internal import net
from hikari.internal import routes
from hikari.internal import time
from hikari.internal import ux

if typing.TYPE_CHECKING:
    import concurrent.futures
    import types

    from hikari import audit_logs
    from hikari import commands
    from hikari import invites
    from hikari import messages as messages_
    from hikari import sessions
    from hikari import stickers
    from hikari import templates
    from hikari import voices
    from hikari import webhooks
    from hikari.api import cache as cache_api
    from hikari.api import entity_factory as entity_factory_
    from hikari.api import special_endpoints
    from hikari.interactions import base_interactions

_LOGGER: typing.Final[logging.Logger] = logging.getLogger(&#34;hikari.rest&#34;)

_APPLICATION_JSON: typing.Final[str] = &#34;application/json&#34;
_APPLICATION_OCTET_STREAM: typing.Final[str] = &#34;application/octet-stream&#34;
_AUTHORIZATION_HEADER: typing.Final[str] = sys.intern(&#34;Authorization&#34;)
_HTTP_USER_AGENT: typing.Final[str] = (
    f&#34;DiscordBot ({about.__url__}, {about.__version__}) {about.__author__} &#34;
    f&#34;AIOHTTP/{aiohttp.__version__} &#34;
    f&#34;{platform.python_implementation()}/{platform.python_version()} {platform.system()} {platform.architecture()[0]}&#34;
)
_USER_AGENT_HEADER: typing.Final[str] = sys.intern(&#34;User-Agent&#34;)
_X_AUDIT_LOG_REASON_HEADER: typing.Final[str] = sys.intern(&#34;X-Audit-Log-Reason&#34;)
_X_RATELIMIT_BUCKET_HEADER: typing.Final[str] = sys.intern(&#34;X-RateLimit-Bucket&#34;)
_X_RATELIMIT_LIMIT_HEADER: typing.Final[str] = sys.intern(&#34;X-RateLimit-Limit&#34;)
_X_RATELIMIT_REMAINING_HEADER: typing.Final[str] = sys.intern(&#34;X-RateLimit-Remaining&#34;)
_X_RATELIMIT_RESET_AFTER_HEADER: typing.Final[str] = sys.intern(&#34;X-RateLimit-Reset-After&#34;)
_RETRY_ERROR_CODES: typing.Final[typing.Set[int]] = {500, 502, 503, 504}
_MAX_BACKOFF_DURATION: typing.Final[int] = 16


class ClientCredentialsStrategy(rest_api.TokenStrategy):
    &#34;&#34;&#34;Strategy class for handling client credential OAuth2 authorization.

    Parameters
    ----------
    client: typing.Optional[snowflakes.SnowflakeishOr[guilds.PartialApplication]]
        Object or ID of the application this client credentials strategy should
        authorize as.
    client_secret : typing.Optional[builtins.str]
        Client secret to use when authorizing.

    Other Parameters
    ----------------
    scopes : typing.Sequence[str]
        The scopes to authorize for.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_client_id&#34;,
        &#34;_client_secret&#34;,
        &#34;_exception&#34;,
        &#34;_expire_at&#34;,
        &#34;_lock&#34;,
        &#34;_scopes&#34;,
        &#34;_token&#34;,
    )

    def __init__(
        self,
        client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        client_secret: str,
        *,
        scopes: typing.Sequence[typing.Union[applications.OAuth2Scope, str]] = (
            applications.OAuth2Scope.APPLICATIONS_COMMANDS_UPDATE,
            applications.OAuth2Scope.IDENTIFY,
        ),
    ) -&gt; None:
        self._client_id = snowflakes.Snowflake(client)
        self._client_secret = client_secret
        self._exception: typing.Optional[errors.ClientHTTPResponseError] = None
        self._expire_at = 0.0
        self._lock = asyncio.Lock()
        self._scopes = tuple(scopes)
        self._token: typing.Optional[str] = None

    @property
    def client_id(self) -&gt; snowflakes.Snowflake:
        &#34;&#34;&#34;ID of the application this token strategy authenticates with.

        Returns
        -------
        hikari.snowflakes.Snowflake
            ID of the application this token strategy authenticates with.
        &#34;&#34;&#34;
        return self._client_id

    @property
    def _is_expired(self) -&gt; bool:
        return time.monotonic() &gt;= self._expire_at

    @property
    def scopes(self) -&gt; typing.Sequence[typing.Union[applications.OAuth2Scope, str]]:
        &#34;&#34;&#34;Scopes this token strategy authenticates for.

        Returns
        -------
        typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, builtins.str]]
            The scopes this token strategy authenticates for.
        &#34;&#34;&#34;
        return self._scopes

    @property
    def token_type(self) -&gt; applications.TokenType:
        return applications.TokenType.BEARER

    async def acquire(self, client: rest_api.RESTClient) -&gt; str:
        if self._token and not self._is_expired:
            return self._token

        async with self._lock:
            if self._token and not self._is_expired:
                return self._token

            if self._exception:
                # If we don&#39;t copy the exception then python keeps adding onto the stack each time it&#39;s raised.
                raise copy.copy(self._exception) from None

            try:
                response = await client.authorize_client_credentials_token(
                    client=self._client_id, client_secret=self._client_secret, scopes=self._scopes
                )

            except errors.ClientHTTPResponseError as exc:
                if not isinstance(exc, errors.RateLimitedError):
                    # If we don&#39;t copy the exception then python keeps adding onto the stack each time it&#39;s raised.
                    self._exception = copy.copy(exc)

                raise

            # Expires in is lowered a bit in-order to lower the chance of a dead token being used.
            self._expire_at = time.monotonic() + math.floor(response.expires_in.total_seconds() * 0.99)
            self._token = f&#34;{response.token_type} {response.access_token}&#34;
            return self._token

    def invalidate(self, token: typing.Optional[str]) -&gt; None:
        if not token or token == self._token:
            self._expire_at = 0.0
            self._token = None


class _RESTProvider(traits.RESTAware):
    __slots__: typing.Sequence[str] = (&#34;_entity_factory&#34;, &#34;_executor&#34;, &#34;_rest&#34;)

    def __init__(
        self,
        entity_factory: typing.Callable[[], entity_factory_.EntityFactory],
        executor: typing.Optional[concurrent.futures.Executor],
        rest: typing.Callable[[], rest_api.RESTClient],
    ) -&gt; None:
        self._entity_factory = entity_factory
        self._executor = executor
        self._rest = rest

    @property
    def entity_factory(self) -&gt; entity_factory_.EntityFactory:
        return self._entity_factory()

    @property
    def executor(self) -&gt; typing.Optional[concurrent.futures.Executor]:
        return self._executor

    @property
    def rest(self) -&gt; rest_api.RESTClient:
        return self._rest()

    @property
    def http_settings(self) -&gt; config.HTTPSettings:
        return self._rest().http_settings

    @property
    def proxy_settings(self) -&gt; config.ProxySettings:
        return self._rest().proxy_settings


_NONE_OR_UNDEFINED: typing.Final[typing.Tuple[None, undefined.UndefinedType]] = (None, undefined.UNDEFINED)


class RESTApp(traits.ExecutorAware):
    &#34;&#34;&#34;The base for a HTTP-only Discord application.

    This comprises of a shared TCP connector connection pool, and can have
    `RESTClientImpl` instances for specific credentials acquired
    from it.

    Parameters
    ----------
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to use for blocking file IO operations. If `builtins.None`
        is passed, then the default `concurrent.futures.ThreadPoolExecutor` for
        the `asyncio.AbstractEventLoop` will be used instead.
    http_settings : typing.Optional[hikari.config.HTTPSettings]
        HTTP settings to use. Sane defaults are used if this is
        `builtins.None`.
    max_rate_limit : builtins.float
        Maximum number of seconds to sleep for when rate limited. If a rate
        limit occurs that is longer than this value, then a
        `hikari.errors.RateLimitedError` will be raised instead of waiting.

        This is provided since some endpoints may respond with non-sensible
        rate limits.

        Defaults to five minutes if unspecified.
    max_retries : typing.Optional[builtins.int]
        Maximum number of times a request will be retried if
        it fails with a `5xx` status. Defaults to 3 if set to `builtins.None`.
    proxy_settings : typing.Optional[hikari.config.ProxySettings]
        Proxy settings to use. If `builtins.None` then no proxy configuration
        will be used.
    url : typing.Optional[builtins.str]
        The base URL for the API. You can generally leave this as being
        `builtins.None` and the correct default API base URL will be generated.

    !!! note
        This event loop will be bound to a connector when the first call
        to `acquire` is made.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_executor&#34;,
        &#34;_http_settings&#34;,
        &#34;_max_rate_limit&#34;,
        &#34;_max_retries&#34;,
        &#34;_proxy_settings&#34;,
        &#34;_url&#34;,
    )

    def __init__(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        http_settings: typing.Optional[config.HTTPSettings] = None,
        max_rate_limit: float = 300,
        max_retries: int = 3,
        proxy_settings: typing.Optional[config.ProxySettings] = None,
        url: typing.Optional[str] = None,
    ) -&gt; None:
        self._http_settings = config.HTTPSettings() if http_settings is None else http_settings
        self._proxy_settings = config.ProxySettings() if proxy_settings is None else proxy_settings
        self._executor = executor
        self._max_rate_limit = max_rate_limit
        self._max_retries = max_retries
        self._url = url

    @property
    def executor(self) -&gt; typing.Optional[concurrent.futures.Executor]:
        return self._executor

    @property
    def http_settings(self) -&gt; config.HTTPSettings:
        return self._http_settings

    @property
    def proxy_settings(self) -&gt; config.ProxySettings:
        return self._proxy_settings

    @typing.overload
    def acquire(self, token: typing.Optional[rest_api.TokenStrategy] = None) -&gt; RESTClientImpl:
        ...

    @typing.overload
    def acquire(
        self,
        token: str,
        token_type: typing.Union[str, applications.TokenType] = applications.TokenType.BEARER,
    ) -&gt; RESTClientImpl:
        ...

    def acquire(
        self,
        token: typing.Union[str, rest_api.TokenStrategy, None] = None,
        token_type: typing.Union[str, applications.TokenType, None] = None,
    ) -&gt; RESTClientImpl:
        &#34;&#34;&#34;Acquire an instance of this REST client.

        !!! note
            The returned REST client should be started before it can be used,
            either by calling `RESTClientImpl.start` or by using it as an
            asynchronous context manager.

        Examples
        --------
        ```py
        rest_app = RESTApp()

        # Using the returned client as a context manager to implicitly start
        # and stop it.
        async with rest_app.acquire(&#34;A token&#34;, &#34;Bot&#34;) as client:
            user = await client.fetch_my_user()
        ```

        Parameters
        ----------
        token : typing.Union[builtins.str, builtins.None, hikari.api.rest.TokenStrategy]
            The bot or bearer token. If no token is to be used,
            this can be undefined.
        token_type : typing.Union[builtins.str, hikari.applications.TokenType, builtins.None]
            The type of token in use. This should only be passed when `builtins.str`
            is passed for `token`, can be `&#34;Bot&#34;` or `&#34;Bearer&#34;` and will be
            defaulted to `&#34;Bearer&#34;` in this situation.

            This should be left as `builtins.None` when either
            `hikari.api.rest.TokenStrategy` or `builtins.None` is passed for
            `token`.

        Returns
        -------
        RESTClientImpl
            An instance of the REST client.

        Raises
        ------
        builtins.ValueError
            If `token_type` is provided when a token strategy is passed for `token`.
        &#34;&#34;&#34;
        # Since we essentially mimic a fake App instance, we need to make a circular provider.
        # We can achieve this using a lambda. This allows the entity factory to build models that
        # are also REST-aware
        provider = _RESTProvider(lambda: entity_factory, self._executor, lambda: rest_client)
        entity_factory = entity_factory_impl.EntityFactoryImpl(provider)

        if token_type is None and isinstance(token, str):
            token_type = applications.TokenType.BEARER

        rest_client = RESTClientImpl(
            cache=None,
            entity_factory=entity_factory,
            executor=self._executor,
            http_settings=self._http_settings,
            max_rate_limit=self._max_rate_limit,
            max_retries=self._max_retries,
            proxy_settings=self._proxy_settings,
            token=token,
            token_type=token_type,
            rest_url=self._url,
        )

        return rest_client


@attr.define()
class _LiveAttributes:
    &#34;&#34;&#34;Fields which are only present within `RESTClientImpl` while it&#39;s &#34;alive&#34;.

    !!! note
        This must be started within an active asyncio event loop.
    &#34;&#34;&#34;

    buckets: buckets_.RESTBucketManager = attr.field()
    client_session: aiohttp.ClientSession = attr.field()
    closed_event: asyncio.Event = attr.field()
    # We&#39;ve been told in DAPI that this is per token.
    global_rate_limit: rate_limits.ManualRateLimiter = attr.field()
    tcp_connector: aiohttp.TCPConnector = attr.field()
    is_closing: bool = attr.field(default=False, init=False)

    @classmethod
    def build(
        cls, max_rate_limit: float, http_settings: config.HTTPSettings, proxy_settings: config.ProxySettings
    ) -&gt; _LiveAttributes:
        &#34;&#34;&#34;Build a live attributes object.

        !!! warning
            This can only be called when the current thread has an active
            asyncio loop.
        &#34;&#34;&#34;
        # This asserts that this is called within an active event loop.
        asyncio.get_running_loop()
        tcp_connector = net.create_tcp_connector(http_settings)
        _LOGGER.log(ux.TRACE, &#34;acquired new tcp connector&#34;)
        client_session = net.create_client_session(
            connector=tcp_connector,
            # No, this is correct. We manage closing the connector ourselves in this class.
            # This works around some other lifespan issues.
            connector_owner=False,
            http_settings=http_settings,
            raise_for_status=False,
            trust_env=proxy_settings.trust_env,
        )
        _LOGGER.log(ux.TRACE, &#34;acquired new aiohttp client session&#34;)
        return _LiveAttributes(
            buckets=buckets_.RESTBucketManager(max_rate_limit),
            client_session=client_session,
            closed_event=asyncio.Event(),
            global_rate_limit=rate_limits.ManualRateLimiter(),
            tcp_connector=tcp_connector,
        )

    async def close(self) -&gt; None:
        self.is_closing = True
        self.closed_event.set()
        self.buckets.close()
        self.global_rate_limit.close()
        await self.client_session.close()
        await self.tcp_connector.close()

    def still_alive(self) -&gt; _LiveAttributes:
        &#34;&#34;&#34;Chained method used to Check if `close` has been called before using this object&#39;s resources.&#34;&#34;&#34;
        if self.is_closing:
            raise errors.ComponentStateConflictError(&#34;The REST client was closed mid-request&#34;)

        return self


@attr.define(auto_exc=True, repr=False, weakref_slot=False)
class _RetryRequest(RuntimeError):
    ...


class RESTClientImpl(rest_api.RESTClient):
    &#34;&#34;&#34;Implementation of the V8-compatible Discord HTTP API.

    This manages making HTTP/1.1 requests to the API and using the entity
    factory within the passed application instance to deserialize JSON responses
    to Pythonic data classes that are used throughout this library.

    Parameters
    ----------
    entity_factory : hikari.api.entity_factory.EntityFactory
        The entity factory to use.
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to use for blocking IO. Defaults to the `asyncio` thread
        pool if set to `builtins.None`.
    max_rate_limit : builtins.float
        Maximum number of seconds to sleep for when rate limited. If a rate
        limit occurs that is longer than this value, then a
        `hikari.errors.RateLimitedError` will be raised instead of waiting.

        This is provided since some endpoints may respond with non-sensible
        rate limits.
    max_retries : typing.Optional[builtins.int]
        Maximum number of times a request will be retried if
        it fails with a `5xx` status. Defaults to 3 if set to `builtins.None`.
    token : typing.Union[builtins.str, builtins.None, hikari.api.rest.TokenStrategy]
        The bot or bearer token. If no token is to be used,
        this can be undefined.
    token_type : typing.Union[builtins.str, hikari.applications.TokenType, builtins.None]
        The type of token in use. This must be passed when a `builtins.str` is
        passed for `token` but and can be `&#34;Bot&#34;` or `&#34;Bearer&#34;`.

        This should be left as `builtins.None` when either
        `hikari.api.rest.TokenStrategy` or `builtins.None` is passed for
        `token`.
    rest_url : builtins.str
        The HTTP API base URL. This can contain format-string specifiers to
        interpolate information such as API version in use.

    Raises
    ------
    builtins.ValueError
        * If `token_type` is provided when a token strategy is passed for `token`.
        * if `token_type` is left as `builtins.None` when a string is passed for `token`.
        * If the a value more than 5 is provided for `max_retries`
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_cache&#34;,
        &#34;_entity_factory&#34;,
        &#34;_executor&#34;,
        &#34;_http_settings&#34;,
        &#34;_live_attributes&#34;,
        &#34;_max_rate_limit&#34;,
        &#34;_max_retries&#34;,
        &#34;_proxy_settings&#34;,
        &#34;_rest_url&#34;,
        &#34;_token&#34;,
        &#34;_token_type&#34;,
    )

    def __init__(
        self,
        *,
        cache: typing.Optional[cache_api.MutableCache],
        entity_factory: entity_factory_.EntityFactory,
        executor: typing.Optional[concurrent.futures.Executor],
        http_settings: config.HTTPSettings,
        max_rate_limit: float,
        max_retries: int = 3,
        proxy_settings: config.ProxySettings,
        token: typing.Union[str, None, rest_api.TokenStrategy],
        token_type: typing.Union[applications.TokenType, str, None],
        rest_url: typing.Optional[str],
    ) -&gt; None:
        if max_retries &gt; 5:
            raise ValueError(&#34;&#39;max_retries&#39; must be below or equal to 5&#34;)

        self._cache = cache
        self._entity_factory = entity_factory
        self._executor = executor
        self._http_settings = http_settings
        self._live_attributes: typing.Optional[_LiveAttributes] = None
        self._max_rate_limit = max_rate_limit
        self._max_retries = max_retries
        self._proxy_settings = proxy_settings

        self._token: typing.Union[str, rest_api.TokenStrategy, None] = None
        self._token_type: typing.Optional[str] = None
        if isinstance(token, str):
            if token_type is None:
                raise ValueError(&#34;Token type required when a str is passed for `token`&#34;)

            self._token = f&#34;{token_type.title()} {token}&#34;
            self._token_type = applications.TokenType(token_type.title())

        elif isinstance(token, rest_api.TokenStrategy):
            if token_type is not None:
                raise ValueError(&#34;Token type should be handled by the token strategy&#34;)

            self._token = token
            self._token_type = token.token_type

        self._rest_url = rest_url if rest_url is not None else urls.REST_API_URL

    @property
    def is_alive(self) -&gt; bool:
        return self._live_attributes is not None

    @property
    def http_settings(self) -&gt; config.HTTPSettings:
        return self._http_settings

    @property
    def proxy_settings(self) -&gt; config.ProxySettings:
        return self._proxy_settings

    @property
    def token_type(self) -&gt; typing.Union[str, applications.TokenType, None]:
        return self._token_type

    @typing.final
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the HTTP client and any open HTTP connections.&#34;&#34;&#34;
        live_attributes = self._get_live_attributes()
        self._live_attributes = None
        await live_attributes.close()

        # We have to sleep to allow aiohttp time to close SSL transports...
        # https://github.com/aio-libs/aiohttp/issues/1925
        # https://docs.aiohttp.org/en/stable/client_advanced.html#graceful-shutdown
        #
        # TODO: Remove when we update to aiohttp 4.0.0
        # https://github.com/aio-libs/aiohttp/issues/1925#issuecomment-715977247
        await asyncio.sleep(0.25)

    @typing.final
    def start(self) -&gt; None:
        &#34;&#34;&#34;Start the HTTP client.

        !!! note
            This must be called within an active event loop.

        Raises
        ------
        RuntimeError
            If this is called in an environment without an active event loop.
        &#34;&#34;&#34;
        if self._live_attributes:
            raise errors.ComponentStateConflictError(&#34;Cannot start a REST Client which is already alive&#34;)

        self._live_attributes = _LiveAttributes.build(self._max_rate_limit, self._http_settings, self._proxy_settings)

    def _get_live_attributes(self) -&gt; _LiveAttributes:
        if self._live_attributes:
            return self._live_attributes

        raise errors.ComponentStateConflictError(&#34;Cannot use an inactive REST client&#34;)

    async def __aenter__(self) -&gt; RESTClientImpl:
        self.start()
        return self

    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        await self.close()

    # These are only included at runtime in-order to avoid the model being typed as a synchronous context manager.
    if not typing.TYPE_CHECKING:

        def __enter__(self) -&gt; typing.NoReturn:
            # This is async only.
            cls = type(self)
            raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is async-only, did you mean &#39;async with&#39;?&#34;) from None

        def __exit__(
            self,
            exc_type: typing.Optional[typing.Type[Exception]],
            exc_val: typing.Optional[Exception],
            exc_tb: typing.Optional[types.TracebackType],
        ) -&gt; None:
            return None

    @typing.final
    async def _request(
        self,
        compiled_route: routes.CompiledRoute,
        *,
        query: typing.Optional[data_binding.StringMapBuilder] = None,
        form: typing.Optional[aiohttp.FormData] = None,
        json: typing.Union[data_binding.JSONObjectBuilder, data_binding.JSONArray, None] = None,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        no_auth: bool = False,
        auth: typing.Optional[str] = None,
    ) -&gt; typing.Union[None, data_binding.JSONObject, data_binding.JSONArray]:
        # Make a ratelimit-protected HTTP request to a JSON endpoint and expect some form
        # of JSON response.
        live_attributes = self._get_live_attributes()
        headers = data_binding.StringMapBuilder()
        headers.setdefault(_USER_AGENT_HEADER, _HTTP_USER_AGENT)

        re_authed = False
        token: typing.Optional[str] = None
        if auth:
            headers[_AUTHORIZATION_HEADER] = auth

        elif not no_auth:
            if isinstance(self._token, str):
                headers[_AUTHORIZATION_HEADER] = self._token

            elif self._token is not None:
                token = await self._token.acquire(self)
                headers[_AUTHORIZATION_HEADER] = token

        headers.put(_X_AUDIT_LOG_REASON_HEADER, reason)

        url = compiled_route.create_url(self._rest_url)

        # This is initiated the first time we hit a 5xx error to save memory when nothing goes wrong
        backoff: typing.Optional[rate_limits.ExponentialBackOff] = None
        retry_count = 0

        while True:
            try:
                uuid = time.uuid()
                async with live_attributes.still_alive().buckets.acquire(compiled_route):
                    # Buckets not using authentication still have a global
                    # rate limit, but it is different from the token one.
                    if not no_auth:
                        await live_attributes.still_alive().global_rate_limit.acquire()

                    if _LOGGER.isEnabledFor(ux.TRACE):
                        _LOGGER.log(
                            ux.TRACE,
                            &#34;%s %s %s\n%s&#34;,
                            uuid,
                            compiled_route.method,
                            url,
                            self._stringify_http_message(headers, json),
                        )
                        start = time.monotonic()

                    # Make the request.
                    response = await live_attributes.still_alive().client_session.request(
                        compiled_route.method,
                        url,
                        headers=headers,
                        params=query,
                        json=json,
                        data=form,
                        allow_redirects=self._http_settings.max_redirects is not None,
                        max_redirects=self._http_settings.max_redirects,
                        proxy=self._proxy_settings.url,
                        proxy_headers=self._proxy_settings.all_headers,
                    )

                    if _LOGGER.isEnabledFor(ux.TRACE):
                        time_taken = (time.monotonic() - start) * 1_000
                        _LOGGER.log(
                            ux.TRACE,
                            &#34;%s %s %s in %sms\n%s&#34;,
                            uuid,
                            response.status,
                            response.reason,
                            time_taken,
                            self._stringify_http_message(response.headers, await response.read()),
                        )

                    # Ensure we are not rate limited, and update rate limiting headers where appropriate.
                    await self._parse_ratelimits(compiled_route, response, live_attributes)

                # Don&#39;t bother processing any further if we got NO CONTENT. There&#39;s not anything
                # to check.
                if response.status == http.HTTPStatus.NO_CONTENT:
                    return None

                # Handle the response when everything went good
                if 200 &lt;= response.status &lt; 300:
                    if response.content_type == _APPLICATION_JSON:
                        # Only deserializing here stops Cloudflare shenanigans messing us around.
                        return data_binding.load_json(await response.read())

                    real_url = str(response.real_url)
                    raise errors.HTTPError(f&#34;Expected JSON [{response.content_type=}, {real_url=}]&#34;)

                # Handling 5xx errors
                if response.status in _RETRY_ERROR_CODES and retry_count &lt; self._max_retries:
                    if backoff is None:
                        backoff = rate_limits.ExponentialBackOff(maximum=_MAX_BACKOFF_DURATION)

                    sleep_time = next(backoff)
                    _LOGGER.warning(
                        &#34;Received status %s on request, backing off for %.2fs and retrying. Retries remaining: %s&#34;,
                        response.status,
                        sleep_time,
                        self._max_retries - retry_count,
                    )
                    retry_count += 1

                    await asyncio.sleep(sleep_time)
                    raise _RetryRequest

                # Attempt to re-auth on UNAUTHORIZED if we are using a TokenStrategy
                can_re_auth = response.status == 401 and not (auth or no_auth or re_authed)
                if can_re_auth and isinstance(self._token, rest_api.TokenStrategy):
                    assert token is not None
                    self._token.invalidate(token)
                    token = await self._token.acquire(self)
                    headers[_AUTHORIZATION_HEADER] = token
                    re_authed = True
                    continue

                await self._handle_error_response(response)

            except _RetryRequest:
                continue

    @staticmethod
    @typing.final
    def _stringify_http_message(headers: data_binding.Headers, body: typing.Any) -&gt; str:
        string = &#34;\n&#34;.join(
            f&#34;    {name}: {value}&#34; if name != _AUTHORIZATION_HEADER else f&#34;    {name}: **REDACTED TOKEN**&#34;
            for name, value in headers.items()
        )

        if body is not None:
            string += &#34;\n\n    &#34;
            string += body.decode(&#34;ascii&#34;) if isinstance(body, bytes) else str(body)

        return string

    @staticmethod
    @typing.final
    async def _handle_error_response(response: aiohttp.ClientResponse) -&gt; typing.NoReturn:
        raise await net.generate_error_response(response)

    @typing.final
    async def _parse_ratelimits(
        self, compiled_route: routes.CompiledRoute, response: aiohttp.ClientResponse, live_attributes: _LiveAttributes
    ) -&gt; None:
        # Handle rate limiting.
        resp_headers = response.headers
        limit = int(resp_headers.get(_X_RATELIMIT_LIMIT_HEADER, &#34;1&#34;))
        remaining = int(resp_headers.get(_X_RATELIMIT_REMAINING_HEADER, &#34;1&#34;))
        bucket = resp_headers.get(_X_RATELIMIT_BUCKET_HEADER)
        reset_after = float(resp_headers.get(_X_RATELIMIT_RESET_AFTER_HEADER, &#34;0&#34;))

        if bucket:
            live_attributes.still_alive().buckets.update_rate_limits(
                compiled_route=compiled_route,
                bucket_header=bucket,
                remaining_header=remaining,
                limit_header=limit,
                reset_after=reset_after,
            )

        if response.status != http.HTTPStatus.TOO_MANY_REQUESTS:
            return

        # Discord have started applying ratelimits to operations on some endpoints
        # based on specific fields used in the JSON body.
        # This does not get reflected in the headers. The first we know is when we
        # get a 429.
        # The issue is that we may get the same response if Discord dynamically
        # adjusts the bucket ratelimits.
        #
        # We have no mechanism for handing field-based ratelimits, so if we get
        # to here, but notice remaining is greater than zero, we should just error.
        #
        # Seems Discord may raise this on some other undocumented cases, which
        # is nice of them. Apparently some dude spamming slurs in the Python
        # guild via a leaked webhook URL made people&#39;s clients exhibit this
        # behaviour.
        #
        # If we get ratelimited when running more than one bot under the same token,
        # or if the ratelimiting logic goes wrong, we will get a 429 and expect the
        # &#34;remaining&#34; header to be zeroed, or even negative as I don&#39;t trust that there
        # isn&#39;t some weird edge case here somewhere in Discord&#39;s implementation.
        # We can safely retry if this happens as acquiring the bucket will handle
        # this.
        if remaining &lt;= 0:
            _LOGGER.warning(
                &#34;rate limited on bucket %s, maybe you are running more than one bot on this token? Retrying request...&#34;,
                bucket,
            )
            raise _RetryRequest

        if response.content_type != _APPLICATION_JSON:
            # We don&#39;t know exactly what this could imply. It is likely Cloudflare interfering
            # but I&#39;d rather we just give up than do something resulting in multiple failed
            # requests repeatedly.
            raise errors.HTTPResponseError(
                str(response.real_url),
                http.HTTPStatus.TOO_MANY_REQUESTS,
                response.headers,
                await response.read(),
                f&#34;received rate limited response with unexpected response type {response.content_type}&#34;,
            )

        body = await response.json()
        body_retry_after = float(body[&#34;retry_after&#34;])

        if body.get(&#34;global&#34;, False) is True:
            _LOGGER.error(
                &#34;rate limited on the global bucket. You should consider lowering the number of requests you make or &#34;
                &#34;contacting Discord to raise this limit. Backing off and retrying request...&#34;
            )
            live_attributes.still_alive().global_rate_limit.throttle(body_retry_after)
            raise _RetryRequest

        # If the values are within 20% of each other by relativistic tolerance, it is probably
        # safe to retry the request, as they are likely the same value just with some
        # measuring difference. 20% was used as a rounded figure.
        if math.isclose(body_retry_after, reset_after, rel_tol=0.20):
            _LOGGER.error(&#34;rate limited on a sub bucket on bucket %s, but it is safe to retry&#34;, bucket)
            raise _RetryRequest

        raise errors.RateLimitedError(
            url=str(response.real_url),
            route=compiled_route,
            headers=response.headers,
            raw_body=body,
            retry_after=body_retry_after,
        )

    async def fetch_channel(
        self, channel: snowflakes.SnowflakeishOr[channels_.PartialChannel]
    ) -&gt; channels_.PartialChannel:
        route = routes.GET_CHANNEL.compile(channel=channel)
        response = await self._request(route)
        assert isinstance(response, dict)
        result = self._entity_factory.deserialize_channel(response)

        if self._cache and isinstance(result, channels_.DMChannel):
            self._cache.set_dm_channel_id(result.recipient.id, result.id)

        return result

    async def edit_channel(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
        /,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        video_quality_mode: undefined.UndefinedOr[typing.Union[channels_.VideoQualityMode, int]] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        region: undefined.UndefinedNoneOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        parent_category: undefined.UndefinedOr[
            snowflakes.SnowflakeishOr[channels_.GuildCategory]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.PartialChannel:
        route = routes.PATCH_CHANNEL.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;position&#34;, position)
        body.put(&#34;topic&#34;, topic)
        body.put(&#34;nsfw&#34;, nsfw)
        body.put(&#34;bitrate&#34;, bitrate)
        body.put(&#34;video_quality_mode&#34;, video_quality_mode)
        body.put(&#34;user_limit&#34;, user_limit)
        body.put(&#34;rate_limit_per_user&#34;, rate_limit_per_user, conversion=time.timespan_to_int)
        body.put(&#34;rtc_region&#34;, region, conversion=str)
        body.put_snowflake(&#34;parent_id&#34;, parent_category)
        body.put_array(
            &#34;permission_overwrites&#34;,
            permission_overwrites,
            conversion=self._entity_factory.serialize_permission_overwrite,
        )

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_channel(response)

    async def follow_channel(
        self,
        news_channel: snowflakes.SnowflakeishOr[channels_.GuildNewsChannel],
        target_channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.ChannelFollow:
        route = routes.POST_CHANNEL_FOLLOWERS.compile(channel=news_channel)
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;webhook_channel_id&#34;, target_channel)

        response = await self._request(route, json=body, reason=reason)

        assert isinstance(response, dict)
        return self._entity_factory.deserialize_channel_follow(response)

    async def delete_channel(
        self, channel: snowflakes.SnowflakeishOr[channels_.PartialChannel]
    ) -&gt; channels_.PartialChannel:
        route = routes.DELETE_CHANNEL.compile(channel=channel)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_channel(response)

    async def edit_my_voice_state(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels_.GuildStageChannel],
        *,
        suppress: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        request_to_speak: typing.Union[undefined.UndefinedType, bool, datetime.datetime] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_MY_GUILD_VOICE_STATE.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;channel_id&#34;, channel)
        body.put(&#34;suppress&#34;, suppress)

        if isinstance(request_to_speak, datetime.datetime):
            body.put(&#34;request_to_speak_timestamp&#34;, request_to_speak.isoformat())

        elif request_to_speak is True:
            body.put(&#34;request_to_speak_timestamp&#34;, time.utc_datetime().isoformat())

        elif request_to_speak is False:
            body.put(&#34;request_to_speak_timestamp&#34;, None)

        await self._request(route, json=body)

    async def edit_voice_state(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels_.GuildStageChannel],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        suppress: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_GUILD_VOICE_STATE.compile(guild=guild, user=user)
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;channel_id&#34;, channel)
        body.put(&#34;suppress&#34;, suppress)
        await self._request(route, json=body)

    async def edit_permission_overwrites(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
        target: typing.Union[
            snowflakes.Snowflakeish, users.PartialUser, guilds.PartialRole, channels_.PermissionOverwrite
        ],
        *,
        target_type: undefined.UndefinedOr[typing.Union[channels_.PermissionOverwriteType, int]] = undefined.UNDEFINED,
        allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        if target_type is undefined.UNDEFINED:
            if isinstance(target, users.PartialUser):
                target_type = channels_.PermissionOverwriteType.MEMBER
            elif isinstance(target, guilds.Role):
                target_type = channels_.PermissionOverwriteType.ROLE
            elif isinstance(target, channels_.PermissionOverwrite):
                target_type = target.type
            else:
                raise TypeError(
                    &#34;Cannot determine the type of the target to update. Try specifying &#39;target_type&#39; manually.&#34;
                )

        route = routes.PUT_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;type&#34;, target_type)
        body.put(&#34;allow&#34;, allow)
        body.put(&#34;deny&#34;, deny)
        await self._request(route, json=body, reason=reason)

    async def delete_permission_overwrite(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
        target: snowflakes.SnowflakeishOr[
            typing.Union[channels_.PermissionOverwrite, guilds.PartialRole, users.PartialUser, snowflakes.Snowflakeish]
        ],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
        await self._request(route)

    async def fetch_channel_invites(
        self, channel: snowflakes.SnowflakeishOr[channels_.GuildChannel]
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        route = routes.GET_CHANNEL_INVITES.compile(channel=channel)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_invite_with_metadata(invite_payload) for invite_payload in response]

    async def create_invite(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
        *,
        max_age: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        max_uses: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        temporary: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        unique: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        target_type: undefined.UndefinedOr[invites.TargetType] = undefined.UNDEFINED,
        target_user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        target_application: undefined.UndefinedOr[
            snowflakes.SnowflakeishOr[guilds.PartialApplication]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; invites.InviteWithMetadata:
        route = routes.POST_CHANNEL_INVITES.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;max_age&#34;, max_age, conversion=time.timespan_to_int)
        body.put(&#34;max_uses&#34;, max_uses)
        body.put(&#34;temporary&#34;, temporary)
        body.put(&#34;unique&#34;, unique)
        body.put(&#34;target_type&#34;, target_type)
        body.put_snowflake(&#34;target_user_id&#34;, target_user)
        body.put_snowflake(&#34;target_application_id&#34;, target_application)
        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_invite_with_metadata(response)

    def trigger_typing(
        self, channel: snowflakes.SnowflakeishOr[channels_.TextableChannel]
    ) -&gt; special_endpoints.TypingIndicator:
        return special_endpoints_impl.TypingIndicator(
            request_call=self._request, channel=channel, rest_closed_event=self._get_live_attributes().closed_event
        )

    async def fetch_pins(
        self, channel: snowflakes.SnowflakeishOr[channels_.TextableChannel]
    ) -&gt; typing.Sequence[messages_.Message]:
        route = routes.GET_CHANNEL_PINS.compile(channel=channel)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_message(message_pl) for message_pl in response]

    async def pin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        route = routes.PUT_CHANNEL_PINS.compile(channel=channel, message=message)
        await self._request(route)

    async def unpin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_PIN.compile(channel=channel, message=message)
        await self._request(route)

    def fetch_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        after: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        around: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[messages_.Message]:
        if undefined.count(before, after, around) &lt; 2:
            raise TypeError(&#34;Expected no kwargs, or a maximum of one of &#39;before&#39;, &#39;after&#39;, &#39;around&#39;&#34;)

        timestamp: undefined.UndefinedOr[str]

        if before is not undefined.UNDEFINED:
            direction = &#34;before&#34;
            if isinstance(before, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(before))
            else:
                timestamp = str(int(before))
        elif after is not undefined.UNDEFINED:
            direction = &#34;after&#34;
            if isinstance(after, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(after))
            else:
                timestamp = str(int(after))
        elif around is not undefined.UNDEFINED:
            direction = &#34;around&#34;
            if isinstance(around, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(around))
            else:
                timestamp = str(int(around))
        else:
            direction = &#34;before&#34;
            timestamp = undefined.UNDEFINED

        return special_endpoints_impl.MessageIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            channel=channel,
            direction=direction,
            first_id=timestamp,
        )

    async def fetch_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; messages_.Message:
        route = routes.GET_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def _create_message(
        self,
        route: routes.CompiledRoute,
        body: data_binding.JSONObjectBuilder,
        query: typing.Optional[data_binding.StringMapBuilder] = None,
        *,
        no_auth: bool = False,
        content: undefined.UndefinedOr[typing.Any],
        attachment: undefined.UndefinedOr[files.Resourceish],
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]],
        component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed],
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]],
        tts: undefined.UndefinedOr[bool],
        mentions_everyone: undefined.UndefinedOr[bool],
        mentions_reply: undefined.UndefinedOr[bool],
        user_mentions: undefined.UndefinedOr[typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]],
        role_mentions: undefined.UndefinedOr[typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]],
    ) -&gt; messages_.Message:
        if not undefined.any_undefined(attachment, attachments):
            raise ValueError(&#34;You may only specify one of &#39;attachment&#39; or &#39;attachments&#39;, not both&#34;)

        if not undefined.any_undefined(component, components):
            raise ValueError(&#34;You may only specify one of &#39;component&#39; or &#39;components&#39;, not both&#34;)

        if not undefined.any_undefined(embed, embeds):
            raise ValueError(&#34;You may only specify one of &#39;embed&#39; or &#39;embeds&#39;, not both&#34;)

        if attachments is not undefined.UNDEFINED and not isinstance(attachments, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;attachments&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;attachment&#39; (singular) instead?&#34;
            )

        if components is not undefined.UNDEFINED and not isinstance(components, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;components&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;component&#39; (singular) instead?&#34;
            )

        if embeds not in _NONE_OR_UNDEFINED and not isinstance(embeds, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;embeds&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;embed&#39; (singular) instead?&#34;
            )

        if undefined.all_undefined(embed, embeds) and isinstance(content, embeds_.Embed):
            # Syntactic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED

        elif undefined.all_undefined(attachment, attachments) and isinstance(
            content, (files.Resource, files.RAWISH_TYPES, os.PathLike)
        ):
            # Syntactic sugar, common mistake to accidentally send an attachment
            # as the content, so lets detect this and fix it for the user. This
            # will still then work with normal implicit embed attachments as
            # we work this out later.
            attachment = content
            content = undefined.UNDEFINED

        final_attachments: typing.List[files.Resource[files.AsyncReader]] = []
        if attachment is not undefined.UNDEFINED:
            final_attachments.append(files.ensure_resource(attachment))
        if attachments is not undefined.UNDEFINED:
            final_attachments.extend([files.ensure_resource(a) for a in attachments])

        if component is not undefined.UNDEFINED:
            body.put(&#34;components&#34;, [component.build()])

        elif components is not undefined.UNDEFINED:
            body.put(&#34;components&#34;, [component.build() for component in components])

        serialized_embeds: undefined.UndefinedOr[data_binding.JSONArray] = undefined.UNDEFINED

        if embed is not undefined.UNDEFINED:
            embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
            final_attachments.extend(embed_attachments)
            serialized_embeds = [embed_payload]
        elif embeds is not undefined.UNDEFINED:
            serialized_embeds = []
            for embed in embeds:
                embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
                final_attachments.extend(embed_attachments)
                serialized_embeds.append(embed_payload)

        body.put(
            &#34;allowed_mentions&#34;,
            mentions.generate_allowed_mentions(mentions_everyone, mentions_reply, user_mentions, role_mentions),
        )
        body.put(&#34;content&#34;, content, conversion=str)
        body.put(&#34;tts&#34;, tts)
        body.put(&#34;embeds&#34;, serialized_embeds)

        if final_attachments:
            form = data_binding.URLEncodedForm()
            form.add_field(&#34;payload_json&#34;, data_binding.dump_json(body), content_type=_APPLICATION_JSON)

            stack = contextlib.AsyncExitStack()

            try:
                for i, attachment in enumerate(final_attachments):
                    stream = await stack.enter_async_context(attachment.stream(executor=self._executor))
                    mimetype = stream.mimetype or _APPLICATION_OCTET_STREAM
                    form.add_field(f&#34;file{i}&#34;, stream, filename=stream.filename, content_type=mimetype)

                response = await self._request(route, form=form, query=query, no_auth=no_auth)
            finally:
                await stack.aclose()
        else:
            response = await self._request(route, json=body, query=query, no_auth=no_auth)

        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def create_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reply: undefined.UndefinedOr[snowflakes.SnowflakeishOr[messages_.PartialMessage]] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentions_reply: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        route = routes.POST_CHANNEL_MESSAGES.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;nonce&#34;, nonce)
        body.put(&#34;message_reference&#34;, reply, conversion=lambda m: {&#34;message_id&#34;: str(int(m))})
        return await self._create_message(
            route,
            body,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            tts=tts,
            mentions_everyone=mentions_everyone,
            mentions_reply=mentions_reply,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
        )

    async def crosspost_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.GuildNewsChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; messages_.Message:
        route = routes.POST_CHANNEL_CROSSPOST.compile(channel=channel, message=message)

        response = await self._request(route)

        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def _edit_message(  # noqa: C901 - Function too complex
        self,
        route: routes.CompiledRoute,
        body: data_binding.JSONObjectBuilder,
        *,
        no_auth: bool = False,
        content: undefined.UndefinedOr[typing.Any],
        attachment: undefined.UndefinedOr[files.Resourceish],
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]],
        component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedNoneOr[
            typing.Sequence[special_endpoints.ComponentBuilder]
        ] = undefined.UNDEFINED,
        embed: undefined.UndefinedNoneOr[embeds_.Embed],
        embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]],
        replace_attachments: bool,
        mentions_everyone: undefined.UndefinedOr[bool],
        mentions_reply: undefined.UndefinedOr[bool],
        user_mentions: undefined.UndefinedOr[typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]],
        role_mentions: undefined.UndefinedOr[typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]],
    ) -&gt; messages_.Message:
        if not undefined.any_undefined(attachment, attachments):
            raise ValueError(&#34;You may only specify one of &#39;attachment&#39; or &#39;attachments&#39;, not both&#34;)

        if not undefined.any_undefined(component, components):
            raise ValueError(&#34;You may only specify one of &#39;component&#39; or &#39;components&#39;, not both&#34;)

        if not undefined.any_undefined(embed, embeds):
            raise ValueError(&#34;You may only specify one of &#39;embed&#39; or &#39;embeds&#39;, not both&#34;)

        if attachments is not undefined.UNDEFINED and not isinstance(attachments, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;attachments&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;attachment&#39; (singular) instead?&#34;
            )

        if components is not undefined.UNDEFINED and not isinstance(components, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;components&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;component&#39; (singular) instead?&#34;
            )

        if embeds not in _NONE_OR_UNDEFINED and not isinstance(embeds, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;embeds&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;embed&#39; (singular) instead?&#34;
            )

        if not undefined.all_undefined(mentions_everyone, mentions_reply, user_mentions, role_mentions):
            body.put(
                &#34;allowed_mentions&#34;,
                mentions.generate_allowed_mentions(mentions_everyone, mentions_reply, user_mentions, role_mentions),
            )

        if embed is undefined.UNDEFINED and isinstance(content, embeds_.Embed):
            # Syntactic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED
        elif undefined.all_undefined(attachment, attachments) and isinstance(
            content, (files.Resource, files.RAWISH_TYPES, os.PathLike)
        ):
            # Syntactic sugar, common mistake to accidentally send an attachment
            # as the content, so lets detect this and fix it for the user. This
            # will still then work with normal implicit embed attachments as
            # we work this out later.
            attachment = content
            content = undefined.UNDEFINED

        if content is not None:
            body.put(&#34;content&#34;, content, conversion=str)
        else:
            body.put(&#34;content&#34;, None)

        final_attachments: typing.List[files.Resource[files.AsyncReader]] = []
        if attachment is not undefined.UNDEFINED:
            final_attachments.append(files.ensure_resource(attachment))
        if attachments is not undefined.UNDEFINED:
            final_attachments.extend([files.ensure_resource(a) for a in attachments])

        serialized_components: typing.Optional[typing.List[data_binding.JSONObject]] = None
        if component is not undefined.UNDEFINED:
            if component is not None:
                serialized_components = [component.build()]

            body.put(&#34;components&#34;, serialized_components)

        elif components is not undefined.UNDEFINED:
            if components is not None:
                serialized_components = [component.build() for component in components]

            body.put(&#34;components&#34;, serialized_components)

        serialized_embeds: data_binding.JSONArray = []
        update_embeds = False
        if embed is not undefined.UNDEFINED:
            update_embeds = True
            if embed is not None:
                embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
                serialized_embeds.append(embed_payload)
                final_attachments.extend(embed_attachments)
        elif embeds is not undefined.UNDEFINED:
            update_embeds = True
            if embeds is not None:
                for embed in embeds:
                    embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
                    serialized_embeds.append(embed_payload)
                    final_attachments.extend(embed_attachments)

        if update_embeds:
            body.put(&#34;embeds&#34;, serialized_embeds)

        if replace_attachments:
            body.put(&#34;attachments&#34;, None)

        if final_attachments:
            form = data_binding.URLEncodedForm()
            form.add_field(&#34;payload_json&#34;, data_binding.dump_json(body), content_type=_APPLICATION_JSON)

            stack = contextlib.AsyncExitStack()
            try:
                for i, attachment in enumerate(final_attachments):
                    stream = await stack.enter_async_context(attachment.stream(executor=self._executor))
                    mimetype = stream.mimetype or _APPLICATION_OCTET_STREAM
                    form.add_field(f&#34;file{i}&#34;, stream, filename=stream.filename, content_type=mimetype)

                response = await self._request(route, form=form, no_auth=no_auth)
            finally:
                await stack.aclose()
        else:
            response = await self._request(route, json=body, no_auth=no_auth)

        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def edit_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedNoneOr[
            typing.Sequence[special_endpoints.ComponentBuilder]
        ] = undefined.UNDEFINED,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        replace_attachments: bool = False,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentions_reply: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
        flags: undefined.UndefinedOr[messages_.MessageFlag] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        route = routes.PATCH_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;flags&#34;, flags)
        return await self._edit_message(
            route,
            body,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            replace_attachments=replace_attachments,
            mentions_everyone=mentions_everyone,
            mentions_reply=mentions_reply,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
        )

    async def delete_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        await self._request(route)

    async def delete_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        messages: typing.Union[
            snowflakes.SnowflakeishOr[messages_.PartialMessage],
            snowflakes.SnowflakeishIterable[messages_.PartialMessage],
        ],
        /,
        *other_messages: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        route = routes.POST_DELETE_CHANNEL_MESSAGES_BULK.compile(channel=channel)

        pending: typing.Deque[snowflakes.SnowflakeishOr[messages_.PartialMessage]] = collections.deque()
        deleted: typing.Deque[snowflakes.SnowflakeishOr[messages_.PartialMessage]] = collections.deque()

        if isinstance(messages, typing.Iterable):  # Syntactic sugar. Allows to use iterables
            pending.extend(messages)

        else:
            pending.append(messages)

        # This maintains the order in-order to keep a predictable deletion order.
        pending.extend(other_messages)

        while pending:
            # Discord only allows 2-100 messages in the BULK_DELETE endpoint. Because of that,
            # if the user wants 101 messages deleted, we will post 100 messages in bulk delete
            # and then the last message in a normal delete.
            # Along with this, the bucket size for v6 and v7 seems to be a bit restrictive. As of
            # 30th July 2020, this endpoint returned the following headers when being ratelimited:
            #       x-ratelimit-bucket         b05c0d8c2ab83895085006a8eae073a3
            #       x-ratelimit-limit          1
            #       x-ratelimit-remaining      0
            #       x-ratelimit-reset          1596033974.096
            #       x-ratelimit-reset-after    3.000
            # This kind of defeats the point of asynchronously gathering any of these
            # in the first place really. To save clogging up the event loop
            # (albeit at a cost of maybe a couple-dozen milliseconds per call),
            # I am just gonna invoke these sequentially instead.
            try:
                if len(pending) == 1:
                    message = pending.popleft()
                    await self.delete_message(channel, message)
                    deleted.append(message)
                else:
                    body = data_binding.JSONObjectBuilder()
                    chunk = [pending.popleft() for _ in range(min(100, len(pending)))]
                    body.put_snowflake_array(&#34;messages&#34;, chunk)
                    await self._request(route, json=body)
                    deleted += chunk
            except Exception as ex:
                raise errors.BulkDeleteError(deleted, pending) from ex

    @staticmethod
    def _transform_emoji_to_url_format(
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]],
        /,
    ) -&gt; str:
        if isinstance(emoji, emojis.Emoji):
            if emoji_id is not undefined.UNDEFINED:
                raise ValueError(&#34;emoji_id shouldn&#39;t be passed when an Emoji object is passed for emoji&#34;)

            return emoji.url_name

        if emoji_id is not undefined.UNDEFINED:
            return f&#34;{emoji}:{snowflakes.Snowflake(emoji_id)}&#34;

        return emoji

    async def add_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PUT_MY_REACTION.compile(
            emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_my_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_MY_REACTION.compile(
            emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_all_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_REACTION_EMOJI.compile(
            emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_REACTION_USER.compile(
            emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
            channel=channel,
            message=message,
            user=user,
        )
        await self._request(route)

    async def delete_all_reactions(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        route = routes.DELETE_ALL_REACTIONS.compile(channel=channel, message=message)
        await self._request(route)

    def fetch_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[users.User]:
        return special_endpoints_impl.ReactorIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            channel=channel,
            message=message,
            emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
        )

    async def create_webhook(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.WebhookChannelT],
        name: str,
        *,
        avatar: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.IncomingWebhook:
        route = routes.POST_CHANNEL_WEBHOOKS.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)

        if avatar is not undefined.UNDEFINED:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_incoming_webhook(response)

    async def fetch_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.PartialWebhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.PartialWebhook:
        if token is undefined.UNDEFINED:
            route = routes.GET_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.GET_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        response = await self._request(route, no_auth=no_auth)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_webhook(response)

    async def fetch_channel_webhooks(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.WebhookChannelT],
    ) -&gt; typing.Sequence[webhooks.PartialWebhook]:
        route = routes.GET_CHANNEL_WEBHOOKS.compile(channel=channel)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_webhook(webhook_pl) for webhook_pl in response]

    async def fetch_guild_webhooks(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[webhooks.PartialWebhook]:
        route = routes.GET_GUILD_WEBHOOKS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_webhook(webhook_payload) for webhook_payload in response]

    async def edit_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.PartialWebhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.WebhookChannelT]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.PartialWebhook:
        if token is undefined.UNDEFINED:
            route = routes.PATCH_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.PATCH_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put_snowflake(&#34;channel&#34;, channel)

        if avatar is None:
            body.put(&#34;avatar&#34;, None)
        elif avatar is not undefined.UNDEFINED:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        response = await self._request(route, json=body, reason=reason, no_auth=no_auth)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_webhook(response)

    async def delete_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.PartialWebhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        if token is undefined.UNDEFINED:
            route = routes.DELETE_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.DELETE_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        await self._request(route, no_auth=no_auth)

    async def execute_webhook(
        self,
        webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
        token: str,
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
        flags: typing.Union[undefined.UndefinedType, int, messages_.MessageFlag] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
        webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
        route = routes.POST_WEBHOOK_WITH_TOKEN.compile(webhook=webhook_id, token=token)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;username&#34;, username)
        body.put(&#34;avatar_url&#34;, avatar_url)
        body.put(&#34;flags&#34;, flags)
        query = data_binding.StringMapBuilder()
        query.put(&#34;wait&#34;, True)
        return await self._create_message(
            route,
            body,
            query,
            no_auth=True,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            tts=tts,
            mentions_everyone=mentions_everyone,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
            mentions_reply=undefined.UNDEFINED,
        )

    async def fetch_webhook_message(
        self,
        webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
        token: str,
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; messages_.Message:
        # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
        webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
        route = routes.GET_WEBHOOK_MESSAGE.compile(webhook=webhook_id, token=token, message=message)
        response = await self._request(route, no_auth=True)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def edit_webhook_message(
        self,
        webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
        token: str,
        message: snowflakes.SnowflakeishOr[messages_.Message],
        content: undefined.UndefinedNoneOr[typing.Any] = undefined.UNDEFINED,
        *,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedNoneOr[
            typing.Sequence[special_endpoints.ComponentBuilder]
        ] = undefined.UNDEFINED,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        replace_attachments: bool = False,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
        webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
        route = routes.PATCH_WEBHOOK_MESSAGE.compile(webhook=webhook_id, token=token, message=message)
        return await self._edit_message(
            route,
            data_binding.JSONObjectBuilder(),
            no_auth=True,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            replace_attachments=replace_attachments,
            mentions_everyone=mentions_everyone,
            mentions_reply=undefined.UNDEFINED,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
        )

    async def delete_webhook_message(
        self,
        webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
        token: str,
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
        webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
        route = routes.DELETE_WEBHOOK_MESSAGE.compile(webhook=webhook_id, token=token, message=message)
        await self._request(route, no_auth=True)

    async def fetch_gateway_url(self) -&gt; str:
        route = routes.GET_GATEWAY.compile()
        # This doesn&#39;t need authorization.
        response = await self._request(route, no_auth=True)
        assert isinstance(response, dict)
        url = response[&#34;url&#34;]
        assert isinstance(url, str)
        return url

    async def fetch_gateway_bot_info(self) -&gt; sessions.GatewayBotInfo:
        route = routes.GET_GATEWAY_BOT.compile()
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_gateway_bot_info(response)

    async def fetch_invite(self, invite: typing.Union[invites.InviteCode, str]) -&gt; invites.Invite:
        route = routes.GET_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
        query = data_binding.StringMapBuilder()
        query.put(&#34;with_counts&#34;, True)
        query.put(&#34;with_expiration&#34;, True)
        response = await self._request(route, query=query)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_invite(response)

    async def delete_invite(self, invite: typing.Union[invites.InviteCode, str]) -&gt; invites.Invite:
        route = routes.DELETE_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_invite(response)

    async def fetch_my_user(self) -&gt; users.OwnUser:
        route = routes.GET_MY_USER.compile()
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_my_user(response)

    async def edit_my_user(
        self,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    ) -&gt; users.OwnUser:
        route = routes.PATCH_MY_USER.compile()
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;username&#34;, username)

        if avatar is None:
            body.put(&#34;avatar&#34;, None)
        elif avatar is not undefined.UNDEFINED:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_my_user(response)

    async def fetch_my_connections(self) -&gt; typing.Sequence[applications.OwnConnection]:
        route = routes.GET_MY_CONNECTIONS.compile()
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_own_connection(connection_payload) for connection_payload in response]

    def fetch_my_guilds(
        self,
        *,
        newest_first: bool = False,
        start_at: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[applications.OwnGuild]:
        if start_at is undefined.UNDEFINED:
            start_at = snowflakes.Snowflake.max() if newest_first else snowflakes.Snowflake.min()
        elif isinstance(start_at, datetime.datetime):
            start_at = snowflakes.Snowflake.from_datetime(start_at)
        else:
            start_at = int(start_at)

        return special_endpoints_impl.OwnGuildIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            newest_first=newest_first,
            first_id=str(start_at),
        )

    async def leave_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /) -&gt; None:
        route = routes.DELETE_MY_GUILD.compile(guild=guild)
        await self._request(route)

    async def create_dm_channel(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; channels_.DMChannel:
        route = routes.POST_MY_CHANNELS.compile()
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;recipient_id&#34;, user)
        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        channel = self._entity_factory.deserialize_dm(response)

        if self._cache:
            self._cache.set_dm_channel_id(user, channel.id)

        return channel

    async def fetch_application(self) -&gt; applications.Application:
        route = routes.GET_MY_APPLICATION.compile()
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_application(response)

    async def fetch_authorization(self) -&gt; applications.AuthorizationInformation:
        route = routes.GET_MY_AUTHORIZATION.compile()
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_authorization_information(response)

    @staticmethod
    def _gen_oauth2_token(client: snowflakes.SnowflakeishOr[guilds.PartialApplication], client_secret: str) -&gt; str:
        token = base64.b64encode(f&#34;{int(client)}:{client_secret}&#34;.encode()).decode(&#34;utf-8&#34;)
        return f&#34;{applications.TokenType.BASIC} {token}&#34;

    async def authorize_client_credentials_token(
        self,
        client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        client_secret: str,
        scopes: typing.Sequence[typing.Union[applications.OAuth2Scope, str]],
    ) -&gt; applications.PartialOAuth2Token:
        route = routes.POST_TOKEN.compile()
        form = data_binding.URLEncodedForm()
        form.add_field(&#34;grant_type&#34;, &#34;client_credentials&#34;)
        form.add_field(&#34;scope&#34;, &#34; &#34;.join(scopes))

        response = await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_partial_token(response)

    async def authorize_access_token(
        self,
        client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        client_secret: str,
        code: str,
        redirect_uri: str,
    ) -&gt; applications.OAuth2AuthorizationToken:
        route = routes.POST_TOKEN.compile()
        form = data_binding.URLEncodedForm()
        form.add_field(&#34;grant_type&#34;, &#34;authorization_code&#34;)
        form.add_field(&#34;code&#34;, code)
        form.add_field(&#34;redirect_uri&#34;, redirect_uri)

        response = await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_authorization_token(response)

    async def refresh_access_token(
        self,
        client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        client_secret: str,
        refresh_token: str,
        *,
        scopes: undefined.UndefinedOr[
            typing.Sequence[typing.Union[applications.OAuth2Scope, str]]
        ] = undefined.UNDEFINED,
    ) -&gt; applications.OAuth2AuthorizationToken:
        route = routes.POST_TOKEN.compile()
        form = data_binding.URLEncodedForm()
        form.add_field(&#34;grant_type&#34;, &#34;refresh_token&#34;)
        form.add_field(&#34;refresh_token&#34;, refresh_token)

        if scopes is not undefined.UNDEFINED:
            form.add_field(&#34;scope&#34;, &#34; &#34;.join(scopes))

        response = await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_authorization_token(response)

    async def revoke_access_token(
        self,
        client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        client_secret: str,
        token: typing.Union[str, applications.PartialOAuth2Token],
    ) -&gt; None:
        route = routes.POST_TOKEN_REVOKE.compile()
        form = data_binding.URLEncodedForm()
        form.add_field(&#34;token&#34;, str(token))
        await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))

    async def add_user_to_guild(
        self,
        access_token: typing.Union[str, applications.PartialOAuth2Token],
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[guilds.Member]:
        route = routes.PUT_GUILD_MEMBER.compile(guild=guild, user=user)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;access_token&#34;, str(access_token))
        body.put(&#34;nick&#34;, nick)
        body.put(&#34;mute&#34;, mute)
        body.put(&#34;deaf&#34;, deaf)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        if (response := await self._request(route, json=body)) is not None:
            assert isinstance(response, dict)
            return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))
        else:
            # User already is in the guild.
            return None

    async def fetch_voice_regions(self) -&gt; typing.Sequence[voices.VoiceRegion]:
        route = routes.GET_VOICE_REGIONS.compile()
        response = await self._request(route)
        assert isinstance(response, list)
        return [
            self._entity_factory.deserialize_voice_region(voice_region_payload) for voice_region_payload in response
        ]

    async def fetch_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser]) -&gt; users.User:
        route = routes.GET_USER.compile(user=user)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_user(response)

    def fetch_audit_log(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        event_type: undefined.UndefinedOr[typing.Union[audit_logs.AuditLogEventType, int]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[audit_logs.AuditLog]:

        timestamp: undefined.UndefinedOr[str]
        if before is undefined.UNDEFINED:
            timestamp = undefined.UNDEFINED
        elif isinstance(before, datetime.datetime):
            timestamp = str(snowflakes.Snowflake.from_datetime(before))
        else:
            timestamp = str(int(before))

        return special_endpoints_impl.AuditLogIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            guild=guild,
            before=timestamp,
            user=user,
            action_type=event_type,
        )

    async def fetch_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.GET_GUILD_EMOJI.compile(guild=guild, emoji=emoji)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def fetch_guild_emojis(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[emojis.KnownCustomEmoji]:
        route = routes.GET_GUILD_EMOJIS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild)
        return [
            self._entity_factory.deserialize_known_custom_emoji(emoji_payload, guild_id=guild_id)
            for emoji_payload in response
        ]

    async def create_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        image: files.Resourceish,
        *,
        roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.POST_GUILD_EMOJIS.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        image_resource = files.ensure_resource(image)
        async with image_resource.stream(executor=self._executor) as stream:
            body.put(&#34;image&#34;, await stream.data_uri())

        body.put_snowflake_array(&#34;roles&#34;, roles)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def edit_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.PATCH_GUILD_EMOJI.compile(guild=guild, emoji=emoji)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def delete_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_EMOJI.compile(guild=guild, emoji=emoji)
        await self._request(route, reason=reason)

    async def fetch_available_sticker_packs(self) -&gt; typing.Sequence[stickers.StickerPack]:
        route = routes.GET_STICKER_PACKS.compile()
        response = await self._request(route, no_auth=True)
        assert isinstance(response, dict)
        return [
            self._entity_factory.deserialize_sticker_pack(sticker_pack_payload)
            for sticker_pack_payload in response[&#34;sticker_packs&#34;]
        ]

    async def fetch_sticker(
        self,
        sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
    ) -&gt; typing.Union[stickers.StandardSticker, stickers.GuildSticker]:
        route = routes.GET_STICKER.compile(sticker=sticker)
        response = await self._request(route)
        assert isinstance(response, dict)
        return (
            self._entity_factory.deserialize_guild_sticker(response)
            if &#34;guild_id&#34; in response
            else self._entity_factory.deserialize_standard_sticker(response)
        )

    async def fetch_guild_stickers(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[stickers.GuildSticker]:
        route = routes.GET_GUILD_STICKERS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [
            self._entity_factory.deserialize_guild_sticker(guild_sticker_payload) for guild_sticker_payload in response
        ]

    async def fetch_guild_sticker(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
    ) -&gt; stickers.GuildSticker:
        route = routes.GET_GUILD_STICKER.compile(guild=guild, sticker=sticker)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_sticker(response)

    async def create_sticker(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        tag: str,
        image: files.Resourceish,
        *,
        description: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; stickers.GuildSticker:
        route = routes.POST_GUILD_STICKERS.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;tags&#34;, tag)
        body.put(&#34;description&#34;, description)

        image_resource = files.ensure_resource(image)
        async with image_resource.stream(executor=self._executor) as stream:
            body.put(&#34;image&#34;, await stream.data_uri())

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_sticker(response)

    async def edit_sticker(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        description: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        tag: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; stickers.GuildSticker:
        route = routes.PATCH_GUILD_STICKER.compile(guild=guild, sticker=sticker)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;tags&#34;, tag)
        body.put(&#34;description&#34;, description)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_sticker(response)

    async def delete_sticker(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_STICKER.compile(guild=guild, sticker=sticker)
        await self._request(route, reason=reason)

    def guild_builder(self, name: str, /) -&gt; special_endpoints.GuildBuilder:
        return special_endpoints_impl.GuildBuilder(
            entity_factory=self._entity_factory, executor=self._executor, request_call=self._request, name=name
        )

    async def fetch_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.RESTGuild:
        route = routes.GET_GUILD.compile(guild=guild)
        query = data_binding.StringMapBuilder()
        query.put(&#34;with_counts&#34;, True)
        response = await self._request(route, query=query)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_rest_guild(response)

    async def fetch_guild_preview(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildPreview:
        route = routes.GET_GUILD_PREVIEW.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_preview(response)

    async def edit_guild(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        verification_level: undefined.UndefinedOr[guilds.GuildVerificationLevel] = undefined.UNDEFINED,
        default_message_notifications: undefined.UndefinedOr[
            guilds.GuildMessageNotificationsLevel
        ] = undefined.UNDEFINED,
        explicit_content_filter_level: undefined.UndefinedOr[
            guilds.GuildExplicitContentFilterLevel
        ] = undefined.UNDEFINED,
        afk_channel: undefined.UndefinedOr[
            snowflakes.SnowflakeishOr[channels_.GuildVoiceChannel]
        ] = undefined.UNDEFINED,
        afk_timeout: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        icon: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        owner: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        splash: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        banner: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        system_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels_.GuildTextChannel]
        ] = undefined.UNDEFINED,
        rules_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels_.GuildTextChannel]
        ] = undefined.UNDEFINED,
        public_updates_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels_.GuildTextChannel]
        ] = undefined.UNDEFINED,
        preferred_locale: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.RESTGuild:
        route = routes.PATCH_GUILD.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;verification_level&#34;, verification_level)
        body.put(&#34;default_message_notifications&#34;, default_message_notifications)
        body.put(&#34;explicit_content_filter&#34;, explicit_content_filter_level)
        body.put(&#34;afk_timeout&#34;, afk_timeout, conversion=time.timespan_to_int)
        body.put(&#34;preferred_locale&#34;, preferred_locale, conversion=str)
        body.put_snowflake(&#34;afk_channel_id&#34;, afk_channel)
        body.put_snowflake(&#34;owner_id&#34;, owner)
        body.put_snowflake(&#34;system_channel_id&#34;, system_channel)
        body.put_snowflake(&#34;rules_channel_id&#34;, rules_channel)
        body.put_snowflake(&#34;public_updates_channel_id&#34;, public_updates_channel)

        tasks: typing.List[asyncio.Task[str]] = []

        if icon is None:
            body.put(&#34;icon&#34;, None)
        elif icon is not undefined.UNDEFINED:
            icon_resource = files.ensure_resource(icon)
            async with icon_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;icon&#34;, future.result()))
                tasks.append(task)

        if splash is None:
            body.put(&#34;splash&#34;, None)
        elif splash is not undefined.UNDEFINED:
            splash_resource = files.ensure_resource(splash)
            async with splash_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;splash&#34;, future.result()))
                tasks.append(task)

        if banner is None:
            body.put(&#34;banner&#34;, None)
        elif banner is not undefined.UNDEFINED:
            banner_resource = files.ensure_resource(banner)
            async with banner_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;banner&#34;, future.result()))
                tasks.append(task)

        await asyncio.gather(*tasks)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_rest_guild(response)

    async def delete_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; None:
        route = routes.DELETE_GUILD.compile(guild=guild)
        await self._request(route)

    async def fetch_guild_channels(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[channels_.GuildChannel]:
        route = routes.GET_GUILD_CHANNELS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        channel_sequence = [self._entity_factory.deserialize_channel(channel_payload) for channel_payload in response]
        # Will always be guild channels unless Discord messes up severely on something!
        return typing.cast(&#34;typing.Sequence[channels_.GuildChannel]&#34;, channel_sequence)

    async def create_guild_text_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildTextChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels_.ChannelType.GUILD_TEXT,
            position=position,
            topic=topic,
            nsfw=nsfw,
            rate_limit_per_user=rate_limit_per_user,
            permission_overwrites=permission_overwrites,
            category=category,
            reason=reason,
        )
        assert isinstance(channel, channels_.GuildTextChannel)
        return channel

    async def create_guild_news_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildNewsChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels_.ChannelType.GUILD_NEWS,
            position=position,
            topic=topic,
            nsfw=nsfw,
            rate_limit_per_user=rate_limit_per_user,
            permission_overwrites=permission_overwrites,
            category=category,
            reason=reason,
        )
        assert isinstance(channel, channels_.GuildNewsChannel)
        return channel

    async def create_guild_voice_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        video_quality_mode: undefined.UndefinedOr[typing.Union[channels_.VideoQualityMode, int]] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        region: undefined.UndefinedOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildVoiceChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels_.ChannelType.GUILD_VOICE,
            position=position,
            user_limit=user_limit,
            bitrate=bitrate,
            video_quality_mode=video_quality_mode,
            permission_overwrites=permission_overwrites,
            region=region,
            category=category,
            reason=reason,
        )
        assert isinstance(channel, channels_.GuildVoiceChannel)
        return channel

    async def create_guild_stage_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        region: undefined.UndefinedOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildStageChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels_.ChannelType.GUILD_STAGE,
            position=position,
            user_limit=user_limit,
            bitrate=bitrate,
            permission_overwrites=permission_overwrites,
            region=region,
            category=category,
            reason=reason,
        )
        assert isinstance(channel, channels_.GuildStageChannel)
        return channel

    async def create_guild_category(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildCategory:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels_.ChannelType.GUILD_CATEGORY,
            position=position,
            permission_overwrites=permission_overwrites,
            reason=reason,
        )
        assert isinstance(channel, channels_.GuildCategory)
        return channel

    async def _create_guild_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        type_: channels_.ChannelType,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        video_quality_mode: undefined.UndefinedOr[typing.Union[channels_.VideoQualityMode, int]] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        region: undefined.UndefinedOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildChannel:
        route = routes.POST_GUILD_CHANNELS.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;type&#34;, type_)
        body.put(&#34;name&#34;, name)
        body.put(&#34;position&#34;, position)
        body.put(&#34;topic&#34;, topic)
        body.put(&#34;nsfw&#34;, nsfw)
        body.put(&#34;bitrate&#34;, bitrate)
        body.put(&#34;video_quality_mode&#34;, video_quality_mode)
        body.put(&#34;user_limit&#34;, user_limit)
        body.put(&#34;rate_limit_per_user&#34;, rate_limit_per_user, conversion=time.timespan_to_int)
        body.put(&#34;rtc_region&#34;, region, conversion=str)
        body.put_snowflake(&#34;parent_id&#34;, category)
        body.put_array(
            &#34;permission_overwrites&#34;,
            permission_overwrites,
            conversion=self._entity_factory.serialize_permission_overwrite,
        )

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        channel = self._entity_factory.deserialize_channel(response)
        assert isinstance(channel, channels_.GuildChannel)
        return channel

    async def reposition_channels(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[channels_.GuildChannel]],
    ) -&gt; None:
        route = routes.POST_GUILD_CHANNELS.compile(guild=guild)
        body = [{&#34;id&#34;: str(int(channel)), &#34;position&#34;: pos} for pos, channel in positions.items()]
        await self._request(route, json=body)

    async def fetch_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.Member:
        route = routes.GET_GUILD_MEMBER.compile(guild=guild, user=user)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))

    def fetch_members(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; iterators.LazyIterator[guilds.Member]:
        return special_endpoints_impl.MemberIterator(
            entity_factory=self._entity_factory, request_call=self._request, guild=guild
        )

    async def search_members(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
    ) -&gt; typing.Sequence[guilds.Member]:
        route = routes.GET_GUILD_MEMBERS_SEARCH.compile(guild=guild)
        query = data_binding.StringMapBuilder()
        query.put(&#34;query&#34;, name)
        query.put(&#34;limit&#34;, 1000)
        response = await self._request(route, query=query)
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild)
        return [
            self._entity_factory.deserialize_member(member_payload, guild_id=guild_id) for member_payload in response
        ]

    async def edit_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        voice_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels_.GuildVoiceChannel]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Member:
        route = routes.PATCH_GUILD_MEMBER.compile(guild=guild, user=user)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;nick&#34;, nick)
        body.put(&#34;mute&#34;, mute)
        body.put(&#34;deaf&#34;, deaf)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        if voice_channel is None:
            body.put(&#34;channel_id&#34;, None)
        elif voice_channel is not undefined.UNDEFINED:
            body.put_snowflake(&#34;channel_id&#34;, voice_channel)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))

    async def edit_my_nick(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.Guild],
        nick: typing.Optional[str],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_MY_GUILD_NICKNAME.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;nick&#34;, nick)
        await self._request(route, json=body, reason=reason)

    async def add_role_to_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PUT_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
        await self._request(route, reason=reason)

    async def remove_role_from_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
        await self._request(route, reason=reason)

    async def kick_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_MEMBER.compile(guild=guild, user=user)
        await self._request(route, reason=reason)

    kick_member = kick_user

    async def ban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        delete_message_days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;delete_message_days&#34;, delete_message_days)
        route = routes.PUT_GUILD_BAN.compile(guild=guild, user=user)
        await self._request(route, json=body, reason=reason)

    ban_member = ban_user

    async def unban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_BAN.compile(guild=guild, user=user)
        await self._request(route, reason=reason)

    unban_member = unban_user

    async def fetch_ban(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.GuildBan:
        route = routes.GET_GUILD_BAN.compile(guild=guild, user=user)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_member_ban(response)

    async def fetch_bans(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[guilds.GuildBan]:
        route = routes.GET_GUILD_BANS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_guild_member_ban(ban_payload) for ban_payload in response]

    async def fetch_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Role]:
        route = routes.GET_GUILD_ROLES.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild)
        return [self._entity_factory.deserialize_role(role_payload, guild_id=guild_id) for role_payload in response]

    async def create_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = permissions_.Permissions.NONE,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        if not undefined.any_undefined(color, colour):
            raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

        route = routes.POST_GUILD_ROLES.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;permissions&#34;, permissions)
        body.put(&#34;color&#34;, color, conversion=colors.Color.of)
        body.put(&#34;color&#34;, colour, conversion=colors.Color.of)
        body.put(&#34;hoist&#34;, hoist)
        body.put(&#34;mentionable&#34;, mentionable)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))

    async def reposition_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[guilds.PartialRole]],
    ) -&gt; None:
        route = routes.POST_GUILD_ROLES.compile(guild=guild)
        body = [{&#34;id&#34;: str(int(role)), &#34;position&#34;: pos} for pos, role in positions.items()]
        await self._request(route, json=body)

    async def edit_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        if not undefined.any_undefined(color, colour):
            raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

        route = routes.PATCH_GUILD_ROLE.compile(guild=guild, role=role)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;permissions&#34;, permissions)
        body.put(&#34;color&#34;, color, conversion=colors.Color.of)
        body.put(&#34;color&#34;, colour, conversion=colors.Color.of)
        body.put(&#34;hoist&#34;, hoist)
        body.put(&#34;mentionable&#34;, mentionable)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))

    async def delete_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    ) -&gt; None:
        route = routes.DELETE_GUILD_ROLE.compile(guild=guild, role=role)
        await self._request(route)

    async def estimate_guild_prune_count(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
    ) -&gt; int:
        route = routes.GET_GUILD_PRUNE.compile(guild=guild)
        query = data_binding.StringMapBuilder()
        query.put(&#34;days&#34;, days)
        if include_roles is not undefined.UNDEFINED:
            roles = &#34;,&#34;.join(str(int(role)) for role in include_roles)
            query.put(&#34;include_roles&#34;, roles)
        response = await self._request(route, query=query)
        assert isinstance(response, dict)
        return int(response[&#34;pruned&#34;])

    async def begin_guild_prune(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        compute_prune_count: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[int]:
        route = routes.POST_GUILD_PRUNE.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;days&#34;, days)
        body.put(&#34;compute_prune_count&#34;, compute_prune_count)
        body.put_snowflake_array(&#34;include_roles&#34;, include_roles)
        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        pruned = response.get(&#34;pruned&#34;)
        return int(pruned) if pruned is not None else None

    async def fetch_guild_voice_regions(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[voices.VoiceRegion]:
        route = routes.GET_GUILD_VOICE_REGIONS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [
            self._entity_factory.deserialize_voice_region(voice_region_payload) for voice_region_payload in response
        ]

    async def fetch_guild_invites(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        route = routes.GET_GUILD_INVITES.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_invite_with_metadata(invite_payload) for invite_payload in response]

    async def fetch_integrations(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Integration]:
        route = routes.GET_GUILD_INTEGRATIONS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild)
        return [
            self._entity_factory.deserialize_integration(integration_payload, guild_id=guild_id)
            for integration_payload in response
        ]

    async def fetch_widget(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildWidget:
        route = routes.GET_GUILD_WIDGET.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_widget(response)

    async def edit_widget(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        channel: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[channels_.GuildChannel]] = undefined.UNDEFINED,
        enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.GuildWidget:
        route = routes.PATCH_GUILD_WIDGET.compile(guild=guild)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;enabled&#34;, enabled)
        if channel is None:
            body.put(&#34;channel&#34;, None)
        elif channel is not undefined.UNDEFINED:
            body.put_snowflake(&#34;channel&#34;, channel)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_widget(response)

    async def fetch_welcome_screen(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.WelcomeScreen:
        route = routes.GET_GUILD_WELCOME_SCREEN.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_welcome_screen(response)

    async def edit_welcome_screen(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        description: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
        enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        channels: undefined.UndefinedNoneOr[typing.Sequence[guilds.WelcomeChannel]] = undefined.UNDEFINED,
    ) -&gt; guilds.WelcomeScreen:
        route = routes.PATCH_GUILD_WELCOME_SCREEN.compile(guild=guild)

        body = data_binding.JSONObjectBuilder()

        body.put(&#34;description&#34;, description)
        body.put(&#34;enabled&#34;, enabled)

        if channels is not None:
            body.put_array(&#34;welcome_channels&#34;, channels, conversion=self._entity_factory.serialize_welcome_channel)

        else:
            body.put(&#34;welcome_channels&#34;, None)

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_welcome_screen(response)

    async def fetch_vanity_url(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; invites.VanityURL:
        route = routes.GET_GUILD_VANITY_URL.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_vanity_url(response)

    async def fetch_template(self, template: typing.Union[templates.Template, str]) -&gt; templates.Template:
        template = template if isinstance(template, str) else template.code
        route = routes.GET_TEMPLATE.compile(template=template)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_template(response)

    async def fetch_guild_templates(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[templates.Template]:
        route = routes.GET_GUILD_TEMPLATES.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_template(template_payload) for template_payload in response]

    async def sync_guild_template(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        template: typing.Union[templates.Template, str],
    ) -&gt; templates.Template:
        template = template if isinstance(template, str) else template.code
        route = routes.PUT_GUILD_TEMPLATE.compile(guild=guild, template=template)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_template(response)

    async def create_guild_from_template(
        self,
        template: typing.Union[str, templates.Template],
        name: str,
        *,
        icon: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    ) -&gt; guilds.RESTGuild:
        template = template if isinstance(template, str) else template.code
        route = routes.POST_TEMPLATE.compile(template=template)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)

        if icon is not undefined.UNDEFINED:
            icon_resource = files.ensure_resource(icon)
            async with icon_resource.stream(executor=self._executor) as stream:
                body.put(&#34;icon&#34;, await stream.data_uri())

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_rest_guild(response)

    async def create_template(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        description: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
    ) -&gt; templates.Template:
        route = routes.POST_GUILD_TEMPLATES.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;description&#34;, description)
        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_template(response)

    async def edit_template(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        template: typing.Union[str, templates.Template],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        description: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
    ) -&gt; templates.Template:
        template = template if isinstance(template, str) else template.code
        route = routes.PATCH_GUILD_TEMPLATE.compile(guild=guild, template=template)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;description&#34;, description)

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_template(response)

    async def delete_template(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        template: typing.Union[str, templates.Template],
    ) -&gt; templates.Template:
        template = template if isinstance(template, str) else template.code
        route = routes.DELETE_GUILD_TEMPLATE.compile(guild=guild, template=template)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_template(response)

    def command_builder(self, name: str, description: str, /) -&gt; special_endpoints.CommandBuilder:
        return special_endpoints_impl.CommandBuilder(name=name, description=description)

    async def fetch_application_command(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        command: snowflakes.SnowflakeishOr[commands.Command],
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; commands.Command:
        if guild is undefined.UNDEFINED:
            route = routes.GET_APPLICATION_COMMAND.compile(application=application, command=command)

        else:
            route = routes.GET_APPLICATION_GUILD_COMMAND.compile(application=application, guild=guild, command=command)

        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_command(
            response, guild_id=snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
        )

    async def fetch_application_commands(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; typing.Sequence[commands.Command]:
        if guild is undefined.UNDEFINED:
            route = routes.GET_APPLICATION_COMMANDS.compile(application=application)

        else:
            route = routes.GET_APPLICATION_GUILD_COMMANDS.compile(application=application, guild=guild)

        response = await self._request(route)
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
        return [self._entity_factory.deserialize_command(command, guild_id=guild_id) for command in response]

    async def create_application_command(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        name: str,
        description: str,
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
        *,
        options: undefined.UndefinedOr[typing.Sequence[commands.CommandOption]] = undefined.UNDEFINED,
        default_permission: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; commands.Command:
        if guild is undefined.UNDEFINED:
            route = routes.POST_APPLICATION_COMMAND.compile(application=application)

        else:
            route = routes.POST_APPLICATION_GUILD_COMMAND.compile(application=application, guild=guild)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;description&#34;, description)
        body.put_array(&#34;options&#34;, options, conversion=self._entity_factory.serialize_command_option)
        body.put(&#34;default_permission&#34;, default_permission)

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_command(
            response, guild_id=snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
        )

    async def set_application_commands(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        commands: typing.Sequence[special_endpoints.CommandBuilder],
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; typing.Sequence[commands.Command]:
        if guild is undefined.UNDEFINED:
            route = routes.PUT_APPLICATION_COMMANDS.compile(application=application)

        else:
            route = routes.PUT_APPLICATION_GUILD_COMMANDS.compile(application=application, guild=guild)

        response = await self._request(route, json=[command.build(self._entity_factory) for command in commands])
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
        return [self._entity_factory.deserialize_command(payload, guild_id=guild_id) for payload in response]

    async def edit_application_command(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        command: snowflakes.SnowflakeishOr[commands.Command],
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        description: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        options: undefined.UndefinedOr[typing.Sequence[commands.CommandOption]] = undefined.UNDEFINED,
    ) -&gt; commands.Command:
        if guild is undefined.UNDEFINED:
            route = routes.PATCH_APPLICATION_COMMAND.compile(application=application, command=command)

        else:
            route = routes.PATCH_APPLICATION_GUILD_COMMAND.compile(
                application=application, command=command, guild=guild
            )

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;description&#34;, description)
        body.put_array(&#34;options&#34;, options, conversion=self._entity_factory.serialize_command_option)

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_command(
            response, guild_id=snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
        )

    async def delete_application_command(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        command: snowflakes.SnowflakeishOr[commands.Command],
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; None:
        if guild is undefined.UNDEFINED:
            route = routes.DELETE_APPLICATION_COMMAND.compile(application=application, command=command)

        else:
            route = routes.DELETE_APPLICATION_GUILD_COMMAND.compile(
                application=application, command=command, guild=guild
            )

        await self._request(route)

    async def fetch_application_guild_commands_permissions(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[commands.GuildCommandPermissions]:
        route = routes.GET_APPLICATION_GUILD_COMMANDS_PERMISSIONS.compile(application=application, guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_guild_command_permissions(payload) for payload in response]

    async def fetch_application_command_permissions(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        command: snowflakes.SnowflakeishOr[commands.Command],
    ) -&gt; commands.GuildCommandPermissions:
        route = routes.GET_APPLICATION_COMMAND_PERMISSIONS.compile(
            application=application, guild=guild, command=command
        )
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_command_permissions(response)

    async def set_application_guild_commands_permissions(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        permissions: typing.Mapping[
            snowflakes.SnowflakeishOr[commands.Command], typing.Sequence[commands.CommandPermission]
        ],
    ) -&gt; typing.Sequence[commands.GuildCommandPermissions]:
        route = routes.PUT_APPLICATION_GUILD_COMMANDS_PERMISSIONS.compile(application=application, guild=guild)
        body = [
            {
                &#34;id&#34;: str(snowflakes.Snowflake(command)),
                &#34;permissions&#34;: [self._entity_factory.serialize_command_permission(permission) for permission in perms],
            }
            for command, perms in permissions.items()
        ]
        response = await self._request(route, json=body)

        assert isinstance(response, list)
        return [self._entity_factory.deserialize_guild_command_permissions(payload) for payload in response]

    async def set_application_command_permissions(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        command: snowflakes.SnowflakeishOr[commands.Command],
        permissions: typing.Sequence[commands.CommandPermission],
    ) -&gt; commands.GuildCommandPermissions:
        route = routes.PUT_APPLICATION_COMMAND_PERMISSIONS.compile(
            application=application, guild=guild, command=command
        )
        body = data_binding.JSONObjectBuilder()
        body.put_array(&#34;permissions&#34;, permissions, conversion=self._entity_factory.serialize_command_permission)
        response = await self._request(route, json=body)

        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_command_permissions(response)

    def interaction_deferred_builder(
        self, type_: typing.Union[base_interactions.ResponseType, int], /
    ) -&gt; special_endpoints.InteractionDeferredBuilder:
        return special_endpoints_impl.InteractionDeferredBuilder(type=type_)

    def interaction_message_builder(
        self, type_: typing.Union[base_interactions.ResponseType, int], /
    ) -&gt; special_endpoints.InteractionMessageBuilder:
        return special_endpoints_impl.InteractionMessageBuilder(type=type_)

    async def fetch_interaction_response(
        self, application: snowflakes.SnowflakeishOr[guilds.PartialApplication], token: str
    ) -&gt; messages_.Message:
        route = routes.GET_INTERACTION_RESPONSE.compile(webhook=application, token=token)
        response = await self._request(route, no_auth=True)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def create_interaction_response(
        self,
        interaction: snowflakes.SnowflakeishOr[base_interactions.PartialInteraction],
        token: str,
        response_type: typing.Union[int, base_interactions.ResponseType],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        flags: typing.Union[int, messages_.MessageFlag, undefined.UndefinedType] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; None:
        if not undefined.any_undefined(component, components):
            raise ValueError(&#34;You may only specify one of &#39;component&#39; or &#39;components&#39;, not both&#34;)

        if not undefined.any_undefined(embed, embeds):
            raise ValueError(&#34;You may only specify one of &#39;embed&#39; or &#39;embeds&#39;, not both&#34;)

        if components is not undefined.UNDEFINED and not isinstance(components, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;components&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;component&#39; (singular) instead?&#34;
            )

        if embeds not in _NONE_OR_UNDEFINED and not isinstance(embeds, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;embeds&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;embed&#39; (singular) instead?&#34;
            )

        if undefined.all_undefined(embed, embeds) and isinstance(content, embeds_.Embed):
            # Syntactic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED

        route = routes.POST_INTERACTION_RESPONSE.compile(interaction=interaction, token=token)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;type&#34;, response_type)

        data = data_binding.JSONObjectBuilder()
        data.put(&#34;content&#34;, content)
        data.put(&#34;flags&#34;, flags)
        data.put(&#34;tts&#34;, tts)
        data.put(
            &#34;allowed_mentions&#34;,
            mentions.generate_allowed_mentions(mentions_everyone, undefined.UNDEFINED, user_mentions, role_mentions),
        )

        if component is not undefined.UNDEFINED:
            data.put(&#34;components&#34;, [component.build()])

        elif components is not undefined.UNDEFINED:
            data.put(&#34;components&#34;, [component.build() for component in components])

        if embed is not undefined.UNDEFINED:
            embed_payload, attachments = self._entity_factory.serialize_embed(embed)
            if attachments:
                raise ValueError(&#34;Cannot send an embed with attachments in a slash command&#39;s initial response&#34;)

            data.put(&#34;embeds&#34;, [embed_payload])

        elif embeds is not undefined.UNDEFINED:
            embed_payloads: data_binding.JSONArray = []
            for embed in embeds:
                serialized_embed, attachments = self._entity_factory.serialize_embed(embed)
                embed_payloads.append(serialized_embed)
                if attachments:
                    raise ValueError(&#34;Cannot send an embed with attachments in a slash command&#39;s initial response&#34;)

            data.put(&#34;embeds&#34;, embed_payloads)

        body.put(&#34;data&#34;, data)
        await self._request(route, json=body, no_auth=True)

    async def edit_interaction_response(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        token: str,
        content: undefined.UndefinedNoneOr[typing.Any] = undefined.UNDEFINED,
        *,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedNoneOr[
            typing.Sequence[special_endpoints.ComponentBuilder]
        ] = undefined.UNDEFINED,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        replace_attachments: bool = False,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        route = routes.PATCH_INTERACTION_RESPONSE.compile(webhook=application, token=token)
        return await self._edit_message(
            route,
            data_binding.JSONObjectBuilder(),
            no_auth=True,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            replace_attachments=replace_attachments,
            mentions_everyone=mentions_everyone,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
            mentions_reply=undefined.UNDEFINED,
        )

    async def delete_interaction_response(
        self, application: snowflakes.SnowflakeishOr[guilds.PartialApplication], token: str
    ) -&gt; None:
        route = routes.DELETE_INTERACTION_RESPONSE.compile(webhook=application, token=token)
        await self._request(route, no_auth=True)

    def build_action_row(self) -&gt; special_endpoints.ActionRowBuilder:
        return special_endpoints_impl.ActionRowBuilder()</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.impl.rest.ClientCredentialsStrategy" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="ClientCredentialsStrategy -- Strategy class for handling client credential OAuth2 authorization …" href="#hikari.impl.rest.ClientCredentialsStrategy"
>ClientCredentialsStrategy</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.rest.ClientCredentialsStrategy" class="hljs python"><abbr title='A standard Python type.'>class</abbr> ClientCredentialsStrategy (
    client: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    client_secret: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    scopes: <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../applications.html#hikari.applications.OAuth2Scope'>applications.OAuth2Scope</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]] = (&lt;OAuth2Scope.APPLICATIONS_COMMANDS_UPDATE: &#x27;applications.commands.update&#x27;&gt;, &lt;OAuth2Scope.IDENTIFY: &#x27;identify&#x27;&gt;),
): ...</code></pre>
<p>Strategy class for handling client credential OAuth2 authorization.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>]]</code></dt>
<dd>Object or ID of the application this client credentials strategy should
authorize as.</dd>
<dt><strong><code>client_secret</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>Client secret to use when authorizing.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>scopes</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The scopes to authorize for.</dd>
</dl>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L117-L224" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class ClientCredentialsStrategy(rest_api.TokenStrategy):
    &#34;&#34;&#34;Strategy class for handling client credential OAuth2 authorization.

    Parameters
    ----------
    client: typing.Optional[snowflakes.SnowflakeishOr[guilds.PartialApplication]]
        Object or ID of the application this client credentials strategy should
        authorize as.
    client_secret : typing.Optional[builtins.str]
        Client secret to use when authorizing.

    Other Parameters
    ----------------
    scopes : typing.Sequence[str]
        The scopes to authorize for.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_client_id&#34;,
        &#34;_client_secret&#34;,
        &#34;_exception&#34;,
        &#34;_expire_at&#34;,
        &#34;_lock&#34;,
        &#34;_scopes&#34;,
        &#34;_token&#34;,
    )

    def __init__(
        self,
        client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        client_secret: str,
        *,
        scopes: typing.Sequence[typing.Union[applications.OAuth2Scope, str]] = (
            applications.OAuth2Scope.APPLICATIONS_COMMANDS_UPDATE,
            applications.OAuth2Scope.IDENTIFY,
        ),
    ) -&gt; None:
        self._client_id = snowflakes.Snowflake(client)
        self._client_secret = client_secret
        self._exception: typing.Optional[errors.ClientHTTPResponseError] = None
        self._expire_at = 0.0
        self._lock = asyncio.Lock()
        self._scopes = tuple(scopes)
        self._token: typing.Optional[str] = None

    @property
    def client_id(self) -&gt; snowflakes.Snowflake:
        &#34;&#34;&#34;ID of the application this token strategy authenticates with.

        Returns
        -------
        hikari.snowflakes.Snowflake
            ID of the application this token strategy authenticates with.
        &#34;&#34;&#34;
        return self._client_id

    @property
    def _is_expired(self) -&gt; bool:
        return time.monotonic() &gt;= self._expire_at

    @property
    def scopes(self) -&gt; typing.Sequence[typing.Union[applications.OAuth2Scope, str]]:
        &#34;&#34;&#34;Scopes this token strategy authenticates for.

        Returns
        -------
        typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, builtins.str]]
            The scopes this token strategy authenticates for.
        &#34;&#34;&#34;
        return self._scopes

    @property
    def token_type(self) -&gt; applications.TokenType:
        return applications.TokenType.BEARER

    async def acquire(self, client: rest_api.RESTClient) -&gt; str:
        if self._token and not self._is_expired:
            return self._token

        async with self._lock:
            if self._token and not self._is_expired:
                return self._token

            if self._exception:
                # If we don&#39;t copy the exception then python keeps adding onto the stack each time it&#39;s raised.
                raise copy.copy(self._exception) from None

            try:
                response = await client.authorize_client_credentials_token(
                    client=self._client_id, client_secret=self._client_secret, scopes=self._scopes
                )

            except errors.ClientHTTPResponseError as exc:
                if not isinstance(exc, errors.RateLimitedError):
                    # If we don&#39;t copy the exception then python keeps adding onto the stack each time it&#39;s raised.
                    self._exception = copy.copy(exc)

                raise

            # Expires in is lowered a bit in-order to lower the chance of a dead token being used.
            self._expire_at = time.monotonic() + math.floor(response.expires_in.total_seconds() * 0.99)
            self._token = f&#34;{response.token_type} {response.access_token}&#34;
            return self._token

    def invalidate(self, token: typing.Optional[str]) -&gt; None:
        if not token or token == self._token:
            self._expire_at = 0.0
            self._token = None</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="ClientCredentialsStrategy -- Strategy class for handling client credential OAuth2 authorization …" href="#hikari.impl.rest.ClientCredentialsStrategy"
>ClientCredentialsStrategy</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="TokenStrategy -- Interface of an object used for managing OAuth2 access." href="../api/rest.html#hikari.api.rest.TokenStrategy"
>TokenStrategy</a></dt>
<dd class="nested"><p>Interface of an object used for managing OAuth2 access.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.impl.rest.ClientCredentialsStrategy.client_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="client_id -- ID of the application this token strategy authenticates with …" href="#hikari.impl.rest.ClientCredentialsStrategy.client_id"  >client_id</a> : <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></pre>
</dt>
<dd><p>ID of the application this token strategy authenticates with.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>ID of the application this token strategy authenticates with.</dd>
</dl></dd>
</div>
<div id="hikari.impl.rest.ClientCredentialsStrategy.scopes" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="scopes -- Scopes this token strategy authenticates for …" href="#hikari.impl.rest.ClientCredentialsStrategy.scopes"  >scopes</a> : Sequence[Union[<a href='../applications.html#hikari.applications.OAuth2Scope'>OAuth2Scope</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]]</code></pre>
</dt>
<dd><p>Scopes this token strategy authenticates for.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../applications.html#hikari.applications.OAuth2Scope'>OAuth2Scope</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]]</code></dt>
<dd>The scopes this token strategy authenticates for.</dd>
</dl></dd>
</div>
<div id="hikari.impl.rest.ClientCredentialsStrategy.token_type" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="token_type -- Type of token this strategy returns …" href="#hikari.impl.rest.ClientCredentialsStrategy.token_type"  >token_type</a> : <a href='../applications.html#hikari.applications.TokenType'>TokenType</a></code></pre>
</dt>
<dd><p>Type of token this strategy returns.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../applications.html#hikari.applications.TokenType'>TokenType</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The type of token this strategy returns.</dd>
</dl></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.impl.rest.ClientCredentialsStrategy.acquire" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="acquire" href="#hikari.impl.rest.ClientCredentialsStrategy.acquire" id="hikari.impl.rest.ClientCredentialsStrategy.acquire">acquire</a>(
    client: <a href='../api/rest.html#hikari.api.rest.RESTClient'>rest_api.RESTClient</a>,
) -> <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="TokenStrategy -- Interface of an object used for managing OAuth2 access." href="../api/rest.html#hikari.api.rest.TokenStrategy"
>TokenStrategy</a></code>.<code><a title="acquire -- Acquire an authorization token (including the prefix) …" href="../api/rest.html#hikari.api.rest.TokenStrategy.acquire"
>acquire</a></code>
</p>
<p>Acquire an authorization token (including the prefix).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The current authorization token to use for this client and it's
prefix.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L192-L219" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def acquire(self, client: rest_api.RESTClient) -&gt; str:
    if self._token and not self._is_expired:
        return self._token

    async with self._lock:
        if self._token and not self._is_expired:
            return self._token

        if self._exception:
            # If we don&#39;t copy the exception then python keeps adding onto the stack each time it&#39;s raised.
            raise copy.copy(self._exception) from None

        try:
            response = await client.authorize_client_credentials_token(
                client=self._client_id, client_secret=self._client_secret, scopes=self._scopes
            )

        except errors.ClientHTTPResponseError as exc:
            if not isinstance(exc, errors.RateLimitedError):
                # If we don&#39;t copy the exception then python keeps adding onto the stack each time it&#39;s raised.
                self._exception = copy.copy(exc)

            raise

        # Expires in is lowered a bit in-order to lower the chance of a dead token being used.
        self._expire_at = time.monotonic() + math.floor(response.expires_in.total_seconds() * 0.99)
        self._token = f&#34;{response.token_type} {response.access_token}&#34;
        return self._token</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.ClientCredentialsStrategy.invalidate" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="invalidate" href="#hikari.impl.rest.ClientCredentialsStrategy.invalidate" id="hikari.impl.rest.ClientCredentialsStrategy.invalidate">invalidate</a>(
    token: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="TokenStrategy -- Interface of an object used for managing OAuth2 access." href="../api/rest.html#hikari.api.rest.TokenStrategy"
>TokenStrategy</a></code>.<code><a title="invalidate -- Invalidate the cached token in this handler …" href="../api/rest.html#hikari.api.rest.TokenStrategy.invalidate"
>invalidate</a></code>
</p>
<p>Invalidate the cached token in this handler.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p><code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code> may be provided in-order to avoid newly generated tokens
from being invalidated due to multiple calls being made by separate
subroutines which are handling the same token.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The token to specifically invalidate. If provided then this will only
invalidate the cached token if it matches this, otherwise it'll be
invalidated regardless.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L221-L224" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def invalidate(self, token: typing.Optional[str]) -&gt; None:
    if not token or token == self._token:
        self._expire_at = 0.0
        self._token = None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.impl.rest.RESTApp" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTApp -- The base for a HTTP-only Discord application …" href="#hikari.impl.rest.RESTApp"
>RESTApp</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.rest.RESTApp" class="hljs python"><abbr title='A standard Python type.'>class</abbr> RESTApp (
    *,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>] = None,
    http_settings: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../config.html#hikari.config.HTTPSettings'>config.HTTPSettings</a>] = None,
    max_rate_limit: <a href='https://docs.python.org/3/library/functions.html#float'>float</a> = 300,
    max_retries: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 3,
    proxy_settings: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../config.html#hikari.config.ProxySettings'>config.ProxySettings</a>] = None,
    url: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
): ...</code></pre>
<p>The base for a HTTP-only Discord application.</p>
<p>This comprises of a shared TCP connector connection pool, and can have
<code><a href='#hikari.impl.rest.RESTClientImpl'>RESTClientImpl</a></code> instances for specific credentials acquired
from it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to use for blocking file IO operations. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>
is passed, then the default <code><a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor'>concurrent.futures.ThreadPoolExecutor</a></code> for
the <code><a href='https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop'>AbstractEventLoop</a></code> will be used instead.</dd>
<dt><strong><code>http_settings</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../config.html#hikari.config.HTTPSettings'>HTTPSettings</a>]</code></dt>
<dd>HTTP settings to use. Sane defaults are used if this is
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
<dt><strong><code>max_rate_limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#float'>float</a></code></dt>
<dd>
<p>Maximum number of seconds to sleep for when rate limited. If a rate
limit occurs that is longer than this value, then a
<code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code> will be raised instead of waiting.</p>
<p>This is provided since some endpoints may respond with non-sensible
rate limits.</p>
<p>Defaults to five minutes if unspecified.</p>
</dd>
<dt><strong><code>max_retries</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>Maximum number of times a request will be retried if
it fails with a <code>5xx</code> status. Defaults to 3 if set to <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
<dt><strong><code>proxy_settings</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../config.html#hikari.config.ProxySettings'>ProxySettings</a>]</code></dt>
<dd>Proxy settings to use. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then no proxy configuration
will be used.</dd>
<dt><strong><code>url</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The base URL for the API. You can generally leave this as being
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> and the correct default API base URL will be generated.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This event loop will be bound to a connector when the first call
to <code>acquire</code> is made.</p>
</div>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L264-L423" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class RESTApp(traits.ExecutorAware):
    &#34;&#34;&#34;The base for a HTTP-only Discord application.

    This comprises of a shared TCP connector connection pool, and can have
    `RESTClientImpl` instances for specific credentials acquired
    from it.

    Parameters
    ----------
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to use for blocking file IO operations. If `builtins.None`
        is passed, then the default `concurrent.futures.ThreadPoolExecutor` for
        the `asyncio.AbstractEventLoop` will be used instead.
    http_settings : typing.Optional[hikari.config.HTTPSettings]
        HTTP settings to use. Sane defaults are used if this is
        `builtins.None`.
    max_rate_limit : builtins.float
        Maximum number of seconds to sleep for when rate limited. If a rate
        limit occurs that is longer than this value, then a
        `hikari.errors.RateLimitedError` will be raised instead of waiting.

        This is provided since some endpoints may respond with non-sensible
        rate limits.

        Defaults to five minutes if unspecified.
    max_retries : typing.Optional[builtins.int]
        Maximum number of times a request will be retried if
        it fails with a `5xx` status. Defaults to 3 if set to `builtins.None`.
    proxy_settings : typing.Optional[hikari.config.ProxySettings]
        Proxy settings to use. If `builtins.None` then no proxy configuration
        will be used.
    url : typing.Optional[builtins.str]
        The base URL for the API. You can generally leave this as being
        `builtins.None` and the correct default API base URL will be generated.

    !!! note
        This event loop will be bound to a connector when the first call
        to `acquire` is made.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_executor&#34;,
        &#34;_http_settings&#34;,
        &#34;_max_rate_limit&#34;,
        &#34;_max_retries&#34;,
        &#34;_proxy_settings&#34;,
        &#34;_url&#34;,
    )

    def __init__(
        self,
        *,
        executor: typing.Optional[concurrent.futures.Executor] = None,
        http_settings: typing.Optional[config.HTTPSettings] = None,
        max_rate_limit: float = 300,
        max_retries: int = 3,
        proxy_settings: typing.Optional[config.ProxySettings] = None,
        url: typing.Optional[str] = None,
    ) -&gt; None:
        self._http_settings = config.HTTPSettings() if http_settings is None else http_settings
        self._proxy_settings = config.ProxySettings() if proxy_settings is None else proxy_settings
        self._executor = executor
        self._max_rate_limit = max_rate_limit
        self._max_retries = max_retries
        self._url = url

    @property
    def executor(self) -&gt; typing.Optional[concurrent.futures.Executor]:
        return self._executor

    @property
    def http_settings(self) -&gt; config.HTTPSettings:
        return self._http_settings

    @property
    def proxy_settings(self) -&gt; config.ProxySettings:
        return self._proxy_settings

    @typing.overload
    def acquire(self, token: typing.Optional[rest_api.TokenStrategy] = None) -&gt; RESTClientImpl:
        ...

    @typing.overload
    def acquire(
        self,
        token: str,
        token_type: typing.Union[str, applications.TokenType] = applications.TokenType.BEARER,
    ) -&gt; RESTClientImpl:
        ...

    def acquire(
        self,
        token: typing.Union[str, rest_api.TokenStrategy, None] = None,
        token_type: typing.Union[str, applications.TokenType, None] = None,
    ) -&gt; RESTClientImpl:
        &#34;&#34;&#34;Acquire an instance of this REST client.

        !!! note
            The returned REST client should be started before it can be used,
            either by calling `RESTClientImpl.start` or by using it as an
            asynchronous context manager.

        Examples
        --------
        ```py
        rest_app = RESTApp()

        # Using the returned client as a context manager to implicitly start
        # and stop it.
        async with rest_app.acquire(&#34;A token&#34;, &#34;Bot&#34;) as client:
            user = await client.fetch_my_user()
        ```

        Parameters
        ----------
        token : typing.Union[builtins.str, builtins.None, hikari.api.rest.TokenStrategy]
            The bot or bearer token. If no token is to be used,
            this can be undefined.
        token_type : typing.Union[builtins.str, hikari.applications.TokenType, builtins.None]
            The type of token in use. This should only be passed when `builtins.str`
            is passed for `token`, can be `&#34;Bot&#34;` or `&#34;Bearer&#34;` and will be
            defaulted to `&#34;Bearer&#34;` in this situation.

            This should be left as `builtins.None` when either
            `hikari.api.rest.TokenStrategy` or `builtins.None` is passed for
            `token`.

        Returns
        -------
        RESTClientImpl
            An instance of the REST client.

        Raises
        ------
        builtins.ValueError
            If `token_type` is provided when a token strategy is passed for `token`.
        &#34;&#34;&#34;
        # Since we essentially mimic a fake App instance, we need to make a circular provider.
        # We can achieve this using a lambda. This allows the entity factory to build models that
        # are also REST-aware
        provider = _RESTProvider(lambda: entity_factory, self._executor, lambda: rest_client)
        entity_factory = entity_factory_impl.EntityFactoryImpl(provider)

        if token_type is None and isinstance(token, str):
            token_type = applications.TokenType.BEARER

        rest_client = RESTClientImpl(
            cache=None,
            entity_factory=entity_factory,
            executor=self._executor,
            http_settings=self._http_settings,
            max_rate_limit=self._max_rate_limit,
            max_retries=self._max_retries,
            proxy_settings=self._proxy_settings,
            token=token,
            token_type=token_type,
            rest_url=self._url,
        )

        return rest_client</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTApp -- The base for a HTTP-only Discord application …" href="#hikari.impl.rest.RESTApp"
>RESTApp</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A structural supertype (similar to an ABC, but with implicit inheritance)'>trait</abbr></em></small> <a title="ExecutorAware -- Structural supertype for an executor-aware object …" href="../traits.html#hikari.traits.ExecutorAware"
>ExecutorAware</a></dt>
<dd class="nested"><p>Structural supertype for an executor-aware object …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A structural supertype (similar to an ABC, but with implicit inheritance)'>trait</abbr></em></small> <a title="FastProtocolChecking -- An extension to make protocols with faster instance checks …" href="../internal/fast_protocol.html#hikari.internal.fast_protocol.FastProtocolChecking"
>FastProtocolChecking</a></dt>
<dd class="nested"><p>An extension to make protocols with faster instance checks …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Protocol -- Base class for protocol classes …" href="https://docs.python.org/3/library/typing.html#typing.Protocol"
>Protocol</a></dt>
<dd class="nested"><p>Base class for protocol classes …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.impl.rest.RESTApp.executor" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="executor -- Return the executor to use for blocking operations …" href="#hikari.impl.rest.RESTApp.executor"  >executor</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></pre>
</dt>
<dd><p>Return the executor to use for blocking operations.</p>
<p>This may return <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if the default <code><a href='https://docs.aiohttp.org/en/stable/glossary.html#term-asyncio'>asyncio</a></code> thread pool
should be used instead.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to use, or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> to use the <code><a href='https://docs.aiohttp.org/en/stable/glossary.html#term-asyncio'>asyncio</a></code> default
instead.</dd>
</dl></dd>
</div>
<div id="hikari.impl.rest.RESTApp.http_settings" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- " href="#hikari.impl.rest.RESTApp.http_settings"  >http_settings</a> : <a href='../config.html#hikari.config.HTTPSettings'>HTTPSettings</a></code></pre>
</dt>
<dd></dd>
</div>
<div id="hikari.impl.rest.RESTApp.proxy_settings" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="proxy_settings -- " href="#hikari.impl.rest.RESTApp.proxy_settings"  >proxy_settings</a> : <a href='../config.html#hikari.config.ProxySettings'>ProxySettings</a></code></pre>
</dt>
<dd></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.impl.rest.RESTApp.acquire" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="acquire" href="#hikari.impl.rest.RESTApp.acquire" id="hikari.impl.rest.RESTApp.acquire">acquire</a>(
    token: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../api/rest.html#hikari.api.rest.TokenStrategy'>rest_api.TokenStrategy</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>] = None,
    token_type: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../applications.html#hikari.applications.TokenType'>applications.TokenType</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>] = None,
) -> <a href='#hikari.impl.rest.RESTClientImpl'>RESTClientImpl</a>: ...</code></pre>
</dt>
<dd>
<p>Acquire an instance of this REST client.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The returned REST client should be started before it can be used,
either by calling <code><a href='#hikari.impl.rest.RESTClientImpl.start'>start</a></code> or by using it as an
asynchronous context manager.</p>
</div>
<h2 id="examples">Examples</h2>
<pre><code class="language-py">rest_app = RESTApp()

# Using the returned client as a context manager to implicitly start
# and stop it.
async with rest_app.acquire(&quot;A token&quot;, &quot;Bot&quot;) as client:
    user = await client.fetch_my_user()
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>, <a href='../api/rest.html#hikari.api.rest.TokenStrategy'>TokenStrategy</a>]</code></dt>
<dd>The bot or bearer token. If no token is to be used,
this can be undefined.</dd>
<dt><strong><code>token_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../applications.html#hikari.applications.TokenType'>TokenType</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>]</code></dt>
<dd>
<p>The type of token in use. This should only be passed when <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>
is passed for <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code>, can be <code>"Bot"</code> or <code>"Bearer"</code> and will be
defaulted to <code>"Bearer"</code> in this situation.</p>
<p>This should be left as <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> when either
<code><a href='../api/rest.html#hikari.api.rest.TokenStrategy'>TokenStrategy</a></code> or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> is passed for
<code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code>.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.impl.rest.RESTClientImpl'>RESTClientImpl</a></code></dt>
<dd>An instance of the REST client.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code>token_type</code> is provided when a token strategy is passed for <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L354-L423" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def acquire(
    self,
    token: typing.Union[str, rest_api.TokenStrategy, None] = None,
    token_type: typing.Union[str, applications.TokenType, None] = None,
) -&gt; RESTClientImpl:
    &#34;&#34;&#34;Acquire an instance of this REST client.

    !!! note
        The returned REST client should be started before it can be used,
        either by calling `RESTClientImpl.start` or by using it as an
        asynchronous context manager.

    Examples
    --------
    ```py
    rest_app = RESTApp()

    # Using the returned client as a context manager to implicitly start
    # and stop it.
    async with rest_app.acquire(&#34;A token&#34;, &#34;Bot&#34;) as client:
        user = await client.fetch_my_user()
    ```

    Parameters
    ----------
    token : typing.Union[builtins.str, builtins.None, hikari.api.rest.TokenStrategy]
        The bot or bearer token. If no token is to be used,
        this can be undefined.
    token_type : typing.Union[builtins.str, hikari.applications.TokenType, builtins.None]
        The type of token in use. This should only be passed when `builtins.str`
        is passed for `token`, can be `&#34;Bot&#34;` or `&#34;Bearer&#34;` and will be
        defaulted to `&#34;Bearer&#34;` in this situation.

        This should be left as `builtins.None` when either
        `hikari.api.rest.TokenStrategy` or `builtins.None` is passed for
        `token`.

    Returns
    -------
    RESTClientImpl
        An instance of the REST client.

    Raises
    ------
    builtins.ValueError
        If `token_type` is provided when a token strategy is passed for `token`.
    &#34;&#34;&#34;
    # Since we essentially mimic a fake App instance, we need to make a circular provider.
    # We can achieve this using a lambda. This allows the entity factory to build models that
    # are also REST-aware
    provider = _RESTProvider(lambda: entity_factory, self._executor, lambda: rest_client)
    entity_factory = entity_factory_impl.EntityFactoryImpl(provider)

    if token_type is None and isinstance(token, str):
        token_type = applications.TokenType.BEARER

    rest_client = RESTClientImpl(
        cache=None,
        entity_factory=entity_factory,
        executor=self._executor,
        http_settings=self._http_settings,
        max_rate_limit=self._max_rate_limit,
        max_retries=self._max_retries,
        proxy_settings=self._proxy_settings,
        token=token,
        token_type=token_type,
        rest_url=self._url,
    )

    return rest_client</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.impl.rest.RESTClientImpl" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClientImpl -- Implementation of the V8-compatible Discord HTTP API …" href="#hikari.impl.rest.RESTClientImpl"
>RESTClientImpl</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.rest.RESTClientImpl" class="hljs python"><abbr title='A standard Python type.'>class</abbr> RESTClientImpl (
    *,
    cache: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../api/cache.html#hikari.api.cache.MutableCache'>cache_api.MutableCache</a>],
    entity_factory: entity_factory_.EntityFactory,
    executor: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>],
    http_settings: <a href='../config.html#hikari.config.HTTPSettings'>config.HTTPSettings</a>,
    max_rate_limit: <a href='https://docs.python.org/3/library/functions.html#float'>float</a>,
    max_retries: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 3,
    proxy_settings: <a href='../config.html#hikari.config.ProxySettings'>config.ProxySettings</a>,
    token: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>, <a href='../api/rest.html#hikari.api.rest.TokenStrategy'>rest_api.TokenStrategy</a>],
    token_type: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../applications.html#hikari.applications.TokenType'>applications.TokenType</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>],
    rest_url: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
): ...</code></pre>
<p>Implementation of the V8-compatible Discord HTTP API.</p>
<p>This manages making HTTP/1.1 requests to the API and using the entity
factory within the passed application instance to deserialize JSON responses
to Pythonic data classes that are used throughout this library.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entity_factory</code></strong> :&ensp;<code><a href='../api/entity_factory.html#hikari.api.entity_factory.EntityFactory'>EntityFactory</a></code></dt>
<dd>The entity factory to use.</dd>
<dt><strong><code>executor</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a>]</code></dt>
<dd>The executor to use for blocking IO. Defaults to the <code><a href='https://docs.aiohttp.org/en/stable/glossary.html#term-asyncio'>asyncio</a></code> thread
pool if set to <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
<dt><strong><code>max_rate_limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#float'>float</a></code></dt>
<dd>
<p>Maximum number of seconds to sleep for when rate limited. If a rate
limit occurs that is longer than this value, then a
<code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code> will be raised instead of waiting.</p>
<p>This is provided since some endpoints may respond with non-sensible
rate limits.</p>
</dd>
<dt><strong><code>max_retries</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>Maximum number of times a request will be retried if
it fails with a <code>5xx</code> status. Defaults to 3 if set to <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>, <a href='../api/rest.html#hikari.api.rest.TokenStrategy'>TokenStrategy</a>]</code></dt>
<dd>The bot or bearer token. If no token is to be used,
this can be undefined.</dd>
<dt><strong><code>token_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../applications.html#hikari.applications.TokenType'>TokenType</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>]</code></dt>
<dd>
<p>The type of token in use. This must be passed when a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> is
passed for <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code> but and can be <code>"Bot"</code> or <code>"Bearer"</code>.</p>
<p>This should be left as <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> when either
<code><a href='../api/rest.html#hikari.api.rest.TokenStrategy'>TokenStrategy</a></code> or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> is passed for
<code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code>.</p>
</dd>
<dt><strong><code>rest_url</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The HTTP API base URL. This can contain format-string specifiers to
interpolate information such as API version in use.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>
<ul>
<li>If <code>token_type</code> is provided when a token strategy is passed for <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code>.</li>
<li>if <code>token_type</code> is left as <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> when a string is passed for <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code>.</li>
<li>If the a value more than 5 is provided for <code>max_retries</code></li>
</ul>
</dd>
</dl>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L495-L3471" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class RESTClientImpl(rest_api.RESTClient):
    &#34;&#34;&#34;Implementation of the V8-compatible Discord HTTP API.

    This manages making HTTP/1.1 requests to the API and using the entity
    factory within the passed application instance to deserialize JSON responses
    to Pythonic data classes that are used throughout this library.

    Parameters
    ----------
    entity_factory : hikari.api.entity_factory.EntityFactory
        The entity factory to use.
    executor : typing.Optional[concurrent.futures.Executor]
        The executor to use for blocking IO. Defaults to the `asyncio` thread
        pool if set to `builtins.None`.
    max_rate_limit : builtins.float
        Maximum number of seconds to sleep for when rate limited. If a rate
        limit occurs that is longer than this value, then a
        `hikari.errors.RateLimitedError` will be raised instead of waiting.

        This is provided since some endpoints may respond with non-sensible
        rate limits.
    max_retries : typing.Optional[builtins.int]
        Maximum number of times a request will be retried if
        it fails with a `5xx` status. Defaults to 3 if set to `builtins.None`.
    token : typing.Union[builtins.str, builtins.None, hikari.api.rest.TokenStrategy]
        The bot or bearer token. If no token is to be used,
        this can be undefined.
    token_type : typing.Union[builtins.str, hikari.applications.TokenType, builtins.None]
        The type of token in use. This must be passed when a `builtins.str` is
        passed for `token` but and can be `&#34;Bot&#34;` or `&#34;Bearer&#34;`.

        This should be left as `builtins.None` when either
        `hikari.api.rest.TokenStrategy` or `builtins.None` is passed for
        `token`.
    rest_url : builtins.str
        The HTTP API base URL. This can contain format-string specifiers to
        interpolate information such as API version in use.

    Raises
    ------
    builtins.ValueError
        * If `token_type` is provided when a token strategy is passed for `token`.
        * if `token_type` is left as `builtins.None` when a string is passed for `token`.
        * If the a value more than 5 is provided for `max_retries`
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_cache&#34;,
        &#34;_entity_factory&#34;,
        &#34;_executor&#34;,
        &#34;_http_settings&#34;,
        &#34;_live_attributes&#34;,
        &#34;_max_rate_limit&#34;,
        &#34;_max_retries&#34;,
        &#34;_proxy_settings&#34;,
        &#34;_rest_url&#34;,
        &#34;_token&#34;,
        &#34;_token_type&#34;,
    )

    def __init__(
        self,
        *,
        cache: typing.Optional[cache_api.MutableCache],
        entity_factory: entity_factory_.EntityFactory,
        executor: typing.Optional[concurrent.futures.Executor],
        http_settings: config.HTTPSettings,
        max_rate_limit: float,
        max_retries: int = 3,
        proxy_settings: config.ProxySettings,
        token: typing.Union[str, None, rest_api.TokenStrategy],
        token_type: typing.Union[applications.TokenType, str, None],
        rest_url: typing.Optional[str],
    ) -&gt; None:
        if max_retries &gt; 5:
            raise ValueError(&#34;&#39;max_retries&#39; must be below or equal to 5&#34;)

        self._cache = cache
        self._entity_factory = entity_factory
        self._executor = executor
        self._http_settings = http_settings
        self._live_attributes: typing.Optional[_LiveAttributes] = None
        self._max_rate_limit = max_rate_limit
        self._max_retries = max_retries
        self._proxy_settings = proxy_settings

        self._token: typing.Union[str, rest_api.TokenStrategy, None] = None
        self._token_type: typing.Optional[str] = None
        if isinstance(token, str):
            if token_type is None:
                raise ValueError(&#34;Token type required when a str is passed for `token`&#34;)

            self._token = f&#34;{token_type.title()} {token}&#34;
            self._token_type = applications.TokenType(token_type.title())

        elif isinstance(token, rest_api.TokenStrategy):
            if token_type is not None:
                raise ValueError(&#34;Token type should be handled by the token strategy&#34;)

            self._token = token
            self._token_type = token.token_type

        self._rest_url = rest_url if rest_url is not None else urls.REST_API_URL

    @property
    def is_alive(self) -&gt; bool:
        return self._live_attributes is not None

    @property
    def http_settings(self) -&gt; config.HTTPSettings:
        return self._http_settings

    @property
    def proxy_settings(self) -&gt; config.ProxySettings:
        return self._proxy_settings

    @property
    def token_type(self) -&gt; typing.Union[str, applications.TokenType, None]:
        return self._token_type

    @typing.final
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the HTTP client and any open HTTP connections.&#34;&#34;&#34;
        live_attributes = self._get_live_attributes()
        self._live_attributes = None
        await live_attributes.close()

        # We have to sleep to allow aiohttp time to close SSL transports...
        # https://github.com/aio-libs/aiohttp/issues/1925
        # https://docs.aiohttp.org/en/stable/client_advanced.html#graceful-shutdown
        #
        # TODO: Remove when we update to aiohttp 4.0.0
        # https://github.com/aio-libs/aiohttp/issues/1925#issuecomment-715977247
        await asyncio.sleep(0.25)

    @typing.final
    def start(self) -&gt; None:
        &#34;&#34;&#34;Start the HTTP client.

        !!! note
            This must be called within an active event loop.

        Raises
        ------
        RuntimeError
            If this is called in an environment without an active event loop.
        &#34;&#34;&#34;
        if self._live_attributes:
            raise errors.ComponentStateConflictError(&#34;Cannot start a REST Client which is already alive&#34;)

        self._live_attributes = _LiveAttributes.build(self._max_rate_limit, self._http_settings, self._proxy_settings)

    def _get_live_attributes(self) -&gt; _LiveAttributes:
        if self._live_attributes:
            return self._live_attributes

        raise errors.ComponentStateConflictError(&#34;Cannot use an inactive REST client&#34;)

    async def __aenter__(self) -&gt; RESTClientImpl:
        self.start()
        return self

    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc_val: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        await self.close()

    # These are only included at runtime in-order to avoid the model being typed as a synchronous context manager.
    if not typing.TYPE_CHECKING:

        def __enter__(self) -&gt; typing.NoReturn:
            # This is async only.
            cls = type(self)
            raise TypeError(f&#34;{cls.__module__}.{cls.__qualname__} is async-only, did you mean &#39;async with&#39;?&#34;) from None

        def __exit__(
            self,
            exc_type: typing.Optional[typing.Type[Exception]],
            exc_val: typing.Optional[Exception],
            exc_tb: typing.Optional[types.TracebackType],
        ) -&gt; None:
            return None

    @typing.final
    async def _request(
        self,
        compiled_route: routes.CompiledRoute,
        *,
        query: typing.Optional[data_binding.StringMapBuilder] = None,
        form: typing.Optional[aiohttp.FormData] = None,
        json: typing.Union[data_binding.JSONObjectBuilder, data_binding.JSONArray, None] = None,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        no_auth: bool = False,
        auth: typing.Optional[str] = None,
    ) -&gt; typing.Union[None, data_binding.JSONObject, data_binding.JSONArray]:
        # Make a ratelimit-protected HTTP request to a JSON endpoint and expect some form
        # of JSON response.
        live_attributes = self._get_live_attributes()
        headers = data_binding.StringMapBuilder()
        headers.setdefault(_USER_AGENT_HEADER, _HTTP_USER_AGENT)

        re_authed = False
        token: typing.Optional[str] = None
        if auth:
            headers[_AUTHORIZATION_HEADER] = auth

        elif not no_auth:
            if isinstance(self._token, str):
                headers[_AUTHORIZATION_HEADER] = self._token

            elif self._token is not None:
                token = await self._token.acquire(self)
                headers[_AUTHORIZATION_HEADER] = token

        headers.put(_X_AUDIT_LOG_REASON_HEADER, reason)

        url = compiled_route.create_url(self._rest_url)

        # This is initiated the first time we hit a 5xx error to save memory when nothing goes wrong
        backoff: typing.Optional[rate_limits.ExponentialBackOff] = None
        retry_count = 0

        while True:
            try:
                uuid = time.uuid()
                async with live_attributes.still_alive().buckets.acquire(compiled_route):
                    # Buckets not using authentication still have a global
                    # rate limit, but it is different from the token one.
                    if not no_auth:
                        await live_attributes.still_alive().global_rate_limit.acquire()

                    if _LOGGER.isEnabledFor(ux.TRACE):
                        _LOGGER.log(
                            ux.TRACE,
                            &#34;%s %s %s\n%s&#34;,
                            uuid,
                            compiled_route.method,
                            url,
                            self._stringify_http_message(headers, json),
                        )
                        start = time.monotonic()

                    # Make the request.
                    response = await live_attributes.still_alive().client_session.request(
                        compiled_route.method,
                        url,
                        headers=headers,
                        params=query,
                        json=json,
                        data=form,
                        allow_redirects=self._http_settings.max_redirects is not None,
                        max_redirects=self._http_settings.max_redirects,
                        proxy=self._proxy_settings.url,
                        proxy_headers=self._proxy_settings.all_headers,
                    )

                    if _LOGGER.isEnabledFor(ux.TRACE):
                        time_taken = (time.monotonic() - start) * 1_000
                        _LOGGER.log(
                            ux.TRACE,
                            &#34;%s %s %s in %sms\n%s&#34;,
                            uuid,
                            response.status,
                            response.reason,
                            time_taken,
                            self._stringify_http_message(response.headers, await response.read()),
                        )

                    # Ensure we are not rate limited, and update rate limiting headers where appropriate.
                    await self._parse_ratelimits(compiled_route, response, live_attributes)

                # Don&#39;t bother processing any further if we got NO CONTENT. There&#39;s not anything
                # to check.
                if response.status == http.HTTPStatus.NO_CONTENT:
                    return None

                # Handle the response when everything went good
                if 200 &lt;= response.status &lt; 300:
                    if response.content_type == _APPLICATION_JSON:
                        # Only deserializing here stops Cloudflare shenanigans messing us around.
                        return data_binding.load_json(await response.read())

                    real_url = str(response.real_url)
                    raise errors.HTTPError(f&#34;Expected JSON [{response.content_type=}, {real_url=}]&#34;)

                # Handling 5xx errors
                if response.status in _RETRY_ERROR_CODES and retry_count &lt; self._max_retries:
                    if backoff is None:
                        backoff = rate_limits.ExponentialBackOff(maximum=_MAX_BACKOFF_DURATION)

                    sleep_time = next(backoff)
                    _LOGGER.warning(
                        &#34;Received status %s on request, backing off for %.2fs and retrying. Retries remaining: %s&#34;,
                        response.status,
                        sleep_time,
                        self._max_retries - retry_count,
                    )
                    retry_count += 1

                    await asyncio.sleep(sleep_time)
                    raise _RetryRequest

                # Attempt to re-auth on UNAUTHORIZED if we are using a TokenStrategy
                can_re_auth = response.status == 401 and not (auth or no_auth or re_authed)
                if can_re_auth and isinstance(self._token, rest_api.TokenStrategy):
                    assert token is not None
                    self._token.invalidate(token)
                    token = await self._token.acquire(self)
                    headers[_AUTHORIZATION_HEADER] = token
                    re_authed = True
                    continue

                await self._handle_error_response(response)

            except _RetryRequest:
                continue

    @staticmethod
    @typing.final
    def _stringify_http_message(headers: data_binding.Headers, body: typing.Any) -&gt; str:
        string = &#34;\n&#34;.join(
            f&#34;    {name}: {value}&#34; if name != _AUTHORIZATION_HEADER else f&#34;    {name}: **REDACTED TOKEN**&#34;
            for name, value in headers.items()
        )

        if body is not None:
            string += &#34;\n\n    &#34;
            string += body.decode(&#34;ascii&#34;) if isinstance(body, bytes) else str(body)

        return string

    @staticmethod
    @typing.final
    async def _handle_error_response(response: aiohttp.ClientResponse) -&gt; typing.NoReturn:
        raise await net.generate_error_response(response)

    @typing.final
    async def _parse_ratelimits(
        self, compiled_route: routes.CompiledRoute, response: aiohttp.ClientResponse, live_attributes: _LiveAttributes
    ) -&gt; None:
        # Handle rate limiting.
        resp_headers = response.headers
        limit = int(resp_headers.get(_X_RATELIMIT_LIMIT_HEADER, &#34;1&#34;))
        remaining = int(resp_headers.get(_X_RATELIMIT_REMAINING_HEADER, &#34;1&#34;))
        bucket = resp_headers.get(_X_RATELIMIT_BUCKET_HEADER)
        reset_after = float(resp_headers.get(_X_RATELIMIT_RESET_AFTER_HEADER, &#34;0&#34;))

        if bucket:
            live_attributes.still_alive().buckets.update_rate_limits(
                compiled_route=compiled_route,
                bucket_header=bucket,
                remaining_header=remaining,
                limit_header=limit,
                reset_after=reset_after,
            )

        if response.status != http.HTTPStatus.TOO_MANY_REQUESTS:
            return

        # Discord have started applying ratelimits to operations on some endpoints
        # based on specific fields used in the JSON body.
        # This does not get reflected in the headers. The first we know is when we
        # get a 429.
        # The issue is that we may get the same response if Discord dynamically
        # adjusts the bucket ratelimits.
        #
        # We have no mechanism for handing field-based ratelimits, so if we get
        # to here, but notice remaining is greater than zero, we should just error.
        #
        # Seems Discord may raise this on some other undocumented cases, which
        # is nice of them. Apparently some dude spamming slurs in the Python
        # guild via a leaked webhook URL made people&#39;s clients exhibit this
        # behaviour.
        #
        # If we get ratelimited when running more than one bot under the same token,
        # or if the ratelimiting logic goes wrong, we will get a 429 and expect the
        # &#34;remaining&#34; header to be zeroed, or even negative as I don&#39;t trust that there
        # isn&#39;t some weird edge case here somewhere in Discord&#39;s implementation.
        # We can safely retry if this happens as acquiring the bucket will handle
        # this.
        if remaining &lt;= 0:
            _LOGGER.warning(
                &#34;rate limited on bucket %s, maybe you are running more than one bot on this token? Retrying request...&#34;,
                bucket,
            )
            raise _RetryRequest

        if response.content_type != _APPLICATION_JSON:
            # We don&#39;t know exactly what this could imply. It is likely Cloudflare interfering
            # but I&#39;d rather we just give up than do something resulting in multiple failed
            # requests repeatedly.
            raise errors.HTTPResponseError(
                str(response.real_url),
                http.HTTPStatus.TOO_MANY_REQUESTS,
                response.headers,
                await response.read(),
                f&#34;received rate limited response with unexpected response type {response.content_type}&#34;,
            )

        body = await response.json()
        body_retry_after = float(body[&#34;retry_after&#34;])

        if body.get(&#34;global&#34;, False) is True:
            _LOGGER.error(
                &#34;rate limited on the global bucket. You should consider lowering the number of requests you make or &#34;
                &#34;contacting Discord to raise this limit. Backing off and retrying request...&#34;
            )
            live_attributes.still_alive().global_rate_limit.throttle(body_retry_after)
            raise _RetryRequest

        # If the values are within 20% of each other by relativistic tolerance, it is probably
        # safe to retry the request, as they are likely the same value just with some
        # measuring difference. 20% was used as a rounded figure.
        if math.isclose(body_retry_after, reset_after, rel_tol=0.20):
            _LOGGER.error(&#34;rate limited on a sub bucket on bucket %s, but it is safe to retry&#34;, bucket)
            raise _RetryRequest

        raise errors.RateLimitedError(
            url=str(response.real_url),
            route=compiled_route,
            headers=response.headers,
            raw_body=body,
            retry_after=body_retry_after,
        )

    async def fetch_channel(
        self, channel: snowflakes.SnowflakeishOr[channels_.PartialChannel]
    ) -&gt; channels_.PartialChannel:
        route = routes.GET_CHANNEL.compile(channel=channel)
        response = await self._request(route)
        assert isinstance(response, dict)
        result = self._entity_factory.deserialize_channel(response)

        if self._cache and isinstance(result, channels_.DMChannel):
            self._cache.set_dm_channel_id(result.recipient.id, result.id)

        return result

    async def edit_channel(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
        /,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        video_quality_mode: undefined.UndefinedOr[typing.Union[channels_.VideoQualityMode, int]] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        region: undefined.UndefinedNoneOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        parent_category: undefined.UndefinedOr[
            snowflakes.SnowflakeishOr[channels_.GuildCategory]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.PartialChannel:
        route = routes.PATCH_CHANNEL.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;position&#34;, position)
        body.put(&#34;topic&#34;, topic)
        body.put(&#34;nsfw&#34;, nsfw)
        body.put(&#34;bitrate&#34;, bitrate)
        body.put(&#34;video_quality_mode&#34;, video_quality_mode)
        body.put(&#34;user_limit&#34;, user_limit)
        body.put(&#34;rate_limit_per_user&#34;, rate_limit_per_user, conversion=time.timespan_to_int)
        body.put(&#34;rtc_region&#34;, region, conversion=str)
        body.put_snowflake(&#34;parent_id&#34;, parent_category)
        body.put_array(
            &#34;permission_overwrites&#34;,
            permission_overwrites,
            conversion=self._entity_factory.serialize_permission_overwrite,
        )

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_channel(response)

    async def follow_channel(
        self,
        news_channel: snowflakes.SnowflakeishOr[channels_.GuildNewsChannel],
        target_channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.ChannelFollow:
        route = routes.POST_CHANNEL_FOLLOWERS.compile(channel=news_channel)
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;webhook_channel_id&#34;, target_channel)

        response = await self._request(route, json=body, reason=reason)

        assert isinstance(response, dict)
        return self._entity_factory.deserialize_channel_follow(response)

    async def delete_channel(
        self, channel: snowflakes.SnowflakeishOr[channels_.PartialChannel]
    ) -&gt; channels_.PartialChannel:
        route = routes.DELETE_CHANNEL.compile(channel=channel)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_channel(response)

    async def edit_my_voice_state(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels_.GuildStageChannel],
        *,
        suppress: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        request_to_speak: typing.Union[undefined.UndefinedType, bool, datetime.datetime] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_MY_GUILD_VOICE_STATE.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;channel_id&#34;, channel)
        body.put(&#34;suppress&#34;, suppress)

        if isinstance(request_to_speak, datetime.datetime):
            body.put(&#34;request_to_speak_timestamp&#34;, request_to_speak.isoformat())

        elif request_to_speak is True:
            body.put(&#34;request_to_speak_timestamp&#34;, time.utc_datetime().isoformat())

        elif request_to_speak is False:
            body.put(&#34;request_to_speak_timestamp&#34;, None)

        await self._request(route, json=body)

    async def edit_voice_state(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels_.GuildStageChannel],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        suppress: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_GUILD_VOICE_STATE.compile(guild=guild, user=user)
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;channel_id&#34;, channel)
        body.put(&#34;suppress&#34;, suppress)
        await self._request(route, json=body)

    async def edit_permission_overwrites(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
        target: typing.Union[
            snowflakes.Snowflakeish, users.PartialUser, guilds.PartialRole, channels_.PermissionOverwrite
        ],
        *,
        target_type: undefined.UndefinedOr[typing.Union[channels_.PermissionOverwriteType, int]] = undefined.UNDEFINED,
        allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        if target_type is undefined.UNDEFINED:
            if isinstance(target, users.PartialUser):
                target_type = channels_.PermissionOverwriteType.MEMBER
            elif isinstance(target, guilds.Role):
                target_type = channels_.PermissionOverwriteType.ROLE
            elif isinstance(target, channels_.PermissionOverwrite):
                target_type = target.type
            else:
                raise TypeError(
                    &#34;Cannot determine the type of the target to update. Try specifying &#39;target_type&#39; manually.&#34;
                )

        route = routes.PUT_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;type&#34;, target_type)
        body.put(&#34;allow&#34;, allow)
        body.put(&#34;deny&#34;, deny)
        await self._request(route, json=body, reason=reason)

    async def delete_permission_overwrite(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
        target: snowflakes.SnowflakeishOr[
            typing.Union[channels_.PermissionOverwrite, guilds.PartialRole, users.PartialUser, snowflakes.Snowflakeish]
        ],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
        await self._request(route)

    async def fetch_channel_invites(
        self, channel: snowflakes.SnowflakeishOr[channels_.GuildChannel]
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        route = routes.GET_CHANNEL_INVITES.compile(channel=channel)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_invite_with_metadata(invite_payload) for invite_payload in response]

    async def create_invite(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
        *,
        max_age: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        max_uses: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        temporary: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        unique: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        target_type: undefined.UndefinedOr[invites.TargetType] = undefined.UNDEFINED,
        target_user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        target_application: undefined.UndefinedOr[
            snowflakes.SnowflakeishOr[guilds.PartialApplication]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; invites.InviteWithMetadata:
        route = routes.POST_CHANNEL_INVITES.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;max_age&#34;, max_age, conversion=time.timespan_to_int)
        body.put(&#34;max_uses&#34;, max_uses)
        body.put(&#34;temporary&#34;, temporary)
        body.put(&#34;unique&#34;, unique)
        body.put(&#34;target_type&#34;, target_type)
        body.put_snowflake(&#34;target_user_id&#34;, target_user)
        body.put_snowflake(&#34;target_application_id&#34;, target_application)
        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_invite_with_metadata(response)

    def trigger_typing(
        self, channel: snowflakes.SnowflakeishOr[channels_.TextableChannel]
    ) -&gt; special_endpoints.TypingIndicator:
        return special_endpoints_impl.TypingIndicator(
            request_call=self._request, channel=channel, rest_closed_event=self._get_live_attributes().closed_event
        )

    async def fetch_pins(
        self, channel: snowflakes.SnowflakeishOr[channels_.TextableChannel]
    ) -&gt; typing.Sequence[messages_.Message]:
        route = routes.GET_CHANNEL_PINS.compile(channel=channel)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_message(message_pl) for message_pl in response]

    async def pin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        route = routes.PUT_CHANNEL_PINS.compile(channel=channel, message=message)
        await self._request(route)

    async def unpin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_PIN.compile(channel=channel, message=message)
        await self._request(route)

    def fetch_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        after: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        around: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[messages_.Message]:
        if undefined.count(before, after, around) &lt; 2:
            raise TypeError(&#34;Expected no kwargs, or a maximum of one of &#39;before&#39;, &#39;after&#39;, &#39;around&#39;&#34;)

        timestamp: undefined.UndefinedOr[str]

        if before is not undefined.UNDEFINED:
            direction = &#34;before&#34;
            if isinstance(before, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(before))
            else:
                timestamp = str(int(before))
        elif after is not undefined.UNDEFINED:
            direction = &#34;after&#34;
            if isinstance(after, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(after))
            else:
                timestamp = str(int(after))
        elif around is not undefined.UNDEFINED:
            direction = &#34;around&#34;
            if isinstance(around, datetime.datetime):
                timestamp = str(snowflakes.Snowflake.from_datetime(around))
            else:
                timestamp = str(int(around))
        else:
            direction = &#34;before&#34;
            timestamp = undefined.UNDEFINED

        return special_endpoints_impl.MessageIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            channel=channel,
            direction=direction,
            first_id=timestamp,
        )

    async def fetch_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; messages_.Message:
        route = routes.GET_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def _create_message(
        self,
        route: routes.CompiledRoute,
        body: data_binding.JSONObjectBuilder,
        query: typing.Optional[data_binding.StringMapBuilder] = None,
        *,
        no_auth: bool = False,
        content: undefined.UndefinedOr[typing.Any],
        attachment: undefined.UndefinedOr[files.Resourceish],
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]],
        component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed],
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]],
        tts: undefined.UndefinedOr[bool],
        mentions_everyone: undefined.UndefinedOr[bool],
        mentions_reply: undefined.UndefinedOr[bool],
        user_mentions: undefined.UndefinedOr[typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]],
        role_mentions: undefined.UndefinedOr[typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]],
    ) -&gt; messages_.Message:
        if not undefined.any_undefined(attachment, attachments):
            raise ValueError(&#34;You may only specify one of &#39;attachment&#39; or &#39;attachments&#39;, not both&#34;)

        if not undefined.any_undefined(component, components):
            raise ValueError(&#34;You may only specify one of &#39;component&#39; or &#39;components&#39;, not both&#34;)

        if not undefined.any_undefined(embed, embeds):
            raise ValueError(&#34;You may only specify one of &#39;embed&#39; or &#39;embeds&#39;, not both&#34;)

        if attachments is not undefined.UNDEFINED and not isinstance(attachments, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;attachments&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;attachment&#39; (singular) instead?&#34;
            )

        if components is not undefined.UNDEFINED and not isinstance(components, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;components&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;component&#39; (singular) instead?&#34;
            )

        if embeds not in _NONE_OR_UNDEFINED and not isinstance(embeds, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;embeds&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;embed&#39; (singular) instead?&#34;
            )

        if undefined.all_undefined(embed, embeds) and isinstance(content, embeds_.Embed):
            # Syntactic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED

        elif undefined.all_undefined(attachment, attachments) and isinstance(
            content, (files.Resource, files.RAWISH_TYPES, os.PathLike)
        ):
            # Syntactic sugar, common mistake to accidentally send an attachment
            # as the content, so lets detect this and fix it for the user. This
            # will still then work with normal implicit embed attachments as
            # we work this out later.
            attachment = content
            content = undefined.UNDEFINED

        final_attachments: typing.List[files.Resource[files.AsyncReader]] = []
        if attachment is not undefined.UNDEFINED:
            final_attachments.append(files.ensure_resource(attachment))
        if attachments is not undefined.UNDEFINED:
            final_attachments.extend([files.ensure_resource(a) for a in attachments])

        if component is not undefined.UNDEFINED:
            body.put(&#34;components&#34;, [component.build()])

        elif components is not undefined.UNDEFINED:
            body.put(&#34;components&#34;, [component.build() for component in components])

        serialized_embeds: undefined.UndefinedOr[data_binding.JSONArray] = undefined.UNDEFINED

        if embed is not undefined.UNDEFINED:
            embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
            final_attachments.extend(embed_attachments)
            serialized_embeds = [embed_payload]
        elif embeds is not undefined.UNDEFINED:
            serialized_embeds = []
            for embed in embeds:
                embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
                final_attachments.extend(embed_attachments)
                serialized_embeds.append(embed_payload)

        body.put(
            &#34;allowed_mentions&#34;,
            mentions.generate_allowed_mentions(mentions_everyone, mentions_reply, user_mentions, role_mentions),
        )
        body.put(&#34;content&#34;, content, conversion=str)
        body.put(&#34;tts&#34;, tts)
        body.put(&#34;embeds&#34;, serialized_embeds)

        if final_attachments:
            form = data_binding.URLEncodedForm()
            form.add_field(&#34;payload_json&#34;, data_binding.dump_json(body), content_type=_APPLICATION_JSON)

            stack = contextlib.AsyncExitStack()

            try:
                for i, attachment in enumerate(final_attachments):
                    stream = await stack.enter_async_context(attachment.stream(executor=self._executor))
                    mimetype = stream.mimetype or _APPLICATION_OCTET_STREAM
                    form.add_field(f&#34;file{i}&#34;, stream, filename=stream.filename, content_type=mimetype)

                response = await self._request(route, form=form, query=query, no_auth=no_auth)
            finally:
                await stack.aclose()
        else:
            response = await self._request(route, json=body, query=query, no_auth=no_auth)

        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def create_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reply: undefined.UndefinedOr[snowflakes.SnowflakeishOr[messages_.PartialMessage]] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentions_reply: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        route = routes.POST_CHANNEL_MESSAGES.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;nonce&#34;, nonce)
        body.put(&#34;message_reference&#34;, reply, conversion=lambda m: {&#34;message_id&#34;: str(int(m))})
        return await self._create_message(
            route,
            body,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            tts=tts,
            mentions_everyone=mentions_everyone,
            mentions_reply=mentions_reply,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
        )

    async def crosspost_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.GuildNewsChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; messages_.Message:
        route = routes.POST_CHANNEL_CROSSPOST.compile(channel=channel, message=message)

        response = await self._request(route)

        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def _edit_message(  # noqa: C901 - Function too complex
        self,
        route: routes.CompiledRoute,
        body: data_binding.JSONObjectBuilder,
        *,
        no_auth: bool = False,
        content: undefined.UndefinedOr[typing.Any],
        attachment: undefined.UndefinedOr[files.Resourceish],
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]],
        component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedNoneOr[
            typing.Sequence[special_endpoints.ComponentBuilder]
        ] = undefined.UNDEFINED,
        embed: undefined.UndefinedNoneOr[embeds_.Embed],
        embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]],
        replace_attachments: bool,
        mentions_everyone: undefined.UndefinedOr[bool],
        mentions_reply: undefined.UndefinedOr[bool],
        user_mentions: undefined.UndefinedOr[typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]],
        role_mentions: undefined.UndefinedOr[typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]],
    ) -&gt; messages_.Message:
        if not undefined.any_undefined(attachment, attachments):
            raise ValueError(&#34;You may only specify one of &#39;attachment&#39; or &#39;attachments&#39;, not both&#34;)

        if not undefined.any_undefined(component, components):
            raise ValueError(&#34;You may only specify one of &#39;component&#39; or &#39;components&#39;, not both&#34;)

        if not undefined.any_undefined(embed, embeds):
            raise ValueError(&#34;You may only specify one of &#39;embed&#39; or &#39;embeds&#39;, not both&#34;)

        if attachments is not undefined.UNDEFINED and not isinstance(attachments, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;attachments&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;attachment&#39; (singular) instead?&#34;
            )

        if components is not undefined.UNDEFINED and not isinstance(components, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;components&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;component&#39; (singular) instead?&#34;
            )

        if embeds not in _NONE_OR_UNDEFINED and not isinstance(embeds, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;embeds&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;embed&#39; (singular) instead?&#34;
            )

        if not undefined.all_undefined(mentions_everyone, mentions_reply, user_mentions, role_mentions):
            body.put(
                &#34;allowed_mentions&#34;,
                mentions.generate_allowed_mentions(mentions_everyone, mentions_reply, user_mentions, role_mentions),
            )

        if embed is undefined.UNDEFINED and isinstance(content, embeds_.Embed):
            # Syntactic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED
        elif undefined.all_undefined(attachment, attachments) and isinstance(
            content, (files.Resource, files.RAWISH_TYPES, os.PathLike)
        ):
            # Syntactic sugar, common mistake to accidentally send an attachment
            # as the content, so lets detect this and fix it for the user. This
            # will still then work with normal implicit embed attachments as
            # we work this out later.
            attachment = content
            content = undefined.UNDEFINED

        if content is not None:
            body.put(&#34;content&#34;, content, conversion=str)
        else:
            body.put(&#34;content&#34;, None)

        final_attachments: typing.List[files.Resource[files.AsyncReader]] = []
        if attachment is not undefined.UNDEFINED:
            final_attachments.append(files.ensure_resource(attachment))
        if attachments is not undefined.UNDEFINED:
            final_attachments.extend([files.ensure_resource(a) for a in attachments])

        serialized_components: typing.Optional[typing.List[data_binding.JSONObject]] = None
        if component is not undefined.UNDEFINED:
            if component is not None:
                serialized_components = [component.build()]

            body.put(&#34;components&#34;, serialized_components)

        elif components is not undefined.UNDEFINED:
            if components is not None:
                serialized_components = [component.build() for component in components]

            body.put(&#34;components&#34;, serialized_components)

        serialized_embeds: data_binding.JSONArray = []
        update_embeds = False
        if embed is not undefined.UNDEFINED:
            update_embeds = True
            if embed is not None:
                embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
                serialized_embeds.append(embed_payload)
                final_attachments.extend(embed_attachments)
        elif embeds is not undefined.UNDEFINED:
            update_embeds = True
            if embeds is not None:
                for embed in embeds:
                    embed_payload, embed_attachments = self._entity_factory.serialize_embed(embed)
                    serialized_embeds.append(embed_payload)
                    final_attachments.extend(embed_attachments)

        if update_embeds:
            body.put(&#34;embeds&#34;, serialized_embeds)

        if replace_attachments:
            body.put(&#34;attachments&#34;, None)

        if final_attachments:
            form = data_binding.URLEncodedForm()
            form.add_field(&#34;payload_json&#34;, data_binding.dump_json(body), content_type=_APPLICATION_JSON)

            stack = contextlib.AsyncExitStack()
            try:
                for i, attachment in enumerate(final_attachments):
                    stream = await stack.enter_async_context(attachment.stream(executor=self._executor))
                    mimetype = stream.mimetype or _APPLICATION_OCTET_STREAM
                    form.add_field(f&#34;file{i}&#34;, stream, filename=stream.filename, content_type=mimetype)

                response = await self._request(route, form=form, no_auth=no_auth)
            finally:
                await stack.aclose()
        else:
            response = await self._request(route, json=body, no_auth=no_auth)

        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def edit_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedNoneOr[
            typing.Sequence[special_endpoints.ComponentBuilder]
        ] = undefined.UNDEFINED,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        replace_attachments: bool = False,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentions_reply: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
        flags: undefined.UndefinedOr[messages_.MessageFlag] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        route = routes.PATCH_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;flags&#34;, flags)
        return await self._edit_message(
            route,
            body,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            replace_attachments=replace_attachments,
            mentions_everyone=mentions_everyone,
            mentions_reply=mentions_reply,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
        )

    async def delete_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        route = routes.DELETE_CHANNEL_MESSAGE.compile(channel=channel, message=message)
        await self._request(route)

    async def delete_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        messages: typing.Union[
            snowflakes.SnowflakeishOr[messages_.PartialMessage],
            snowflakes.SnowflakeishIterable[messages_.PartialMessage],
        ],
        /,
        *other_messages: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        route = routes.POST_DELETE_CHANNEL_MESSAGES_BULK.compile(channel=channel)

        pending: typing.Deque[snowflakes.SnowflakeishOr[messages_.PartialMessage]] = collections.deque()
        deleted: typing.Deque[snowflakes.SnowflakeishOr[messages_.PartialMessage]] = collections.deque()

        if isinstance(messages, typing.Iterable):  # Syntactic sugar. Allows to use iterables
            pending.extend(messages)

        else:
            pending.append(messages)

        # This maintains the order in-order to keep a predictable deletion order.
        pending.extend(other_messages)

        while pending:
            # Discord only allows 2-100 messages in the BULK_DELETE endpoint. Because of that,
            # if the user wants 101 messages deleted, we will post 100 messages in bulk delete
            # and then the last message in a normal delete.
            # Along with this, the bucket size for v6 and v7 seems to be a bit restrictive. As of
            # 30th July 2020, this endpoint returned the following headers when being ratelimited:
            #       x-ratelimit-bucket         b05c0d8c2ab83895085006a8eae073a3
            #       x-ratelimit-limit          1
            #       x-ratelimit-remaining      0
            #       x-ratelimit-reset          1596033974.096
            #       x-ratelimit-reset-after    3.000
            # This kind of defeats the point of asynchronously gathering any of these
            # in the first place really. To save clogging up the event loop
            # (albeit at a cost of maybe a couple-dozen milliseconds per call),
            # I am just gonna invoke these sequentially instead.
            try:
                if len(pending) == 1:
                    message = pending.popleft()
                    await self.delete_message(channel, message)
                    deleted.append(message)
                else:
                    body = data_binding.JSONObjectBuilder()
                    chunk = [pending.popleft() for _ in range(min(100, len(pending)))]
                    body.put_snowflake_array(&#34;messages&#34;, chunk)
                    await self._request(route, json=body)
                    deleted += chunk
            except Exception as ex:
                raise errors.BulkDeleteError(deleted, pending) from ex

    @staticmethod
    def _transform_emoji_to_url_format(
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]],
        /,
    ) -&gt; str:
        if isinstance(emoji, emojis.Emoji):
            if emoji_id is not undefined.UNDEFINED:
                raise ValueError(&#34;emoji_id shouldn&#39;t be passed when an Emoji object is passed for emoji&#34;)

            return emoji.url_name

        if emoji_id is not undefined.UNDEFINED:
            return f&#34;{emoji}:{snowflakes.Snowflake(emoji_id)}&#34;

        return emoji

    async def add_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PUT_MY_REACTION.compile(
            emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_my_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_MY_REACTION.compile(
            emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_all_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_REACTION_EMOJI.compile(
            emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
            channel=channel,
            message=message,
        )
        await self._request(route)

    async def delete_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_REACTION_USER.compile(
            emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
            channel=channel,
            message=message,
            user=user,
        )
        await self._request(route)

    async def delete_all_reactions(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        route = routes.DELETE_ALL_REACTIONS.compile(channel=channel, message=message)
        await self._request(route)

    def fetch_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: typing.Union[str, emojis.Emoji],
        emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[users.User]:
        return special_endpoints_impl.ReactorIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            channel=channel,
            message=message,
            emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
        )

    async def create_webhook(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.WebhookChannelT],
        name: str,
        *,
        avatar: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.IncomingWebhook:
        route = routes.POST_CHANNEL_WEBHOOKS.compile(channel=channel)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)

        if avatar is not undefined.UNDEFINED:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_incoming_webhook(response)

    async def fetch_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.PartialWebhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.PartialWebhook:
        if token is undefined.UNDEFINED:
            route = routes.GET_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.GET_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        response = await self._request(route, no_auth=no_auth)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_webhook(response)

    async def fetch_channel_webhooks(
        self,
        channel: snowflakes.SnowflakeishOr[channels_.WebhookChannelT],
    ) -&gt; typing.Sequence[webhooks.PartialWebhook]:
        route = routes.GET_CHANNEL_WEBHOOKS.compile(channel=channel)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_webhook(webhook_pl) for webhook_pl in response]

    async def fetch_guild_webhooks(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[webhooks.PartialWebhook]:
        route = routes.GET_GUILD_WEBHOOKS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_webhook(webhook_payload) for webhook_payload in response]

    async def edit_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.PartialWebhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.WebhookChannelT]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.PartialWebhook:
        if token is undefined.UNDEFINED:
            route = routes.PATCH_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.PATCH_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put_snowflake(&#34;channel&#34;, channel)

        if avatar is None:
            body.put(&#34;avatar&#34;, None)
        elif avatar is not undefined.UNDEFINED:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        response = await self._request(route, json=body, reason=reason, no_auth=no_auth)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_webhook(response)

    async def delete_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.PartialWebhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        if token is undefined.UNDEFINED:
            route = routes.DELETE_WEBHOOK.compile(webhook=webhook)
            no_auth = False
        else:
            route = routes.DELETE_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
            no_auth = True

        await self._request(route, no_auth=no_auth)

    async def execute_webhook(
        self,
        webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
        token: str,
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
        flags: typing.Union[undefined.UndefinedType, int, messages_.MessageFlag] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
        webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
        route = routes.POST_WEBHOOK_WITH_TOKEN.compile(webhook=webhook_id, token=token)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;username&#34;, username)
        body.put(&#34;avatar_url&#34;, avatar_url)
        body.put(&#34;flags&#34;, flags)
        query = data_binding.StringMapBuilder()
        query.put(&#34;wait&#34;, True)
        return await self._create_message(
            route,
            body,
            query,
            no_auth=True,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            tts=tts,
            mentions_everyone=mentions_everyone,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
            mentions_reply=undefined.UNDEFINED,
        )

    async def fetch_webhook_message(
        self,
        webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
        token: str,
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; messages_.Message:
        # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
        webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
        route = routes.GET_WEBHOOK_MESSAGE.compile(webhook=webhook_id, token=token, message=message)
        response = await self._request(route, no_auth=True)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def edit_webhook_message(
        self,
        webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
        token: str,
        message: snowflakes.SnowflakeishOr[messages_.Message],
        content: undefined.UndefinedNoneOr[typing.Any] = undefined.UNDEFINED,
        *,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedNoneOr[
            typing.Sequence[special_endpoints.ComponentBuilder]
        ] = undefined.UNDEFINED,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        replace_attachments: bool = False,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
        webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
        route = routes.PATCH_WEBHOOK_MESSAGE.compile(webhook=webhook_id, token=token, message=message)
        return await self._edit_message(
            route,
            data_binding.JSONObjectBuilder(),
            no_auth=True,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            replace_attachments=replace_attachments,
            mentions_everyone=mentions_everyone,
            mentions_reply=undefined.UNDEFINED,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
        )

    async def delete_webhook_message(
        self,
        webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
        token: str,
        message: snowflakes.SnowflakeishOr[messages_.Message],
    ) -&gt; None:
        # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
        webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
        route = routes.DELETE_WEBHOOK_MESSAGE.compile(webhook=webhook_id, token=token, message=message)
        await self._request(route, no_auth=True)

    async def fetch_gateway_url(self) -&gt; str:
        route = routes.GET_GATEWAY.compile()
        # This doesn&#39;t need authorization.
        response = await self._request(route, no_auth=True)
        assert isinstance(response, dict)
        url = response[&#34;url&#34;]
        assert isinstance(url, str)
        return url

    async def fetch_gateway_bot_info(self) -&gt; sessions.GatewayBotInfo:
        route = routes.GET_GATEWAY_BOT.compile()
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_gateway_bot_info(response)

    async def fetch_invite(self, invite: typing.Union[invites.InviteCode, str]) -&gt; invites.Invite:
        route = routes.GET_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
        query = data_binding.StringMapBuilder()
        query.put(&#34;with_counts&#34;, True)
        query.put(&#34;with_expiration&#34;, True)
        response = await self._request(route, query=query)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_invite(response)

    async def delete_invite(self, invite: typing.Union[invites.InviteCode, str]) -&gt; invites.Invite:
        route = routes.DELETE_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_invite(response)

    async def fetch_my_user(self) -&gt; users.OwnUser:
        route = routes.GET_MY_USER.compile()
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_my_user(response)

    async def edit_my_user(
        self,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    ) -&gt; users.OwnUser:
        route = routes.PATCH_MY_USER.compile()
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;username&#34;, username)

        if avatar is None:
            body.put(&#34;avatar&#34;, None)
        elif avatar is not undefined.UNDEFINED:
            avatar_resource = files.ensure_resource(avatar)
            async with avatar_resource.stream(executor=self._executor) as stream:
                body.put(&#34;avatar&#34;, await stream.data_uri())

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_my_user(response)

    async def fetch_my_connections(self) -&gt; typing.Sequence[applications.OwnConnection]:
        route = routes.GET_MY_CONNECTIONS.compile()
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_own_connection(connection_payload) for connection_payload in response]

    def fetch_my_guilds(
        self,
        *,
        newest_first: bool = False,
        start_at: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[applications.OwnGuild]:
        if start_at is undefined.UNDEFINED:
            start_at = snowflakes.Snowflake.max() if newest_first else snowflakes.Snowflake.min()
        elif isinstance(start_at, datetime.datetime):
            start_at = snowflakes.Snowflake.from_datetime(start_at)
        else:
            start_at = int(start_at)

        return special_endpoints_impl.OwnGuildIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            newest_first=newest_first,
            first_id=str(start_at),
        )

    async def leave_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /) -&gt; None:
        route = routes.DELETE_MY_GUILD.compile(guild=guild)
        await self._request(route)

    async def create_dm_channel(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; channels_.DMChannel:
        route = routes.POST_MY_CHANNELS.compile()
        body = data_binding.JSONObjectBuilder()
        body.put_snowflake(&#34;recipient_id&#34;, user)
        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        channel = self._entity_factory.deserialize_dm(response)

        if self._cache:
            self._cache.set_dm_channel_id(user, channel.id)

        return channel

    async def fetch_application(self) -&gt; applications.Application:
        route = routes.GET_MY_APPLICATION.compile()
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_application(response)

    async def fetch_authorization(self) -&gt; applications.AuthorizationInformation:
        route = routes.GET_MY_AUTHORIZATION.compile()
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_authorization_information(response)

    @staticmethod
    def _gen_oauth2_token(client: snowflakes.SnowflakeishOr[guilds.PartialApplication], client_secret: str) -&gt; str:
        token = base64.b64encode(f&#34;{int(client)}:{client_secret}&#34;.encode()).decode(&#34;utf-8&#34;)
        return f&#34;{applications.TokenType.BASIC} {token}&#34;

    async def authorize_client_credentials_token(
        self,
        client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        client_secret: str,
        scopes: typing.Sequence[typing.Union[applications.OAuth2Scope, str]],
    ) -&gt; applications.PartialOAuth2Token:
        route = routes.POST_TOKEN.compile()
        form = data_binding.URLEncodedForm()
        form.add_field(&#34;grant_type&#34;, &#34;client_credentials&#34;)
        form.add_field(&#34;scope&#34;, &#34; &#34;.join(scopes))

        response = await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_partial_token(response)

    async def authorize_access_token(
        self,
        client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        client_secret: str,
        code: str,
        redirect_uri: str,
    ) -&gt; applications.OAuth2AuthorizationToken:
        route = routes.POST_TOKEN.compile()
        form = data_binding.URLEncodedForm()
        form.add_field(&#34;grant_type&#34;, &#34;authorization_code&#34;)
        form.add_field(&#34;code&#34;, code)
        form.add_field(&#34;redirect_uri&#34;, redirect_uri)

        response = await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_authorization_token(response)

    async def refresh_access_token(
        self,
        client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        client_secret: str,
        refresh_token: str,
        *,
        scopes: undefined.UndefinedOr[
            typing.Sequence[typing.Union[applications.OAuth2Scope, str]]
        ] = undefined.UNDEFINED,
    ) -&gt; applications.OAuth2AuthorizationToken:
        route = routes.POST_TOKEN.compile()
        form = data_binding.URLEncodedForm()
        form.add_field(&#34;grant_type&#34;, &#34;refresh_token&#34;)
        form.add_field(&#34;refresh_token&#34;, refresh_token)

        if scopes is not undefined.UNDEFINED:
            form.add_field(&#34;scope&#34;, &#34; &#34;.join(scopes))

        response = await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_authorization_token(response)

    async def revoke_access_token(
        self,
        client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        client_secret: str,
        token: typing.Union[str, applications.PartialOAuth2Token],
    ) -&gt; None:
        route = routes.POST_TOKEN_REVOKE.compile()
        form = data_binding.URLEncodedForm()
        form.add_field(&#34;token&#34;, str(token))
        await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))

    async def add_user_to_guild(
        self,
        access_token: typing.Union[str, applications.PartialOAuth2Token],
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[guilds.Member]:
        route = routes.PUT_GUILD_MEMBER.compile(guild=guild, user=user)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;access_token&#34;, str(access_token))
        body.put(&#34;nick&#34;, nick)
        body.put(&#34;mute&#34;, mute)
        body.put(&#34;deaf&#34;, deaf)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        if (response := await self._request(route, json=body)) is not None:
            assert isinstance(response, dict)
            return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))
        else:
            # User already is in the guild.
            return None

    async def fetch_voice_regions(self) -&gt; typing.Sequence[voices.VoiceRegion]:
        route = routes.GET_VOICE_REGIONS.compile()
        response = await self._request(route)
        assert isinstance(response, list)
        return [
            self._entity_factory.deserialize_voice_region(voice_region_payload) for voice_region_payload in response
        ]

    async def fetch_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser]) -&gt; users.User:
        route = routes.GET_USER.compile(user=user)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_user(response)

    def fetch_audit_log(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        event_type: undefined.UndefinedOr[typing.Union[audit_logs.AuditLogEventType, int]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[audit_logs.AuditLog]:

        timestamp: undefined.UndefinedOr[str]
        if before is undefined.UNDEFINED:
            timestamp = undefined.UNDEFINED
        elif isinstance(before, datetime.datetime):
            timestamp = str(snowflakes.Snowflake.from_datetime(before))
        else:
            timestamp = str(int(before))

        return special_endpoints_impl.AuditLogIterator(
            entity_factory=self._entity_factory,
            request_call=self._request,
            guild=guild,
            before=timestamp,
            user=user,
            action_type=event_type,
        )

    async def fetch_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.GET_GUILD_EMOJI.compile(guild=guild, emoji=emoji)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def fetch_guild_emojis(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[emojis.KnownCustomEmoji]:
        route = routes.GET_GUILD_EMOJIS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild)
        return [
            self._entity_factory.deserialize_known_custom_emoji(emoji_payload, guild_id=guild_id)
            for emoji_payload in response
        ]

    async def create_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        image: files.Resourceish,
        *,
        roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.POST_GUILD_EMOJIS.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        image_resource = files.ensure_resource(image)
        async with image_resource.stream(executor=self._executor) as stream:
            body.put(&#34;image&#34;, await stream.data_uri())

        body.put_snowflake_array(&#34;roles&#34;, roles)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def edit_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        route = routes.PATCH_GUILD_EMOJI.compile(guild=guild, emoji=emoji)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))

    async def delete_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_EMOJI.compile(guild=guild, emoji=emoji)
        await self._request(route, reason=reason)

    async def fetch_available_sticker_packs(self) -&gt; typing.Sequence[stickers.StickerPack]:
        route = routes.GET_STICKER_PACKS.compile()
        response = await self._request(route, no_auth=True)
        assert isinstance(response, dict)
        return [
            self._entity_factory.deserialize_sticker_pack(sticker_pack_payload)
            for sticker_pack_payload in response[&#34;sticker_packs&#34;]
        ]

    async def fetch_sticker(
        self,
        sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
    ) -&gt; typing.Union[stickers.StandardSticker, stickers.GuildSticker]:
        route = routes.GET_STICKER.compile(sticker=sticker)
        response = await self._request(route)
        assert isinstance(response, dict)
        return (
            self._entity_factory.deserialize_guild_sticker(response)
            if &#34;guild_id&#34; in response
            else self._entity_factory.deserialize_standard_sticker(response)
        )

    async def fetch_guild_stickers(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[stickers.GuildSticker]:
        route = routes.GET_GUILD_STICKERS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [
            self._entity_factory.deserialize_guild_sticker(guild_sticker_payload) for guild_sticker_payload in response
        ]

    async def fetch_guild_sticker(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
    ) -&gt; stickers.GuildSticker:
        route = routes.GET_GUILD_STICKER.compile(guild=guild, sticker=sticker)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_sticker(response)

    async def create_sticker(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        tag: str,
        image: files.Resourceish,
        *,
        description: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; stickers.GuildSticker:
        route = routes.POST_GUILD_STICKERS.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;tags&#34;, tag)
        body.put(&#34;description&#34;, description)

        image_resource = files.ensure_resource(image)
        async with image_resource.stream(executor=self._executor) as stream:
            body.put(&#34;image&#34;, await stream.data_uri())

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_sticker(response)

    async def edit_sticker(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        description: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        tag: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; stickers.GuildSticker:
        route = routes.PATCH_GUILD_STICKER.compile(guild=guild, sticker=sticker)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;tags&#34;, tag)
        body.put(&#34;description&#34;, description)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_sticker(response)

    async def delete_sticker(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_STICKER.compile(guild=guild, sticker=sticker)
        await self._request(route, reason=reason)

    def guild_builder(self, name: str, /) -&gt; special_endpoints.GuildBuilder:
        return special_endpoints_impl.GuildBuilder(
            entity_factory=self._entity_factory, executor=self._executor, request_call=self._request, name=name
        )

    async def fetch_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.RESTGuild:
        route = routes.GET_GUILD.compile(guild=guild)
        query = data_binding.StringMapBuilder()
        query.put(&#34;with_counts&#34;, True)
        response = await self._request(route, query=query)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_rest_guild(response)

    async def fetch_guild_preview(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildPreview:
        route = routes.GET_GUILD_PREVIEW.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_preview(response)

    async def edit_guild(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        verification_level: undefined.UndefinedOr[guilds.GuildVerificationLevel] = undefined.UNDEFINED,
        default_message_notifications: undefined.UndefinedOr[
            guilds.GuildMessageNotificationsLevel
        ] = undefined.UNDEFINED,
        explicit_content_filter_level: undefined.UndefinedOr[
            guilds.GuildExplicitContentFilterLevel
        ] = undefined.UNDEFINED,
        afk_channel: undefined.UndefinedOr[
            snowflakes.SnowflakeishOr[channels_.GuildVoiceChannel]
        ] = undefined.UNDEFINED,
        afk_timeout: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        icon: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        owner: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        splash: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        banner: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        system_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels_.GuildTextChannel]
        ] = undefined.UNDEFINED,
        rules_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels_.GuildTextChannel]
        ] = undefined.UNDEFINED,
        public_updates_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels_.GuildTextChannel]
        ] = undefined.UNDEFINED,
        preferred_locale: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.RESTGuild:
        route = routes.PATCH_GUILD.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;verification_level&#34;, verification_level)
        body.put(&#34;default_message_notifications&#34;, default_message_notifications)
        body.put(&#34;explicit_content_filter&#34;, explicit_content_filter_level)
        body.put(&#34;afk_timeout&#34;, afk_timeout, conversion=time.timespan_to_int)
        body.put(&#34;preferred_locale&#34;, preferred_locale, conversion=str)
        body.put_snowflake(&#34;afk_channel_id&#34;, afk_channel)
        body.put_snowflake(&#34;owner_id&#34;, owner)
        body.put_snowflake(&#34;system_channel_id&#34;, system_channel)
        body.put_snowflake(&#34;rules_channel_id&#34;, rules_channel)
        body.put_snowflake(&#34;public_updates_channel_id&#34;, public_updates_channel)

        tasks: typing.List[asyncio.Task[str]] = []

        if icon is None:
            body.put(&#34;icon&#34;, None)
        elif icon is not undefined.UNDEFINED:
            icon_resource = files.ensure_resource(icon)
            async with icon_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;icon&#34;, future.result()))
                tasks.append(task)

        if splash is None:
            body.put(&#34;splash&#34;, None)
        elif splash is not undefined.UNDEFINED:
            splash_resource = files.ensure_resource(splash)
            async with splash_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;splash&#34;, future.result()))
                tasks.append(task)

        if banner is None:
            body.put(&#34;banner&#34;, None)
        elif banner is not undefined.UNDEFINED:
            banner_resource = files.ensure_resource(banner)
            async with banner_resource.stream(executor=self._executor) as stream:
                task = asyncio.create_task(stream.data_uri())
                task.add_done_callback(lambda future: body.put(&#34;banner&#34;, future.result()))
                tasks.append(task)

        await asyncio.gather(*tasks)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_rest_guild(response)

    async def delete_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; None:
        route = routes.DELETE_GUILD.compile(guild=guild)
        await self._request(route)

    async def fetch_guild_channels(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[channels_.GuildChannel]:
        route = routes.GET_GUILD_CHANNELS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        channel_sequence = [self._entity_factory.deserialize_channel(channel_payload) for channel_payload in response]
        # Will always be guild channels unless Discord messes up severely on something!
        return typing.cast(&#34;typing.Sequence[channels_.GuildChannel]&#34;, channel_sequence)

    async def create_guild_text_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildTextChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels_.ChannelType.GUILD_TEXT,
            position=position,
            topic=topic,
            nsfw=nsfw,
            rate_limit_per_user=rate_limit_per_user,
            permission_overwrites=permission_overwrites,
            category=category,
            reason=reason,
        )
        assert isinstance(channel, channels_.GuildTextChannel)
        return channel

    async def create_guild_news_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildNewsChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels_.ChannelType.GUILD_NEWS,
            position=position,
            topic=topic,
            nsfw=nsfw,
            rate_limit_per_user=rate_limit_per_user,
            permission_overwrites=permission_overwrites,
            category=category,
            reason=reason,
        )
        assert isinstance(channel, channels_.GuildNewsChannel)
        return channel

    async def create_guild_voice_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        video_quality_mode: undefined.UndefinedOr[typing.Union[channels_.VideoQualityMode, int]] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        region: undefined.UndefinedOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildVoiceChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels_.ChannelType.GUILD_VOICE,
            position=position,
            user_limit=user_limit,
            bitrate=bitrate,
            video_quality_mode=video_quality_mode,
            permission_overwrites=permission_overwrites,
            region=region,
            category=category,
            reason=reason,
        )
        assert isinstance(channel, channels_.GuildVoiceChannel)
        return channel

    async def create_guild_stage_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        region: undefined.UndefinedOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildStageChannel:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels_.ChannelType.GUILD_STAGE,
            position=position,
            user_limit=user_limit,
            bitrate=bitrate,
            permission_overwrites=permission_overwrites,
            region=region,
            category=category,
            reason=reason,
        )
        assert isinstance(channel, channels_.GuildStageChannel)
        return channel

    async def create_guild_category(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildCategory:
        channel = await self._create_guild_channel(
            guild,
            name,
            channels_.ChannelType.GUILD_CATEGORY,
            position=position,
            permission_overwrites=permission_overwrites,
            reason=reason,
        )
        assert isinstance(channel, channels_.GuildCategory)
        return channel

    async def _create_guild_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        type_: channels_.ChannelType,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        video_quality_mode: undefined.UndefinedOr[typing.Union[channels_.VideoQualityMode, int]] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels_.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        region: undefined.UndefinedOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels_.GuildChannel:
        route = routes.POST_GUILD_CHANNELS.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;type&#34;, type_)
        body.put(&#34;name&#34;, name)
        body.put(&#34;position&#34;, position)
        body.put(&#34;topic&#34;, topic)
        body.put(&#34;nsfw&#34;, nsfw)
        body.put(&#34;bitrate&#34;, bitrate)
        body.put(&#34;video_quality_mode&#34;, video_quality_mode)
        body.put(&#34;user_limit&#34;, user_limit)
        body.put(&#34;rate_limit_per_user&#34;, rate_limit_per_user, conversion=time.timespan_to_int)
        body.put(&#34;rtc_region&#34;, region, conversion=str)
        body.put_snowflake(&#34;parent_id&#34;, category)
        body.put_array(
            &#34;permission_overwrites&#34;,
            permission_overwrites,
            conversion=self._entity_factory.serialize_permission_overwrite,
        )

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        channel = self._entity_factory.deserialize_channel(response)
        assert isinstance(channel, channels_.GuildChannel)
        return channel

    async def reposition_channels(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[channels_.GuildChannel]],
    ) -&gt; None:
        route = routes.POST_GUILD_CHANNELS.compile(guild=guild)
        body = [{&#34;id&#34;: str(int(channel)), &#34;position&#34;: pos} for pos, channel in positions.items()]
        await self._request(route, json=body)

    async def fetch_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.Member:
        route = routes.GET_GUILD_MEMBER.compile(guild=guild, user=user)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))

    def fetch_members(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; iterators.LazyIterator[guilds.Member]:
        return special_endpoints_impl.MemberIterator(
            entity_factory=self._entity_factory, request_call=self._request, guild=guild
        )

    async def search_members(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
    ) -&gt; typing.Sequence[guilds.Member]:
        route = routes.GET_GUILD_MEMBERS_SEARCH.compile(guild=guild)
        query = data_binding.StringMapBuilder()
        query.put(&#34;query&#34;, name)
        query.put(&#34;limit&#34;, 1000)
        response = await self._request(route, query=query)
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild)
        return [
            self._entity_factory.deserialize_member(member_payload, guild_id=guild_id) for member_payload in response
        ]

    async def edit_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        voice_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels_.GuildVoiceChannel]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Member:
        route = routes.PATCH_GUILD_MEMBER.compile(guild=guild, user=user)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;nick&#34;, nick)
        body.put(&#34;mute&#34;, mute)
        body.put(&#34;deaf&#34;, deaf)
        body.put_snowflake_array(&#34;roles&#34;, roles)

        if voice_channel is None:
            body.put(&#34;channel_id&#34;, None)
        elif voice_channel is not undefined.UNDEFINED:
            body.put_snowflake(&#34;channel_id&#34;, voice_channel)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))

    async def edit_my_nick(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.Guild],
        nick: typing.Optional[str],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PATCH_MY_GUILD_NICKNAME.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;nick&#34;, nick)
        await self._request(route, json=body, reason=reason)

    async def add_role_to_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.PUT_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
        await self._request(route, reason=reason)

    async def remove_role_from_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
        await self._request(route, reason=reason)

    async def kick_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_MEMBER.compile(guild=guild, user=user)
        await self._request(route, reason=reason)

    kick_member = kick_user

    async def ban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        delete_message_days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;delete_message_days&#34;, delete_message_days)
        route = routes.PUT_GUILD_BAN.compile(guild=guild, user=user)
        await self._request(route, json=body, reason=reason)

    ban_member = ban_user

    async def unban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        route = routes.DELETE_GUILD_BAN.compile(guild=guild, user=user)
        await self._request(route, reason=reason)

    unban_member = unban_user

    async def fetch_ban(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.GuildBan:
        route = routes.GET_GUILD_BAN.compile(guild=guild, user=user)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_member_ban(response)

    async def fetch_bans(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[guilds.GuildBan]:
        route = routes.GET_GUILD_BANS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_guild_member_ban(ban_payload) for ban_payload in response]

    async def fetch_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Role]:
        route = routes.GET_GUILD_ROLES.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild)
        return [self._entity_factory.deserialize_role(role_payload, guild_id=guild_id) for role_payload in response]

    async def create_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = permissions_.Permissions.NONE,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        if not undefined.any_undefined(color, colour):
            raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

        route = routes.POST_GUILD_ROLES.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;permissions&#34;, permissions)
        body.put(&#34;color&#34;, color, conversion=colors.Color.of)
        body.put(&#34;color&#34;, colour, conversion=colors.Color.of)
        body.put(&#34;hoist&#34;, hoist)
        body.put(&#34;mentionable&#34;, mentionable)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))

    async def reposition_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[guilds.PartialRole]],
    ) -&gt; None:
        route = routes.POST_GUILD_ROLES.compile(guild=guild)
        body = [{&#34;id&#34;: str(int(role)), &#34;position&#34;: pos} for pos, role in positions.items()]
        await self._request(route, json=body)

    async def edit_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        if not undefined.any_undefined(color, colour):
            raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

        route = routes.PATCH_GUILD_ROLE.compile(guild=guild, role=role)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;permissions&#34;, permissions)
        body.put(&#34;color&#34;, color, conversion=colors.Color.of)
        body.put(&#34;color&#34;, colour, conversion=colors.Color.of)
        body.put(&#34;hoist&#34;, hoist)
        body.put(&#34;mentionable&#34;, mentionable)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))

    async def delete_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    ) -&gt; None:
        route = routes.DELETE_GUILD_ROLE.compile(guild=guild, role=role)
        await self._request(route)

    async def estimate_guild_prune_count(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
    ) -&gt; int:
        route = routes.GET_GUILD_PRUNE.compile(guild=guild)
        query = data_binding.StringMapBuilder()
        query.put(&#34;days&#34;, days)
        if include_roles is not undefined.UNDEFINED:
            roles = &#34;,&#34;.join(str(int(role)) for role in include_roles)
            query.put(&#34;include_roles&#34;, roles)
        response = await self._request(route, query=query)
        assert isinstance(response, dict)
        return int(response[&#34;pruned&#34;])

    async def begin_guild_prune(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        compute_prune_count: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[int]:
        route = routes.POST_GUILD_PRUNE.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;days&#34;, days)
        body.put(&#34;compute_prune_count&#34;, compute_prune_count)
        body.put_snowflake_array(&#34;include_roles&#34;, include_roles)
        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        pruned = response.get(&#34;pruned&#34;)
        return int(pruned) if pruned is not None else None

    async def fetch_guild_voice_regions(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[voices.VoiceRegion]:
        route = routes.GET_GUILD_VOICE_REGIONS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [
            self._entity_factory.deserialize_voice_region(voice_region_payload) for voice_region_payload in response
        ]

    async def fetch_guild_invites(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        route = routes.GET_GUILD_INVITES.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_invite_with_metadata(invite_payload) for invite_payload in response]

    async def fetch_integrations(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Integration]:
        route = routes.GET_GUILD_INTEGRATIONS.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild)
        return [
            self._entity_factory.deserialize_integration(integration_payload, guild_id=guild_id)
            for integration_payload in response
        ]

    async def fetch_widget(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildWidget:
        route = routes.GET_GUILD_WIDGET.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_widget(response)

    async def edit_widget(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        channel: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[channels_.GuildChannel]] = undefined.UNDEFINED,
        enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.GuildWidget:
        route = routes.PATCH_GUILD_WIDGET.compile(guild=guild)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;enabled&#34;, enabled)
        if channel is None:
            body.put(&#34;channel&#34;, None)
        elif channel is not undefined.UNDEFINED:
            body.put_snowflake(&#34;channel&#34;, channel)

        response = await self._request(route, json=body, reason=reason)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_widget(response)

    async def fetch_welcome_screen(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.WelcomeScreen:
        route = routes.GET_GUILD_WELCOME_SCREEN.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_welcome_screen(response)

    async def edit_welcome_screen(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        description: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
        enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        channels: undefined.UndefinedNoneOr[typing.Sequence[guilds.WelcomeChannel]] = undefined.UNDEFINED,
    ) -&gt; guilds.WelcomeScreen:
        route = routes.PATCH_GUILD_WELCOME_SCREEN.compile(guild=guild)

        body = data_binding.JSONObjectBuilder()

        body.put(&#34;description&#34;, description)
        body.put(&#34;enabled&#34;, enabled)

        if channels is not None:
            body.put_array(&#34;welcome_channels&#34;, channels, conversion=self._entity_factory.serialize_welcome_channel)

        else:
            body.put(&#34;welcome_channels&#34;, None)

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_welcome_screen(response)

    async def fetch_vanity_url(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; invites.VanityURL:
        route = routes.GET_GUILD_VANITY_URL.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_vanity_url(response)

    async def fetch_template(self, template: typing.Union[templates.Template, str]) -&gt; templates.Template:
        template = template if isinstance(template, str) else template.code
        route = routes.GET_TEMPLATE.compile(template=template)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_template(response)

    async def fetch_guild_templates(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[templates.Template]:
        route = routes.GET_GUILD_TEMPLATES.compile(guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_template(template_payload) for template_payload in response]

    async def sync_guild_template(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        template: typing.Union[templates.Template, str],
    ) -&gt; templates.Template:
        template = template if isinstance(template, str) else template.code
        route = routes.PUT_GUILD_TEMPLATE.compile(guild=guild, template=template)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_template(response)

    async def create_guild_from_template(
        self,
        template: typing.Union[str, templates.Template],
        name: str,
        *,
        icon: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    ) -&gt; guilds.RESTGuild:
        template = template if isinstance(template, str) else template.code
        route = routes.POST_TEMPLATE.compile(template=template)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)

        if icon is not undefined.UNDEFINED:
            icon_resource = files.ensure_resource(icon)
            async with icon_resource.stream(executor=self._executor) as stream:
                body.put(&#34;icon&#34;, await stream.data_uri())

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_rest_guild(response)

    async def create_template(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        description: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
    ) -&gt; templates.Template:
        route = routes.POST_GUILD_TEMPLATES.compile(guild=guild)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;description&#34;, description)
        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_template(response)

    async def edit_template(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        template: typing.Union[str, templates.Template],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        description: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
    ) -&gt; templates.Template:
        template = template if isinstance(template, str) else template.code
        route = routes.PATCH_GUILD_TEMPLATE.compile(guild=guild, template=template)
        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;description&#34;, description)

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_template(response)

    async def delete_template(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        template: typing.Union[str, templates.Template],
    ) -&gt; templates.Template:
        template = template if isinstance(template, str) else template.code
        route = routes.DELETE_GUILD_TEMPLATE.compile(guild=guild, template=template)
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_template(response)

    def command_builder(self, name: str, description: str, /) -&gt; special_endpoints.CommandBuilder:
        return special_endpoints_impl.CommandBuilder(name=name, description=description)

    async def fetch_application_command(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        command: snowflakes.SnowflakeishOr[commands.Command],
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; commands.Command:
        if guild is undefined.UNDEFINED:
            route = routes.GET_APPLICATION_COMMAND.compile(application=application, command=command)

        else:
            route = routes.GET_APPLICATION_GUILD_COMMAND.compile(application=application, guild=guild, command=command)

        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_command(
            response, guild_id=snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
        )

    async def fetch_application_commands(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; typing.Sequence[commands.Command]:
        if guild is undefined.UNDEFINED:
            route = routes.GET_APPLICATION_COMMANDS.compile(application=application)

        else:
            route = routes.GET_APPLICATION_GUILD_COMMANDS.compile(application=application, guild=guild)

        response = await self._request(route)
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
        return [self._entity_factory.deserialize_command(command, guild_id=guild_id) for command in response]

    async def create_application_command(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        name: str,
        description: str,
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
        *,
        options: undefined.UndefinedOr[typing.Sequence[commands.CommandOption]] = undefined.UNDEFINED,
        default_permission: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; commands.Command:
        if guild is undefined.UNDEFINED:
            route = routes.POST_APPLICATION_COMMAND.compile(application=application)

        else:
            route = routes.POST_APPLICATION_GUILD_COMMAND.compile(application=application, guild=guild)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;description&#34;, description)
        body.put_array(&#34;options&#34;, options, conversion=self._entity_factory.serialize_command_option)
        body.put(&#34;default_permission&#34;, default_permission)

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_command(
            response, guild_id=snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
        )

    async def set_application_commands(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        commands: typing.Sequence[special_endpoints.CommandBuilder],
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; typing.Sequence[commands.Command]:
        if guild is undefined.UNDEFINED:
            route = routes.PUT_APPLICATION_COMMANDS.compile(application=application)

        else:
            route = routes.PUT_APPLICATION_GUILD_COMMANDS.compile(application=application, guild=guild)

        response = await self._request(route, json=[command.build(self._entity_factory) for command in commands])
        assert isinstance(response, list)
        guild_id = snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
        return [self._entity_factory.deserialize_command(payload, guild_id=guild_id) for payload in response]

    async def edit_application_command(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        command: snowflakes.SnowflakeishOr[commands.Command],
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        description: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        options: undefined.UndefinedOr[typing.Sequence[commands.CommandOption]] = undefined.UNDEFINED,
    ) -&gt; commands.Command:
        if guild is undefined.UNDEFINED:
            route = routes.PATCH_APPLICATION_COMMAND.compile(application=application, command=command)

        else:
            route = routes.PATCH_APPLICATION_GUILD_COMMAND.compile(
                application=application, command=command, guild=guild
            )

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;name&#34;, name)
        body.put(&#34;description&#34;, description)
        body.put_array(&#34;options&#34;, options, conversion=self._entity_factory.serialize_command_option)

        response = await self._request(route, json=body)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_command(
            response, guild_id=snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
        )

    async def delete_application_command(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        command: snowflakes.SnowflakeishOr[commands.Command],
        guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; None:
        if guild is undefined.UNDEFINED:
            route = routes.DELETE_APPLICATION_COMMAND.compile(application=application, command=command)

        else:
            route = routes.DELETE_APPLICATION_GUILD_COMMAND.compile(
                application=application, command=command, guild=guild
            )

        await self._request(route)

    async def fetch_application_guild_commands_permissions(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[commands.GuildCommandPermissions]:
        route = routes.GET_APPLICATION_GUILD_COMMANDS_PERMISSIONS.compile(application=application, guild=guild)
        response = await self._request(route)
        assert isinstance(response, list)
        return [self._entity_factory.deserialize_guild_command_permissions(payload) for payload in response]

    async def fetch_application_command_permissions(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        command: snowflakes.SnowflakeishOr[commands.Command],
    ) -&gt; commands.GuildCommandPermissions:
        route = routes.GET_APPLICATION_COMMAND_PERMISSIONS.compile(
            application=application, guild=guild, command=command
        )
        response = await self._request(route)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_command_permissions(response)

    async def set_application_guild_commands_permissions(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        permissions: typing.Mapping[
            snowflakes.SnowflakeishOr[commands.Command], typing.Sequence[commands.CommandPermission]
        ],
    ) -&gt; typing.Sequence[commands.GuildCommandPermissions]:
        route = routes.PUT_APPLICATION_GUILD_COMMANDS_PERMISSIONS.compile(application=application, guild=guild)
        body = [
            {
                &#34;id&#34;: str(snowflakes.Snowflake(command)),
                &#34;permissions&#34;: [self._entity_factory.serialize_command_permission(permission) for permission in perms],
            }
            for command, perms in permissions.items()
        ]
        response = await self._request(route, json=body)

        assert isinstance(response, list)
        return [self._entity_factory.deserialize_guild_command_permissions(payload) for payload in response]

    async def set_application_command_permissions(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        command: snowflakes.SnowflakeishOr[commands.Command],
        permissions: typing.Sequence[commands.CommandPermission],
    ) -&gt; commands.GuildCommandPermissions:
        route = routes.PUT_APPLICATION_COMMAND_PERMISSIONS.compile(
            application=application, guild=guild, command=command
        )
        body = data_binding.JSONObjectBuilder()
        body.put_array(&#34;permissions&#34;, permissions, conversion=self._entity_factory.serialize_command_permission)
        response = await self._request(route, json=body)

        assert isinstance(response, dict)
        return self._entity_factory.deserialize_guild_command_permissions(response)

    def interaction_deferred_builder(
        self, type_: typing.Union[base_interactions.ResponseType, int], /
    ) -&gt; special_endpoints.InteractionDeferredBuilder:
        return special_endpoints_impl.InteractionDeferredBuilder(type=type_)

    def interaction_message_builder(
        self, type_: typing.Union[base_interactions.ResponseType, int], /
    ) -&gt; special_endpoints.InteractionMessageBuilder:
        return special_endpoints_impl.InteractionMessageBuilder(type=type_)

    async def fetch_interaction_response(
        self, application: snowflakes.SnowflakeishOr[guilds.PartialApplication], token: str
    ) -&gt; messages_.Message:
        route = routes.GET_INTERACTION_RESPONSE.compile(webhook=application, token=token)
        response = await self._request(route, no_auth=True)
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_message(response)

    async def create_interaction_response(
        self,
        interaction: snowflakes.SnowflakeishOr[base_interactions.PartialInteraction],
        token: str,
        response_type: typing.Union[int, base_interactions.ResponseType],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        flags: typing.Union[int, messages_.MessageFlag, undefined.UndefinedType] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; None:
        if not undefined.any_undefined(component, components):
            raise ValueError(&#34;You may only specify one of &#39;component&#39; or &#39;components&#39;, not both&#34;)

        if not undefined.any_undefined(embed, embeds):
            raise ValueError(&#34;You may only specify one of &#39;embed&#39; or &#39;embeds&#39;, not both&#34;)

        if components is not undefined.UNDEFINED and not isinstance(components, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;components&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;component&#39; (singular) instead?&#34;
            )

        if embeds not in _NONE_OR_UNDEFINED and not isinstance(embeds, typing.Collection):
            raise TypeError(
                &#34;You passed a non-collection to &#39;embeds&#39;, but this expects a collection. Maybe you meant to &#34;
                &#34;use &#39;embed&#39; (singular) instead?&#34;
            )

        if undefined.all_undefined(embed, embeds) and isinstance(content, embeds_.Embed):
            # Syntactic sugar, common mistake to accidentally send an embed
            # as the content, so lets detect this and fix it for the user.
            embed = content
            content = undefined.UNDEFINED

        route = routes.POST_INTERACTION_RESPONSE.compile(interaction=interaction, token=token)

        body = data_binding.JSONObjectBuilder()
        body.put(&#34;type&#34;, response_type)

        data = data_binding.JSONObjectBuilder()
        data.put(&#34;content&#34;, content)
        data.put(&#34;flags&#34;, flags)
        data.put(&#34;tts&#34;, tts)
        data.put(
            &#34;allowed_mentions&#34;,
            mentions.generate_allowed_mentions(mentions_everyone, undefined.UNDEFINED, user_mentions, role_mentions),
        )

        if component is not undefined.UNDEFINED:
            data.put(&#34;components&#34;, [component.build()])

        elif components is not undefined.UNDEFINED:
            data.put(&#34;components&#34;, [component.build() for component in components])

        if embed is not undefined.UNDEFINED:
            embed_payload, attachments = self._entity_factory.serialize_embed(embed)
            if attachments:
                raise ValueError(&#34;Cannot send an embed with attachments in a slash command&#39;s initial response&#34;)

            data.put(&#34;embeds&#34;, [embed_payload])

        elif embeds is not undefined.UNDEFINED:
            embed_payloads: data_binding.JSONArray = []
            for embed in embeds:
                serialized_embed, attachments = self._entity_factory.serialize_embed(embed)
                embed_payloads.append(serialized_embed)
                if attachments:
                    raise ValueError(&#34;Cannot send an embed with attachments in a slash command&#39;s initial response&#34;)

            data.put(&#34;embeds&#34;, embed_payloads)

        body.put(&#34;data&#34;, data)
        await self._request(route, json=body, no_auth=True)

    async def edit_interaction_response(
        self,
        application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
        token: str,
        content: undefined.UndefinedNoneOr[typing.Any] = undefined.UNDEFINED,
        *,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedNoneOr[
            typing.Sequence[special_endpoints.ComponentBuilder]
        ] = undefined.UNDEFINED,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        replace_attachments: bool = False,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        route = routes.PATCH_INTERACTION_RESPONSE.compile(webhook=application, token=token)
        return await self._edit_message(
            route,
            data_binding.JSONObjectBuilder(),
            no_auth=True,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            replace_attachments=replace_attachments,
            mentions_everyone=mentions_everyone,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
            mentions_reply=undefined.UNDEFINED,
        )

    async def delete_interaction_response(
        self, application: snowflakes.SnowflakeishOr[guilds.PartialApplication], token: str
    ) -&gt; None:
        route = routes.DELETE_INTERACTION_RESPONSE.compile(webhook=application, token=token)
        await self._request(route, no_auth=True)

    def build_action_row(self) -&gt; special_endpoints.ActionRowBuilder:
        return special_endpoints_impl.ActionRowBuilder()</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClientImpl -- Implementation of the V8-compatible Discord HTTP API …" href="#hikari.impl.rest.RESTClientImpl"
>RESTClientImpl</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></dt>
<dd class="nested"><p>Interface for functionality that a REST API implementation provides.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A structural supertype (similar to an ABC, but with implicit inheritance)'>trait</abbr></em></small> <a title="NetworkSettingsAware -- Structural supertype for any component aware of network settings." href="../traits.html#hikari.traits.NetworkSettingsAware"
>NetworkSettingsAware</a></dt>
<dd class="nested"><p>Structural supertype for any component aware of network settings.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A structural supertype (similar to an ABC, but with implicit inheritance)'>trait</abbr></em></small> <a title="FastProtocolChecking -- An extension to make protocols with faster instance checks …" href="../internal/fast_protocol.html#hikari.internal.fast_protocol.FastProtocolChecking"
>FastProtocolChecking</a></dt>
<dd class="nested"><p>An extension to make protocols with faster instance checks …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Protocol -- Base class for protocol classes …" href="https://docs.python.org/3/library/typing.html#typing.Protocol"
>Protocol</a></dt>
<dd class="nested"><p>Base class for protocol classes …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.impl.rest.RESTClientImpl.http_settings" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- Return the HTTP settings in use by this component …" href="#hikari.impl.rest.RESTClientImpl.http_settings"  >http_settings</a> : <a href='../config.html#hikari.config.HTTPSettings'>HTTPSettings</a></code></pre>
</dt>
<dd><p>Return the HTTP settings in use by this component.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../config.html#hikari.config.HTTPSettings'>HTTPSettings</a></code></dt>
<dd>The HTTP settings in use.</dd>
</dl></dd>
</div>
<div id="hikari.impl.rest.RESTClientImpl.is_alive" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_alive -- Whether this component is alive." href="#hikari.impl.rest.RESTClientImpl.is_alive"  >is_alive</a> : <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></pre>
</dt>
<dd><p>Whether this component is alive.</p></dd>
</div>
<div id="hikari.impl.rest.RESTClientImpl.proxy_settings" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="proxy_settings -- Return the proxy settings in use by this component …" href="#hikari.impl.rest.RESTClientImpl.proxy_settings"  >proxy_settings</a> : <a href='../config.html#hikari.config.ProxySettings'>ProxySettings</a></code></pre>
</dt>
<dd><p>Return the proxy settings in use by this component.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../config.html#hikari.config.ProxySettings'>ProxySettings</a></code></dt>
<dd>The proxy settings in use.</dd>
</dl></dd>
</div>
<div id="hikari.impl.rest.RESTClientImpl.token_type" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="token_type -- Type of token this client is using for most requests …" href="#hikari.impl.rest.RESTClientImpl.token_type"  >token_type</a> : Union[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../applications.html#hikari.applications.TokenType'>TokenType</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>]</code></pre>
</dt>
<dd><p>Type of token this client is using for most requests.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../applications.html#hikari.applications.TokenType'>TokenType</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>]</code></dt>
<dd>
<p>The type of token this client is using for most requests.</p>
<p>If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then this client will likely only work
for some endpoints such as public and webhook ones.</p>
</dd>
</dl></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.impl.rest.RESTClientImpl.add_reaction" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="add_reaction" href="#hikari.impl.rest.RESTClientImpl.add_reaction" id="hikari.impl.rest.RESTClientImpl.add_reaction">add_reaction</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    emoji: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.Emoji'>emojis.Emoji</a>],
    emoji_id: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="add_reaction -- Add a reaction emoji to a message in a given channel …" href="../api/rest.html#hikari.api.rest.RESTClient.add_reaction"
>add_reaction</a></code>
</p>
<p>Add a reaction emoji to a message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel where the message to add the reaction to is. This
may be a <code><a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a></code> or the ID of an existing
channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to add a reaction to. This may be the
object or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a>]</code></dt>
<dd>Object or name of the emoji to react with.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>emoji_id</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]]</code></dt>
<dd>ID of the custom emoji to react with.
This should only be provided when a custom emoji's name is passed
for <code>emoji</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>ADD_REACTIONS</code> (this is only necessary if you
are the first person to add the reaction).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1634-L1646" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def add_reaction(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    emoji: typing.Union[str, emojis.Emoji],
    emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.PUT_MY_REACTION.compile(
        emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
        channel=channel,
        message=message,
    )
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.add_role_to_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="add_role_to_member" href="#hikari.impl.rest.RESTClientImpl.add_role_to_member" id="hikari.impl.rest.RESTClientImpl.add_role_to_member">add_role_to_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="add_role_to_member -- Add a role to a member …" href="../api/rest.html#hikari.api.rest.RESTClient.add_role_to_member"
>add_role_to_member</a></code>
</p>
<p>Add a role to a member.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild where the member is in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to add the role to. This may be the
object or the ID of an existing user.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]</code></dt>
<dd>The role to add. This may be the object or the
ID of an existing role.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild, user or role are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2743-L2752" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def add_role_to_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.PUT_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.add_user_to_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="add_user_to_guild" href="#hikari.impl.rest.RESTClientImpl.add_user_to_guild" id="hikari.impl.rest.RESTClientImpl.add_user_to_guild">add_user_to_guild</a>(
    access_token: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../applications.html#hikari.applications.PartialOAuth2Token'>applications.PartialOAuth2Token</a>],
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    nick: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]] = UNDEFINED,
    mute: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    deaf: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
) -> Optional[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="add_user_to_guild -- Add a user to a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.add_user_to_guild"
>add_user_to_guild</a></code>
</p>
<p>Add a user to a guild.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This requires the <code>access_token</code> to have the
<code><a href='../applications.html#hikari.applications.OAuth2Scope.GUILDS_JOIN'>GUILDS_JOIN</a></code> scope enabled along
with the authorization of a Bot which has <code>MANAGE_INVITES</code>
permission within the target guild.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>access_token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../applications.html#hikari.applications.PartialOAuth2Token'>PartialOAuth2Token</a>]</code></dt>
<dd>Object or string of the access token to use for this request.</dd>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to add the user to. This may be the object
or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to add to the guild. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>nick</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>
<p>If provided, the nick to add to the user when he joins the guild.</p>
<p>Requires the <code>MANAGE_NICKNAMES</code> permission on the guild.</p>
</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]</code></dt>
<dd>
<p>If provided, the roles to add to the user when he joins the guild.
This may be a collection objects or IDs of existing roles.</p>
<p>Requires the <code>MANAGE_ROLES</code> permission on the guild.</p>
</dd>
<dt><strong><code>mute</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If provided, the mute state to add the user when he joins the guild.</p>
<p>Requires the <code>MUTE_MEMBERS</code> permission on the guild.</p>
</dd>
<dt><strong><code>deaf</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If provided, the deaf state to add the user when he joins the guild.</p>
<p>Requires the <code>DEAFEN_MEMBERS</code> permission on the guild.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd><code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if the user was already part of the guild, else
<code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild you want to add the user to,
if you are missing permissions to do one of the things you specified,
if you are using an access token for another user, if the token is
bound to another bot or if the access token doesn't have the
<code><a href='../applications.html#hikari.applications.OAuth2Scope.GUILDS_JOIN'>GUILDS_JOIN</a></code> scope enabled.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If you own the guild or the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2122-L2146" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def add_user_to_guild(
    self,
    access_token: typing.Union[str, applications.PartialOAuth2Token],
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    nick: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
    mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
) -&gt; typing.Optional[guilds.Member]:
    route = routes.PUT_GUILD_MEMBER.compile(guild=guild, user=user)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;access_token&#34;, str(access_token))
    body.put(&#34;nick&#34;, nick)
    body.put(&#34;mute&#34;, mute)
    body.put(&#34;deaf&#34;, deaf)
    body.put_snowflake_array(&#34;roles&#34;, roles)

    if (response := await self._request(route, json=body)) is not None:
        assert isinstance(response, dict)
        return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))
    else:
        # User already is in the guild.
        return None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.authorize_access_token" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="authorize_access_token" href="#hikari.impl.rest.RESTClientImpl.authorize_access_token" id="hikari.impl.rest.RESTClientImpl.authorize_access_token">authorize_access_token</a>(
    client: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    client_secret: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    code: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    redirect_uri: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
) -> <a href='../applications.html#hikari.applications.OAuth2AuthorizationToken'>OAuth2AuthorizationToken</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="authorize_access_token -- Authorize an OAuth2 token using the authorize code grant type …" href="../api/rest.html#hikari.api.rest.RESTClient.authorize_access_token"
>authorize_access_token</a></code>
</p>
<p>Authorize an OAuth2 token using the authorize code grant type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to authorize with.</dd>
<dt><strong><code>client_secret</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>Secret of the application to authorize with.</dd>
<dt><strong><code>code</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The authorization code to exchange for an OAuth2 access token.</dd>
<dt><strong><code>redirect_uri</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The redirect uri that was included in the authorization request.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../applications.html#hikari.applications.OAuth2AuthorizationToken'>OAuth2AuthorizationToken</a></code></dt>
<dd>Object of the authorized OAuth2 token.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid redirect uri or code is passed.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>When an client or client secret is passed.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2072-L2087" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def authorize_access_token(
    self,
    client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    client_secret: str,
    code: str,
    redirect_uri: str,
) -&gt; applications.OAuth2AuthorizationToken:
    route = routes.POST_TOKEN.compile()
    form = data_binding.URLEncodedForm()
    form.add_field(&#34;grant_type&#34;, &#34;authorization_code&#34;)
    form.add_field(&#34;code&#34;, code)
    form.add_field(&#34;redirect_uri&#34;, redirect_uri)

    response = await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_authorization_token(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.authorize_client_credentials_token" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="authorize_client_credentials_token" href="#hikari.impl.rest.RESTClientImpl.authorize_client_credentials_token" id="hikari.impl.rest.RESTClientImpl.authorize_client_credentials_token">authorize_client_credentials_token</a>(
    client: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    client_secret: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    scopes: <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../applications.html#hikari.applications.OAuth2Scope'>applications.OAuth2Scope</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]],
) -> <a href='../applications.html#hikari.applications.PartialOAuth2Token'>PartialOAuth2Token</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="authorize_client_credentials_token -- Authorize a client credentials token for an application …" href="../api/rest.html#hikari.api.rest.RESTClient.authorize_client_credentials_token"
>authorize_client_credentials_token</a></code>
</p>
<p>Authorize a client credentials token for an application.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to authorize as.</dd>
<dt><strong><code>client_secret</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>Secret of the application to authorize as.</dd>
<dt><strong><code>scopes</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../applications.html#hikari.applications.OAuth2Scope'>OAuth2Scope</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]]</code></dt>
<dd>The scopes to authorize for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../applications.html#hikari.applications.PartialOAuth2Token'>PartialOAuth2Token</a></code></dt>
<dd>Object of the authorized partial OAuth2 token.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If invalid any invalid or malformed scopes are passed.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>When an client or client secret is passed.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2057-L2070" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def authorize_client_credentials_token(
    self,
    client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    client_secret: str,
    scopes: typing.Sequence[typing.Union[applications.OAuth2Scope, str]],
) -&gt; applications.PartialOAuth2Token:
    route = routes.POST_TOKEN.compile()
    form = data_binding.URLEncodedForm()
    form.add_field(&#34;grant_type&#34;, &#34;client_credentials&#34;)
    form.add_field(&#34;scope&#34;, &#34; &#34;.join(scopes))

    response = await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_partial_token(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.ban_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="ban_member" href="#hikari.impl.rest.RESTClientImpl.ban_user" id="hikari.impl.rest.RESTClientImpl.ban_member">ban_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    delete_message_days: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="ban_member -- Ban a member from a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.ban_user"
>ban_member</a></code>
</p>
<p>Ban a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to ban the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to kick. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>delete_message_days</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the number of days to delete messages for.
This must be between 0 and 7.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2777-L2788" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def ban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    delete_message_days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;delete_message_days&#34;, delete_message_days)
    route = routes.PUT_GUILD_BAN.compile(guild=guild, user=user)
    await self._request(route, json=body, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.ban_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="ban_user" href="#hikari.impl.rest.RESTClientImpl.ban_user" id="hikari.impl.rest.RESTClientImpl.ban_user">ban_user</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    delete_message_days: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="ban_user -- Ban a member from a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.ban_user"
>ban_user</a></code>
</p>
<p>Ban a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to ban the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to kick. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>delete_message_days</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the number of days to delete messages for.
This must be between 0 and 7.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2777-L2788" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def ban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    delete_message_days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;delete_message_days&#34;, delete_message_days)
    route = routes.PUT_GUILD_BAN.compile(guild=guild, user=user)
    await self._request(route, json=body, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.begin_guild_prune" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="begin_guild_prune" href="#hikari.impl.rest.RESTClientImpl.begin_guild_prune" id="hikari.impl.rest.RESTClientImpl.begin_guild_prune">begin_guild_prune</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    days: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    compute_prune_count: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    include_roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> Optional[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="begin_guild_prune -- Begin the guild prune …" href="../api/rest.html#hikari.api.rest.RESTClient.begin_guild_prune"
>begin_guild_prune</a></code>
</p>
<p>Begin the guild prune.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to begin the guild prune in. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>days</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, number of days to count prune for.</dd>
<dt><strong><code>compute_prune_count</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to return the prune count. This is discouraged
for large guilds.</dd>
<dt><strong><code>include_roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]</code></dt>
<dd>If provided, the role(s) to include. By default, this endpoint will
not count users with roles. Providing roles using this attribute
will make members with the specified roles also get included into
the count.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If <code>compute_prune_count</code> is not provided or <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, the
number of members pruned. Else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>KICK_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2924-L2941" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def begin_guild_prune(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    compute_prune_count: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    include_roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; typing.Optional[int]:
    route = routes.POST_GUILD_PRUNE.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;days&#34;, days)
    body.put(&#34;compute_prune_count&#34;, compute_prune_count)
    body.put_snowflake_array(&#34;include_roles&#34;, include_roles)
    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    pruned = response.get(&#34;pruned&#34;)
    return int(pruned) if pruned is not None else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.build_action_row" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="build_action_row" href="#hikari.impl.rest.RESTClientImpl.build_action_row" id="hikari.impl.rest.RESTClientImpl.build_action_row">build_action_row</a>() -> <a href='special_endpoints.html#hikari.impl.special_endpoints.ActionRowBuilder'>special_endpoints.ActionRowBuilder</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="build_action_row -- Build an action row message component for use in message create and REST calls …" href="../api/rest.html#hikari.api.rest.RESTClient.build_action_row"
>build_action_row</a></code>
</p>
<p>Build an action row message component for use in message create and REST calls.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.ActionRowBuilder'>ActionRowBuilder</a></code></dt>
<dd>The initialised action row builder.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3470-L3471" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def build_action_row(self) -&gt; special_endpoints.ActionRowBuilder:
    return special_endpoints_impl.ActionRowBuilder()</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.close" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="close" href="#hikari.impl.rest.RESTClientImpl.close" id="hikari.impl.rest.RESTClientImpl.close">close</a>() -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Close the HTTP client and any open HTTP connections.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L615-L628" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@typing.final
async def close(self) -&gt; None:
    &#34;&#34;&#34;Close the HTTP client and any open HTTP connections.&#34;&#34;&#34;
    live_attributes = self._get_live_attributes()
    self._live_attributes = None
    await live_attributes.close()

    # We have to sleep to allow aiohttp time to close SSL transports...
    # https://github.com/aio-libs/aiohttp/issues/1925
    # https://docs.aiohttp.org/en/stable/client_advanced.html#graceful-shutdown
    #
    # TODO: Remove when we update to aiohttp 4.0.0
    # https://github.com/aio-libs/aiohttp/issues/1925#issuecomment-715977247
    await asyncio.sleep(0.25)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.command_builder" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="command_builder" href="#hikari.impl.rest.RESTClientImpl.command_builder" id="hikari.impl.rest.RESTClientImpl.command_builder">command_builder</a>(
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    description: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    /,
) -> <a href='special_endpoints.html#hikari.impl.special_endpoints.CommandBuilder'>special_endpoints.CommandBuilder</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="command_builder -- Create a command builder for use in `RESTClient.set_application_commands` …" href="../api/rest.html#hikari.api.rest.RESTClient.command_builder"
>command_builder</a></code>
</p>
<p>Create a command builder for use in <code>RESTClient.set_application_commands</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The command's name. This should match the regex <code>^[a-z0-9_-]{1,32}$</code>.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The description to set for the command.
This should be inclusively between 1-100 characters in length.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.CommandBuilder'>CommandBuilder</a></code></dt>
<dd>The created command builder object.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3131-L3132" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def command_builder(self, name: str, description: str, /) -&gt; special_endpoints.CommandBuilder:
    return special_endpoints_impl.CommandBuilder(name=name, description=description)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_application_command" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_application_command" href="#hikari.impl.rest.RESTClientImpl.create_application_command" id="hikari.impl.rest.RESTClientImpl.create_application_command">create_application_command</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    description: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    guild: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>]] = UNDEFINED,
    *,
    options: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.CommandOption'>commands.CommandOption</a>]] = UNDEFINED,
    default_permission: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
) -> <a href='../commands.html#hikari.commands.Command'>commands.Command</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_application_command -- Create an application command …" href="../api/rest.html#hikari.api.rest.RESTClient.create_application_command"
>create_application_command</a></code>
</p>
<p>Create an application command.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to create a command for.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The command's name. This should match the regex <code>^[a-z0-9_-]{1,32}$</code>.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The description to set for the command.
This should be inclusively between 1-100 characters in length.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the specific guild this should be made for.
If left as <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> then this call will create
a global command rather than a guild specific one.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.CommandOption'>CommandOption</a>]]</code></dt>
<dd>A sequence of up to 10 options for this command.</dd>
<dt><strong><code>default_permission</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>Whether this command should be enabled by default (without any
permissions) when added to a guild.</p>
<p>Defaults to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../commands.html#hikari.commands.Command'>Command</a></code></dt>
<dd>Object of the created command.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the provided application's commands.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the provided application isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3168-L3194" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_application_command(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    name: str,
    description: str,
    guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    *,
    options: undefined.UndefinedOr[typing.Sequence[commands.CommandOption]] = undefined.UNDEFINED,
    default_permission: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
) -&gt; commands.Command:
    if guild is undefined.UNDEFINED:
        route = routes.POST_APPLICATION_COMMAND.compile(application=application)

    else:
        route = routes.POST_APPLICATION_GUILD_COMMAND.compile(application=application, guild=guild)

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;description&#34;, description)
    body.put_array(&#34;options&#34;, options, conversion=self._entity_factory.serialize_command_option)
    body.put(&#34;default_permission&#34;, default_permission)

    response = await self._request(route, json=body)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_command(
        response, guild_id=snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_dm_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_dm_channel" href="#hikari.impl.rest.RESTClientImpl.create_dm_channel" id="hikari.impl.rest.RESTClientImpl.create_dm_channel">create_dm_channel</a>(
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='../channels.html#hikari.channels.DMChannel'>DMChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_dm_channel -- Create a DM channel with a user …" href="../api/rest.html#hikari.api.rest.RESTClient.create_dm_channel"
>create_dm_channel</a></code>
</p>
<p>Create a DM channel with a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to create the DM channel with. This may be the
object or the ID of an existing user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.DMChannel'>DMChannel</a></code></dt>
<dd>The created DM channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2027-L2038" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_dm_channel(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; channels_.DMChannel:
    route = routes.POST_MY_CHANNELS.compile()
    body = data_binding.JSONObjectBuilder()
    body.put_snowflake(&#34;recipient_id&#34;, user)
    response = await self._request(route, json=body)
    assert isinstance(response, dict)
    channel = self._entity_factory.deserialize_dm(response)

    if self._cache:
        self._cache.set_dm_channel_id(user, channel.id)

    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_emoji" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_emoji" href="#hikari.impl.rest.RESTClientImpl.create_emoji" id="hikari.impl.rest.RESTClientImpl.create_emoji">create_emoji</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    image: <a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>,
    *,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_emoji -- Create an emoji in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.create_emoji"
>create_emoji</a></code>
</p>
<p>Create an emoji in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the emoji on. This can be a
guild object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The name for the emoji.</dd>
<dt><strong><code>image</code></strong> :&ensp;<code><a href='../files.html#hikari.files.Resourceish'>Resourceish</a></code></dt>
<dd>The 128x128 image for the emoji. Maximum upload size is 256kb.
This can be a still or an animated image.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]</code></dt>
<dd>If provided, a collection of the roles that will be able to
use this emoji. This can be a <code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> or
the ID of an existing role.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a></code></dt>
<dd>The created emoji.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value or
if there are no more spaces for the type of emoji in the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2210-L2230" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    image: files.Resourceish,
    *,
    roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; emojis.KnownCustomEmoji:
    route = routes.POST_GUILD_EMOJIS.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    image_resource = files.ensure_resource(image)
    async with image_resource.stream(executor=self._executor) as stream:
        body.put(&#34;image&#34;, await stream.data_uri())

    body.put_snowflake_array(&#34;roles&#34;, roles)

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_guild_category" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_guild_category" href="#hikari.impl.rest.RESTClientImpl.create_guild_category" id="hikari.impl.rest.RESTClientImpl.create_guild_category">create_guild_category</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels_.PermissionOverwrite</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_guild_category -- Create a category in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.create_guild_category"
>create_guild_category</a></code>
</p>
<p>Create a category in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the channel in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The channels name. Must be between 2 and 1000 characters.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the position of the category.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the permission overwrites for the category.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a></code></dt>
<dd>The created category.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2592-L2612" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_guild_category(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels_.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels_.GuildCategory:
    channel = await self._create_guild_channel(
        guild,
        name,
        channels_.ChannelType.GUILD_CATEGORY,
        position=position,
        permission_overwrites=permission_overwrites,
        reason=reason,
    )
    assert isinstance(channel, channels_.GuildCategory)
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_guild_from_template" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_guild_from_template" href="#hikari.impl.rest.RESTClientImpl.create_guild_from_template" id="hikari.impl.rest.RESTClientImpl.create_guild_from_template">create_guild_from_template</a>(
    template: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../templates.html#hikari.templates.Template'>templates.Template</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    icon: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.RESTGuild'>guilds.RESTGuild</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_guild_from_template -- Make a guild from a template …" href="../api/rest.html#hikari.api.rest.RESTClient.create_guild_from_template"
>create_guild_from_template</a></code>
</p>
<p>Make a guild from a template.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>template</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../templates.html#hikari.templates.Template'>Template</a>]</code></dt>
<dd>The object or string code of the template to create a guild based on.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The new guilds name.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>icon</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the guild icon to set. Must be a 1024x1024 image or can
be an animated gif when the guild has the <code>ANIMATED_ICON</code> feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.RESTGuild'>RESTGuild</a></code></dt>
<dd>Object of the created guild.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This endpoint can only be used by bots in less than 10 guilds.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value or if you
call this as a bot that's in more than 10 guilds.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3066-L3085" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_guild_from_template(
    self,
    template: typing.Union[str, templates.Template],
    name: str,
    *,
    icon: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
) -&gt; guilds.RESTGuild:
    template = template if isinstance(template, str) else template.code
    route = routes.POST_TEMPLATE.compile(template=template)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)

    if icon is not undefined.UNDEFINED:
        icon_resource = files.ensure_resource(icon)
        async with icon_resource.stream(executor=self._executor) as stream:
            body.put(&#34;icon&#34;, await stream.data_uri())

    response = await self._request(route, json=body)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_rest_guild(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_guild_news_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_guild_news_channel" href="#hikari.impl.rest.RESTClientImpl.create_guild_news_channel" id="hikari.impl.rest.RESTClientImpl.create_guild_news_channel">create_guild_news_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    topic: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    nsfw: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    rate_limit_per_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>time.Intervalish</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels_.PermissionOverwrite</a>]] = UNDEFINED,
    category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels_.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_guild_news_channel -- Create a news channel in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.create_guild_news_channel"
>create_guild_news_channel</a></code>
</p>
<p>Create a news channel in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the channel in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The channels name. Must be between 2 and 1000 characters.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the position of the channel (relative to the
category, if any).</dd>
<dt><strong><code>topic</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the channels topic. Maximum 1024 characters.</dd>
<dt><strong><code>nsfw</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to mark the channel as NSFW.</dd>
<dt><strong><code>rate_limit_per_user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>Intervalish</a>]</code></dt>
<dd>If provided, the amount of seconds a user has to wait
before being able to send another message in the channel.
Maximum 21600 seconds.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the permission overwrites for the channel.</dd>
<dt><strong><code>category</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>]]</code></dt>
<dd>The category to create the channel under. This may be the
object or the ID of an existing category.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a></code></dt>
<dd>The created channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2500-L2528" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_guild_news_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels_.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels_.GuildNewsChannel:
    channel = await self._create_guild_channel(
        guild,
        name,
        channels_.ChannelType.GUILD_NEWS,
        position=position,
        topic=topic,
        nsfw=nsfw,
        rate_limit_per_user=rate_limit_per_user,
        permission_overwrites=permission_overwrites,
        category=category,
        reason=reason,
    )
    assert isinstance(channel, channels_.GuildNewsChannel)
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_guild_stage_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_guild_stage_channel" href="#hikari.impl.rest.RESTClientImpl.create_guild_stage_channel" id="hikari.impl.rest.RESTClientImpl.create_guild_stage_channel">create_guild_stage_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    user_limit: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    bitrate: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels_.PermissionOverwrite</a>]] = UNDEFINED,
    region: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>voices.VoiceRegion</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]] = UNDEFINED,
    category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels_.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildStageChannel'>channels_.GuildStageChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_guild_stage_channel -- Create a stage channel in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.create_guild_stage_channel"
>create_guild_stage_channel</a></code>
</p>
<p>Create a stage channel in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the channel in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The channel's name. Must be between 2 and 1000 characters.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the position of the channel (relative to the
category, if any).</dd>
<dt><strong><code>user_limit</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the maximum users in the channel at once.
Must be between 0 and 99 with 0 meaning no limit.</dd>
<dt><strong><code>bitrate</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the bitrate for the channel. Must be
between 8000 and 96000 or 8000 and 128000 for VIP
servers.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the permission overwrites for the channel.</dd>
<dt><strong><code>region</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>VoiceRegion</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]]</code></dt>
<dd>If provided, the voice region to for this channel. Passing
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> here will set it to "auto" mode where the used
region will be decided based on the first person who connects to it
when it's empty.</dd>
<dt><strong><code>category</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>]]</code></dt>
<dd>The category to create the channel under. This may be the
object or the ID of an existing category.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.GuildStageChannel'>GuildStageChannel</a></code></dt>
<dd>The created channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2562-L2590" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_guild_stage_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels_.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    region: undefined.UndefinedOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
    category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels_.GuildStageChannel:
    channel = await self._create_guild_channel(
        guild,
        name,
        channels_.ChannelType.GUILD_STAGE,
        position=position,
        user_limit=user_limit,
        bitrate=bitrate,
        permission_overwrites=permission_overwrites,
        region=region,
        category=category,
        reason=reason,
    )
    assert isinstance(channel, channels_.GuildStageChannel)
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_guild_text_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_guild_text_channel" href="#hikari.impl.rest.RESTClientImpl.create_guild_text_channel" id="hikari.impl.rest.RESTClientImpl.create_guild_text_channel">create_guild_text_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    topic: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    nsfw: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    rate_limit_per_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>time.Intervalish</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels_.PermissionOverwrite</a>]] = UNDEFINED,
    category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels_.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_guild_text_channel -- Create a text channel in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.create_guild_text_channel"
>create_guild_text_channel</a></code>
</p>
<p>Create a text channel in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the channel in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The channels name. Must be between 2 and 1000 characters.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the position of the channel (relative to the
category, if any).</dd>
<dt><strong><code>topic</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the channels topic. Maximum 1024 characters.</dd>
<dt><strong><code>nsfw</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to mark the channel as NSFW.</dd>
<dt><strong><code>rate_limit_per_user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>Intervalish</a>]</code></dt>
<dd>If provided, the amount of seconds a user has to wait
before being able to send another message in the channel.
Maximum 21600 seconds.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the permission overwrites for the channel.</dd>
<dt><strong><code>category</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>]]</code></dt>
<dd>The category to create the channel under. This may be the
object or the ID of an existing category.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a></code></dt>
<dd>The created channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2470-L2498" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_guild_text_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels_.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels_.GuildTextChannel:
    channel = await self._create_guild_channel(
        guild,
        name,
        channels_.ChannelType.GUILD_TEXT,
        position=position,
        topic=topic,
        nsfw=nsfw,
        rate_limit_per_user=rate_limit_per_user,
        permission_overwrites=permission_overwrites,
        category=category,
        reason=reason,
    )
    assert isinstance(channel, channels_.GuildTextChannel)
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_guild_voice_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_guild_voice_channel" href="#hikari.impl.rest.RESTClientImpl.create_guild_voice_channel" id="hikari.impl.rest.RESTClientImpl.create_guild_voice_channel">create_guild_voice_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    user_limit: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    bitrate: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    video_quality_mode: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.VideoQualityMode'>channels_.VideoQualityMode</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels_.PermissionOverwrite</a>]] = UNDEFINED,
    region: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>voices.VoiceRegion</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]] = UNDEFINED,
    category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels_.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildVoiceChannel'>channels_.GuildVoiceChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_guild_voice_channel -- Create a voice channel in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.create_guild_voice_channel"
>create_guild_voice_channel</a></code>
</p>
<p>Create a voice channel in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the channel in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The channels name. Must be between 2 and 1000 characters.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the position of the channel (relative to the
category, if any).</dd>
<dt><strong><code>user_limit</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the maximum users in the channel at once.
Must be between 0 and 99 with 0 meaning no limit.</dd>
<dt><strong><code>bitrate</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the bitrate for the channel. Must be
between 8000 and 96000 or 8000 and 128000 for VIP
servers.</dd>
<dt><strong><code>video_quality_mode</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.VideoQualityMode'>VideoQualityMode</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]]</code></dt>
<dd>If provided, the new video quality mode for the channel.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the permission overwrites for the channel.</dd>
<dt><strong><code>region</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>VoiceRegion</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]]</code></dt>
<dd>If provided, the voice region to for this channel. Passing
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> here will set it to "auto" mode where the used
region will be decided based on the first person who connects to it
when it's empty.</dd>
<dt><strong><code>category</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>]]</code></dt>
<dd>The category to create the channel under. This may be the
object or the ID of an existing category.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.GuildVoiceChannel'>GuildVoiceChannel</a></code></dt>
<dd>The created channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2530-L2560" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_guild_voice_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    video_quality_mode: undefined.UndefinedOr[typing.Union[channels_.VideoQualityMode, int]] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels_.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    region: undefined.UndefinedOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
    category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels_.GuildVoiceChannel:
    channel = await self._create_guild_channel(
        guild,
        name,
        channels_.ChannelType.GUILD_VOICE,
        position=position,
        user_limit=user_limit,
        bitrate=bitrate,
        video_quality_mode=video_quality_mode,
        permission_overwrites=permission_overwrites,
        region=region,
        category=category,
        reason=reason,
    )
    assert isinstance(channel, channels_.GuildVoiceChannel)
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_interaction_response" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_interaction_response" href="#hikari.impl.rest.RESTClientImpl.create_interaction_response" id="hikari.impl.rest.RESTClientImpl.create_interaction_response">create_interaction_response</a>(
    interaction: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.PartialInteraction'>base_interactions.PartialInteraction</a>],
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    response_type: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.ResponseType'>base_interactions.ResponseType</a>],
    content: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    flags: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../messages.html#hikari.messages.MessageFlag'>messages_.MessageFlag</a>, <a href='../undefined.html#hikari.undefined.UndefinedType'>undefined.UndefinedType</a>] = UNDEFINED,
    tts: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    component: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[special_endpoints.ComponentBuilder] = UNDEFINED,
    components: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[special_endpoints.ComponentBuilder]] = UNDEFINED,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_interaction_response -- Create the initial response for a interaction …" href="../api/rest.html#hikari.api.rest.RESTClient.create_interaction_response"
>create_interaction_response</a></code>
</p>
<p>Create the initial response for a interaction.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Calling this with an interaction which already has an initial
response will result in this raising a <code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code>.
This includes if the REST interaction server has already responded
to the request.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>interaction</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.PartialInteraction'>PartialInteraction</a>]</code></dt>
<dd>Object or ID of the interaction this response is for.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The command interaction's token.</dd>
<dt><strong><code>response_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.ResponseType'>ResponseType</a>]</code></dt>
<dd>The type of interaction response this is.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message contents. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> nor
no <code>embeds</code> kwarg is provided, then this will instead
update the embed. This allows for simpler syntax when
sending an embed alone.</p>
</dd>
<dt><strong><code>component</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]</code></dt>
<dd>If provided, builder object of the component to include in this message.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]]</code></dt>
<dd>If provided, a sequence of the component builder objects to include
in this message.</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the message embed.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]]</code></dt>
<dd>If provided, the message embeds.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../messages.html#hikari.messages.MessageFlag'>MessageFlag</a>, <a href='../undefined.html#hikari.undefined.UndefinedType'>UndefinedType</a>]</code></dt>
<dd>
<p>If provided, the message flags this response should have.</p>
<p>As of writing the only message flag which can be set here is
<code><a href='../messages.html#hikari.messages.MessageFlag.EPHEMERAL'>EPHEMERAL</a></code>.</p>
</dd>
<dt><strong><code>tts</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message will be read out by a screen
reader using Discord's TTS (text-to-speech) system.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message should parse @everyone/@here
mentions.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all user mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all user mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all role mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all role mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If more than 100 unique objects/entities are passed for
<code>role_mentions</code> or <code>user_mentions</code>.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>embed</code> and <code>embeds</code> are specified.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no embeds; messages with more than 2000 characters
in them, embeds that exceed one of the many embed limits
invalid image URLs in embeds.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the interaction is not found or if the interaction's initial
response has already been created.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3337-L3420" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_interaction_response(
    self,
    interaction: snowflakes.SnowflakeishOr[base_interactions.PartialInteraction],
    token: str,
    response_type: typing.Union[int, base_interactions.ResponseType],
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    flags: typing.Union[int, messages_.MessageFlag, undefined.UndefinedType] = undefined.UNDEFINED,
    tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
    components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
    embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
    embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
    ] = undefined.UNDEFINED,
) -&gt; None:
    if not undefined.any_undefined(component, components):
        raise ValueError(&#34;You may only specify one of &#39;component&#39; or &#39;components&#39;, not both&#34;)

    if not undefined.any_undefined(embed, embeds):
        raise ValueError(&#34;You may only specify one of &#39;embed&#39; or &#39;embeds&#39;, not both&#34;)

    if components is not undefined.UNDEFINED and not isinstance(components, typing.Collection):
        raise TypeError(
            &#34;You passed a non-collection to &#39;components&#39;, but this expects a collection. Maybe you meant to &#34;
            &#34;use &#39;component&#39; (singular) instead?&#34;
        )

    if embeds not in _NONE_OR_UNDEFINED and not isinstance(embeds, typing.Collection):
        raise TypeError(
            &#34;You passed a non-collection to &#39;embeds&#39;, but this expects a collection. Maybe you meant to &#34;
            &#34;use &#39;embed&#39; (singular) instead?&#34;
        )

    if undefined.all_undefined(embed, embeds) and isinstance(content, embeds_.Embed):
        # Syntactic sugar, common mistake to accidentally send an embed
        # as the content, so lets detect this and fix it for the user.
        embed = content
        content = undefined.UNDEFINED

    route = routes.POST_INTERACTION_RESPONSE.compile(interaction=interaction, token=token)

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;type&#34;, response_type)

    data = data_binding.JSONObjectBuilder()
    data.put(&#34;content&#34;, content)
    data.put(&#34;flags&#34;, flags)
    data.put(&#34;tts&#34;, tts)
    data.put(
        &#34;allowed_mentions&#34;,
        mentions.generate_allowed_mentions(mentions_everyone, undefined.UNDEFINED, user_mentions, role_mentions),
    )

    if component is not undefined.UNDEFINED:
        data.put(&#34;components&#34;, [component.build()])

    elif components is not undefined.UNDEFINED:
        data.put(&#34;components&#34;, [component.build() for component in components])

    if embed is not undefined.UNDEFINED:
        embed_payload, attachments = self._entity_factory.serialize_embed(embed)
        if attachments:
            raise ValueError(&#34;Cannot send an embed with attachments in a slash command&#39;s initial response&#34;)

        data.put(&#34;embeds&#34;, [embed_payload])

    elif embeds is not undefined.UNDEFINED:
        embed_payloads: data_binding.JSONArray = []
        for embed in embeds:
            serialized_embed, attachments = self._entity_factory.serialize_embed(embed)
            embed_payloads.append(serialized_embed)
            if attachments:
                raise ValueError(&#34;Cannot send an embed with attachments in a slash command&#39;s initial response&#34;)

        data.put(&#34;embeds&#34;, embed_payloads)

    body.put(&#34;data&#34;, data)
    await self._request(route, json=body, no_auth=True)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_invite" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_invite" href="#hikari.impl.rest.RESTClientImpl.create_invite" id="hikari.impl.rest.RESTClientImpl.create_invite">create_invite</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels_.GuildChannel</a>],
    *,
    max_age: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>time.Intervalish</a>] = UNDEFINED,
    max_uses: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    temporary: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    unique: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    target_type: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../invites.html#hikari.invites.TargetType'>invites.TargetType</a>] = UNDEFINED,
    target_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]] = UNDEFINED,
    target_application: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_invite -- Create an invite to the given guild channel …" href="../api/rest.html#hikari.api.rest.RESTClient.create_invite"
>create_invite</a></code>
</p>
<p>Create an invite to the given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to create a invite for. This may be the object
or the ID of an existing channel.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>max_age</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/datetime.html#datetime.timedelta'>datetime.timedelta</a>, <a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]]</code></dt>
<dd>If provided, the duration of the invite before expiry.</dd>
<dt><strong><code>max_uses</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the max uses the invite can have.</dd>
<dt><strong><code>temporary</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the invite only grants temporary membership.</dd>
<dt><strong><code>unique</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the invite should be unique.</dd>
<dt><strong><code>target_type</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../invites.html#hikari.invites.TargetType'>TargetType</a>]</code></dt>
<dd>If provided, the target type of this invite.</dd>
<dt><strong><code>target_user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]]</code></dt>
<dd>
<p>If provided, the target user id for this invite. This may be the
object or the ID of an existing user.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This is required if <code>target_type</code> is <code>STREAM</code> and the targeted
user must be streaming into the channel.</p>
</div>
</dd>
<dt><strong><code>target_application</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]]</code></dt>
<dd>
<p>If provided, the target application id for this invite. This may be
the object or the ID of an existing application.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This is required if <code>target_type</code> is <code>EMBEDDED_APPLICATION</code> and
the targeted application must have the <code>EMBEDDED</code> flag.</p>
</div>
</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a></code></dt>
<dd>The invite to the given guild channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNELS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found, or if the target user does not exist,
if provided.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1091-L1117" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_invite(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
    *,
    max_age: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
    max_uses: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    temporary: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    unique: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    target_type: undefined.UndefinedOr[invites.TargetType] = undefined.UNDEFINED,
    target_user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
    target_application: undefined.UndefinedOr[
        snowflakes.SnowflakeishOr[guilds.PartialApplication]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; invites.InviteWithMetadata:
    route = routes.POST_CHANNEL_INVITES.compile(channel=channel)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;max_age&#34;, max_age, conversion=time.timespan_to_int)
    body.put(&#34;max_uses&#34;, max_uses)
    body.put(&#34;temporary&#34;, temporary)
    body.put(&#34;unique&#34;, unique)
    body.put(&#34;target_type&#34;, target_type)
    body.put_snowflake(&#34;target_user_id&#34;, target_user)
    body.put_snowflake(&#34;target_application_id&#34;, target_application)
    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_invite_with_metadata(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_message" href="#hikari.impl.rest.RESTClientImpl.create_message" id="hikari.impl.rest.RESTClientImpl.create_message">create_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    content: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    attachment: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    component: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[special_endpoints.ComponentBuilder] = UNDEFINED,
    components: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[special_endpoints.ComponentBuilder]] = UNDEFINED,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    tts: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    nonce: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    reply: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>]] = UNDEFINED,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentions_reply: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_message -- Create a message in the given channel …" href="../api/rest.html#hikari.api.rest.RESTClient.create_message"
>create_message</a></code>
</p>
<p>Create a message in the given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel to create the message in.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message contents. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> nor <code>embeds</code> kwarg
is provided, then this will instead update the embed. This allows
for simpler syntax when sending an embed alone.</p>
<p>Likewise, if this is a <code><a href='../files.html#hikari.files.Resource'>Resource</a></code>, then the
content is instead treated as an attachment if no <code>attachment</code> and
no <code>attachments</code> kwargs are provided.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>],</code></dt>
<dd>If provided, the message attachment. This can be a resource,
or string of a path on your computer or a URL.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]],</code></dt>
<dd>If provided, the message attachments. These can be resources, or
strings consisting of paths on your computer or URLs.</dd>
<dt><strong><code>component</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]</code></dt>
<dd>If provided, builder object of the component to include in this message.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]]</code></dt>
<dd>If provided, a sequence of the component builder objects to include
in this message.</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the message embed.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]]</code></dt>
<dd>If provided, the message embeds.</dd>
<dt><strong><code>tts</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message will be read out by a screen
reader using Discord's TTS (text-to-speech) system.</dd>
<dt><strong><code>nonce</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>An arbitrary identifier to associate with the message. This
can be used to identify it later in received events. If provided,
this must be less than 32 bytes. If not provided, then
a null value is placed on the message instead. All users can
see this value.</dd>
<dt><strong><code>reply</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]]</code></dt>
<dd>If provided, the message to reply to.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message should parse @everyone/@here
mentions.</dd>
<dt><strong><code>mentions_reply</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If provided, whether to mention the author of the message
that is being replied to.</p>
<p>This will not do anything if not being used with <code>reply</code>.</p>
</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all user mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all user mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all role mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all role mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Attachments can be passed as many different things, to aid in
convenience.</p>
<ul>
<li>If a <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> to a valid URL, the
resource at the given URL will be streamed to Discord when
sending the message. Subclasses of
<code><a href='../files.html#hikari.files.WebResource'>WebResource</a></code> such as
<code><a href='../files.html#hikari.files.URL'>URL</a></code>,
<code><a href='../messages.html#hikari.messages.Attachment'>Attachment</a></code>,
<code><a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a></code>,
<code>EmbedResource</code>, etc will also be uploaded this way.
This will use bit-inception, so only a small percentage of the
resource will remain in memory at any one time, thus aiding in
scalability.</li>
<li>If a <code><a href='../files.html#hikari.files.Bytes'>Bytes</a></code> is passed, or a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>
that contains a valid data URI is passed, then this is uploaded
with a randomized file name if not provided.</li>
<li>If a <code><a href='../files.html#hikari.files.File'>File</a></code>, <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> that is an absolute or relative path to a file
on your file system is passed, then this resource is uploaded
as an attachment using non-blocking code internally and streamed
using bit-inception where possible. This depends on the
type of <code><a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a></code> that is being used for
the application (default is a thread pool which supports this
behaviour).</li>
</ul>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The created message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If more than 100 unique objects/entities are passed for
<code>role_mentions</code> or <code>user_mentions</code> or if both <code>attachment</code> and
<code>attachments</code>, <code>component</code> and <code>components</code> or <code>embed</code> and <code>embeds</code>
are specified.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If <code>attachments</code>, <code>components</code> or <code>embeds</code> is passed but is not a
sequence.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no attachments or embeds; messages with more than
2000 characters in them, embeds that exceed one of the many embed
limits; too many attachments; attachments that are too large;
invalid image URLs in embeds; if <code>reply</code> is not found or not in the
same channel as <code>channel</code>; too many components.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>SEND_MESSAGES</code> in the channel or the
person you are trying to message has the DM's disabled.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1320-L1362" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
    component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
    components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
    embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
    embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
    tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    reply: undefined.UndefinedOr[snowflakes.SnowflakeishOr[messages_.PartialMessage]] = undefined.UNDEFINED,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentions_reply: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
    ] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    route = routes.POST_CHANNEL_MESSAGES.compile(channel=channel)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;nonce&#34;, nonce)
    body.put(&#34;message_reference&#34;, reply, conversion=lambda m: {&#34;message_id&#34;: str(int(m))})
    return await self._create_message(
        route,
        body,
        content=content,
        attachment=attachment,
        attachments=attachments,
        component=component,
        components=components,
        embed=embed,
        embeds=embeds,
        tts=tts,
        mentions_everyone=mentions_everyone,
        mentions_reply=mentions_reply,
        user_mentions=user_mentions,
        role_mentions=role_mentions,
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_role" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_role" href="#hikari.impl.rest.RESTClientImpl.create_role" id="hikari.impl.rest.RESTClientImpl.create_role">create_role</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    permissions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = &lt;Permissions.NONE: 0&gt;,
    color: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    colour: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    hoist: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentionable: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.Role'>Role</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_role -- Create a role …" href="../api/rest.html#hikari.api.rest.RESTClient.create_role"
>create_role</a></code>
</p>
<p>Create a role.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the role in. This may be the
object or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the name for the role.</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>Permissions</a>]</code></dt>
<dd>The permissions to give the role. This will default to setting
NO roles if left to the default value. This is in contrast to
default behaviour on Discord where some random permissions will
be set by default.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>Colorish</a>]</code></dt>
<dd>If provided, the role's color.</dd>
<dt><strong><code>colour</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>Colorish</a>]</code></dt>
<dd>An alias for <code>color</code>.</dd>
<dt><strong><code>hoist</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to hoist the role.</dd>
<dt><strong><code>mentionable</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to make the role mentionable.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.Role'>Role</a></code></dt>
<dd>The created role.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>color</code> and <code>colour</code> are specified.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2832-L2858" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_role(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    permissions: undefined.UndefinedOr[permissions_.Permissions] = permissions_.Permissions.NONE,
    color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.Role:
    if not undefined.any_undefined(color, colour):
        raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

    route = routes.POST_GUILD_ROLES.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;permissions&#34;, permissions)
    body.put(&#34;color&#34;, color, conversion=colors.Color.of)
    body.put(&#34;color&#34;, colour, conversion=colors.Color.of)
    body.put(&#34;hoist&#34;, hoist)
    body.put(&#34;mentionable&#34;, mentionable)

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_sticker" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_sticker" href="#hikari.impl.rest.RESTClientImpl.create_sticker" id="hikari.impl.rest.RESTClientImpl.create_sticker">create_sticker</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    tag: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    image: <a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>,
    *,
    description: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../stickers.html#hikari.stickers.GuildSticker'>stickers.GuildSticker</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_sticker -- Create a sticker in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.create_sticker"
>create_sticker</a></code>
</p>
<p>Create a sticker in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the sticker on. This can be a guild object or the
ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The name for the sticker.</dd>
<dt><strong><code>tag</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The tag for the sticker.</dd>
<dt><strong><code>image</code></strong> :&ensp;<code><a href='../files.html#hikari.files.Resourceish'>Resourceish</a></code></dt>
<dd>
<p>The 320x320 image for the sticker. Maximum upload size is 500kb.
This can be a still or an animated PNG or a Lottie.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Lottie support is only available for verified and partnered
servers.</p>
</div>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>description</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the description of the sticker.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../stickers.html#hikari.stickers.GuildSticker'>GuildSticker</a></code></dt>
<dd>The created sticker.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value or
if there are no more spaces for the sticker in the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2302-L2324" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_sticker(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    tag: str,
    image: files.Resourceish,
    *,
    description: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; stickers.GuildSticker:
    route = routes.POST_GUILD_STICKERS.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;tags&#34;, tag)
    body.put(&#34;description&#34;, description)

    image_resource = files.ensure_resource(image)
    async with image_resource.stream(executor=self._executor) as stream:
        body.put(&#34;image&#34;, await stream.data_uri())

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_guild_sticker(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_template" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_template" href="#hikari.impl.rest.RESTClientImpl.create_template" id="hikari.impl.rest.RESTClientImpl.create_template">create_template</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    description: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../templates.html#hikari.templates.Template'>templates.Template</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_template -- Create a guild template …" href="../api/rest.html#hikari.api.rest.RESTClient.create_template"
>create_template</a></code>
</p>
<p>Create a guild template.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create a template from.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The name to use for the created template.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>description</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The description to set for the template.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../templates.html#hikari.templates.Template'>Template</a></code></dt>
<dd>The object of the created template.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found or you are missing the <code>MANAGE_GUILD</code>
permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3087-L3100" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_template(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    description: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
) -&gt; templates.Template:
    route = routes.POST_GUILD_TEMPLATES.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;description&#34;, description)
    response = await self._request(route, json=body)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_template(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.create_webhook" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_webhook" href="#hikari.impl.rest.RESTClientImpl.create_webhook" id="hikari.impl.rest.RESTClientImpl.create_webhook">create_webhook</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.WebhookChannelT'>channels_.WebhookChannelT</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    avatar: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../webhooks.html#hikari.webhooks.IncomingWebhook'>webhooks.IncomingWebhook</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="create_webhook -- Create webhook in a channel …" href="../api/rest.html#hikari.api.rest.RESTClient.create_webhook"
>create_webhook</a></code>
</p>
<p>Create webhook in a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.WebhookChannelT'>WebhookChannelT</a>]</code></dt>
<dd>The channel where the webhook will be created. This may be
the object or the ID of an existing channel.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The name for the webhook. This cannot be <code>clyde</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the avatar for the webhook.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../webhooks.html#hikari.webhooks.IncomingWebhook'>IncomingWebhook</a></code></dt>
<dd>The created webhook.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/reference/introduction.html#grammar-token-name'>name</a></code> doesn't follow the restrictions enforced by discord.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1715-L1734" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def create_webhook(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.WebhookChannelT],
    name: str,
    *,
    avatar: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; webhooks.IncomingWebhook:
    route = routes.POST_CHANNEL_WEBHOOKS.compile(channel=channel)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)

    if avatar is not undefined.UNDEFINED:
        avatar_resource = files.ensure_resource(avatar)
        async with avatar_resource.stream(executor=self._executor) as stream:
            body.put(&#34;avatar&#34;, await stream.data_uri())

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_incoming_webhook(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.crosspost_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="crosspost_message" href="#hikari.impl.rest.RESTClientImpl.crosspost_message" id="hikari.impl.rest.RESTClientImpl.crosspost_message">crosspost_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>channels_.GuildNewsChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="crosspost_message -- Broadcast an announcement message …" href="../api/rest.html#hikari.api.rest.RESTClient.crosspost_message"
>crosspost_message</a></code>
</p>
<p>Broadcast an announcement message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a>]</code></dt>
<dd>The object or ID of the news channel to crosspost a message in.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The object or ID of the message to crosspost.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The message object that was crossposted.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If you tried to crosspost a message that has already been broadcast.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you try to crosspost a message by the current user without the
<code>SEND_MESSAGES</code> permission for the target news channel or try to
crosspost a message by another user without both the <code>SEND_MESSAGES</code>
and <code>MANAGE_MESSAGES</code> permissions for the target channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1364-L1374" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def crosspost_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.GuildNewsChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; messages_.Message:
    route = routes.POST_CHANNEL_CROSSPOST.compile(channel=channel, message=message)

    response = await self._request(route)

    assert isinstance(response, dict)
    return self._entity_factory.deserialize_message(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_all_reactions" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_all_reactions" href="#hikari.impl.rest.RESTClientImpl.delete_all_reactions" id="hikari.impl.rest.RESTClientImpl.delete_all_reactions">delete_all_reactions</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_all_reactions -- Delete all reactions from a message …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_all_reactions"
>delete_all_reactions</a></code>
</p>
<p>Delete all reactions from a message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel where the message to delete all reactions from is.
This may be the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete all reaction from. This may be the
object or the ID of an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1692-L1698" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_all_reactions(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; None:
    route = routes.DELETE_ALL_REACTIONS.compile(channel=channel, message=message)
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_all_reactions_for_emoji" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_all_reactions_for_emoji" href="#hikari.impl.rest.RESTClientImpl.delete_all_reactions_for_emoji" id="hikari.impl.rest.RESTClientImpl.delete_all_reactions_for_emoji">delete_all_reactions_for_emoji</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    emoji: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.Emoji'>emojis.Emoji</a>],
    emoji_id: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_all_reactions_for_emoji -- Delete all reactions for a single emoji on a given message …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_all_reactions_for_emoji"
>delete_all_reactions_for_emoji</a></code>
</p>
<p>Delete all reactions for a single emoji on a given message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel where the message to delete the reactions from is.
This may be the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete a reactions from. This may be the
object or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a>]</code></dt>
<dd>Object or name of the emoji to remove all the reactions for.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>emoji_id</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]]</code></dt>
<dd>ID of the custom emoji to remove all the reactions for.
This should only be provided when a custom emoji's name is passed
for <code>emoji</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1662-L1674" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_all_reactions_for_emoji(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    emoji: typing.Union[str, emojis.Emoji],
    emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_REACTION_EMOJI.compile(
        emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
        channel=channel,
        message=message,
    )
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_application_command" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_application_command" href="#hikari.impl.rest.RESTClientImpl.delete_application_command" id="hikari.impl.rest.RESTClientImpl.delete_application_command">delete_application_command</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    command: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>commands.Command</a>],
    guild: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_application_command -- Delete a registered application command …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_application_command"
>delete_application_command</a></code>
</p>
<p>Delete a registered application command.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to delete a command for.</dd>
<dt><strong><code>command</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>Command</a>]</code></dt>
<dd>Object or ID of the command to delete.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]]</code></dt>
<dd>Object or ID of the guild to delete a command for if this is a guild
specific command. Leave this as <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> to
delete a global command.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the provided application's commands.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the provided application or command isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3242-L3256" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_application_command(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    command: snowflakes.SnowflakeishOr[commands.Command],
    guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
) -&gt; None:
    if guild is undefined.UNDEFINED:
        route = routes.DELETE_APPLICATION_COMMAND.compile(application=application, command=command)

    else:
        route = routes.DELETE_APPLICATION_GUILD_COMMAND.compile(
            application=application, command=command, guild=guild
        )

    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_channel" href="#hikari.impl.rest.RESTClientImpl.delete_channel" id="hikari.impl.rest.RESTClientImpl.delete_channel">delete_channel</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels_.PartialChannel</a>],
) -> <a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_channel -- Delete a channel in a guild, or close a DM …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_channel"
>delete_channel</a></code>
</p>
<p>Delete a channel in a guild, or close a DM.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>The channel to delete. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code></dt>
<dd>Object of the channel that was deleted.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>For Public servers, the set 'Rules' or 'Guidelines' channels and the
'Public Server Updates' channel cannot be deleted.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L996-L1002" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_channel(
    self, channel: snowflakes.SnowflakeishOr[channels_.PartialChannel]
) -&gt; channels_.PartialChannel:
    route = routes.DELETE_CHANNEL.compile(channel=channel)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_channel(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_emoji" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_emoji" href="#hikari.impl.rest.RESTClientImpl.delete_emoji" id="hikari.impl.rest.RESTClientImpl.delete_emoji">delete_emoji</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    emoji: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_emoji -- Delete an emoji in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_emoji"
>delete_emoji</a></code>
</p>
<p>Delete an emoji in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to delete the emoji on. This can be a guild object or the
ID of an existing guild.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]</code></dt>
<dd>The emoji to delete. This can be a <code><a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a></code>
or the ID of an existing emoji.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the emoji are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2250-L2258" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_EMOJI.compile(guild=guild, emoji=emoji)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_guild" href="#hikari.impl.rest.RESTClientImpl.delete_guild" id="hikari.impl.rest.RESTClientImpl.delete_guild">delete_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_guild -- Delete a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_guild"
>delete_guild</a></code>
</p>
<p>Delete a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to delete. This may be the object or
the ID of an existing guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not the owner of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If you own the guild or if you are not in it.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2456-L2458" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; None:
    route = routes.DELETE_GUILD.compile(guild=guild)
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_interaction_response" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_interaction_response" href="#hikari.impl.rest.RESTClientImpl.delete_interaction_response" id="hikari.impl.rest.RESTClientImpl.delete_interaction_response">delete_interaction_response</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_interaction_response -- Delete the initial response of an interaction …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_interaction_response"
>delete_interaction_response</a></code>
</p>
<p>Delete the initial response of an interaction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to delete a command response for.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The interaction's token.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the interaction or response is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3464-L3468" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_interaction_response(
    self, application: snowflakes.SnowflakeishOr[guilds.PartialApplication], token: str
) -&gt; None:
    route = routes.DELETE_INTERACTION_RESPONSE.compile(webhook=application, token=token)
    await self._request(route, no_auth=True)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_invite" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_invite" href="#hikari.impl.rest.RESTClientImpl.delete_invite" id="hikari.impl.rest.RESTClientImpl.delete_invite">delete_invite</a>(
    invite: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../invites.html#hikari.invites.InviteCode'>invites.InviteCode</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
) -> <a href='../invites.html#hikari.invites.Invite'>invites.Invite</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_invite -- Delete an existing invite …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_invite"
>delete_invite</a></code>
</p>
<p>Delete an existing invite.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../invites.html#hikari.invites.InviteCode'>InviteCode</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The invite to delete. This may be an invite object or
the code of an existing invite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../invites.html#hikari.invites.Invite'>Invite</a></code></dt>
<dd>Object of the invite that was deleted.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission in the guild
the invite is from or if you are missing the <code>MANAGE_CHANNELS</code>
permission in the channel the invite is from.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the invite is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1964-L1968" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_invite(self, invite: typing.Union[invites.InviteCode, str]) -&gt; invites.Invite:
    route = routes.DELETE_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_invite(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_message" href="#hikari.impl.rest.RESTClientImpl.delete_message" id="hikari.impl.rest.RESTClientImpl.delete_message">delete_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_message -- Delete a given message in a given channel …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_message"
>delete_message</a></code>
</p>
<p>Delete a given message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel to delete the message in. This may be
the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete. This may be the object or the ID of
an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code>, and the message is
not sent by you.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1556-L1562" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; None:
    route = routes.DELETE_CHANNEL_MESSAGE.compile(channel=channel, message=message)
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_messages" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_messages" href="#hikari.impl.rest.RESTClientImpl.delete_messages" id="hikari.impl.rest.RESTClientImpl.delete_messages">delete_messages</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    messages: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>], <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishIterable'>snowflakes.SnowflakeishIterable</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>]],
    /,
    *other_messages: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_messages -- Bulk-delete messages from the channel …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_messages"
>delete_messages</a></code>
</p>
<p>Bulk-delete messages from the channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel to bulk delete the messages in. This may be
the object or the ID of an existing channel.</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>], <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishIterable'>SnowflakeishIterable</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]]</code></dt>
<dd>Either the object/ID of an existing message to delete or an iterable
of the objects and/or IDs of existing messages to delete.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>*other_messages</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The objects and/or IDs of other existing messages to delete.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This API endpoint will only be able to delete 100 messages
at a time. For anything more than this, multiple requests will
be executed one-after-the-other, since the rate limits for this
endpoint do not favour more than one request per bucket.</p>
<p>If one message is left over from chunking per 100 messages, or
only one message is passed to this coroutine function, then the
logic is expected to defer to <code>delete_message</code>. The implication
of this is that the <code>delete_message</code> endpoint is ratelimited
by a different bucket with different usage rates.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>This endpoint is not atomic. If an error occurs midway through
a bulk delete, you will <strong>not</strong> be able to revert any changes made
up to this point.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Specifying any messages more than 14 days old will cause the call
to fail, potentially with partial completion.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BulkDeleteError'>BulkDeleteError</a></code></dt>
<dd>An error containing the messages successfully deleted, and the
messages that were not removed. The
<code>BaseException.__cause__</code> of the exception will be the
original error that terminated this process.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1564-L1615" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_messages(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    messages: typing.Union[
        snowflakes.SnowflakeishOr[messages_.PartialMessage],
        snowflakes.SnowflakeishIterable[messages_.PartialMessage],
    ],
    /,
    *other_messages: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; None:
    route = routes.POST_DELETE_CHANNEL_MESSAGES_BULK.compile(channel=channel)

    pending: typing.Deque[snowflakes.SnowflakeishOr[messages_.PartialMessage]] = collections.deque()
    deleted: typing.Deque[snowflakes.SnowflakeishOr[messages_.PartialMessage]] = collections.deque()

    if isinstance(messages, typing.Iterable):  # Syntactic sugar. Allows to use iterables
        pending.extend(messages)

    else:
        pending.append(messages)

    # This maintains the order in-order to keep a predictable deletion order.
    pending.extend(other_messages)

    while pending:
        # Discord only allows 2-100 messages in the BULK_DELETE endpoint. Because of that,
        # if the user wants 101 messages deleted, we will post 100 messages in bulk delete
        # and then the last message in a normal delete.
        # Along with this, the bucket size for v6 and v7 seems to be a bit restrictive. As of
        # 30th July 2020, this endpoint returned the following headers when being ratelimited:
        #       x-ratelimit-bucket         b05c0d8c2ab83895085006a8eae073a3
        #       x-ratelimit-limit          1
        #       x-ratelimit-remaining      0
        #       x-ratelimit-reset          1596033974.096
        #       x-ratelimit-reset-after    3.000
        # This kind of defeats the point of asynchronously gathering any of these
        # in the first place really. To save clogging up the event loop
        # (albeit at a cost of maybe a couple-dozen milliseconds per call),
        # I am just gonna invoke these sequentially instead.
        try:
            if len(pending) == 1:
                message = pending.popleft()
                await self.delete_message(channel, message)
                deleted.append(message)
            else:
                body = data_binding.JSONObjectBuilder()
                chunk = [pending.popleft() for _ in range(min(100, len(pending)))]
                body.put_snowflake_array(&#34;messages&#34;, chunk)
                await self._request(route, json=body)
                deleted += chunk
        except Exception as ex:
            raise errors.BulkDeleteError(deleted, pending) from ex</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_my_reaction" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_my_reaction" href="#hikari.impl.rest.RESTClientImpl.delete_my_reaction" id="hikari.impl.rest.RESTClientImpl.delete_my_reaction">delete_my_reaction</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    emoji: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.Emoji'>emojis.Emoji</a>],
    emoji_id: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_my_reaction -- Delete a reaction that your application user created …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_my_reaction"
>delete_my_reaction</a></code>
</p>
<p>Delete a reaction that your application user created.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel where the message to delete the reaction from is.
This may be the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete a reaction from. This may be the
object or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a>]</code></dt>
<dd>Object or name of the emoji to remove your reaction for.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>emoji_id</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]]</code></dt>
<dd>ID of the custom emoji to remove your reaction for.
This should only be provided when a custom emoji's name is passed
for <code>emoji</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1648-L1660" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_my_reaction(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    emoji: typing.Union[str, emojis.Emoji],
    emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_MY_REACTION.compile(
        emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
        channel=channel,
        message=message,
    )
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_permission_overwrite" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_permission_overwrite" href="#hikari.impl.rest.RESTClientImpl.delete_permission_overwrite" id="hikari.impl.rest.RESTClientImpl.delete_permission_overwrite">delete_permission_overwrite</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels_.GuildChannel</a>],
    target: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels_.PermissionOverwrite</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>, <a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>]],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_permission_overwrite -- Delete a custom permission for an entity in a given guild channel …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_permission_overwrite"
>delete_permission_overwrite</a></code>
</p>
<p>Delete a custom permission for an entity in a given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to delete a permission overwrite in. This may be the
object, or the ID of an existing channel.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>, <a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a>]</code></dt>
<dd>The channel overwrite to delete.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_PERMISSIONS</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the target is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1073-L1081" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_permission_overwrite(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
    target: snowflakes.SnowflakeishOr[
        typing.Union[channels_.PermissionOverwrite, guilds.PartialRole, users.PartialUser, snowflakes.Snowflakeish]
    ],
) -&gt; None:
    route = routes.DELETE_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_reaction" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_reaction" href="#hikari.impl.rest.RESTClientImpl.delete_reaction" id="hikari.impl.rest.RESTClientImpl.delete_reaction">delete_reaction</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    emoji: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.Emoji'>emojis.Emoji</a>],
    emoji_id: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_reaction -- Delete a reaction from a message …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_reaction"
>delete_reaction</a></code>
</p>
<p>Delete a reaction from a message.</p>
<p>If you are looking to delete your own applications reaction, use
<code>delete_my_reaction</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel where the message to delete the reaction from is.
This may be the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete a reaction from. This may be the
object or the ID of an existing message.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user to remove the reaction of.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a>]</code></dt>
<dd>Object or name of the emoji to react with.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>emoji_id</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]]</code></dt>
<dd>ID of the custom emoji to react with.
This should only be provided when a custom emoji's name is passed
for <code>emoji</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1676-L1690" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_reaction(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    emoji: typing.Union[str, emojis.Emoji],
    emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_REACTION_USER.compile(
        emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
        channel=channel,
        message=message,
        user=user,
    )
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_role" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_role" href="#hikari.impl.rest.RESTClientImpl.delete_role" id="hikari.impl.rest.RESTClientImpl.delete_role">delete_role</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_role -- Delete a role …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_role"
>delete_role</a></code>
</p>
<p>Delete a role.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to delete the role in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]</code></dt>
<dd>The role to delete. This may be the object or the
ID of an existing role.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or role are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2899-L2905" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_role(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
) -&gt; None:
    route = routes.DELETE_GUILD_ROLE.compile(guild=guild, role=role)
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_sticker" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_sticker" href="#hikari.impl.rest.RESTClientImpl.delete_sticker" id="hikari.impl.rest.RESTClientImpl.delete_sticker">delete_sticker</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    sticker: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../stickers.html#hikari.stickers.PartialSticker'>stickers.PartialSticker</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_sticker -- Delete a sticker in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_sticker"
>delete_sticker</a></code>
</p>
<p>Delete a sticker in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to delete the sticker on. This can be a guild object or
the ID of an existing guild.</dd>
<dt><strong><code>sticker</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../stickers.html#hikari.stickers.PartialSticker'>PartialSticker</a>]</code></dt>
<dd>The sticker to delete. This can be a sticker object or the ID
of an existing sticker.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the sticker are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2346-L2354" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_sticker(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_STICKER.compile(guild=guild, sticker=sticker)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_template" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_template" href="#hikari.impl.rest.RESTClientImpl.delete_template" id="hikari.impl.rest.RESTClientImpl.delete_template">delete_template</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    template: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../templates.html#hikari.templates.Template'>templates.Template</a>],
) -> <a href='../templates.html#hikari.templates.Template'>templates.Template</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_template -- Delete a guild template …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_template"
>delete_template</a></code>
</p>
<p>Delete a guild template.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to delete a template in.</dd>
<dt><strong><code>template</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../templates.html#hikari.templates.Template'>Template</a>]</code></dt>
<dd>Object or string code of the template to delete.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../templates.html#hikari.templates.Template'>Template</a></code></dt>
<dd>The deleted template's object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found or you are missing the <code>MANAGE_GUILD</code>
permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3120-L3129" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_template(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    template: typing.Union[str, templates.Template],
) -&gt; templates.Template:
    template = template if isinstance(template, str) else template.code
    route = routes.DELETE_GUILD_TEMPLATE.compile(guild=guild, template=template)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_template(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_webhook" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_webhook" href="#hikari.impl.rest.RESTClientImpl.delete_webhook" id="hikari.impl.rest.RESTClientImpl.delete_webhook">delete_webhook</a>(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.PartialWebhook'>webhooks.PartialWebhook</a>],
    *,
    token: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_webhook -- Delete a webhook …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_webhook"
>delete_webhook</a></code>
</p>
<p>Delete a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.PartialWebhook'>PartialWebhook</a>]</code></dt>
<dd>The webhook to delete. This may be the object or the
ID of an existing webhook.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the webhoook token that will be used to delete
the webhook instead of the token the client was initialized with.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not
using a token.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhoook is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1803-L1816" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.PartialWebhook],
    *,
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    if token is undefined.UNDEFINED:
        route = routes.DELETE_WEBHOOK.compile(webhook=webhook)
        no_auth = False
    else:
        route = routes.DELETE_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
        no_auth = True

    await self._request(route, no_auth=no_auth)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.delete_webhook_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_webhook_message" href="#hikari.impl.rest.RESTClientImpl.delete_webhook_message" id="hikari.impl.rest.RESTClientImpl.delete_webhook_message">delete_webhook_message</a>(
    webhook: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../webhooks.html#hikari.webhooks.ExecutableWebhook'>webhooks.ExecutableWebhook</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>],
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="delete_webhook_message -- Delete a given message in a given channel …" href="../api/rest.html#hikari.api.rest.RESTClient.delete_webhook_message"
>delete_webhook_message</a></code>
</p>
<p>Delete a given message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a>, <a href='../webhooks.html#hikari.webhooks.ExecutableWebhook'>ExecutableWebhook</a>]</code></dt>
<dd>The webhook to execute. This may be the object
or the ID of an existing webhook.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The webhook token.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete. This may be the object or the ID of
an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook or the message are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1929-L1938" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_webhook_message(
    self,
    webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
    token: str,
    message: snowflakes.SnowflakeishOr[messages_.Message],
) -&gt; None:
    # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
    webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
    route = routes.DELETE_WEBHOOK_MESSAGE.compile(webhook=webhook_id, token=token, message=message)
    await self._request(route, no_auth=True)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_application_command" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_application_command" href="#hikari.impl.rest.RESTClientImpl.edit_application_command" id="hikari.impl.rest.RESTClientImpl.edit_application_command">edit_application_command</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    command: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>commands.Command</a>],
    guild: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>]] = UNDEFINED,
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    description: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    options: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.CommandOption'>commands.CommandOption</a>]] = UNDEFINED,
) -> <a href='../commands.html#hikari.commands.Command'>commands.Command</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_application_command -- Edit a registered application command …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_application_command"
>edit_application_command</a></code>
</p>
<p>Edit a registered application command.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to edit a command for.</dd>
<dt><strong><code>command</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>Command</a>]</code></dt>
<dd>Object or ID of the command to modify.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]]</code></dt>
<dd>Object or ID of the guild to edit a command for if this is a guild
specific command. Leave this as <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> to delete
a global command.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The name to set for the command. Leave as <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>
to not change.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The description to set for the command. Leave as <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>
to not change.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.CommandOption'>CommandOption</a>]]</code></dt>
<dd>A sequence of up to 10 options to set for this command. Leave this as
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> to not change.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../commands.html#hikari.commands.Command'>Command</a></code></dt>
<dd>The edited command object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the provided application's commands.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the provided application or command isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3213-L3240" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_application_command(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    command: snowflakes.SnowflakeishOr[commands.Command],
    guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    description: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    options: undefined.UndefinedOr[typing.Sequence[commands.CommandOption]] = undefined.UNDEFINED,
) -&gt; commands.Command:
    if guild is undefined.UNDEFINED:
        route = routes.PATCH_APPLICATION_COMMAND.compile(application=application, command=command)

    else:
        route = routes.PATCH_APPLICATION_GUILD_COMMAND.compile(
            application=application, command=command, guild=guild
        )

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;description&#34;, description)
    body.put_array(&#34;options&#34;, options, conversion=self._entity_factory.serialize_command_option)

    response = await self._request(route, json=body)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_command(
        response, guild_id=snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_channel" href="#hikari.impl.rest.RESTClientImpl.edit_channel" id="hikari.impl.rest.RESTClientImpl.edit_channel">edit_channel</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels_.GuildChannel</a>],
    /,
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    topic: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    nsfw: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    bitrate: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    video_quality_mode: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.VideoQualityMode'>channels_.VideoQualityMode</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]] = UNDEFINED,
    user_limit: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    rate_limit_per_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>time.Intervalish</a>] = UNDEFINED,
    region: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>voices.VoiceRegion</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels_.PermissionOverwrite</a>]] = UNDEFINED,
    parent_category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels_.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.PartialChannel'>channels_.PartialChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_channel -- Edit a channel …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_channel"
>edit_channel</a></code>
</p>
<p>Edit a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to edit. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new name for the channel.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the new position for the channel.</dd>
<dt><strong><code>topic</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new topic for the channel.</dd>
<dt><strong><code>nsfw</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the channel should be marked as NSFW or not.</dd>
<dt><strong><code>bitrate</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the new bitrate for the channel.</dd>
<dt><strong><code>video_quality_mode</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.VideoQualityMode'>VideoQualityMode</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]]</code></dt>
<dd>If provided, the new video quality mode for the channel.</dd>
<dt><strong><code>user_limit</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the new user limit in the channel.</dd>
<dt><strong><code>rate_limit_per_user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>Intervalish</a>]</code></dt>
<dd>If provided, the new rate limit per user in the channel.</dd>
<dt><strong><code>region</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../voices.html#hikari.voices.VoiceRegion'>VoiceRegion</a>]]</code></dt>
<dd>If provided, the voice region to set for this channel. Passing
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> here will set it to "auto" mode where the used
region will be decided based on the first person who connects to it
when it's empty.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the new permission overwrites for the channel.</dd>
<dt><strong><code>parent_category</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>]]</code></dt>
<dd>If provided, the new guild category for the channel.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code></dt>
<dd>The edited channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing permissions to edit the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L936-L978" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_channel(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
    /,
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    video_quality_mode: undefined.UndefinedOr[typing.Union[channels_.VideoQualityMode, int]] = undefined.UNDEFINED,
    user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
    region: undefined.UndefinedNoneOr[typing.Union[voices.VoiceRegion, str]] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels_.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    parent_category: undefined.UndefinedOr[
        snowflakes.SnowflakeishOr[channels_.GuildCategory]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels_.PartialChannel:
    route = routes.PATCH_CHANNEL.compile(channel=channel)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;position&#34;, position)
    body.put(&#34;topic&#34;, topic)
    body.put(&#34;nsfw&#34;, nsfw)
    body.put(&#34;bitrate&#34;, bitrate)
    body.put(&#34;video_quality_mode&#34;, video_quality_mode)
    body.put(&#34;user_limit&#34;, user_limit)
    body.put(&#34;rate_limit_per_user&#34;, rate_limit_per_user, conversion=time.timespan_to_int)
    body.put(&#34;rtc_region&#34;, region, conversion=str)
    body.put_snowflake(&#34;parent_id&#34;, parent_category)
    body.put_array(
        &#34;permission_overwrites&#34;,
        permission_overwrites,
        conversion=self._entity_factory.serialize_permission_overwrite,
    )

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_channel(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_emoji" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_emoji" href="#hikari.impl.rest.RESTClientImpl.edit_emoji" id="hikari.impl.rest.RESTClientImpl.edit_emoji">edit_emoji</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    emoji: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_emoji -- Edit an emoji in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_emoji"
>edit_emoji</a></code>
</p>
<p>Edit an emoji in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit the emoji on. This can be a
guild object or the ID of an existing guild.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]</code></dt>
<dd>The emoji to edit. This can be a <code><a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a></code>
or the ID of an existing emoji.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new name for the emoji.</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]</code></dt>
<dd>If provided, the new collection of roles that will be able to
use this emoji. This can be a <code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> or
the ID of an existing role.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a></code></dt>
<dd>The edited emoji.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the emoji are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2232-L2248" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; emojis.KnownCustomEmoji:
    route = routes.PATCH_GUILD_EMOJI.compile(guild=guild, emoji=emoji)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put_snowflake_array(&#34;roles&#34;, roles)

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_guild" href="#hikari.impl.rest.RESTClientImpl.edit_guild" id="hikari.impl.rest.RESTClientImpl.edit_guild">edit_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    verification_level: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildVerificationLevel'>guilds.GuildVerificationLevel</a>] = UNDEFINED,
    default_message_notifications: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildMessageNotificationsLevel'>guilds.GuildMessageNotificationsLevel</a>] = UNDEFINED,
    explicit_content_filter_level: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildExplicitContentFilterLevel'>guilds.GuildExplicitContentFilterLevel</a>] = UNDEFINED,
    afk_channel: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>channels_.GuildVoiceChannel</a>]] = UNDEFINED,
    afk_timeout: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>time.Intervalish</a>] = UNDEFINED,
    icon: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    owner: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]] = UNDEFINED,
    splash: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    banner: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    system_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>channels_.GuildTextChannel</a>]] = UNDEFINED,
    rules_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>channels_.GuildTextChannel</a>]] = UNDEFINED,
    public_updates_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>channels_.GuildTextChannel</a>]] = UNDEFINED,
    preferred_locale: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.RESTGuild'>RESTGuild</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_guild -- Edit a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_guild"
>edit_guild</a></code>
</p>
<p>Edit a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new name for the guild.</dd>
<dt><strong><code>verification_level</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildVerificationLevel'>GuildVerificationLevel</a>]</code></dt>
<dd>If provided, the new verification level.</dd>
<dt><strong><code>default_message_notifications</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildMessageNotificationsLevel'>GuildMessageNotificationsLevel</a>]</code></dt>
<dd>If provided, the new default message notifications level.</dd>
<dt><strong><code>explicit_content_filter_level</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildExplicitContentFilterLevel'>GuildExplicitContentFilterLevel</a>]</code></dt>
<dd>If provided, the new explicit content filter level.</dd>
<dt><strong><code>afk_channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>GuildVoiceChannel</a>]]</code></dt>
<dd>If provided, the new afk channel. Requires <code>afk_timeout</code> to
be set to work.</dd>
<dt><strong><code>afk_timeout</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>Intervalish</a>]</code></dt>
<dd>If provided, the new afk timeout.</dd>
<dt><strong><code>icon</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new guild icon. Must be a 1024x1024 image or can be
an animated gif when the guild has the <code>ANIMATED_ICON</code> feature.</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]]]</code></dt>
<dd>
<p>If provided, the new guild owner.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>You need to be the owner of the server to use this.</p>
</div>
</dd>
<dt><strong><code>splash</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new guild splash. Must be a 16:9 image and the
guild must have the <code>INVITE_SPLASH</code> feature.</dd>
<dt><strong><code>banner</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new guild banner. Must be a 16:9 image and the
guild must have the <code>BANNER</code> feature.</dd>
<dt><strong><code>system_channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a>]]</code></dt>
<dd>If provided, the new system channel.</dd>
<dt><strong><code>rules_channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a>]]</code></dt>
<dd>If provided, the new rules channel.</dd>
<dt><strong><code>public_updates_channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a>]]</code></dt>
<dd>If provided, the new public updates channel.</dd>
<dt><strong><code>preferred_locale</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new preferred locale.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.RESTGuild'>RESTGuild</a></code></dt>
<dd>The edited guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value. Or
you are missing the</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission or if you tried to
pass ownership without being the server owner.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2375-L2454" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_guild(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    verification_level: undefined.UndefinedOr[guilds.GuildVerificationLevel] = undefined.UNDEFINED,
    default_message_notifications: undefined.UndefinedOr[
        guilds.GuildMessageNotificationsLevel
    ] = undefined.UNDEFINED,
    explicit_content_filter_level: undefined.UndefinedOr[
        guilds.GuildExplicitContentFilterLevel
    ] = undefined.UNDEFINED,
    afk_channel: undefined.UndefinedOr[
        snowflakes.SnowflakeishOr[channels_.GuildVoiceChannel]
    ] = undefined.UNDEFINED,
    afk_timeout: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
    icon: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    owner: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
    splash: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    banner: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    system_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels_.GuildTextChannel]
    ] = undefined.UNDEFINED,
    rules_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels_.GuildTextChannel]
    ] = undefined.UNDEFINED,
    public_updates_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels_.GuildTextChannel]
    ] = undefined.UNDEFINED,
    preferred_locale: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.RESTGuild:
    route = routes.PATCH_GUILD.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;verification_level&#34;, verification_level)
    body.put(&#34;default_message_notifications&#34;, default_message_notifications)
    body.put(&#34;explicit_content_filter&#34;, explicit_content_filter_level)
    body.put(&#34;afk_timeout&#34;, afk_timeout, conversion=time.timespan_to_int)
    body.put(&#34;preferred_locale&#34;, preferred_locale, conversion=str)
    body.put_snowflake(&#34;afk_channel_id&#34;, afk_channel)
    body.put_snowflake(&#34;owner_id&#34;, owner)
    body.put_snowflake(&#34;system_channel_id&#34;, system_channel)
    body.put_snowflake(&#34;rules_channel_id&#34;, rules_channel)
    body.put_snowflake(&#34;public_updates_channel_id&#34;, public_updates_channel)

    tasks: typing.List[asyncio.Task[str]] = []

    if icon is None:
        body.put(&#34;icon&#34;, None)
    elif icon is not undefined.UNDEFINED:
        icon_resource = files.ensure_resource(icon)
        async with icon_resource.stream(executor=self._executor) as stream:
            task = asyncio.create_task(stream.data_uri())
            task.add_done_callback(lambda future: body.put(&#34;icon&#34;, future.result()))
            tasks.append(task)

    if splash is None:
        body.put(&#34;splash&#34;, None)
    elif splash is not undefined.UNDEFINED:
        splash_resource = files.ensure_resource(splash)
        async with splash_resource.stream(executor=self._executor) as stream:
            task = asyncio.create_task(stream.data_uri())
            task.add_done_callback(lambda future: body.put(&#34;splash&#34;, future.result()))
            tasks.append(task)

    if banner is None:
        body.put(&#34;banner&#34;, None)
    elif banner is not undefined.UNDEFINED:
        banner_resource = files.ensure_resource(banner)
        async with banner_resource.stream(executor=self._executor) as stream:
            task = asyncio.create_task(stream.data_uri())
            task.add_done_callback(lambda future: body.put(&#34;banner&#34;, future.result()))
            tasks.append(task)

    await asyncio.gather(*tasks)

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_rest_guild(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_interaction_response" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_interaction_response" href="#hikari.impl.rest.RESTClientImpl.edit_interaction_response" id="hikari.impl.rest.RESTClientImpl.edit_interaction_response">edit_interaction_response</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    content: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    attachment: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    component: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[special_endpoints.ComponentBuilder] = UNDEFINED,
    components: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[special_endpoints.ComponentBuilder]] = UNDEFINED,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    replace_attachments: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_interaction_response -- Edit the initial response to a command interaction …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_interaction_response"
>edit_interaction_response</a></code>
</p>
<p>Edit the initial response to a command interaction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to edit a command response for.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The interaction's token.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message content to update with. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the content will not
be changed. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the content will be removed.</p>
<p>Any other value will be cast to a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> before sending.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and neither the
<code>embed</code> or <code>embeds</code> kwargs are provided or if this is a
<code><a href='../files.html#hikari.files.Resourceish'>Resourceish</a></code> and neither the <code>attachment</code> or
<code>attachments</code> kwargs are provided, the values will be overwritten.
This allows for simpler syntax when sending an embed or an
attachment alone.</p>
</dd>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the attachment to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous attachment, if
present, is not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the
attachment is removed, if present. Otherwise, the new attachment
that was provided will be attached.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]]</code></dt>
<dd>If provided, the attachments to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous attachments, if
present, are not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the
attachments is removed, if present. Otherwise, the new attachments
that were provided will be attached.</dd>
<dt><strong><code>component</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]</code></dt>
<dd>If provided, builder object of the component to set for this message.
This component will replace any previously set components and passing
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> will remove all components.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]]</code></dt>
<dd>If provided, a sequence of the component builder objects set for
this message. These components will replace any previously set
components and passing <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> or an empty sequence will
remove all components.</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the embed to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed(s) are not changed.
If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then any present embeds are removed.
Otherwise, the new embed that was provided will be used as the
replacement.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]]</code></dt>
<dd>If provided, the embeds to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed(s) are not changed.
If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then any present embeds are removed.
Otherwise, the new embeds that were provided will be used as the
replacement.</dd>
<dt><strong><code>replace_attachments</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>
<p>Whether to replace the attachments with the provided ones. Defaults
to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</p>
<p>Note this will also overwrite the embed attachments.</p>
</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message should parse @everyone/@here
mentions.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all user mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all user mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all role mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all role mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Mentioning everyone, roles, or users in message edits currently
will not send a push notification showing a new mention to people
on Discord. It will still highlight in their chat as if they
were mentioned, however.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify one of <code>mentions_everyone</code>, <code>user_mentions</code>, or
<code>role_mentions</code>, then all others will default to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>,
even if they were enabled previously.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all three of
them each time.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The edited message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code>, <code>component</code> and <code>components</code>
or <code>embed</code> and <code>embeds</code> are specified.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If <code>attachments</code>, <code>components</code> or <code>embeds</code> is passed but is not a
sequence.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no attachments or embeds; messages with more than
2000 characters in them, embeds that exceed one of the many embed
limits; too many attachments; attachments that are too large;
invalid image URLs in embeds; too many components.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the interaction or the message are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3422-L3462" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_interaction_response(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    token: str,
    content: undefined.UndefinedNoneOr[typing.Any] = undefined.UNDEFINED,
    *,
    attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
    component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
    components: undefined.UndefinedNoneOr[
        typing.Sequence[special_endpoints.ComponentBuilder]
    ] = undefined.UNDEFINED,
    embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
    embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
    replace_attachments: bool = False,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
    ] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    route = routes.PATCH_INTERACTION_RESPONSE.compile(webhook=application, token=token)
    return await self._edit_message(
        route,
        data_binding.JSONObjectBuilder(),
        no_auth=True,
        content=content,
        attachment=attachment,
        attachments=attachments,
        component=component,
        components=components,
        embed=embed,
        embeds=embeds,
        replace_attachments=replace_attachments,
        mentions_everyone=mentions_everyone,
        user_mentions=user_mentions,
        role_mentions=role_mentions,
        mentions_reply=undefined.UNDEFINED,
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_member" href="#hikari.impl.rest.RESTClientImpl.edit_member" id="hikari.impl.rest.RESTClientImpl.edit_member">edit_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    nick: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]] = UNDEFINED,
    mute: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    deaf: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    voice_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>channels_.GuildVoiceChannel</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.Member'>Member</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_member -- Edit a guild member …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_member"
>edit_member</a></code>
</p>
<p>Edit a guild member.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit. This may be the object
or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>nick</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>
<p>If provided, the new nick for the member. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>,
will remove the members nick.</p>
<p>Requires the <code>MANAGE_NICKNAMES</code> permission.</p>
</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]</code></dt>
<dd>
<p>If provided, the new roles for the member.</p>
<p>Requires the <code>MANAGE_ROLES</code> permission.</p>
</dd>
<dt><strong><code>mute</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If provided, the new server mute state for the member.</p>
<p>Requires the <code>MUTE_MEMBERS</code> permission.</p>
</dd>
<dt><strong><code>deaf</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If provided, the new server deaf state for the member.</p>
<p>Requires the <code>DEAFEN_MEMBERS</code> permission.</p>
</dd>
<dt><strong><code>voice_channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>GuildVoiceChannel</a>]]]</code></dt>
<dd>
<p>If provided, <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> or the object or the ID of
an existing voice channel to move the member to.
If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, will disconnect the member from voice.</p>
<p>Requires the <code>MOVE_MEMBERS</code> permission and the <code>CONNECT</code>
permission in the original voice channel and the target
voice channel.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>If the member is not in a voice channel, this will
take no effect.</p>
</div>
</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code></dt>
<dd>Object of the member that was updated.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing a permission to do an action.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2701-L2729" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    nick: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
    roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
    mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    voice_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels_.GuildVoiceChannel]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.Member:
    route = routes.PATCH_GUILD_MEMBER.compile(guild=guild, user=user)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;nick&#34;, nick)
    body.put(&#34;mute&#34;, mute)
    body.put(&#34;deaf&#34;, deaf)
    body.put_snowflake_array(&#34;roles&#34;, roles)

    if voice_channel is None:
        body.put(&#34;channel_id&#34;, None)
    elif voice_channel is not undefined.UNDEFINED:
        body.put_snowflake(&#34;channel_id&#34;, voice_channel)

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_message" href="#hikari.impl.rest.RESTClientImpl.edit_message" id="hikari.impl.rest.RESTClientImpl.edit_message">edit_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    content: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    attachment: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    component: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[special_endpoints.ComponentBuilder] = UNDEFINED,
    components: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[special_endpoints.ComponentBuilder]] = UNDEFINED,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    replace_attachments: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentions_reply: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    flags: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../messages.html#hikari.messages.MessageFlag'>messages_.MessageFlag</a>] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_message -- Edit an existing message in a given channel …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_message"
>edit_message</a></code>
</p>
<p>Edit an existing message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel to create the message in. This may be
the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to edit. This may be the object or the ID
of an existing message.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message content to update with. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the content will not
be changed. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the content will be removed.</p>
<p>Any other value will be cast to a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> before sending.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and neither the <code>embed</code> or
<code>embeds</code> kwargs are provided or if this is a
<code><a href='../files.html#hikari.files.Resourceish'>Resourceish</a></code> and neither the
<code>attachment</code> or <code>attachments</code> kwargs are provided, the values will
be overwritten. This allows for simpler syntax when sending an
embed or an attachment alone.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the attachment to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous attachment, if
present, is not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the
attachment is removed, if present. Otherwise, the new attachment
that was provided will be attached.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]]</code></dt>
<dd>If provided, the attachments to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous attachments, if
present, are not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the
attachments is removed, if present. Otherwise, the new attachments
that were provided will be attached.</dd>
<dt><strong><code>component</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]</code></dt>
<dd>If provided, builder object of the component to set for this message.
This component will replace any previously set components and passing
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> will remove all components.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]]</code></dt>
<dd>If provided, a sequence of the component builder objects set for
this message. These components will replace any previously set
components and passing <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> or an empty sequence will
remove all components.</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the embed to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed(s) are not changed.
If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then any present embeds are removed.
Otherwise, the new embed that was provided will be used as the
replacement.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]]</code></dt>
<dd>If provided, the embeds to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed(s) are not changed.
If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then any present embeds are removed.
Otherwise, the new embeds that were provided will be used as the
replacement.</dd>
<dt><strong><code>replace_attachments</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>
<p>Whether to replace the attachments with the provided ones. Defaults
to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</p>
<p>Note this will also overwrite the embed attachments.</p>
</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, sanitation for <code>@everyone</code> mentions. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, then <code>@everyone</code>/<code>@here</code> mentions
in the message content will show up as mentioning everyone that can
view the chat.</dd>
<dt><strong><code>mentions_reply</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If provided, whether to mention the author of the message
that is being replied to.</p>
<p>This will not do anything if <code>message</code> is not a reply message.</p>
</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>
<p>If provided, sanitation for user mentions. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all valid user mentions will behave
as mentions. If <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all valid user mentions will not
behave as mentions.</p>
<p>You may alternatively pass a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code> user IDs, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code>-derived objects.</p>
</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>
<p>If provided, sanitation for role mentions. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all valid role mentions will behave
as mentions. If <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all valid role mentions will not
behave as mentions.</p>
<p>You may alternatively pass a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code> role IDs, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code>-derived objects.</p>
</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../messages.html#hikari.messages.MessageFlag'>MessageFlag</a>]</code></dt>
<dd>
<p>If provided, optional flags to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing is changed.</p>
<p>Note that some flags may not be able to be set. Currently the only
flags that can be set are <code>NONE</code> and <code>SUPPRESS_EMBEDS</code>. If you
have <code>MANAGE_MESSAGES</code> permissions, you can use this call to
suppress embeds on another user's message.</p>
</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Mentioning everyone, roles, or users in message edits currently
will not send a push notification showing a new mention to people
on Discord. It will still highlight in their chat as if they
were mentioned, however.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify a non-embed <code>content</code>, <code>mentions_everyone</code>,
<code>mentions_reply</code>, <code>user_mentions</code>, and <code>role_mentions</code> will default
to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> as the message will be re-parsed for mentions.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all
four of them each time.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify one of <code>mentions_everyone</code>, <code>mentions_reply</code>,
<code>user_mentions</code>, or <code>role_mentions</code>, then all others will default to
<code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, even if they were enabled previously.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all
four of them each time.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If the message was not sent by your user, the only parameter
you may provide to this call is the <code>flags</code> parameter. Anything
else will result in a <code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code> being raised.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The edited message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code>, <code>component</code> and <code>components</code>
or <code>embed</code> and <code>embeds</code> are specified.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If <code>attachments</code>, <code>components</code> or <code>embeds</code> is passed but is not a
sequence.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no embeds; messages with more than 2000 characters
in them, embeds that exceed one of the many embed
limits; invalid image URLs in embeds.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>SEND_MESSAGES</code> in the channel; if you try to
change the contents of another user's message; or if you try to edit
the flags on another user's message without the <code>MANAGE_MESSAGES</code>
permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1511-L1554" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
    component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
    components: undefined.UndefinedNoneOr[
        typing.Sequence[special_endpoints.ComponentBuilder]
    ] = undefined.UNDEFINED,
    embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
    embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
    replace_attachments: bool = False,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentions_reply: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
    ] = undefined.UNDEFINED,
    flags: undefined.UndefinedOr[messages_.MessageFlag] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    route = routes.PATCH_CHANNEL_MESSAGE.compile(channel=channel, message=message)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;flags&#34;, flags)
    return await self._edit_message(
        route,
        body,
        content=content,
        attachment=attachment,
        attachments=attachments,
        component=component,
        components=components,
        embed=embed,
        embeds=embeds,
        replace_attachments=replace_attachments,
        mentions_everyone=mentions_everyone,
        mentions_reply=mentions_reply,
        user_mentions=user_mentions,
        role_mentions=role_mentions,
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_my_nick" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_my_nick" href="#hikari.impl.rest.RESTClientImpl.edit_my_nick" id="hikari.impl.rest.RESTClientImpl.edit_my_nick">edit_my_nick</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.Guild'>guilds.Guild</a>],
    nick: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_my_nick -- Edit the associated token's member nick …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_my_nick"
>edit_my_nick</a></code>
</p>
<p>Edit the associated token's member nick.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit. This may be the object
or the ID of an existing guild.</dd>
<dt><strong><code>nick</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The new nick. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>,
will remove the nick.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>CHANGE_NICKNAME</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2731-L2741" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_my_nick(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.Guild],
    nick: typing.Optional[str],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.PATCH_MY_GUILD_NICKNAME.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;nick&#34;, nick)
    await self._request(route, json=body, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_my_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_my_user" href="#hikari.impl.rest.RESTClientImpl.edit_my_user" id="hikari.impl.rest.RESTClientImpl.edit_my_user">edit_my_user</a>(
    *,
    username: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
) -> <a href='../users.html#hikari.users.OwnUser'>OwnUser</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_my_user -- Edit the token's associated user …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_my_user"
>edit_my_user</a></code>
</p>
<p>Edit the token's associated user.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new username.</dd>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new avatar. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>,
the avatar will be removed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.OwnUser'>OwnUser</a></code></dt>
<dd>The edited token's associated user.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>
<p>If any of the fields that are passed have an invalid value.</p>
<p>Discord also returns this on a ratelimit:
<a href="https://github.com/discord/discord-api-docs/issues/1462">https://github.com/discord/discord-api-docs/issues/1462</a></p>
</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1976-L1995" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_my_user(
    self,
    *,
    username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
) -&gt; users.OwnUser:
    route = routes.PATCH_MY_USER.compile()
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;username&#34;, username)

    if avatar is None:
        body.put(&#34;avatar&#34;, None)
    elif avatar is not undefined.UNDEFINED:
        avatar_resource = files.ensure_resource(avatar)
        async with avatar_resource.stream(executor=self._executor) as stream:
            body.put(&#34;avatar&#34;, await stream.data_uri())

    response = await self._request(route, json=body)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_my_user(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_my_voice_state" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_my_voice_state" href="#hikari.impl.rest.RESTClientImpl.edit_my_voice_state" id="hikari.impl.rest.RESTClientImpl.edit_my_voice_state">edit_my_voice_state</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildStageChannel'>channels_.GuildStageChannel</a>],
    *,
    suppress: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    request_to_speak: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../undefined.html#hikari.undefined.UndefinedType'>undefined.UndefinedType</a>, <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>, <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_my_voice_state -- Edit the current user's voice state in a stage channel …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_my_voice_state"
>edit_my_voice_state</a></code>
</p>
<p>Edit the current user's voice state in a stage channel.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The current user has to have already joined the target stage channel
before any calls can be made to this endpoint.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or Id of the guild to edit a voice state in.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildStageChannel'>GuildStageChannel</a>]</code></dt>
<dd>Object or Id of the channel to edit a voice state in.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>suppress</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If specified, whether the user should be allowed to become a speaker
in the target stage channel with <code>builtin.True</code> suppressing them from
becoming one.</dd>
<dt><strong><code>request_to_speak</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../undefined.html#hikari.undefined.UndefinedType'>UndefinedType</a>, <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>, <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a>]</code></dt>
<dd>
<p>Whether to request to speak. This may be one of the following:</p>
<ul>
<li><code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> to indicate that the bot wants to speak.</li>
<li><code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> to remove any previously set request to speak.</li>
<li><code><a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code> to specify when they want their request to
speak timestamp to be set to.</li>
</ul>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>If a datetime from the past is passed then Discord will use the
current time instead.</p>
</div>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If you try to target a non-staging channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MUTE_MEMBERS</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel, message or voice state is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1004-L1026" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_my_voice_state(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    channel: snowflakes.SnowflakeishOr[channels_.GuildStageChannel],
    *,
    suppress: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    request_to_speak: typing.Union[undefined.UndefinedType, bool, datetime.datetime] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.PATCH_MY_GUILD_VOICE_STATE.compile(guild=guild)
    body = data_binding.JSONObjectBuilder()
    body.put_snowflake(&#34;channel_id&#34;, channel)
    body.put(&#34;suppress&#34;, suppress)

    if isinstance(request_to_speak, datetime.datetime):
        body.put(&#34;request_to_speak_timestamp&#34;, request_to_speak.isoformat())

    elif request_to_speak is True:
        body.put(&#34;request_to_speak_timestamp&#34;, time.utc_datetime().isoformat())

    elif request_to_speak is False:
        body.put(&#34;request_to_speak_timestamp&#34;, None)

    await self._request(route, json=body)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_permission_overwrites" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_permission_overwrites" href="#hikari.impl.rest.RESTClientImpl.edit_permission_overwrites" id="hikari.impl.rest.RESTClientImpl.edit_permission_overwrites">edit_permission_overwrites</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels_.GuildChannel</a>],
    target: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>, <a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>, <a href='../channels.html#hikari.channels.PermissionOverwrite'>channels_.PermissionOverwrite</a>],
    *,
    target_type: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.PermissionOverwriteType'>channels_.PermissionOverwriteType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]] = UNDEFINED,
    allow: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    deny: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_permission_overwrites -- Edit permissions for a specific entity in the given guild channel …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_permission_overwrites"
>edit_permission_overwrites</a></code>
</p>
<p>Edit permissions for a specific entity in the given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to edit a permission overwrite in. This may be the
object, or the ID of an existing channel.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>, <a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a>]</code></dt>
<dd>The channel overwrite to edit. This may be the object or the ID of an
existing overwrite.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>target_type</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.PermissionOverwriteType'>PermissionOverwriteType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]]</code></dt>
<dd>If provided, the type of the target to update. If unset, will attempt to get
the type from <code><a href='https://docs.python.org/3/reference/simple_stmts.html#grammar-token-target'>target</a></code>.</dd>
<dt><strong><code>allow</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>Permissions</a>]</code></dt>
<dd>If provided, the new vale of all allowed permissions.</dd>
<dt><strong><code>deny</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>Permissions</a>]</code></dt>
<dd>If provided, the new vale of all disallowed permissions.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If <code>target_type</code> is unset and we were unable to determine the type
from <code><a href='https://docs.python.org/3/reference/simple_stmts.html#grammar-token-target'>target</a></code>.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_PERMISSIONS</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the target is not found if it is
a role.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1042-L1071" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_permission_overwrites(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
    target: typing.Union[
        snowflakes.Snowflakeish, users.PartialUser, guilds.PartialRole, channels_.PermissionOverwrite
    ],
    *,
    target_type: undefined.UndefinedOr[typing.Union[channels_.PermissionOverwriteType, int]] = undefined.UNDEFINED,
    allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    if target_type is undefined.UNDEFINED:
        if isinstance(target, users.PartialUser):
            target_type = channels_.PermissionOverwriteType.MEMBER
        elif isinstance(target, guilds.Role):
            target_type = channels_.PermissionOverwriteType.ROLE
        elif isinstance(target, channels_.PermissionOverwrite):
            target_type = target.type
        else:
            raise TypeError(
                &#34;Cannot determine the type of the target to update. Try specifying &#39;target_type&#39; manually.&#34;
            )

    route = routes.PUT_CHANNEL_PERMISSIONS.compile(channel=channel, overwrite=target)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;type&#34;, target_type)
    body.put(&#34;allow&#34;, allow)
    body.put(&#34;deny&#34;, deny)
    await self._request(route, json=body, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_role" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_role" href="#hikari.impl.rest.RESTClientImpl.edit_role" id="hikari.impl.rest.RESTClientImpl.edit_role">edit_role</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    permissions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    color: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    colour: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    hoist: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentionable: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.Role'>Role</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_role -- Edit a role …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_role"
>edit_role</a></code>
</p>
<p>Edit a role.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit the role in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]</code></dt>
<dd>The role to edit. This may be the object or the
ID of an existing role.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new name for the role.</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>Permissions</a>]</code></dt>
<dd>If provided, the new permissions for the role.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>Colorish</a>]</code></dt>
<dd>If provided, the new color for the role.</dd>
<dt><strong><code>colour</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>Colorish</a>]</code></dt>
<dd>An alias for <code>color</code>.</dd>
<dt><strong><code>hoist</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to hoist the role.</dd>
<dt><strong><code>mentionable</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to make the role mentionable.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.Role'>Role</a></code></dt>
<dd>The edited role.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>color</code> and <code>colour</code> are specified.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or role are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2869-L2897" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_role(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.Role:
    if not undefined.any_undefined(color, colour):
        raise TypeError(&#34;Can not specify &#39;color&#39; and &#39;colour&#39; together.&#34;)

    route = routes.PATCH_GUILD_ROLE.compile(guild=guild, role=role)

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;permissions&#34;, permissions)
    body.put(&#34;color&#34;, color, conversion=colors.Color.of)
    body.put(&#34;color&#34;, colour, conversion=colors.Color.of)
    body.put(&#34;hoist&#34;, hoist)
    body.put(&#34;mentionable&#34;, mentionable)

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_role(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_sticker" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_sticker" href="#hikari.impl.rest.RESTClientImpl.edit_sticker" id="hikari.impl.rest.RESTClientImpl.edit_sticker">edit_sticker</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    sticker: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../stickers.html#hikari.stickers.PartialSticker'>stickers.PartialSticker</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    description: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    tag: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../stickers.html#hikari.stickers.GuildSticker'>stickers.GuildSticker</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_sticker -- Edit a sticker in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_sticker"
>edit_sticker</a></code>
</p>
<p>Edit a sticker in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit the sticker on. This can be a guild object or the
ID of an existing guild.</dd>
<dt><strong><code>sticker</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../stickers.html#hikari.stickers.PartialSticker'>PartialSticker</a>]</code></dt>
<dd>The sticker to edit. This can be a sticker object or the ID of an
existing sticker.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new name for the sticker.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new description for the sticker.</dd>
<dt><strong><code>tag</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new sticker tag.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../stickers.html#hikari.stickers.GuildSticker'>GuildSticker</a></code></dt>
<dd>The edited sticker.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the sticker are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2326-L2344" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_sticker(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    description: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    tag: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; stickers.GuildSticker:
    route = routes.PATCH_GUILD_STICKER.compile(guild=guild, sticker=sticker)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;tags&#34;, tag)
    body.put(&#34;description&#34;, description)

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_guild_sticker(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_template" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_template" href="#hikari.impl.rest.RESTClientImpl.edit_template" id="hikari.impl.rest.RESTClientImpl.edit_template">edit_template</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    template: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../templates.html#hikari.templates.Template'>templates.Template</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    description: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../templates.html#hikari.templates.Template'>templates.Template</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_template -- Modify a guild template …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_template"
>edit_template</a></code>
</p>
<p>Modify a guild template.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit a template in.</dd>
<dt><strong><code>template</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../templates.html#hikari.templates.Template'>Template</a>]</code></dt>
<dd>Object or string code of the template to modify.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The name to set for this template.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The description to set for the template.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../templates.html#hikari.templates.Template'>Template</a></code></dt>
<dd>The object of the edited template.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found or you are missing the <code>MANAGE_GUILD</code>
permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3102-L3118" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_template(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    template: typing.Union[str, templates.Template],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    description: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
) -&gt; templates.Template:
    template = template if isinstance(template, str) else template.code
    route = routes.PATCH_GUILD_TEMPLATE.compile(guild=guild, template=template)
    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put(&#34;description&#34;, description)

    response = await self._request(route, json=body)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_template(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_voice_state" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_voice_state" href="#hikari.impl.rest.RESTClientImpl.edit_voice_state" id="hikari.impl.rest.RESTClientImpl.edit_voice_state">edit_voice_state</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildStageChannel'>channels_.GuildStageChannel</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    suppress: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_voice_state -- Edit an existing voice state in a stage channel …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_voice_state"
>edit_voice_state</a></code>
</p>
<p>Edit an existing voice state in a stage channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or Id of the guild to edit a voice state in.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildStageChannel'>GuildStageChannel</a>]</code></dt>
<dd>Object or Id of the channel to edit a voice state in.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or Id of the user to to edit the voice state of.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>suppress</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If defined, whether the user should be allowed to become a speaker
in the target stage channel.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The target user must already be present in the stage channel before
any calls are made to this endpoint.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If you try to target a non-staging channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MUTE_MEMBERS</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel, message or voice state is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1028-L1040" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_voice_state(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    channel: snowflakes.SnowflakeishOr[channels_.GuildStageChannel],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    suppress: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.PATCH_GUILD_VOICE_STATE.compile(guild=guild, user=user)
    body = data_binding.JSONObjectBuilder()
    body.put_snowflake(&#34;channel_id&#34;, channel)
    body.put(&#34;suppress&#34;, suppress)
    await self._request(route, json=body)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_webhook" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_webhook" href="#hikari.impl.rest.RESTClientImpl.edit_webhook" id="hikari.impl.rest.RESTClientImpl.edit_webhook">edit_webhook</a>(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.PartialWebhook'>webhooks.PartialWebhook</a>],
    *,
    token: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    channel: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.WebhookChannelT'>channels_.WebhookChannelT</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../webhooks.html#hikari.webhooks.PartialWebhook'>webhooks.PartialWebhook</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_webhook -- Edit a webhook …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_webhook"
>edit_webhook</a></code>
</p>
<p>Edit a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.PartialWebhook'>PartialWebhook</a>]</code></dt>
<dd>The webhook to edit. This may be the object or the
ID of an existing webhook.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the webhoook token that will be used to edit
the webhook instead of the token the client was initialized with.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new webhook name.</dd>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new webhook avatar. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, will
remove the webhook avatar.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.WebhookChannelT'>WebhookChannelT</a>]]</code></dt>
<dd>If provided, the text channel to move the webhook to.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../webhooks.html#hikari.webhooks.PartialWebhook'>PartialWebhook</a></code></dt>
<dd>The edited webhook.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not
using a token.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1771-L1801" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.PartialWebhook],
    *,
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.WebhookChannelT]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; webhooks.PartialWebhook:
    if token is undefined.UNDEFINED:
        route = routes.PATCH_WEBHOOK.compile(webhook=webhook)
        no_auth = False
    else:
        route = routes.PATCH_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
        no_auth = True

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;name&#34;, name)
    body.put_snowflake(&#34;channel&#34;, channel)

    if avatar is None:
        body.put(&#34;avatar&#34;, None)
    elif avatar is not undefined.UNDEFINED:
        avatar_resource = files.ensure_resource(avatar)
        async with avatar_resource.stream(executor=self._executor) as stream:
            body.put(&#34;avatar&#34;, await stream.data_uri())

    response = await self._request(route, json=body, reason=reason, no_auth=no_auth)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_webhook(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_webhook_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_webhook_message" href="#hikari.impl.rest.RESTClientImpl.edit_webhook_message" id="hikari.impl.rest.RESTClientImpl.edit_webhook_message">edit_webhook_message</a>(
    webhook: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../webhooks.html#hikari.webhooks.ExecutableWebhook'>webhooks.ExecutableWebhook</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>],
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>],
    content: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    attachment: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    component: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[special_endpoints.ComponentBuilder] = UNDEFINED,
    components: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[special_endpoints.ComponentBuilder]] = UNDEFINED,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    replace_attachments: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_webhook_message -- Edit a message sent by a webhook …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_webhook_message"
>edit_webhook_message</a></code>
</p>
<p>Edit a message sent by a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a>, <a href='../webhooks.html#hikari.webhooks.ExecutableWebhook'>ExecutableWebhook</a>]</code></dt>
<dd>The webhook to execute. This may be the object
or the ID of an existing webhook.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The webhook token.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete. This may be the object or the ID of
an existing message.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message content to update with. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the content will not
be changed. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the content will be removed.</p>
<p>Any other value will be cast to a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> before sending.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and neither the
<code>embed</code> or <code>embeds</code> kwargs are provided or if this is a
<code><a href='../files.html#hikari.files.Resourceish'>Resourceish</a></code> and neither the <code>attachment</code> or
<code>attachments</code> kwargs are provided, the values will be overwritten.
This allows for simpler syntax when sending an embed or an
attachment alone.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the attachment to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous attachment, if
present, is not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the
attachment is removed, if present. Otherwise, the new attachment
that was provided will be attached.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]]</code></dt>
<dd>If provided, the attachments to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous attachments, if
present, are not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the
attachments is removed, if present. Otherwise, the new attachments
that were provided will be attached.</dd>
<dt><strong><code>component</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]</code></dt>
<dd>If provided, builder object of the component to set for this message.
This component will replace any previously set components and passing
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> will remove all components.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]]</code></dt>
<dd>If provided, a sequence of the component builder objects set for
this message. These components will replace any previously set
components and passing <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> or an empty sequence will
remove all components.</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the embed to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed(s) are not changed.
If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then any present embeds are removed.
Otherwise, the new embed that was provided will be used as the
replacement.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]]</code></dt>
<dd>If provided, the embeds to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed(s) are not changed.
If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then any present embeds are removed.
Otherwise, the new embeds that were provided will be used as the
replacement.</dd>
<dt><strong><code>replace_attachments</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>
<p>Whether to replace the attachments with the provided ones. Defaults
to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</p>
<p>Note this will also overwrite the embed attachments.</p>
</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, sanitation for <code>@everyone</code> mentions. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, then <code>@everyone</code>/<code>@here</code> mentions
in the message content will show up as mentioning everyone that can
view the chat.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all user mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all user mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all role mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all role mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Mentioning everyone, roles, or users in message edits currently
will not send a push notification showing a new mention to people
on Discord. It will still highlight in their chat as if they
were mentioned, however.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify a non-embed <code>content</code>, <code>mentions_everyone</code>,
<code>mentions_reply</code>, <code>user_mentions</code>, and <code>role_mentions</code> will default
to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> as the message will be re-parsed for mentions.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all
three of them each time.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify one of <code>mentions_everyone</code>, <code>mentions_reply</code>,
<code>user_mentions</code>, or <code>role_mentions</code>, then all others will default to
<code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, even if they were enabled previously.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all
three of them each time.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The edited message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code>, <code>component</code> and <code>components</code>
or <code>embed</code> and <code>embeds</code> are specified.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If <code>attachments</code>, <code>components</code> or <code>embeds</code> is passed but is not a
sequence.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no attachments or embeds; messages with more than
2000 characters in them, embeds that exceed one of the many embed
limits; too many attachments; attachments that are too large;
invalid image URLs in embeds; too many components.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook or the message are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1884-L1927" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_webhook_message(
    self,
    webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
    token: str,
    message: snowflakes.SnowflakeishOr[messages_.Message],
    content: undefined.UndefinedNoneOr[typing.Any] = undefined.UNDEFINED,
    *,
    attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
    component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
    components: undefined.UndefinedNoneOr[
        typing.Sequence[special_endpoints.ComponentBuilder]
    ] = undefined.UNDEFINED,
    embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
    embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
    replace_attachments: bool = False,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
    ] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
    webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
    route = routes.PATCH_WEBHOOK_MESSAGE.compile(webhook=webhook_id, token=token, message=message)
    return await self._edit_message(
        route,
        data_binding.JSONObjectBuilder(),
        no_auth=True,
        content=content,
        attachment=attachment,
        attachments=attachments,
        component=component,
        components=components,
        embed=embed,
        embeds=embeds,
        replace_attachments=replace_attachments,
        mentions_everyone=mentions_everyone,
        mentions_reply=undefined.UNDEFINED,
        user_mentions=user_mentions,
        role_mentions=role_mentions,
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_welcome_screen" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_welcome_screen" href="#hikari.impl.rest.RESTClientImpl.edit_welcome_screen" id="hikari.impl.rest.RESTClientImpl.edit_welcome_screen">edit_welcome_screen</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    description: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    enabled: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    channels: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.WelcomeChannel'>guilds.WelcomeChannel</a>]] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.WelcomeScreen'>WelcomeScreen</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_welcome_screen -- Edit the welcome screen of a community guild …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_welcome_screen"
>edit_welcome_screen</a></code>
</p>
<p>Edit the welcome screen of a community guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>ID or object of the guild to edit the welcome screen for.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>description</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the description to set for the guild's welcome screen.
This may be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> to unset the description.</dd>
<dt><strong><code>enabled</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, Whether the guild's welcome screen should be enabled.</dd>
<dt><strong><code>channels</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.WelcomeChannel'>WelcomeChannel</a>]]</code></dt>
<dd>
<p>If provided, a sequence of up to 5 public channels to set in this
guild's welcome screen. This may be passed as <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> to
remove all welcome channels</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Custom emojis may only be included in a guild's welcome channels
if it's boost status is tier 2 or above.</p>
</div>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.WelcomeScreen'>WelcomeScreen</a></code></dt>
<dd>The edited guild welcome screen.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If more than 5 welcome channels are provided or if a custom emoji
is included on a welcome channel in a guild that doesn't have tier
2 of above boost status or if a private channel is included as a
welcome channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission, are not part of
the guild or the guild doesn't have access to the community welcome
screen feature.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3009-L3032" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_welcome_screen(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    description: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
    enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    channels: undefined.UndefinedNoneOr[typing.Sequence[guilds.WelcomeChannel]] = undefined.UNDEFINED,
) -&gt; guilds.WelcomeScreen:
    route = routes.PATCH_GUILD_WELCOME_SCREEN.compile(guild=guild)

    body = data_binding.JSONObjectBuilder()

    body.put(&#34;description&#34;, description)
    body.put(&#34;enabled&#34;, enabled)

    if channels is not None:
        body.put_array(&#34;welcome_channels&#34;, channels, conversion=self._entity_factory.serialize_welcome_channel)

    else:
        body.put(&#34;welcome_channels&#34;, None)

    response = await self._request(route, json=body)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_welcome_screen(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.edit_widget" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_widget" href="#hikari.impl.rest.RESTClientImpl.edit_widget" id="hikari.impl.rest.RESTClientImpl.edit_widget">edit_widget</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels_.GuildChannel</a>]] = UNDEFINED,
    enabled: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.GuildWidget'>GuildWidget</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="edit_widget -- Fetch a guilds's widget …" href="../api/rest.html#hikari.api.rest.RESTClient.edit_widget"
>edit_widget</a></code>
</p>
<p>Fetch a guilds's widget.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit the widget in. This can be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]]</code></dt>
<dd>If provided, the channel to set the widget to. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>,
will not set to any.</dd>
<dt><strong><code>enabled</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to enable the widget.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.GuildWidget'>GuildWidget</a></code></dt>
<dd>The edited guild widget.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2982-L3001" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_widget(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    channel: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[channels_.GuildChannel]] = undefined.UNDEFINED,
    enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.GuildWidget:
    route = routes.PATCH_GUILD_WIDGET.compile(guild=guild)

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;enabled&#34;, enabled)
    if channel is None:
        body.put(&#34;channel&#34;, None)
    elif channel is not undefined.UNDEFINED:
        body.put_snowflake(&#34;channel&#34;, channel)

    response = await self._request(route, json=body, reason=reason)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_guild_widget(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.estimate_guild_prune_count" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="estimate_guild_prune_count" href="#hikari.impl.rest.RESTClientImpl.estimate_guild_prune_count" id="hikari.impl.rest.RESTClientImpl.estimate_guild_prune_count">estimate_guild_prune_count</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    days: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    include_roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/functions.html#int'>int</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="estimate_guild_prune_count -- Estimate the guild prune count …" href="../api/rest.html#hikari.api.rest.RESTClient.estimate_guild_prune_count"
>estimate_guild_prune_count</a></code>
</p>
<p>Estimate the guild prune count.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to estimate the guild prune count for. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>days</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, number of days to count prune for.</dd>
<dt><strong><code>include_roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]]</code></dt>
<dd>If provided, the role(s) to include. By default, this endpoint will
not count users with roles. Providing roles using this attribute
will make members with the specified roles also get included into
the count.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The estimated guild prune count.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>KICK_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2907-L2922" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def estimate_guild_prune_count(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    include_roles: undefined.UndefinedOr[snowflakes.SnowflakeishSequence[guilds.PartialRole]] = undefined.UNDEFINED,
) -&gt; int:
    route = routes.GET_GUILD_PRUNE.compile(guild=guild)
    query = data_binding.StringMapBuilder()
    query.put(&#34;days&#34;, days)
    if include_roles is not undefined.UNDEFINED:
        roles = &#34;,&#34;.join(str(int(role)) for role in include_roles)
        query.put(&#34;include_roles&#34;, roles)
    response = await self._request(route, query=query)
    assert isinstance(response, dict)
    return int(response[&#34;pruned&#34;])</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.execute_webhook" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="execute_webhook" href="#hikari.impl.rest.RESTClientImpl.execute_webhook" id="hikari.impl.rest.RESTClientImpl.execute_webhook">execute_webhook</a>(
    webhook: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../webhooks.html#hikari.webhooks.ExecutableWebhook'>webhooks.ExecutableWebhook</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>],
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    content: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    username: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar_url: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    attachment: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    component: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[special_endpoints.ComponentBuilder] = UNDEFINED,
    components: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[special_endpoints.ComponentBuilder]] = UNDEFINED,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    tts: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    flags: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../undefined.html#hikari.undefined.UndefinedType'>undefined.UndefinedType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../messages.html#hikari.messages.MessageFlag'>messages_.MessageFlag</a>] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="execute_webhook -- Execute a webhook …" href="../api/rest.html#hikari.api.rest.RESTClient.execute_webhook"
>execute_webhook</a></code>
</p>
<p>Execute a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a>, <a href='../webhooks.html#hikari.webhooks.ExecutableWebhook'>ExecutableWebhook</a>]</code></dt>
<dd>The webhook to execute. This may be the object
or the ID of an existing webhook.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The webhook token.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message contents. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> nor
no <code>embeds</code> kwarg is provided, then this will instead
update the embed. This allows for simpler syntax when
sending an embed alone.</p>
<p>Likewise, if this is a <code><a href='../files.html#hikari.files.Resource'>Resource</a></code>, then the
content is instead treated as an attachment if no <code>attachment</code> and
no <code>attachments</code> kwargs are provided.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the username to override the webhook's username
for this request.</dd>
<dt><strong><code>avatar_url</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the url of an image to override the webhook's
avatar with for this request.</dd>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>],</code></dt>
<dd>If provided, the message attachment. This can be a resource,
or string of a path on your computer or a URL.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]],</code></dt>
<dd>If provided, the message attachments. These can be resources, or
strings consisting of paths on your computer or URLs.</dd>
<dt><strong><code>component</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]</code></dt>
<dd>If provided, builder object of the component to include in this message.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]]</code></dt>
<dd>If provided, a sequence of the component builder objects to include
in this message.</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the message embed.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]]</code></dt>
<dd>If provided, the message embeds.</dd>
<dt><strong><code>tts</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message will be read out by a screen
reader using Discord's TTS (text-to-speech) system.</dd>
<dt><strong><code>nonce</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>An arbitrary identifier to associate with the message. This
can be used to identify it later in received events. If provided,
this must be less than 32 bytes. If not provided, then
a null value is placed on the message instead. All users can
see this value.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message should parse @everyone/@here
mentions.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all user mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all user mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all role mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all role mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../undefined.html#hikari.undefined.UndefinedType'>UndefinedType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../messages.html#hikari.messages.MessageFlag'>MessageFlag</a>]</code></dt>
<dd>
<p>The flags to set for this webhook message.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>As of writing this can only be set for interaction webhooks
and the only settable flag is EPHEMERAL; this field is just
ignored for non-interaction webhooks.</p>
</div>
</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>As of writing, <code>username</code> and <code>avatar_url</code> are ignored for
interaction webhooks.</p>
</div>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Attachments can be passed as many different things, to aid in
convenience.</p>
<ul>
<li>If a <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> to a valid URL, the
resource at the given URL will be streamed to Discord when
sending the message. Subclasses of
<code><a href='../files.html#hikari.files.WebResource'>WebResource</a></code> such as
<code><a href='../files.html#hikari.files.URL'>URL</a></code>,
<code><a href='../messages.html#hikari.messages.Attachment'>Attachment</a></code>,
<code><a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a></code>,
<code>EmbedResource</code>, etc will also be uploaded this way.
This will use bit-inception, so only a small percentage of the
resource will remain in memory at any one time, thus aiding in
scalability.</li>
<li>If a <code><a href='../files.html#hikari.files.Bytes'>Bytes</a></code> is passed, or a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>
that contains a valid data URI is passed, then this is uploaded
with a randomized file name if not provided.</li>
<li>If a <code><a href='../files.html#hikari.files.File'>File</a></code>, <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> that is an absolute or relative path to a file
on your file system is passed, then this resource is uploaded
as an attachment using non-blocking code internally and streamed
using bit-inception where possible. This depends on the
type of <code><a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a></code> that is being used for
the application (default is a thread pool which supports this
behaviour).</li>
</ul>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The created message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If more than 100 unique objects/entities are passed for
<code>role_mentions</code> or <code>user_mentions</code> or if both <code>attachment</code> and
<code>attachments</code> or <code>embed</code> and <code>embeds</code> are specified.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If <code>attachments</code>, or <code>embeds</code> is passed but is not a sequence.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no attachments or embeds; messages with more than
2000 characters in them, embeds that exceed one of the many embed
limits; too many attachments; attachments that are too large;
invalid image URLs in embeds; too many components.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1818-L1869" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def execute_webhook(
    self,
    webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
    token: str,
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
    component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
    components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
    embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
    embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
    tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[users.PartialUser], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[guilds.PartialRole], bool]
    ] = undefined.UNDEFINED,
    flags: typing.Union[undefined.UndefinedType, int, messages_.MessageFlag] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
    webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
    route = routes.POST_WEBHOOK_WITH_TOKEN.compile(webhook=webhook_id, token=token)

    body = data_binding.JSONObjectBuilder()
    body.put(&#34;username&#34;, username)
    body.put(&#34;avatar_url&#34;, avatar_url)
    body.put(&#34;flags&#34;, flags)
    query = data_binding.StringMapBuilder()
    query.put(&#34;wait&#34;, True)
    return await self._create_message(
        route,
        body,
        query,
        no_auth=True,
        content=content,
        attachment=attachment,
        attachments=attachments,
        component=component,
        components=components,
        embed=embed,
        embeds=embeds,
        tts=tts,
        mentions_everyone=mentions_everyone,
        user_mentions=user_mentions,
        role_mentions=role_mentions,
        mentions_reply=undefined.UNDEFINED,
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_application" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_application" href="#hikari.impl.rest.RESTClientImpl.fetch_application" id="hikari.impl.rest.RESTClientImpl.fetch_application">fetch_application</a>() -> <a href='../applications.html#hikari.applications.Application'>Application</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_application -- Fetch the token's associated application …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_application"
>fetch_application</a></code>
</p>
<p>Fetch the token's associated application.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>This endpoint can only be used with a Bot token. Using this with a
Bearer token will result in a <code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code>.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../applications.html#hikari.applications.Application'>Application</a></code></dt>
<dd>The token's associated application.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2040-L2044" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_application(self) -&gt; applications.Application:
    route = routes.GET_MY_APPLICATION.compile()
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_application(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_application_command" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_application_command" href="#hikari.impl.rest.RESTClientImpl.fetch_application_command" id="hikari.impl.rest.RESTClientImpl.fetch_application_command">fetch_application_command</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    command: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>commands.Command</a>],
    guild: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>]] = UNDEFINED,
) -> <a href='../commands.html#hikari.commands.Command'>commands.Command</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_application_command -- Fetch a command set for an application …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_application_command"
>fetch_application_command</a></code>
</p>
<p>Fetch a command set for an application.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to fetch a command for.</dd>
<dt><strong><code>command</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>Command</a>]</code></dt>
<dd>Object or ID of the command to fetch.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to fetch the command for. If left as
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> then this will return a global command,
otherwise this will return a command made for the specified guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../commands.html#hikari.commands.Command'>Command</a></code></dt>
<dd>Object of the fetched command.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the target command.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the command isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3134-L3150" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_application_command(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    command: snowflakes.SnowflakeishOr[commands.Command],
    guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
) -&gt; commands.Command:
    if guild is undefined.UNDEFINED:
        route = routes.GET_APPLICATION_COMMAND.compile(application=application, command=command)

    else:
        route = routes.GET_APPLICATION_GUILD_COMMAND.compile(application=application, guild=guild, command=command)

    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_command(
        response, guild_id=snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_application_command_permissions" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_application_command_permissions" href="#hikari.impl.rest.RESTClientImpl.fetch_application_command_permissions" id="hikari.impl.rest.RESTClientImpl.fetch_application_command_permissions">fetch_application_command_permissions</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    command: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>commands.Command</a>],
) -> <a href='../commands.html#hikari.commands.GuildCommandPermissions'>commands.GuildCommandPermissions</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_application_command_permissions -- Fetch the permissions registered for a specific command in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_application_command_permissions"
>fetch_application_command_permissions</a></code>
</p>
<p>Fetch the permissions registered for a specific command in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to fetch the command permissions for.</dd>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]]</code></dt>
<dd>Object or ID of the guild to fetch the command permissions for.</dd>
<dt><strong><code>command</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>Command</a>]</code></dt>
<dd>Objecr or ID of the command to fetch the command permissions for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../commands.html#hikari.commands.GuildCommandPermissions'>GuildCommandPermissions</a></code></dt>
<dd>Object of the command permissions set for the specified command.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the provided application's commands or guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the provided application or command isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3268-L3279" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_application_command_permissions(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    command: snowflakes.SnowflakeishOr[commands.Command],
) -&gt; commands.GuildCommandPermissions:
    route = routes.GET_APPLICATION_COMMAND_PERMISSIONS.compile(
        application=application, guild=guild, command=command
    )
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_guild_command_permissions(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_application_commands" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_application_commands" href="#hikari.impl.rest.RESTClientImpl.fetch_application_commands" id="hikari.impl.rest.RESTClientImpl.fetch_application_commands">fetch_application_commands</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    guild: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.Command'>commands.Command</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_application_commands -- Fetch the commands set for an application …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_application_commands"
>fetch_application_commands</a></code>
</p>
<p>Fetch the commands set for an application.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to fetch the commands for.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to fetch the commands for. If left as
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> then this will only return the global
commands, otherwise this will only return the commands set exclusively
for the specific guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.Command'>Command</a>]</code></dt>
<dd>A sequence of the commands declared for the provided application.
This will exclusively either contain the commands set for a specific
guild if <code>guild</code> is provided or the global commands if not.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the target guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the provided application isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3152-L3166" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_application_commands(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
) -&gt; typing.Sequence[commands.Command]:
    if guild is undefined.UNDEFINED:
        route = routes.GET_APPLICATION_COMMANDS.compile(application=application)

    else:
        route = routes.GET_APPLICATION_GUILD_COMMANDS.compile(application=application, guild=guild)

    response = await self._request(route)
    assert isinstance(response, list)
    guild_id = snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
    return [self._entity_factory.deserialize_command(command, guild_id=guild_id) for command in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_application_guild_commands_permissions" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_application_guild_commands_permissions" href="#hikari.impl.rest.RESTClientImpl.fetch_application_guild_commands_permissions" id="hikari.impl.rest.RESTClientImpl.fetch_application_guild_commands_permissions">fetch_application_guild_commands_permissions</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.GuildCommandPermissions'>commands.GuildCommandPermissions</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_application_guild_commands_permissions -- Fetch the command permissions registered in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_application_guild_commands_permissions"
>fetch_application_guild_commands_permissions</a></code>
</p>
<p>Fetch the command permissions registered in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to fetch the command permissions for.</dd>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]]</code></dt>
<dd>Object or ID of the guild to fetch the command permissions for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.GuildCommandPermissions'>GuildCommandPermissions</a>]</code></dt>
<dd>Sequence of the guild command permissions set for the specified guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the provided application's commands or guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the provided application isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3258-L3266" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_application_guild_commands_permissions(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[commands.GuildCommandPermissions]:
    route = routes.GET_APPLICATION_GUILD_COMMANDS_PERMISSIONS.compile(application=application, guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    return [self._entity_factory.deserialize_guild_command_permissions(payload) for payload in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_audit_log" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_audit_log" href="#hikari.impl.rest.RESTClientImpl.fetch_audit_log" id="hikari.impl.rest.RESTClientImpl.fetch_audit_log">fetch_audit_log</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    before: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
    user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]] = UNDEFINED,
    event_type: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../audit_logs.html#hikari.audit_logs.AuditLogEventType'>audit_logs.AuditLogEventType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]] = UNDEFINED,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../audit_logs.html#hikari.audit_logs.AuditLog'>audit_logs.AuditLog</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_audit_log -- Fetch the guild's audit log …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_audit_log"
>fetch_audit_log</a></code>
</p>
<p>Fetch the guild's audit log.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the audit logs from. This can be a
guild object or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>before</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, filter to only actions after this snowflake. If you provide
a datetime object, it will be transformed into a snowflake. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]]</code></dt>
<dd>If provided, the user to filter for.</dd>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../audit_logs.html#hikari.audit_logs.AuditLogEventType'>AuditLogEventType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]]</code></dt>
<dd>If provided, the event type to filter for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../audit_logs.html#hikari.audit_logs.AuditLog'>AuditLog</a>]</code></dt>
<dd>The guild's audit log.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>VIEW_AUDIT_LOG</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the
result is awaited or iterated over. Invoking this function
itself will not raise anything.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2162-L2186" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_audit_log(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
    event_type: undefined.UndefinedOr[typing.Union[audit_logs.AuditLogEventType, int]] = undefined.UNDEFINED,
) -&gt; iterators.LazyIterator[audit_logs.AuditLog]:

    timestamp: undefined.UndefinedOr[str]
    if before is undefined.UNDEFINED:
        timestamp = undefined.UNDEFINED
    elif isinstance(before, datetime.datetime):
        timestamp = str(snowflakes.Snowflake.from_datetime(before))
    else:
        timestamp = str(int(before))

    return special_endpoints_impl.AuditLogIterator(
        entity_factory=self._entity_factory,
        request_call=self._request,
        guild=guild,
        before=timestamp,
        user=user,
        action_type=event_type,
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_authorization" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_authorization" href="#hikari.impl.rest.RESTClientImpl.fetch_authorization" id="hikari.impl.rest.RESTClientImpl.fetch_authorization">fetch_authorization</a>() -> <a href='../applications.html#hikari.applications.AuthorizationInformation'>AuthorizationInformation</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_authorization -- Fetch the token's authorization information …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_authorization"
>fetch_authorization</a></code>
</p>
<p>Fetch the token's authorization information.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>This endpoint can only be used with a Bearer token. Using this
with a Bot token will result in a <code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code>.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../applications.html#hikari.applications.AuthorizationInformation'>AuthorizationInformation</a></code></dt>
<dd>The token's authorization information.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2046-L2050" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_authorization(self) -&gt; applications.AuthorizationInformation:
    route = routes.GET_MY_AUTHORIZATION.compile()
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_authorization_information(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_available_sticker_packs" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_available_sticker_packs" href="#hikari.impl.rest.RESTClientImpl.fetch_available_sticker_packs" id="hikari.impl.rest.RESTClientImpl.fetch_available_sticker_packs">fetch_available_sticker_packs</a>() -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../stickers.html#hikari.stickers.StickerPack'>stickers.StickerPack</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_available_sticker_packs -- Fetch the available sticker packs …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_available_sticker_packs"
>fetch_available_sticker_packs</a></code>
</p>
<p>Fetch the available sticker packs.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../stickers.html#hikari.stickers.StickerPack'>StickerPack</a>]</code></dt>
<dd>The available sticker packs.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2260-L2267" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_available_sticker_packs(self) -&gt; typing.Sequence[stickers.StickerPack]:
    route = routes.GET_STICKER_PACKS.compile()
    response = await self._request(route, no_auth=True)
    assert isinstance(response, dict)
    return [
        self._entity_factory.deserialize_sticker_pack(sticker_pack_payload)
        for sticker_pack_payload in response[&#34;sticker_packs&#34;]
    ]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_ban" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_ban" href="#hikari.impl.rest.RESTClientImpl.fetch_ban" id="hikari.impl.rest.RESTClientImpl.fetch_ban">fetch_ban</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='../guilds.html#hikari.guilds.GuildBan'>GuildBan</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_ban -- Fetch the guild's ban info for a user …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_ban"
>fetch_ban</a></code>
</p>
<p>Fetch the guild's ban info for a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the ban from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to fetch the ban of. This may be the
object or the ID of an existing user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.GuildBan'>GuildBan</a></code></dt>
<dd>The requested ban info.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found or if the user
is not banned.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2804-L2812" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_ban(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
) -&gt; guilds.GuildBan:
    route = routes.GET_GUILD_BAN.compile(guild=guild, user=user)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_guild_member_ban(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_bans" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_bans" href="#hikari.impl.rest.RESTClientImpl.fetch_bans" id="hikari.impl.rest.RESTClientImpl.fetch_bans">fetch_bans</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> Sequence[<a href='../guilds.html#hikari.guilds.GuildBan'>GuildBan</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_bans -- Fetch the bans of a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_bans"
>fetch_bans</a></code>
</p>
<p>Fetch the bans of a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the bans from. This may be the
object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.GuildBan'>GuildBan</a>]</code></dt>
<dd>The requested bans.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2814-L2820" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_bans(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; typing.Sequence[guilds.GuildBan]:
    route = routes.GET_GUILD_BANS.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    return [self._entity_factory.deserialize_guild_member_ban(ban_payload) for ban_payload in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel" href="#hikari.impl.rest.RESTClientImpl.fetch_channel" id="hikari.impl.rest.RESTClientImpl.fetch_channel">fetch_channel</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels_.PartialChannel</a>],
) -> <a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_channel -- Fetch a channel …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_channel"
>fetch_channel</a></code>
</p>
<p>Fetch a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>The channel to fetch. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code></dt>
<dd>
<p>The channel. This will be a <em>derivative</em> of
<code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code>, depending on the type of
channel you request for.</p>
<p>This means that you may get one of
<code><a href='../channels.html#hikari.channels.DMChannel'>DMChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GroupDMChannel'>GroupDMChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildVoiceChannel'>GuildVoiceChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildStoreChannel'>GuildStoreChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a></code>.</p>
<p>Likewise, the <code><a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a></code> can be used to
determine if a channel is guild-bound, and
<code><a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a></code> can be used to determine
if the channel provides textual functionality to the application.</p>
<p>You can check for these using the <code><a href='https://docs.python.org/3/library/functions.html#isinstance'>isinstance</a></code>
builtin function.</p>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGES</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L923-L934" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel(
    self, channel: snowflakes.SnowflakeishOr[channels_.PartialChannel]
) -&gt; channels_.PartialChannel:
    route = routes.GET_CHANNEL.compile(channel=channel)
    response = await self._request(route)
    assert isinstance(response, dict)
    result = self._entity_factory.deserialize_channel(response)

    if self._cache and isinstance(result, channels_.DMChannel):
        self._cache.set_dm_channel_id(result.recipient.id, result.id)

    return result</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_channel_invites" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel_invites" href="#hikari.impl.rest.RESTClientImpl.fetch_channel_invites" id="hikari.impl.rest.RESTClientImpl.fetch_channel_invites">fetch_channel_invites</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels_.GuildChannel</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_channel_invites -- Fetch all invites pointing to the given guild channel …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_channel_invites"
>fetch_channel_invites</a></code>
</p>
<p>Fetch all invites pointing to the given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to fetch the invites from. This may be a channel
object, or the ID of an existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>The invites pointing to the given guild channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found in any guilds you are a member of.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1083-L1089" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel_invites(
    self, channel: snowflakes.SnowflakeishOr[channels_.GuildChannel]
) -&gt; typing.Sequence[invites.InviteWithMetadata]:
    route = routes.GET_CHANNEL_INVITES.compile(channel=channel)
    response = await self._request(route)
    assert isinstance(response, list)
    return [self._entity_factory.deserialize_invite_with_metadata(invite_payload) for invite_payload in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_channel_webhooks" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel_webhooks" href="#hikari.impl.rest.RESTClientImpl.fetch_channel_webhooks" id="hikari.impl.rest.RESTClientImpl.fetch_channel_webhooks">fetch_channel_webhooks</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.WebhookChannelT'>channels_.WebhookChannelT</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.PartialWebhook'>webhooks.PartialWebhook</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_channel_webhooks -- Fetch all channel webhooks …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_channel_webhooks"
>fetch_channel_webhooks</a></code>
</p>
<p>Fetch all channel webhooks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.WebhookChannelT'>WebhookChannelT</a>]</code></dt>
<dd>The channel to fetch the webhooks for. This may be an instance of any
of the classes which are valid for <code><a href='../channels.html#hikari.channels.WebhookChannelT'>WebhookChannelT</a></code>
or the ID of an existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.PartialWebhook'>PartialWebhook</a>]</code></dt>
<dd>The fetched webhooks.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1753-L1760" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel_webhooks(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.WebhookChannelT],
) -&gt; typing.Sequence[webhooks.PartialWebhook]:
    route = routes.GET_CHANNEL_WEBHOOKS.compile(channel=channel)
    response = await self._request(route)
    assert isinstance(response, list)
    return [self._entity_factory.deserialize_webhook(webhook_pl) for webhook_pl in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_emoji" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_emoji" href="#hikari.impl.rest.RESTClientImpl.fetch_emoji" id="hikari.impl.rest.RESTClientImpl.fetch_emoji">fetch_emoji</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    emoji: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
) -> <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_emoji -- Fetch a guild emoji …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_emoji"
>fetch_emoji</a></code>
</p>
<p>Fetch a guild emoji.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the emoji from. This can be a
guild object or the ID of an existing guild.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]</code></dt>
<dd>The emoji to fetch. This can be a <code><a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a></code>
or the ID of an existing emoji.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a></code></dt>
<dd>The requested emoji.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the emoji are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2188-L2196" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
) -&gt; emojis.KnownCustomEmoji:
    route = routes.GET_GUILD_EMOJI.compile(guild=guild, emoji=emoji)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_known_custom_emoji(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_gateway_bot_info" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_gateway_bot_info" href="#hikari.impl.rest.RESTClientImpl.fetch_gateway_bot_info" id="hikari.impl.rest.RESTClientImpl.fetch_gateway_bot_info">fetch_gateway_bot_info</a>() -> <a href='../sessions.html#hikari.sessions.GatewayBotInfo'>sessions.GatewayBotInfo</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_gateway_bot_info -- Fetch the gateway gateway info for the bot …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_gateway_bot_info"
>fetch_gateway_bot_info</a></code>
</p>
<p>Fetch the gateway gateway info for the bot.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../sessions.html#hikari.sessions.GatewayBotInfo'>GatewayBotInfo</a></code></dt>
<dd>The gateway bot information.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1949-L1953" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_gateway_bot_info(self) -&gt; sessions.GatewayBotInfo:
    route = routes.GET_GATEWAY_BOT.compile()
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_gateway_bot_info(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_gateway_url" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_gateway_url" href="#hikari.impl.rest.RESTClientImpl.fetch_gateway_url" id="hikari.impl.rest.RESTClientImpl.fetch_gateway_url">fetch_gateway_url</a>() -> <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_gateway_url -- Fetch the gateway url …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_gateway_url"
>fetch_gateway_url</a></code>
</p>
<p>Fetch the gateway url.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This endpoint does not require any valid authorization.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1940-L1947" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_gateway_url(self) -&gt; str:
    route = routes.GET_GATEWAY.compile()
    # This doesn&#39;t need authorization.
    response = await self._request(route, no_auth=True)
    assert isinstance(response, dict)
    url = response[&#34;url&#34;]
    assert isinstance(url, str)
    return url</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild" href="#hikari.impl.rest.RESTClientImpl.fetch_guild" id="hikari.impl.rest.RESTClientImpl.fetch_guild">fetch_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../guilds.html#hikari.guilds.RESTGuild'>RESTGuild</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_guild -- Fetch a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild"
>fetch_guild</a></code>
</p>
<p>Fetch a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch. This can be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.RESTGuild'>RESTGuild</a></code></dt>
<dd>The requested guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2361-L2367" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.RESTGuild:
    route = routes.GET_GUILD.compile(guild=guild)
    query = data_binding.StringMapBuilder()
    query.put(&#34;with_counts&#34;, True)
    response = await self._request(route, query=query)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_rest_guild(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_guild_channels" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_channels" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_channels" id="hikari.impl.rest.RESTClientImpl.fetch_guild_channels">fetch_guild_channels</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> Sequence[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_guild_channels -- Fetch the channels in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild_channels"
>fetch_guild_channels</a></code>
</p>
<p>Fetch the channels in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the channels from. This may be the
object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The requested channels.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2460-L2468" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_channels(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; typing.Sequence[channels_.GuildChannel]:
    route = routes.GET_GUILD_CHANNELS.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    channel_sequence = [self._entity_factory.deserialize_channel(channel_payload) for channel_payload in response]
    # Will always be guild channels unless Discord messes up severely on something!
    return typing.cast(&#34;typing.Sequence[channels_.GuildChannel]&#34;, channel_sequence)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_guild_emojis" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_emojis" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_emojis" id="hikari.impl.rest.RESTClientImpl.fetch_guild_emojis">fetch_guild_emojis</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> Sequence[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_guild_emojis -- Fetch the emojis of a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild_emojis"
>fetch_guild_emojis</a></code>
</p>
<p>Fetch the emojis of a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the emojis from. This can be a
guild object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>The requested emojis.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2198-L2208" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_emojis(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; typing.Sequence[emojis.KnownCustomEmoji]:
    route = routes.GET_GUILD_EMOJIS.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    guild_id = snowflakes.Snowflake(guild)
    return [
        self._entity_factory.deserialize_known_custom_emoji(emoji_payload, guild_id=guild_id)
        for emoji_payload in response
    ]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_guild_invites" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_invites" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_invites" id="hikari.impl.rest.RESTClientImpl.fetch_guild_invites">fetch_guild_invites</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_guild_invites -- Fetch the guild's invites …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild_invites"
>fetch_guild_invites</a></code>
</p>
<p>Fetch the guild's invites.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the invites for. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>The invites for the guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2954-L2961" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_invites(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[invites.InviteWithMetadata]:
    route = routes.GET_GUILD_INVITES.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    return [self._entity_factory.deserialize_invite_with_metadata(invite_payload) for invite_payload in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_guild_preview" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_preview" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_preview" id="hikari.impl.rest.RESTClientImpl.fetch_guild_preview">fetch_guild_preview</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../guilds.html#hikari.guilds.GuildPreview'>GuildPreview</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_guild_preview -- Fetch a guild preview …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild_preview"
>fetch_guild_preview</a></code>
</p>
<p>Fetch a guild preview.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the preview of. This can be a
guild object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.GuildPreview'>GuildPreview</a></code></dt>
<dd>The requested guild preview.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will only work for guilds you are a part of or are public.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found or you are not part of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2369-L2373" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_preview(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildPreview:
    route = routes.GET_GUILD_PREVIEW.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_guild_preview(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_guild_sticker" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_sticker" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_sticker" id="hikari.impl.rest.RESTClientImpl.fetch_guild_sticker">fetch_guild_sticker</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    sticker: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../stickers.html#hikari.stickers.PartialSticker'>stickers.PartialSticker</a>],
) -> <a href='../stickers.html#hikari.stickers.GuildSticker'>stickers.GuildSticker</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_guild_sticker -- Fetch a guild sticker …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild_sticker"
>fetch_guild_sticker</a></code>
</p>
<p>Fetch a guild sticker.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[stickers.PartialGuild]</code></dt>
<dd>The guild the sticker is in. This can be a guild object or the
ID of an existing guild.</dd>
<dt><strong><code>sticker</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../stickers.html#hikari.stickers.PartialSticker'>stickers.PartialSticker</a>]</code></dt>
<dd>The sticker to fetch. This can be a sticker object or the
ID of an existing sticker.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../stickers.html#hikari.stickers.GuildSticker'>GuildSticker</a></code></dt>
<dd>The requested sticker.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the sticker are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2292-L2300" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_sticker(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
) -&gt; stickers.GuildSticker:
    route = routes.GET_GUILD_STICKER.compile(guild=guild, sticker=sticker)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_guild_sticker(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_guild_stickers" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_stickers" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_stickers" id="hikari.impl.rest.RESTClientImpl.fetch_guild_stickers">fetch_guild_stickers</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../stickers.html#hikari.stickers.GuildSticker'>stickers.GuildSticker</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_guild_stickers -- Fetch a standard sticker …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild_stickers"
>fetch_guild_stickers</a></code>
</p>
<p>Fetch a standard sticker.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[stickers.PartialGuild]</code></dt>
<dd>The guild to request stickers for. This can be a guild object or the
ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../stickers.html#hikari.stickers.GuildSticker'>GuildSticker</a>]</code></dt>
<dd>The requested stickers.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2282-L2290" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_stickers(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; typing.Sequence[stickers.GuildSticker]:
    route = routes.GET_GUILD_STICKERS.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    return [
        self._entity_factory.deserialize_guild_sticker(guild_sticker_payload) for guild_sticker_payload in response
    ]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_guild_templates" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_templates" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_templates" id="hikari.impl.rest.RESTClientImpl.fetch_guild_templates">fetch_guild_templates</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../templates.html#hikari.templates.Template'>templates.Template</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_guild_templates -- Fetch the templates for a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild_templates"
>fetch_guild_templates</a></code>
</p>
<p>Fetch the templates for a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The object or ID of the guild to get the templates for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../templates.html#hikari.templates.Template'>Template</a>]</code></dt>
<dd>A sequence of the found template objects.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found or are missing the <code>MANAGE_GUILD</code>
permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3047-L3053" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_templates(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; typing.Sequence[templates.Template]:
    route = routes.GET_GUILD_TEMPLATES.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    return [self._entity_factory.deserialize_template(template_payload) for template_payload in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_guild_voice_regions" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_voice_regions" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_voice_regions" id="hikari.impl.rest.RESTClientImpl.fetch_guild_voice_regions">fetch_guild_voice_regions</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>voices.VoiceRegion</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_guild_voice_regions -- Fetch the available voice regions for a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild_voice_regions"
>fetch_guild_voice_regions</a></code>
</p>
<p>Fetch the available voice regions for a guild.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Unlike <code>RESTClient.fetch_voice_regions</code>, this will
return the VIP regions if the guild has access to them.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the voice regions for. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>VoiceRegion</a>]</code></dt>
<dd>The available voice regions for the guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2943-L2952" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_voice_regions(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[voices.VoiceRegion]:
    route = routes.GET_GUILD_VOICE_REGIONS.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    return [
        self._entity_factory.deserialize_voice_region(voice_region_payload) for voice_region_payload in response
    ]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_guild_webhooks" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_webhooks" href="#hikari.impl.rest.RESTClientImpl.fetch_guild_webhooks" id="hikari.impl.rest.RESTClientImpl.fetch_guild_webhooks">fetch_guild_webhooks</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.PartialWebhook'>webhooks.PartialWebhook</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_guild_webhooks -- Fetch all guild webhooks …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_guild_webhooks"
>fetch_guild_webhooks</a></code>
</p>
<p>Fetch all guild webhooks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the webhooks for. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.PartialWebhook'>PartialWebhook</a>]</code></dt>
<dd>The fetched webhooks.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1762-L1769" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_webhooks(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[webhooks.PartialWebhook]:
    route = routes.GET_GUILD_WEBHOOKS.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    return [self._entity_factory.deserialize_webhook(webhook_payload) for webhook_payload in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_integrations" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_integrations" href="#hikari.impl.rest.RESTClientImpl.fetch_integrations" id="hikari.impl.rest.RESTClientImpl.fetch_integrations">fetch_integrations</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> Sequence[<a href='../guilds.html#hikari.guilds.Integration'>Integration</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_integrations -- Fetch the guild's integrations …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_integrations"
>fetch_integrations</a></code>
</p>
<p>Fetch the guild's integrations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the integrations for. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.Integration'>Integration</a>]</code></dt>
<dd>The integrations for the guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2963-L2974" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_integrations(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[guilds.Integration]:
    route = routes.GET_GUILD_INTEGRATIONS.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    guild_id = snowflakes.Snowflake(guild)
    return [
        self._entity_factory.deserialize_integration(integration_payload, guild_id=guild_id)
        for integration_payload in response
    ]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_interaction_response" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_interaction_response" href="#hikari.impl.rest.RESTClientImpl.fetch_interaction_response" id="hikari.impl.rest.RESTClientImpl.fetch_interaction_response">fetch_interaction_response</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_interaction_response -- Fetch the initial response for an interaction …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_interaction_response"
>fetch_interaction_response</a></code>
</p>
<p>Fetch the initial response for an interaction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to fetch a command for.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>Token of the interaction to get the initial response for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>Message object of the initial response.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the target interaction.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the initial response isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3329-L3335" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_interaction_response(
    self, application: snowflakes.SnowflakeishOr[guilds.PartialApplication], token: str
) -&gt; messages_.Message:
    route = routes.GET_INTERACTION_RESPONSE.compile(webhook=application, token=token)
    response = await self._request(route, no_auth=True)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_message(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_invite" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_invite" href="#hikari.impl.rest.RESTClientImpl.fetch_invite" id="hikari.impl.rest.RESTClientImpl.fetch_invite">fetch_invite</a>(
    invite: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../invites.html#hikari.invites.InviteCode'>invites.InviteCode</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
) -> <a href='../invites.html#hikari.invites.Invite'>invites.Invite</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_invite -- Fetch an existing invite …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_invite"
>fetch_invite</a></code>
</p>
<p>Fetch an existing invite.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../invites.html#hikari.invites.InviteCode'>InviteCode</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The invite to fetch. This may be an invite object or
the code of an existing invite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../invites.html#hikari.invites.Invite'>Invite</a></code></dt>
<dd>The requested invite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the invite is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1955-L1962" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_invite(self, invite: typing.Union[invites.InviteCode, str]) -&gt; invites.Invite:
    route = routes.GET_INVITE.compile(invite_code=invite if isinstance(invite, str) else invite.code)
    query = data_binding.StringMapBuilder()
    query.put(&#34;with_counts&#34;, True)
    query.put(&#34;with_expiration&#34;, True)
    response = await self._request(route, query=query)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_invite(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_member" href="#hikari.impl.rest.RESTClientImpl.fetch_member" id="hikari.impl.rest.RESTClientImpl.fetch_member">fetch_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='../guilds.html#hikari.guilds.Member'>Member</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_member -- Fetch a guild member …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_member"
>fetch_member</a></code>
</p>
<p>Fetch a guild member.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to get the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to get the member for. This may be the
object or the ID of an existing user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code></dt>
<dd>The requested member.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2668-L2676" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
) -&gt; guilds.Member:
    route = routes.GET_GUILD_MEMBER.compile(guild=guild, user=user)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_member(response, guild_id=snowflakes.Snowflake(guild))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_members" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_members" href="#hikari.impl.rest.RESTClientImpl.fetch_members" id="hikari.impl.rest.RESTClientImpl.fetch_members">fetch_members</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_members -- Fetch the members from a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_members"
>fetch_members</a></code>
</p>
<p>Fetch the members from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the members of. This may be the
object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>An iterator to fetch the members.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the
result is awaited or iterated over. Invoking this function
itself will not raise anything.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>This endpoint requires the <code>GUILD_MEMBERS</code> intent to be enabled in
the dashboard, not necessarily authenticated with it if using the
gateway.</p>
<p>If you don't have the intents you can use <code>search_members</code> which
doesn't require any intents.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2678-L2683" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_members(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; iterators.LazyIterator[guilds.Member]:
    return special_endpoints_impl.MemberIterator(
        entity_factory=self._entity_factory, request_call=self._request, guild=guild
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_message" href="#hikari.impl.rest.RESTClientImpl.fetch_message" id="hikari.impl.rest.RESTClientImpl.fetch_message">fetch_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_message -- Fetch a specific message in the given text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_message"
>fetch_message</a></code>
</p>
<p>Fetch a specific message in the given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel to fetch messages in. This may be the object or
the ID of an existing message.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to fetch. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The requested message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGE_HISTORY</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the message is not found in the
given text channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1193-L1201" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; messages_.Message:
    route = routes.GET_CHANNEL_MESSAGE.compile(channel=channel, message=message)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_message(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_messages" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_messages" href="#hikari.impl.rest.RESTClientImpl.fetch_messages" id="hikari.impl.rest.RESTClientImpl.fetch_messages">fetch_messages</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    *,
    before: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
    after: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
    around: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_messages -- Browse the message history for a given text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_messages"
>fetch_messages</a></code>
</p>
<p>Browse the message history for a given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel to fetch messages in. This may be the object or
the ID of an existing channel.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>before</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, fetch messages before this snowflake. If you provide
a datetime object, it will be transformed into a snowflake. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
<dt><strong><code>after</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, fetch messages after this snowflake. If you provide
a datetime object, it will be transformed into a snowflake. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
<dt><strong><code>around</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, fetch messages around this snowflake. If you provide
a datetime object, it will be transformed into a snowflake. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>An iterator to fetch the messages.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If you specify more than one of <code>before</code>, <code>after</code>, <code>about</code>.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGE_HISTORY</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint (other than <code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code>) will only
be raised once the result is awaited or iterated over. Invoking
this function itself will not raise anything (other than
<code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code>).</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1150-L1191" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_messages(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    *,
    before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    after: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    around: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
) -&gt; iterators.LazyIterator[messages_.Message]:
    if undefined.count(before, after, around) &lt; 2:
        raise TypeError(&#34;Expected no kwargs, or a maximum of one of &#39;before&#39;, &#39;after&#39;, &#39;around&#39;&#34;)

    timestamp: undefined.UndefinedOr[str]

    if before is not undefined.UNDEFINED:
        direction = &#34;before&#34;
        if isinstance(before, datetime.datetime):
            timestamp = str(snowflakes.Snowflake.from_datetime(before))
        else:
            timestamp = str(int(before))
    elif after is not undefined.UNDEFINED:
        direction = &#34;after&#34;
        if isinstance(after, datetime.datetime):
            timestamp = str(snowflakes.Snowflake.from_datetime(after))
        else:
            timestamp = str(int(after))
    elif around is not undefined.UNDEFINED:
        direction = &#34;around&#34;
        if isinstance(around, datetime.datetime):
            timestamp = str(snowflakes.Snowflake.from_datetime(around))
        else:
            timestamp = str(int(around))
    else:
        direction = &#34;before&#34;
        timestamp = undefined.UNDEFINED

    return special_endpoints_impl.MessageIterator(
        entity_factory=self._entity_factory,
        request_call=self._request,
        channel=channel,
        direction=direction,
        first_id=timestamp,
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_my_connections" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_my_connections" href="#hikari.impl.rest.RESTClientImpl.fetch_my_connections" id="hikari.impl.rest.RESTClientImpl.fetch_my_connections">fetch_my_connections</a>() -> Sequence[<a href='../applications.html#hikari.applications.OwnConnection'>OwnConnection</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_my_connections -- Fetch the token's associated connections …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_my_connections"
>fetch_my_connections</a></code>
</p>
<p>Fetch the token's associated connections.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../applications.html#hikari.applications.OwnConnection'>OwnConnection</a></code></dt>
<dd>The token's associated connections.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1997-L2001" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_my_connections(self) -&gt; typing.Sequence[applications.OwnConnection]:
    route = routes.GET_MY_CONNECTIONS.compile()
    response = await self._request(route)
    assert isinstance(response, list)
    return [self._entity_factory.deserialize_own_connection(connection_payload) for connection_payload in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_my_guilds" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_my_guilds" href="#hikari.impl.rest.RESTClientImpl.fetch_my_guilds" id="hikari.impl.rest.RESTClientImpl.fetch_my_guilds">fetch_my_guilds</a>(
    *,
    newest_first: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
    start_at: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>]] = UNDEFINED,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../applications.html#hikari.applications.OwnGuild'>OwnGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_my_guilds -- Fetch the token's associated guilds …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_my_guilds"
>fetch_my_guilds</a></code>
</p>
<p>Fetch the token's associated guilds.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>newest_first</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Whether to fetch the newest first or the olders first.
Defaults to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</dd>
<dt><strong><code>start_at</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>SearchableSnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]]</code></dt>
<dd>If provided, will start at this snowflake. If you provide
a datetime object, it will be transformed into a snowflake. This
may also be a guild object. In this case, the
date the object was first created will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../applications.html#hikari.applications.OwnGuild'>OwnGuild</a>]</code></dt>
<dd>The token's associated guilds.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the
result is awaited or iterated over. Invoking this function
itself will not raise anything.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2003-L2021" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_my_guilds(
    self,
    *,
    newest_first: bool = False,
    start_at: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
) -&gt; iterators.LazyIterator[applications.OwnGuild]:
    if start_at is undefined.UNDEFINED:
        start_at = snowflakes.Snowflake.max() if newest_first else snowflakes.Snowflake.min()
    elif isinstance(start_at, datetime.datetime):
        start_at = snowflakes.Snowflake.from_datetime(start_at)
    else:
        start_at = int(start_at)

    return special_endpoints_impl.OwnGuildIterator(
        entity_factory=self._entity_factory,
        request_call=self._request,
        newest_first=newest_first,
        first_id=str(start_at),
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_my_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_my_user" href="#hikari.impl.rest.RESTClientImpl.fetch_my_user" id="hikari.impl.rest.RESTClientImpl.fetch_my_user">fetch_my_user</a>() -> <a href='../users.html#hikari.users.OwnUser'>OwnUser</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_my_user -- Fetch the token's associated user …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_my_user"
>fetch_my_user</a></code>
</p>
<p>Fetch the token's associated user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.OwnUser'>OwnUser</a></code></dt>
<dd>The token's associated user.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1970-L1974" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_my_user(self) -&gt; users.OwnUser:
    route = routes.GET_MY_USER.compile()
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_my_user(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_pins" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_pins" href="#hikari.impl.rest.RESTClientImpl.fetch_pins" id="hikari.impl.rest.RESTClientImpl.fetch_pins">fetch_pins</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_pins -- Fetch the pinned messages in this text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_pins"
>fetch_pins</a></code>
</p>
<p>Fetch the pinned messages in this text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel to fetch pins from. This may be the object or
the ID of an existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The pinned messages in this text channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGES</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1126-L1132" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_pins(
    self, channel: snowflakes.SnowflakeishOr[channels_.TextableChannel]
) -&gt; typing.Sequence[messages_.Message]:
    route = routes.GET_CHANNEL_PINS.compile(channel=channel)
    response = await self._request(route)
    assert isinstance(response, list)
    return [self._entity_factory.deserialize_message(message_pl) for message_pl in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_reactions_for_emoji" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_reactions_for_emoji" href="#hikari.impl.rest.RESTClientImpl.fetch_reactions_for_emoji" id="hikari.impl.rest.RESTClientImpl.fetch_reactions_for_emoji">fetch_reactions_for_emoji</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    emoji: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.Emoji'>emojis.Emoji</a>],
    emoji_id: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>]] = UNDEFINED,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../users.html#hikari.users.User'>users.User</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_reactions_for_emoji -- Fetch reactions for an emoji from a message …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_reactions_for_emoji"
>fetch_reactions_for_emoji</a></code>
</p>
<p>Fetch reactions for an emoji from a message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel where the message to delete all reactions from is.
This may be the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete all reaction from. This may be the
object or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a>]</code></dt>
<dd>Object or name of the emoji to get the reactions for.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>emoji_id</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]]</code></dt>
<dd>ID of the custom emoji to get the reactions for.
This should only be provided when a custom emoji's name is passed
for <code>emoji</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>An iterator to fetch the users.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the
result is awaited or iterated over. Invoking this function
itself will not raise anything.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1700-L1713" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_reactions_for_emoji(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    emoji: typing.Union[str, emojis.Emoji],
    emoji_id: undefined.UndefinedOr[snowflakes.SnowflakeishOr[emojis.CustomEmoji]] = undefined.UNDEFINED,
) -&gt; iterators.LazyIterator[users.User]:
    return special_endpoints_impl.ReactorIterator(
        entity_factory=self._entity_factory,
        request_call=self._request,
        channel=channel,
        message=message,
        emoji=self._transform_emoji_to_url_format(emoji, emoji_id),
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_roles" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_roles" href="#hikari.impl.rest.RESTClientImpl.fetch_roles" id="hikari.impl.rest.RESTClientImpl.fetch_roles">fetch_roles</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> Sequence[<a href='../guilds.html#hikari.guilds.Role'>Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_roles -- Fetch the roles of a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_roles"
>fetch_roles</a></code>
</p>
<p>Fetch the roles of a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the roles from. This may be the
object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>The requested roles.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2822-L2830" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_roles(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[guilds.Role]:
    route = routes.GET_GUILD_ROLES.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, list)
    guild_id = snowflakes.Snowflake(guild)
    return [self._entity_factory.deserialize_role(role_payload, guild_id=guild_id) for role_payload in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_sticker" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_sticker" href="#hikari.impl.rest.RESTClientImpl.fetch_sticker" id="hikari.impl.rest.RESTClientImpl.fetch_sticker">fetch_sticker</a>(
    sticker: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../stickers.html#hikari.stickers.PartialSticker'>stickers.PartialSticker</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../stickers.html#hikari.stickers.StandardSticker'>stickers.StandardSticker</a>, <a href='../stickers.html#hikari.stickers.GuildSticker'>stickers.GuildSticker</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_sticker -- Fetch a sticker …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_sticker"
>fetch_sticker</a></code>
</p>
<p>Fetch a sticker.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sticker</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../stickers.html#hikari.stickers.PartialSticker'>stickers.PartialSticker</a>]</code></dt>
<dd>The sticker to fetch. This can be a sticker object or the
ID of an existing sticker.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../stickers.html#hikari.stickers.GuildSticker'>GuildSticker</a>, <a href='../stickers.html#hikari.stickers.StandardSticker'>StandardSticker</a>]</code></dt>
<dd>The requested sticker.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the sticker is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2269-L2280" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_sticker(
    self,
    sticker: snowflakes.SnowflakeishOr[stickers.PartialSticker],
) -&gt; typing.Union[stickers.StandardSticker, stickers.GuildSticker]:
    route = routes.GET_STICKER.compile(sticker=sticker)
    response = await self._request(route)
    assert isinstance(response, dict)
    return (
        self._entity_factory.deserialize_guild_sticker(response)
        if &#34;guild_id&#34; in response
        else self._entity_factory.deserialize_standard_sticker(response)
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_template" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_template" href="#hikari.impl.rest.RESTClientImpl.fetch_template" id="hikari.impl.rest.RESTClientImpl.fetch_template">fetch_template</a>(
    template: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../templates.html#hikari.templates.Template'>templates.Template</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
) -> <a href='../templates.html#hikari.templates.Template'>templates.Template</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_template -- Fetch a guild template …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_template"
>fetch_template</a></code>
</p>
<p>Fetch a guild template.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>template</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../templates.html#hikari.templates.Template'>Template</a>]</code></dt>
<dd>The object or string code of the template to fetch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../templates.html#hikari.templates.Template'>Template</a></code></dt>
<dd>The object of the found template.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the template was not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3040-L3045" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_template(self, template: typing.Union[templates.Template, str]) -&gt; templates.Template:
    template = template if isinstance(template, str) else template.code
    route = routes.GET_TEMPLATE.compile(template=template)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_template(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_user" href="#hikari.impl.rest.RESTClientImpl.fetch_user" id="hikari.impl.rest.RESTClientImpl.fetch_user">fetch_user</a>(
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='../users.html#hikari.users.User'>User</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_user -- Fetch a user …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_user"
>fetch_user</a></code>
</p>
<p>Fetch a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to fetch. This can be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.User'>User</a></code></dt>
<dd>The requested user</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2156-L2160" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser]) -&gt; users.User:
    route = routes.GET_USER.compile(user=user)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_user(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_vanity_url" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_vanity_url" href="#hikari.impl.rest.RESTClientImpl.fetch_vanity_url" id="hikari.impl.rest.RESTClientImpl.fetch_vanity_url">fetch_vanity_url</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../invites.html#hikari.invites.VanityURL'>invites.VanityURL</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_vanity_url -- Fetch a guild's vanity url …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_vanity_url"
>fetch_vanity_url</a></code>
</p>
<p>Fetch a guild's vanity url.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the vanity url from. This can
be the object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../invites.html#hikari.invites.VanityURL'>VanityURL</a></code></dt>
<dd>The requested invite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3034-L3038" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_vanity_url(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; invites.VanityURL:
    route = routes.GET_GUILD_VANITY_URL.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_vanity_url(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_voice_regions" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_voice_regions" href="#hikari.impl.rest.RESTClientImpl.fetch_voice_regions" id="hikari.impl.rest.RESTClientImpl.fetch_voice_regions">fetch_voice_regions</a>() -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>voices.VoiceRegion</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_voice_regions -- Fetch available voice regions …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_voice_regions"
>fetch_voice_regions</a></code>
</p>
<p>Fetch available voice regions.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This endpoint doesn't return VIP voice regions.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>VoiceRegion</a>]</code></dt>
<dd>The available voice regions.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2148-L2154" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_voice_regions(self) -&gt; typing.Sequence[voices.VoiceRegion]:
    route = routes.GET_VOICE_REGIONS.compile()
    response = await self._request(route)
    assert isinstance(response, list)
    return [
        self._entity_factory.deserialize_voice_region(voice_region_payload) for voice_region_payload in response
    ]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_webhook" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_webhook" href="#hikari.impl.rest.RESTClientImpl.fetch_webhook" id="hikari.impl.rest.RESTClientImpl.fetch_webhook">fetch_webhook</a>(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.PartialWebhook'>webhooks.PartialWebhook</a>],
    *,
    token: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../webhooks.html#hikari.webhooks.PartialWebhook'>webhooks.PartialWebhook</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_webhook -- Fetch an existing webhook …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_webhook"
>fetch_webhook</a></code>
</p>
<p>Fetch an existing webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.PartialWebhook'>PartialWebhook</a>]</code></dt>
<dd>The webhook to fetch. This may be the object or the ID
of an existing webhook.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the webhoook token that will be used to fetch
the webhook instead of the token the client was initialized with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../webhooks.html#hikari.webhooks.PartialWebhook'>PartialWebhook</a></code></dt>
<dd>The requested webhook.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not
using a token.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1736-L1751" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.PartialWebhook],
    *,
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; webhooks.PartialWebhook:
    if token is undefined.UNDEFINED:
        route = routes.GET_WEBHOOK.compile(webhook=webhook)
        no_auth = False
    else:
        route = routes.GET_WEBHOOK_WITH_TOKEN.compile(webhook=webhook, token=token)
        no_auth = True

    response = await self._request(route, no_auth=no_auth)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_webhook(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_webhook_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_webhook_message" href="#hikari.impl.rest.RESTClientImpl.fetch_webhook_message" id="hikari.impl.rest.RESTClientImpl.fetch_webhook_message">fetch_webhook_message</a>(
    webhook: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../webhooks.html#hikari.webhooks.ExecutableWebhook'>webhooks.ExecutableWebhook</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>],
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_webhook_message -- Fetch an old message sent by the webhook …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_webhook_message"
>fetch_webhook_message</a></code>
</p>
<p>Fetch an old message sent by the webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a>, <a href='../webhooks.html#hikari.webhooks.ExecutableWebhook'>ExecutableWebhook</a>]</code></dt>
<dd>The webhook to execute. This may be the object
or the ID of an existing webhook.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The webhook token.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to fetch. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The requested message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found or the webhook's message wasn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1871-L1882" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_webhook_message(
    self,
    webhook: typing.Union[webhooks.ExecutableWebhook, snowflakes.Snowflakeish],
    token: str,
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; messages_.Message:
    # int(ExecutableWebhook) isn&#39;t guaranteed to be valid nor the ID used to execute this entity as a webhook.
    webhook_id = webhook if isinstance(webhook, int) else webhook.webhook_id
    route = routes.GET_WEBHOOK_MESSAGE.compile(webhook=webhook_id, token=token, message=message)
    response = await self._request(route, no_auth=True)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_message(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_welcome_screen" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_welcome_screen" href="#hikari.impl.rest.RESTClientImpl.fetch_welcome_screen" id="hikari.impl.rest.RESTClientImpl.fetch_welcome_screen">fetch_welcome_screen</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../guilds.html#hikari.guilds.WelcomeScreen'>WelcomeScreen</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_welcome_screen -- Fetch a guild's welcome screen …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_welcome_screen"
>fetch_welcome_screen</a></code>
</p>
<p>Fetch a guild's welcome screen.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to fetch the welcome screen for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.WelcomeScreen'>WelcomeScreen</a></code></dt>
<dd>The requested welcome screen.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found or the welcome screen has never been set
for this guild (if the welcome screen has been set for a guild
before and then disabled you should still be able to fetch it).</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3003-L3007" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_welcome_screen(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.WelcomeScreen:
    route = routes.GET_GUILD_WELCOME_SCREEN.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_welcome_screen(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.fetch_widget" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_widget" href="#hikari.impl.rest.RESTClientImpl.fetch_widget" id="hikari.impl.rest.RESTClientImpl.fetch_widget">fetch_widget</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../guilds.html#hikari.guilds.GuildWidget'>GuildWidget</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="fetch_widget -- Fetch a guilds's widget …" href="../api/rest.html#hikari.api.rest.RESTClient.fetch_widget"
>fetch_widget</a></code>
</p>
<p>Fetch a guilds's widget.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the widget from. This can be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.GuildWidget'>GuildWidget</a></code></dt>
<dd>The requested guild widget.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2976-L2980" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_widget(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildWidget:
    route = routes.GET_GUILD_WIDGET.compile(guild=guild)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_guild_widget(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.follow_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="follow_channel" href="#hikari.impl.rest.RESTClientImpl.follow_channel" id="hikari.impl.rest.RESTClientImpl.follow_channel">follow_channel</a>(
    news_channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>channels_.GuildNewsChannel</a>],
    target_channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels_.GuildChannel</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.ChannelFollow'>ChannelFollow</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="follow_channel -- Follow a news channel to send messages to a target channel …" href="../api/rest.html#hikari.api.rest.RESTClient.follow_channel"
>follow_channel</a></code>
</p>
<p>Follow a news channel to send messages to a target channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>news_channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a>]</code></dt>
<dd>The object or ID of the news channel to follow.</dd>
<dt><strong><code>target_channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The object or ID of the channel to target.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.ChannelFollow'>ChannelFollow</a></code></dt>
<dd>Information about the new relationship that was made.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If you try to follow a channel that's not a news channel or if the
target channel has reached it's webhook limit, which is 10 at the
time of writing.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission in the target
channel or are missing the <code>VIEW_CHANNEL</code> permission in the origin
channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the origin or target channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L980-L994" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def follow_channel(
    self,
    news_channel: snowflakes.SnowflakeishOr[channels_.GuildNewsChannel],
    target_channel: snowflakes.SnowflakeishOr[channels_.GuildChannel],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels_.ChannelFollow:
    route = routes.POST_CHANNEL_FOLLOWERS.compile(channel=news_channel)
    body = data_binding.JSONObjectBuilder()
    body.put_snowflake(&#34;webhook_channel_id&#34;, target_channel)

    response = await self._request(route, json=body, reason=reason)

    assert isinstance(response, dict)
    return self._entity_factory.deserialize_channel_follow(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.guild_builder" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="guild_builder" href="#hikari.impl.rest.RESTClientImpl.guild_builder" id="hikari.impl.rest.RESTClientImpl.guild_builder">guild_builder</a>(
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    /,
) -> <a href='special_endpoints.html#hikari.impl.special_endpoints.GuildBuilder'>special_endpoints.GuildBuilder</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="guild_builder -- Make a guild builder to create a guild with …" href="../api/rest.html#hikari.api.rest.RESTClient.guild_builder"
>guild_builder</a></code>
</p>
<p>Make a guild builder to create a guild with.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The new guilds name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.GuildBuilder'>GuildBuilder</a></code></dt>
<dd>The guild builder to use. This will allow to create a guild
later with <code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.GuildBuilder.create'>create</a></code>.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This endpoint can only be used by bots in less than 10 guilds.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value or if you
call this as a bot that's in more than 10 guilds.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once
<code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.GuildBuilder.create'>create</a></code> is called.
Invoking this function itself will not raise any of
the above types.</p>
</div>
<h2 id="see-also">See Also</h2>
<p><code>Guild builder: </code>hikari.api.special_endpoints.GuildBuilder``</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2356-L2359" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def guild_builder(self, name: str, /) -&gt; special_endpoints.GuildBuilder:
    return special_endpoints_impl.GuildBuilder(
        entity_factory=self._entity_factory, executor=self._executor, request_call=self._request, name=name
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.interaction_deferred_builder" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="interaction_deferred_builder" href="#hikari.impl.rest.RESTClientImpl.interaction_deferred_builder" id="hikari.impl.rest.RESTClientImpl.interaction_deferred_builder">interaction_deferred_builder</a>(
    type_: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.ResponseType'>base_interactions.ResponseType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>],
    /,
) -> <a href='special_endpoints.html#hikari.impl.special_endpoints.InteractionDeferredBuilder'>special_endpoints.InteractionDeferredBuilder</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="interaction_deferred_builder -- Create a builder for a deferred message interaction response …" href="../api/rest.html#hikari.api.rest.RESTClient.interaction_deferred_builder"
>interaction_deferred_builder</a></code>
</p>
<p>Create a builder for a deferred message interaction response.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.ResponseType'>ResponseType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>The type of deferred message response this builder is for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.InteractionDeferredBuilder'>InteractionDeferredBuilder</a></code></dt>
<dd>The deferred message interaction response builder object.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3319-L3322" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def interaction_deferred_builder(
    self, type_: typing.Union[base_interactions.ResponseType, int], /
) -&gt; special_endpoints.InteractionDeferredBuilder:
    return special_endpoints_impl.InteractionDeferredBuilder(type=type_)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.interaction_message_builder" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="interaction_message_builder" href="#hikari.impl.rest.RESTClientImpl.interaction_message_builder" id="hikari.impl.rest.RESTClientImpl.interaction_message_builder">interaction_message_builder</a>(
    type_: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.ResponseType'>base_interactions.ResponseType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>],
    /,
) -> <a href='special_endpoints.html#hikari.impl.special_endpoints.InteractionMessageBuilder'>special_endpoints.InteractionMessageBuilder</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="interaction_message_builder -- Create a builder for a message interaction response …" href="../api/rest.html#hikari.api.rest.RESTClient.interaction_message_builder"
>interaction_message_builder</a></code>
</p>
<p>Create a builder for a message interaction response.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../interactions/base_interactions.html#hikari.interactions.base_interactions.ResponseType'>ResponseType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>The type of message response this builder is for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.InteractionMessageBuilder'>InteractionMessageBuilder</a></code></dt>
<dd>The interaction message response builder object.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3324-L3327" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def interaction_message_builder(
    self, type_: typing.Union[base_interactions.ResponseType, int], /
) -&gt; special_endpoints.InteractionMessageBuilder:
    return special_endpoints_impl.InteractionMessageBuilder(type=type_)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.kick_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="kick_member" href="#hikari.impl.rest.RESTClientImpl.kick_user" id="hikari.impl.rest.RESTClientImpl.kick_member">kick_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="kick_member -- Kick a member from a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.kick_user"
>kick_member</a></code>
</p>
<p>Kick a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to kick the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to kick. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>KICK_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2765-L2773" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def kick_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_MEMBER.compile(guild=guild, user=user)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.kick_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="kick_user" href="#hikari.impl.rest.RESTClientImpl.kick_user" id="hikari.impl.rest.RESTClientImpl.kick_user">kick_user</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="kick_user -- Kick a member from a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.kick_user"
>kick_user</a></code>
</p>
<p>Kick a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to kick the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to kick. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>KICK_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2765-L2773" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def kick_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_MEMBER.compile(guild=guild, user=user)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.leave_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="leave_guild" href="#hikari.impl.rest.RESTClientImpl.leave_guild" id="hikari.impl.rest.RESTClientImpl.leave_guild">leave_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="leave_guild -- Leave a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.leave_guild"
>leave_guild</a></code>
</p>
<p>Leave a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to leave. This may be the object or
the ID of an existing guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found or you own the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2023-L2025" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def leave_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /) -&gt; None:
    route = routes.DELETE_MY_GUILD.compile(guild=guild)
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.pin_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="pin_message" href="#hikari.impl.rest.RESTClientImpl.pin_message" id="hikari.impl.rest.RESTClientImpl.pin_message">pin_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="pin_message -- Pin an existing message in the given text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.pin_message"
>pin_message</a></code>
</p>
<p>Pin an existing message in the given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel to pin a message in. This may be the object or
the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to pin. This may be the object or the ID
of an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found, or if the message does not exist in
the given channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1134-L1140" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def pin_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; None:
    route = routes.PUT_CHANNEL_PINS.compile(channel=channel, message=message)
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.refresh_access_token" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="refresh_access_token" href="#hikari.impl.rest.RESTClientImpl.refresh_access_token" id="hikari.impl.rest.RESTClientImpl.refresh_access_token">refresh_access_token</a>(
    client: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    client_secret: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    refresh_token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    scopes: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../applications.html#hikari.applications.OAuth2Scope'>applications.OAuth2Scope</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]]] = UNDEFINED,
) -> <a href='../applications.html#hikari.applications.OAuth2AuthorizationToken'>OAuth2AuthorizationToken</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="refresh_access_token -- Refresh an access token …" href="../api/rest.html#hikari.api.rest.RESTClient.refresh_access_token"
>refresh_access_token</a></code>
</p>
<p>Refresh an access token.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>As of writing this Discord currently ignores any passed scopes,
therefore you should use
<code><a href='../applications.html#hikari.applications.OAuth2AuthorizationToken.scopes'>scopes</a></code> to validate
that the expected scopes were actually authorized here.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to authorize with.</dd>
<dt><strong><code>client_secret</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>Secret of the application to authorize with.</dd>
<dt><strong><code>refresh_token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The refresh token to use.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>scopes</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../applications.html#hikari.applications.OAuth2Scope'>OAuth2Scope</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]]</code></dt>
<dd>The scope of the access request.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../applications.html#hikari.applications.OAuth2AuthorizationToken'>OAuth2AuthorizationToken</a></code></dt>
<dd>Object of the authorized OAuth2 token.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid redirect uri or refresh_token is passed.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>When an client or client secret is passed.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2089-L2109" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def refresh_access_token(
    self,
    client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    client_secret: str,
    refresh_token: str,
    *,
    scopes: undefined.UndefinedOr[
        typing.Sequence[typing.Union[applications.OAuth2Scope, str]]
    ] = undefined.UNDEFINED,
) -&gt; applications.OAuth2AuthorizationToken:
    route = routes.POST_TOKEN.compile()
    form = data_binding.URLEncodedForm()
    form.add_field(&#34;grant_type&#34;, &#34;refresh_token&#34;)
    form.add_field(&#34;refresh_token&#34;, refresh_token)

    if scopes is not undefined.UNDEFINED:
        form.add_field(&#34;scope&#34;, &#34; &#34;.join(scopes))

    response = await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_authorization_token(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.remove_role_from_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="remove_role_from_member" href="#hikari.impl.rest.RESTClientImpl.remove_role_from_member" id="hikari.impl.rest.RESTClientImpl.remove_role_from_member">remove_role_from_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="remove_role_from_member -- Remove a role from a member …" href="../api/rest.html#hikari.api.rest.RESTClient.remove_role_from_member"
>remove_role_from_member</a></code>
</p>
<p>Remove a role from a member.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild where the member is in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to remove the role from. This may be the
object or the ID of an existing user.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]</code></dt>
<dd>The role to remove. This may be the object or the
ID of an existing role.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild, user or role are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2754-L2763" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def remove_role_from_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_MEMBER_ROLE.compile(guild=guild, user=user, role=role)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.reposition_channels" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="reposition_channels" href="#hikari.impl.rest.RESTClientImpl.reposition_channels" id="hikari.impl.rest.RESTClientImpl.reposition_channels">reposition_channels</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    positions: <a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels_.GuildChannel</a>]],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="reposition_channels -- Reposition the channels in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.reposition_channels"
>reposition_channels</a></code>
</p>
<p>Reposition the channels in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to reposition the channels in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]]</code></dt>
<dd>A mapping of of the object or the ID of an existing channel to
the new position, relative to their parent category, if any.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2659-L2666" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def reposition_channels(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    positions: typing.Mapping[int, snowflakes.SnowflakeishOr[channels_.GuildChannel]],
) -&gt; None:
    route = routes.POST_GUILD_CHANNELS.compile(guild=guild)
    body = [{&#34;id&#34;: str(int(channel)), &#34;position&#34;: pos} for pos, channel in positions.items()]
    await self._request(route, json=body)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.reposition_roles" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="reposition_roles" href="#hikari.impl.rest.RESTClientImpl.reposition_roles" id="hikari.impl.rest.RESTClientImpl.reposition_roles">reposition_roles</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    positions: <a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="reposition_roles -- Reposition the roles in a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.reposition_roles"
>reposition_roles</a></code>
</p>
<p>Reposition the roles in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to reposition the roles in. This may be
the object or the ID of an existing guild.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]</code></dt>
<dd>A mapping of the position to the role.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2860-L2867" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def reposition_roles(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    positions: typing.Mapping[int, snowflakes.SnowflakeishOr[guilds.PartialRole]],
) -&gt; None:
    route = routes.POST_GUILD_ROLES.compile(guild=guild)
    body = [{&#34;id&#34;: str(int(role)), &#34;position&#34;: pos} for pos, role in positions.items()]
    await self._request(route, json=body)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.revoke_access_token" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="revoke_access_token" href="#hikari.impl.rest.RESTClientImpl.revoke_access_token" id="hikari.impl.rest.RESTClientImpl.revoke_access_token">revoke_access_token</a>(
    client: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    client_secret: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    token: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../applications.html#hikari.applications.PartialOAuth2Token'>applications.PartialOAuth2Token</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="revoke_access_token -- Revoke an OAuth2 token …" href="../api/rest.html#hikari.api.rest.RESTClient.revoke_access_token"
>revoke_access_token</a></code>
</p>
<p>Revoke an OAuth2 token.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to authorize with.</dd>
<dt><strong><code>client_secret</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>Secret of the application to authorize with.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../applications.html#hikari.applications.PartialOAuth2Token'>PartialOAuth2Token</a>]</code></dt>
<dd>Object or string of the access token to revoke.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>When an client or client secret is passed.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2111-L2120" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def revoke_access_token(
    self,
    client: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    client_secret: str,
    token: typing.Union[str, applications.PartialOAuth2Token],
) -&gt; None:
    route = routes.POST_TOKEN_REVOKE.compile()
    form = data_binding.URLEncodedForm()
    form.add_field(&#34;token&#34;, str(token))
    await self._request(route, form=form, auth=self._gen_oauth2_token(client, client_secret))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.search_members" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="search_members" href="#hikari.impl.rest.RESTClientImpl.search_members" id="hikari.impl.rest.RESTClientImpl.search_members">search_members</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
) -> Sequence[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="search_members -- Search the members in a guild by nickname and username …" href="../api/rest.html#hikari.api.rest.RESTClient.search_members"
>search_members</a></code>
</p>
<p>Search the members in a guild by nickname and username.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The object or ID of the guild to search members in.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The query to match username(s) and nickname(s) against.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>A sequence of the members who matched the provided <code><a href='https://docs.python.org/3/reference/introduction.html#grammar-token-name'>name</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Unlike <code>RESTClient.fetch_members</code> this endpoint isn't paginated and
therefore will return all the members in one go rather than needing
to be asynchronously iterated over.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2685-L2699" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def search_members(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
) -&gt; typing.Sequence[guilds.Member]:
    route = routes.GET_GUILD_MEMBERS_SEARCH.compile(guild=guild)
    query = data_binding.StringMapBuilder()
    query.put(&#34;query&#34;, name)
    query.put(&#34;limit&#34;, 1000)
    response = await self._request(route, query=query)
    assert isinstance(response, list)
    guild_id = snowflakes.Snowflake(guild)
    return [
        self._entity_factory.deserialize_member(member_payload, guild_id=guild_id) for member_payload in response
    ]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.set_application_command_permissions" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="set_application_command_permissions" href="#hikari.impl.rest.RESTClientImpl.set_application_command_permissions" id="hikari.impl.rest.RESTClientImpl.set_application_command_permissions">set_application_command_permissions</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    command: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>commands.Command</a>],
    permissions: <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.CommandPermission'>commands.CommandPermission</a>],
) -> <a href='../commands.html#hikari.commands.GuildCommandPermissions'>commands.GuildCommandPermissions</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="set_application_command_permissions -- Set permissions for a specific command …" href="../api/rest.html#hikari.api.rest.RESTClient.set_application_command_permissions"
>set_application_command_permissions</a></code>
</p>
<p>Set permissions for a specific command.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This overwrites any previously set permissions.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to set the command permissions for.</dd>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]]</code></dt>
<dd>Object or ID of the guild to set the command permissions for.</dd>
<dt><strong><code>command</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>Command</a>]</code></dt>
<dd>Object or ID of the command to set the permissions for.</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.CommandPermission'>CommandPermission</a>]</code></dt>
<dd>Sequence of up to 10 of the permission objects to set.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../commands.html#hikari.commands.GuildCommandPermissions'>GuildCommandPermissions</a></code></dt>
<dd>Object of the set permissions.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the provided application's commands or guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the provided application or command isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3302-L3317" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def set_application_command_permissions(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    command: snowflakes.SnowflakeishOr[commands.Command],
    permissions: typing.Sequence[commands.CommandPermission],
) -&gt; commands.GuildCommandPermissions:
    route = routes.PUT_APPLICATION_COMMAND_PERMISSIONS.compile(
        application=application, guild=guild, command=command
    )
    body = data_binding.JSONObjectBuilder()
    body.put_array(&#34;permissions&#34;, permissions, conversion=self._entity_factory.serialize_command_permission)
    response = await self._request(route, json=body)

    assert isinstance(response, dict)
    return self._entity_factory.deserialize_guild_command_permissions(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.set_application_commands" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="set_application_commands" href="#hikari.impl.rest.RESTClientImpl.set_application_commands" id="hikari.impl.rest.RESTClientImpl.set_application_commands">set_application_commands</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    commands: <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='special_endpoints.html#hikari.impl.special_endpoints.CommandBuilder'>special_endpoints.CommandBuilder</a>],
    guild: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.Command'>commands.Command</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="set_application_commands -- Set the commands for an application …" href="../api/rest.html#hikari.api.rest.RESTClient.set_application_commands"
>set_application_commands</a></code>
</p>
<p>Set the commands for an application.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Any existing commands not included in the provided commands array
will be deleted.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to create a command for.</dd>
<dt><strong><code>commands</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../api/special_endpoints.html#hikari.api.special_endpoints.CommandBuilder'>CommandBuilder</a>]</code></dt>
<dd>A sequence of up to 100 initialised command builder objects of the
commands to set for this the application.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the specific guild to set the commands for.
If left as <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> then this set the global
commands rather than guild specific commands.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.Command'>Command</a>]</code></dt>
<dd>A sequence of the set command objects.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the provided application's commands.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the provided application isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3196-L3211" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def set_application_commands(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    commands: typing.Sequence[special_endpoints.CommandBuilder],
    guild: undefined.UndefinedOr[snowflakes.SnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
) -&gt; typing.Sequence[commands.Command]:
    if guild is undefined.UNDEFINED:
        route = routes.PUT_APPLICATION_COMMANDS.compile(application=application)

    else:
        route = routes.PUT_APPLICATION_GUILD_COMMANDS.compile(application=application, guild=guild)

    response = await self._request(route, json=[command.build(self._entity_factory) for command in commands])
    assert isinstance(response, list)
    guild_id = snowflakes.Snowflake(guild) if guild is not undefined.UNDEFINED else None
    return [self._entity_factory.deserialize_command(payload, guild_id=guild_id) for payload in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.set_application_guild_commands_permissions" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="set_application_guild_commands_permissions" href="#hikari.impl.rest.RESTClientImpl.set_application_guild_commands_permissions" id="hikari.impl.rest.RESTClientImpl.set_application_guild_commands_permissions">set_application_guild_commands_permissions</a>(
    application: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>guilds.PartialApplication</a>],
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    permissions: <a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>commands.Command</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.CommandPermission'>commands.CommandPermission</a>]],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.GuildCommandPermissions'>commands.GuildCommandPermissions</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="set_application_guild_commands_permissions -- Set permissions in a guild for multiple commands …" href="../api/rest.html#hikari.api.rest.RESTClient.set_application_guild_commands_permissions"
>set_application_guild_commands_permissions</a></code>
</p>
<p>Set permissions in a guild for multiple commands.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This overwrites any previously set permissions for the specified
commands.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialApplication'>PartialApplication</a>]</code></dt>
<dd>Object or ID of the application to set the command permissions for.</dd>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]]</code></dt>
<dd>Object or ID of the guild to set the command permissions for.</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../commands.html#hikari.commands.Command'>Command</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.CommandPermission'>CommandPermission</a>]]</code></dt>
<dd>
<p>Mapping of objects and/or IDs of commands to sequences of the commands
to set for the specified guild.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Only a maximum of up to 10 permissions can be set per command.</p>
</div>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../commands.html#hikari.commands.GuildCommandPermissions'>GuildCommandPermissions</a>]</code></dt>
<dd>Sequence of the set guild command permissions.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you cannot access the provided application's commands or guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the provided application or command isn't found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3281-L3300" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def set_application_guild_commands_permissions(
    self,
    application: snowflakes.SnowflakeishOr[guilds.PartialApplication],
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    permissions: typing.Mapping[
        snowflakes.SnowflakeishOr[commands.Command], typing.Sequence[commands.CommandPermission]
    ],
) -&gt; typing.Sequence[commands.GuildCommandPermissions]:
    route = routes.PUT_APPLICATION_GUILD_COMMANDS_PERMISSIONS.compile(application=application, guild=guild)
    body = [
        {
            &#34;id&#34;: str(snowflakes.Snowflake(command)),
            &#34;permissions&#34;: [self._entity_factory.serialize_command_permission(permission) for permission in perms],
        }
        for command, perms in permissions.items()
    ]
    response = await self._request(route, json=body)

    assert isinstance(response, list)
    return [self._entity_factory.deserialize_guild_command_permissions(payload) for payload in response]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.start" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="start" href="#hikari.impl.rest.RESTClientImpl.start" id="hikari.impl.rest.RESTClientImpl.start">start</a>() -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Start the HTTP client.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This must be called within an active event loop.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#RuntimeError'>RuntimeError</a></code></dt>
<dd>If this is called in an environment without an active event loop.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L630-L645" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@typing.final
def start(self) -&gt; None:
    &#34;&#34;&#34;Start the HTTP client.

    !!! note
        This must be called within an active event loop.

    Raises
    ------
    RuntimeError
        If this is called in an environment without an active event loop.
    &#34;&#34;&#34;
    if self._live_attributes:
        raise errors.ComponentStateConflictError(&#34;Cannot start a REST Client which is already alive&#34;)

    self._live_attributes = _LiveAttributes.build(self._max_rate_limit, self._http_settings, self._proxy_settings)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.sync_guild_template" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="sync_guild_template" href="#hikari.impl.rest.RESTClientImpl.sync_guild_template" id="hikari.impl.rest.RESTClientImpl.sync_guild_template">sync_guild_template</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    template: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../templates.html#hikari.templates.Template'>templates.Template</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
) -> <a href='../templates.html#hikari.templates.Template'>templates.Template</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="sync_guild_template -- Create a guild template …" href="../api/rest.html#hikari.api.rest.RESTClient.sync_guild_template"
>sync_guild_template</a></code>
</p>
<p>Create a guild template.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to sync a template in.</dd>
<dt><strong><code>template</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../templates.html#hikari.templates.Template'>Template</a>]</code></dt>
<dd>Object or code of the template to sync.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../templates.html#hikari.templates.Template'>Template</a></code></dt>
<dd>The object of the synced template.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild or are missing the <code>MANAGE_GUILD</code>
permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or template is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L3055-L3064" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def sync_guild_template(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    template: typing.Union[templates.Template, str],
) -&gt; templates.Template:
    template = template if isinstance(template, str) else template.code
    route = routes.PUT_GUILD_TEMPLATE.compile(guild=guild, template=template)
    response = await self._request(route)
    assert isinstance(response, dict)
    return self._entity_factory.deserialize_template(response)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.trigger_typing" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="trigger_typing" href="#hikari.impl.rest.RESTClientImpl.trigger_typing" id="hikari.impl.rest.RESTClientImpl.trigger_typing">trigger_typing</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
) -> <a href='special_endpoints.html#hikari.impl.special_endpoints.TypingIndicator'>special_endpoints.TypingIndicator</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="trigger_typing -- Trigger typing in a text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.trigger_typing"
>trigger_typing</a></code>
</p>
<p>Trigger typing in a text channel.</p>
<p>The result of this call can be awaited to trigger typing once, or
can be used as an async context manager to continually type until the
context manager is left.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-py"># Trigger typing just once.
await rest.trigger_typing(channel)

# Trigger typing repeatedly for 1 minute.
async with rest.trigger_typing(channel):
    await asyncio.sleep(60)
</code></pre>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Sending a message to the channel will cause the typing indicator
to disappear until it is re-triggered.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel to trigger typing in. This may be the object or
the ID of an existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.TypingIndicator'>TypingIndicator</a></code></dt>
<dd>A typing indicator to use.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>SEND_MESSAGES</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the result
is awaited or iterated over. Invoking this function itself will
not raise any of the above types.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1119-L1124" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def trigger_typing(
    self, channel: snowflakes.SnowflakeishOr[channels_.TextableChannel]
) -&gt; special_endpoints.TypingIndicator:
    return special_endpoints_impl.TypingIndicator(
        request_call=self._request, channel=channel, rest_closed_event=self._get_live_attributes().closed_event
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.unban_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="unban_member" href="#hikari.impl.rest.RESTClientImpl.unban_user" id="hikari.impl.rest.RESTClientImpl.unban_member">unban_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="unban_member -- Unban a member from a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.unban_user"
>unban_member</a></code>
</p>
<p>Unban a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to unban the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to unban. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2792-L2800" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def unban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_BAN.compile(guild=guild, user=user)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.unban_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="unban_user" href="#hikari.impl.rest.RESTClientImpl.unban_user" id="hikari.impl.rest.RESTClientImpl.unban_user">unban_user</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="unban_user -- Unban a member from a guild …" href="../api/rest.html#hikari.api.rest.RESTClient.unban_user"
>unban_user</a></code>
</p>
<p>Unban a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to unban the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to unban. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L2792-L2800" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def unban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    route = routes.DELETE_GUILD_BAN.compile(guild=guild, user=user)
    await self._request(route, reason=reason)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.rest.RESTClientImpl.unpin_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="unpin_message" href="#hikari.impl.rest.RESTClientImpl.unpin_message" id="hikari.impl.rest.RESTClientImpl.unpin_message">unpin_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>channels_.TextableChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="../api/rest.html#hikari.api.rest.RESTClient"
>RESTClient</a></code>.<code><a title="unpin_message -- Unpin a given message from a given text channel …" href="../api/rest.html#hikari.api.rest.RESTClient.unpin_message"
>unpin_message</a></code>
</p>
<p>Unpin a given message from a given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>]</code></dt>
<dd>The channel to unpin a message in. This may be the object or
the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to unpin. This may be the object or the ID of an
existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the message is not a pinned message
in the given channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/rest.py#L1142-L1148" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def unpin_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels_.TextableChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; None:
    route = routes.DELETE_CHANNEL_PIN.compile(channel=channel, message=message)
    await self._request(route)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
</dl>
</section>
</div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>