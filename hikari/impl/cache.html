<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.impl.cache API documentation</title>
<meta name="description" content="Basic implementation of a cache for general bots and gateway apps.">
<meta property="og:title" content="hikari.impl.cache module list">
<meta property="og:type" content="website">
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png">
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions">
<meta property="theme-color" content="#ff029a">
<link rel="shortcut icon" type="image/png" href="../../logo.png">
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
text-indent: 100%;
white-space: nowrap;
overflow: hidden;
}
small.smaller {
font-size: 0.50em;
}
html {
height: 100%;
scroll-behavior: smooth;
scrollbar-color: #202324 #454a4d;
}
body {
background-color: #181A1B;
color: #C9C5C0;
height: fit-content;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.container > li {
margin-left: 1em;
margin-top: 2.5em;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
.anchor:target {
background-color: var(--dark);
}
@media screen and (max-width: 990px) {
.anchor:target {
margin-left: -2em;
padding-left: 2em;
}
}
@media screen and (min-width: 990px) {
.anchor:target {
border-radius: 0.5em; !important
margin-right: -2em;
padding-right: 2em;
margin-top: -1em;
padding-top: 1em;
}
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="../../logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small class="smaller">2.0.0.dev102</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
<li class="nav-item"><a class="nav-link active" href="../../hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" action="../../hikari/search.html">
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search" name="q"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.impl -- Basic implementations of application components …" href="index.html"
>impl</a></li>
<li class="breadcrumb-item active"><a href="#">cache</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Basic implementation of a cache for general bots and gateway apps.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="CacheImpl -- In-memory cache implementation …" href="#hikari.impl.cache.CacheImpl"
>CacheImpl</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear -- Clear the full cache." href="#hikari.impl.cache.CacheImpl.clear"
>clear</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_dm_channel_ids -- Remove all the cached DM channel IDs …" href="#hikari.impl.cache.CacheImpl.clear_dm_channel_ids"
>clear_dm_channel_ids</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_emojis -- Remove all the known custom emoji objects from the cache …" href="#hikari.impl.cache.CacheImpl.clear_emojis"
>clear_emojis</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_emojis_for_guild -- Remove the known custom emoji objects cached for a specific guild …" href="#hikari.impl.cache.CacheImpl.clear_emojis_for_guild"
>clear_emojis_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_guild_channels -- Remove all guild channels from the cache …" href="#hikari.impl.cache.CacheImpl.clear_guild_channels"
>clear_guild_channels</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_guild_channels_for_guild -- Remove guild channels from the cache for a specific guild …" href="#hikari.impl.cache.CacheImpl.clear_guild_channels_for_guild"
>clear_guild_channels_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_guilds -- Remove all the guild objects from the cache …" href="#hikari.impl.cache.CacheImpl.clear_guilds"
>clear_guilds</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_invites -- Remove all the invite objects from the cache …" href="#hikari.impl.cache.CacheImpl.clear_invites"
>clear_invites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_invites_for_channel -- Remove the invite objects in the cache for a specific channel …" href="#hikari.impl.cache.CacheImpl.clear_invites_for_channel"
>clear_invites_for_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_invites_for_guild -- Remove the invite objects in the cache for a specific guild …" href="#hikari.impl.cache.CacheImpl.clear_invites_for_guild"
>clear_invites_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_members -- Remove all the guild members in the cache …" href="#hikari.impl.cache.CacheImpl.clear_members"
>clear_members</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_members_for_guild -- Remove the members for a specific guild from the cache …" href="#hikari.impl.cache.CacheImpl.clear_members_for_guild"
>clear_members_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_messages -- Remove all message objects from the cache …" href="#hikari.impl.cache.CacheImpl.clear_messages"
>clear_messages</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_presences -- Remove all the presences in the cache …" href="#hikari.impl.cache.CacheImpl.clear_presences"
>clear_presences</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_presences_for_guild -- Remove the presences in the cache for a specific guild …" href="#hikari.impl.cache.CacheImpl.clear_presences_for_guild"
>clear_presences_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_roles -- Remove all role objects from the cache …" href="#hikari.impl.cache.CacheImpl.clear_roles"
>clear_roles</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_roles_for_guild -- Remove role objects from the cache for a specific guild …" href="#hikari.impl.cache.CacheImpl.clear_roles_for_guild"
>clear_roles_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_voice_states -- Remove all voice state objects from the cache …" href="#hikari.impl.cache.CacheImpl.clear_voice_states"
>clear_voice_states</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_voice_states_for_channel -- Remove the voice state objects cached for a specific channel …" href="#hikari.impl.cache.CacheImpl.clear_voice_states_for_channel"
>clear_voice_states_for_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_voice_states_for_guild -- Clear the voice state objects cached for a specific guild …" href="#hikari.impl.cache.CacheImpl.clear_voice_states_for_guild"
>clear_voice_states_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_dm_channel_id -- Remove a DM channel ID from the cache …" href="#hikari.impl.cache.CacheImpl.delete_dm_channel_id"
>delete_dm_channel_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_emoji -- Remove a known custom emoji from the cache …" href="#hikari.impl.cache.CacheImpl.delete_emoji"
>delete_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_guild -- Remove a guild object from the cache …" href="#hikari.impl.cache.CacheImpl.delete_guild"
>delete_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_guild_channel -- Remove a guild channel from the cache …" href="#hikari.impl.cache.CacheImpl.delete_guild_channel"
>delete_guild_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_invite -- Remove an invite object from the cache …" href="#hikari.impl.cache.CacheImpl.delete_invite"
>delete_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_me -- Remove the own user object from the cache …" href="#hikari.impl.cache.CacheImpl.delete_me"
>delete_me</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_member -- Remove a member object from the cache …" href="#hikari.impl.cache.CacheImpl.delete_member"
>delete_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_message -- Remove a message object from the cache …" href="#hikari.impl.cache.CacheImpl.delete_message"
>delete_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_presence -- Remove a presence from the cache …" href="#hikari.impl.cache.CacheImpl.delete_presence"
>delete_presence</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_role -- Remove a role object form the cache …" href="#hikari.impl.cache.CacheImpl.delete_role"
>delete_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_voice_state -- Remove a voice state object from the cache …" href="#hikari.impl.cache.CacheImpl.delete_voice_state"
>delete_voice_state</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_available_guild -- Get the object of an available guild from the cache …" href="#hikari.impl.cache.CacheImpl.get_available_guild"
>get_available_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_available_guilds_view -- Get a view of the available guild objects in the cache …" href="#hikari.impl.cache.CacheImpl.get_available_guilds_view"
>get_available_guilds_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_dm_channel_id -- Get the DM channel ID for a user …" href="#hikari.impl.cache.CacheImpl.get_dm_channel_id"
>get_dm_channel_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_dm_channel_ids_view -- Get a view of the cached DM channel IDs …" href="#hikari.impl.cache.CacheImpl.get_dm_channel_ids_view"
>get_dm_channel_ids_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_emoji -- Get a known custom emoji from the cache …" href="#hikari.impl.cache.CacheImpl.get_emoji"
>get_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_emojis_view -- Get a view of the known custom emoji objects in the cache …" href="#hikari.impl.cache.CacheImpl.get_emojis_view"
>get_emojis_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_emojis_view_for_guild -- Get a view of the known custom emojis cached for a specific guild …" href="#hikari.impl.cache.CacheImpl.get_emojis_view_for_guild"
>get_emojis_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_guild -- Get a guild from the cache …" href="#hikari.impl.cache.CacheImpl.get_guild"
>get_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_guild_channel -- Get a guild channel from the cache …" href="#hikari.impl.cache.CacheImpl.get_guild_channel"
>get_guild_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_guild_channels_view -- Get a view of the guild channels in the cache …" href="#hikari.impl.cache.CacheImpl.get_guild_channels_view"
>get_guild_channels_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_guild_channels_view_for_guild -- Get a view of the guild channels in the cache for a specific guild …" href="#hikari.impl.cache.CacheImpl.get_guild_channels_view_for_guild"
>get_guild_channels_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_guilds_view -- Get a view of all the guild objects in the cache regardless if availability …" href="#hikari.impl.cache.CacheImpl.get_guilds_view"
>get_guilds_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_invite -- Get an invite object from the cache …" href="#hikari.impl.cache.CacheImpl.get_invite"
>get_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_invites_view -- Get a view of the invite objects in the cache …" href="#hikari.impl.cache.CacheImpl.get_invites_view"
>get_invites_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_invites_view_for_channel -- Get a view of the invite objects in the cache for a specified channel …" href="#hikari.impl.cache.CacheImpl.get_invites_view_for_channel"
>get_invites_view_for_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_invites_view_for_guild -- Get a view of the invite objects in the cache for a specific guild …" href="#hikari.impl.cache.CacheImpl.get_invites_view_for_guild"
>get_invites_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_me -- Get the own user object from the cache …" href="#hikari.impl.cache.CacheImpl.get_me"
>get_me</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_member -- Get a member object from the cache …" href="#hikari.impl.cache.CacheImpl.get_member"
>get_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_members_view -- Get a view of all the members objects in the cache …" href="#hikari.impl.cache.CacheImpl.get_members_view"
>get_members_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_members_view_for_guild -- Get a view of the members cached for a specific guild …" href="#hikari.impl.cache.CacheImpl.get_members_view_for_guild"
>get_members_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_message -- Get a message object from the cache …" href="#hikari.impl.cache.CacheImpl.get_message"
>get_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_messages_view -- Get a view of all the message objects in the cache …" href="#hikari.impl.cache.CacheImpl.get_messages_view"
>get_messages_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_presence -- Get a presence object from the cache …" href="#hikari.impl.cache.CacheImpl.get_presence"
>get_presence</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_presences_view -- Get a view of all the presence objects in the cache …" href="#hikari.impl.cache.CacheImpl.get_presences_view"
>get_presences_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_presences_view_for_guild -- Get a view of the presence objects in the cache for a specific guild …" href="#hikari.impl.cache.CacheImpl.get_presences_view_for_guild"
>get_presences_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_role -- Get a role object from the cache …" href="#hikari.impl.cache.CacheImpl.get_role"
>get_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_roles_view -- Get a view of all the role objects in the cache …" href="#hikari.impl.cache.CacheImpl.get_roles_view"
>get_roles_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_roles_view_for_guild -- Get a view of the roles in the cache for a specific guild …" href="#hikari.impl.cache.CacheImpl.get_roles_view_for_guild"
>get_roles_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_unavailable_guild -- Get the object of a unavailable guild from the cache …" href="#hikari.impl.cache.CacheImpl.get_unavailable_guild"
>get_unavailable_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_unavailable_guilds_view -- Get a view of the unavailable guild objects in the cache …" href="#hikari.impl.cache.CacheImpl.get_unavailable_guilds_view"
>get_unavailable_guilds_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_user -- Get a user object from the cache …" href="#hikari.impl.cache.CacheImpl.get_user"
>get_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_users_view -- Get a view of the user objects in the cache …" href="#hikari.impl.cache.CacheImpl.get_users_view"
>get_users_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_voice_state -- Get a voice state object from the cache …" href="#hikari.impl.cache.CacheImpl.get_voice_state"
>get_voice_state</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_voice_states_view -- Get a view of all the voice state objects in the cache …" href="#hikari.impl.cache.CacheImpl.get_voice_states_view"
>get_voice_states_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_voice_states_view_for_channel -- Get a view of the voice states cached for a specific channel …" href="#hikari.impl.cache.CacheImpl.get_voice_states_view_for_channel"
>get_voice_states_view_for_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_voice_states_view_for_guild -- Get a view of the voice states cached for a specific guild …" href="#hikari.impl.cache.CacheImpl.get_voice_states_view_for_guild"
>get_voice_states_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_dm_channel_id -- Add a DM channel ID to the cache …" href="#hikari.impl.cache.CacheImpl.set_dm_channel_id"
>set_dm_channel_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_emoji -- Add a known custom emoji to the cache …" href="#hikari.impl.cache.CacheImpl.set_emoji"
>set_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_guild -- Add a guild object to the cache …" href="#hikari.impl.cache.CacheImpl.set_guild"
>set_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_guild_availability -- Set whether a cached guild is available or not …" href="#hikari.impl.cache.CacheImpl.set_guild_availability"
>set_guild_availability</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_guild_channel -- Add a guild channel to the cache …" href="#hikari.impl.cache.CacheImpl.set_guild_channel"
>set_guild_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_invite -- Add an invite object to the cache …" href="#hikari.impl.cache.CacheImpl.set_invite"
>set_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_me -- Set the own user object in the cache …" href="#hikari.impl.cache.CacheImpl.set_me"
>set_me</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_member -- Add a member object to the cache …" href="#hikari.impl.cache.CacheImpl.set_member"
>set_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_message -- Add a message object to the cache …" href="#hikari.impl.cache.CacheImpl.set_message"
>set_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_presence -- Add a presence object to the cache …" href="#hikari.impl.cache.CacheImpl.set_presence"
>set_presence</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_role -- Add a role object to the cache …" href="#hikari.impl.cache.CacheImpl.set_role"
>set_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_voice_state -- Add a voice state object to the cache …" href="#hikari.impl.cache.CacheImpl.set_voice_state"
>set_voice_state</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="settings -- " href="#hikari.impl.cache.CacheImpl.settings"
>settings</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_emoji -- Update an emoji object in the cache …" href="#hikari.impl.cache.CacheImpl.update_emoji"
>update_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_guild -- Update a guild in the cache …" href="#hikari.impl.cache.CacheImpl.update_guild"
>update_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_guild_channel -- Update a guild channel in the cache, …" href="#hikari.impl.cache.CacheImpl.update_guild_channel"
>update_guild_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_invite -- Update an invite in the cache …" href="#hikari.impl.cache.CacheImpl.update_invite"
>update_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_me -- Update the own user entry in the cache …" href="#hikari.impl.cache.CacheImpl.update_me"
>update_me</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_member -- Update a member in the cache …" href="#hikari.impl.cache.CacheImpl.update_member"
>update_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_message -- Update a message in the cache …" href="#hikari.impl.cache.CacheImpl.update_message"
>update_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_presence -- Update a presence object in the cache …" href="#hikari.impl.cache.CacheImpl.update_presence"
>update_presence</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_role -- Update a role in the cache …" href="#hikari.impl.cache.CacheImpl.update_role"
>update_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_voice_state -- Update a voice state object in the cache …" href="#hikari.impl.cache.CacheImpl.update_voice_state"
>update_voice_state</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1-L1640" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
# Copyright (c) 2021 davfsa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Basic implementation of a cache for general bots and gateway apps.&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.List[str] = [&#34;CacheImpl&#34;]

import copy
import logging
import typing

from hikari import channels
from hikari import config
from hikari import emojis
from hikari import messages
from hikari import snowflakes
from hikari import undefined
from hikari.api import cache
from hikari.internal import cache as cache_utility
from hikari.internal import collections

if typing.TYPE_CHECKING:
    from hikari import guilds
    from hikari import invites
    from hikari import presences
    from hikari import traits
    from hikari import users
    from hikari import voices

    _T = typing.TypeVar(&#34;_T&#34;)

_LOGGER: typing.Final[logging.Logger] = logging.getLogger(&#34;hikari.cache&#34;)


# TODO: do we want to hide entities that are marked as &#34;deleted&#34; and being kept alive by references?
class CacheImpl(cache.MutableCache):
    &#34;&#34;&#34;In-memory cache implementation.

    Parameters
    ----------
    app : hikari.traits.RESTAware
        The object of the REST aware app this is bound to.
    settings : hikari.config.CacheSettings
        The cache settings to use.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_app&#34;,
        &#34;_dm_channel_entries&#34;,
        &#34;_emoji_entries&#34;,
        &#34;_guild_channel_entries&#34;,
        &#34;_guild_entries&#34;,
        &#34;_intents&#34;,
        &#34;_invite_entries&#34;,
        &#34;_me&#34;,
        &#34;_role_entries&#34;,
        &#34;_unknown_custom_emoji_entries&#34;,
        &#34;_user_entries&#34;,
        &#34;_message_entries&#34;,
        &#34;_referenced_messages&#34;,
        &#34;_settings&#34;,
    )

    # For the sake of keeping things clean, the annotations are being kept separate from the assignment here.
    _me: typing.Optional[users.OwnUser]
    _emoji_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.KnownCustomEmojiData]
    _dm_channel_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, snowflakes.Snowflake]
    _guild_channel_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, channels.GuildChannel]
    _guild_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.GuildRecord]
    _invite_entries: collections.ExtendedMutableMapping[str, cache_utility.InviteData]
    _role_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, guilds.Role]
    _unknown_custom_emoji_entries: collections.ExtendedMutableMapping[
        snowflakes.Snowflake,
        cache_utility.RefCell[emojis.CustomEmoji],
    ]
    _user_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.RefCell[users.User]]
    _message_entries: collections.ExtendedMutableMapping[
        snowflakes.Snowflake, cache_utility.RefCell[cache_utility.MessageData]
    ]
    _referenced_messages: collections.ExtendedMutableMapping[
        snowflakes.Snowflake, cache_utility.RefCell[cache_utility.MessageData]
    ]

    def __init__(self, app: traits.RESTAware, settings: config.CacheSettings) -&gt; None:
        self._app = app
        self._settings = settings
        self._create_cache()

    @property
    def settings(self) -&gt; config.CacheSettings:
        return self._settings

    def _create_cache(self) -&gt; None:
        self._me = None
        self._dm_channel_entries = collections.LimitedCapacityCacheMap(limit=self._settings.max_dm_channel_ids)
        self._emoji_entries = collections.FreezableDict()
        self._guild_channel_entries = collections.FreezableDict()
        self._guild_entries = collections.FreezableDict()
        self._invite_entries = collections.FreezableDict()
        self._role_entries = collections.FreezableDict()
        # This is a purely internal cache used for handling the caching and de-duplicating of the unknown custom emojis
        # found attached to cached presence activities.
        self._unknown_custom_emoji_entries = collections.FreezableDict()
        self._user_entries = collections.FreezableDict()
        self._message_entries = collections.LimitedCapacityCacheMap(
            limit=self._settings.max_messages, on_expire=self._on_message_expire
        )
        self._referenced_messages = collections.FreezableDict()

    def _is_cache_enabled_for(self, required_flag: config.CacheComponents) -&gt; bool:
        return (self._settings.components &amp; required_flag) == required_flag

    @staticmethod
    def _increment_ref_count(obj: cache_utility.RefCell[typing.Any], increment: int = 1) -&gt; None:
        obj.ref_count += increment

    def clear(self) -&gt; None:
        if self._settings.components == config.CacheComponents.NONE:
            return None

        self._create_cache()

    def clear_dm_channel_ids(self) -&gt; cache.CacheView[snowflakes.Snowflake, snowflakes.Snowflake]:
        if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
            return cache_utility.EmptyCacheView()

        result = self._dm_channel_entries
        self._dm_channel_entries = collections.LimitedCapacityCacheMap(limit=self._settings.max_dm_channel_ids)
        return cache_utility.CacheMappingView(result)

    def delete_dm_channel_id(
        self, user: snowflakes.SnowflakeishOr[users.PartialUser], /
    ) -&gt; typing.Optional[snowflakes.Snowflake]:
        if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
            return None

        return self._dm_channel_entries.pop(snowflakes.Snowflake(user), None)

    def get_dm_channel_id(
        self, user: snowflakes.SnowflakeishOr[users.PartialUser], /
    ) -&gt; typing.Optional[snowflakes.Snowflake]:
        if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
            return None

        return self._dm_channel_entries.get(snowflakes.Snowflake(user))

    def get_dm_channel_ids_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, snowflakes.Snowflake]:
        if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(self._dm_channel_entries.freeze())

    def set_dm_channel_id(
        self,
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
        /,
    ) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
            return None

        self._dm_channel_entries[snowflakes.Snowflake(user)] = snowflakes.Snowflake(channel)

    def _build_emoji(
        self,
        emoji_data: cache_utility.KnownCustomEmojiData,
    ) -&gt; emojis.KnownCustomEmoji:
        return emoji_data.build_entity(self._app)

    def clear_emojis(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return cache_utility.EmptyCacheView()

        cached_emojis = self._emoji_entries
        self._emoji_entries = collections.FreezableDict()

        for emoji_data in cached_emojis.values():
            if emoji_data.user:
                self._garbage_collect_user(emoji_data.user, decrement=1)

        for guild_id, guild_record in self._guild_entries.freeze().items():
            guild_record.emojis = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_emojis, builder=self._build_emoji)

    def clear_emojis_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.emojis:
            return cache_utility.EmptyCacheView()

        cached_emojis = {emoji_id: self._emoji_entries.pop(emoji_id) for emoji_id in guild_record.emojis}
        guild_record.emojis = None
        self._remove_guild_record_if_empty(guild_id, guild_record)

        for emoji_data in cached_emojis.values():
            if emoji_data.user:
                self._garbage_collect_user(emoji_data.user, decrement=1)

        return cache_utility.CacheMappingView(cached_emojis, builder=self._build_emoji)

    def delete_emoji(
        self, emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji], /
    ) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return None

        emoji_id = snowflakes.Snowflake(emoji)
        emoji_data = self._emoji_entries.pop(emoji_id, None)
        if not emoji_data:
            return None

        if emoji_data.user:
            self._garbage_collect_user(emoji_data.user, decrement=1)

        guild_record = self._guild_entries.get(emoji_data.guild_id)
        if guild_record and guild_record.emojis:
            guild_record.emojis.remove(emoji_id)

            if not guild_record.emojis:
                guild_record.emojis = None

        return self._build_emoji(emoji_data)

    def get_emoji(
        self, emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji], /
    ) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return None

        emoji_data = self._emoji_entries.get(snowflakes.Snowflake(emoji))
        return self._build_emoji(emoji_data) if emoji_data else None

    def get_emojis_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(self._emoji_entries.freeze(), builder=self._build_emoji)

    def get_emojis_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return cache_utility.EmptyCacheView()

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.emojis:
            return cache_utility.EmptyCacheView()

        cached_emojis = {emoji_id: self._emoji_entries[emoji_id] for emoji_id in guild_record.emojis}
        return cache_utility.CacheMappingView(cached_emojis, builder=self._build_emoji)

    def set_emoji(self, emoji: emojis.KnownCustomEmoji, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return None

        user: typing.Optional[cache_utility.RefCell[users.User]] = None
        if emoji.user:
            user = self._set_user(emoji.user)
            if emoji.id not in self._emoji_entries:
                self._increment_ref_count(user)

        emoji_data = cache_utility.KnownCustomEmojiData.build_from_entity(emoji, user=user)
        self._emoji_entries[emoji.id] = emoji_data
        guild_record = self._get_or_create_guild_record(emoji.guild_id)

        if guild_record.emojis is None:  # TODO: add test cases when it is not None?
            guild_record.emojis = collections.SnowflakeSet()

        guild_record.emojis.add(emoji.id)

    def update_emoji(
        self, emoji: emojis.KnownCustomEmoji, /
    ) -&gt; typing.Tuple[typing.Optional[emojis.KnownCustomEmoji], typing.Optional[emojis.KnownCustomEmoji]]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return None, None

        cached_emoji = self.get_emoji(emoji.id)
        self.set_emoji(emoji)
        return cached_emoji, self.get_emoji(emoji.id)

    def _remove_guild_record_if_empty(
        self, guild_id: snowflakes.Snowflake, record: cache_utility.GuildRecord, /
    ) -&gt; None:
        if guild_id in self._guild_entries and record.empty():
            del self._guild_entries[guild_id]

    def _get_or_create_guild_record(self, guild_id: snowflakes.Snowflake) -&gt; cache_utility.GuildRecord:
        if guild_id not in self._guild_entries:
            self._guild_entries[guild_id] = cache_utility.GuildRecord()

        return self._guild_entries[guild_id]

    def clear_guilds(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return cache_utility.EmptyCacheView()

        cached_guilds = {}

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.guild:
                cached_guilds[guild_id] = guild_record.guild
                guild_record.guild = None
                guild_record.is_available = None
                self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_guilds) if cached_guilds else cache_utility.EmptyCacheView()

    def delete_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record:
            return None

        guild = guild_record.guild

        if guild:
            guild_record.guild = None
            guild_record.is_available = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        return guild

    def _get_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /, *, availability: bool
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.guild or guild_record.is_available is not availability:
            return None

        return copy.copy(guild_record.guild)

    def get_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        return copy.copy(guild_record.guild) if guild_record and guild_record.guild else None

    def get_available_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        return self._get_guild(guild, availability=True)

    def get_unavailable_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        return self._get_guild(guild, availability=False)

    def _get_guilds_view(self, *, availability: bool) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        # We may have a guild record without a guild object in cases where we&#39;re caching other entities that belong to
        # the guild therefore we want to make sure record.guild isn&#39;t None.
        results = {
            sf: guild_record.guild
            for sf, guild_record in self._guild_entries.items()
            if guild_record.guild and guild_record.is_available is availability
        }
        return cache_utility.CacheMappingView(results) if results else cache_utility.EmptyCacheView()

    def get_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        return cache_utility.CacheMappingView(
            {guild_id: record.guild for guild_id, record in self._guild_entries.items() if record.guild}
        )

    def get_available_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return cache_utility.EmptyCacheView()

        return self._get_guilds_view(availability=True)

    def get_unavailable_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return cache_utility.EmptyCacheView()

        return self._get_guilds_view(availability=False)

    def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        guild_record = self._get_or_create_guild_record(guild.id)
        guild_record.guild = copy.copy(guild)
        guild_record.is_available = True

    def set_guild_availability(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], is_available: bool, /
    ) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if guild_record and guild_record.guild:
            guild_record.is_available = is_available

    def update_guild(
        self, guild: guilds.GatewayGuild, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.GatewayGuild], typing.Optional[guilds.GatewayGuild]]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None, None

        guild = copy.copy(guild)
        cached_guild = self.get_guild(guild.id)

        # We have to manually update these because Inconsistency is Discord&#39;s middle name.
        if cached_guild:
            guild.member_count = cached_guild.member_count
            guild.joined_at = cached_guild.joined_at
            guild.is_large = cached_guild.is_large

        self.set_guild(guild)
        return cached_guild, self.get_guild(guild.id)

    def clear_guild_channels(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return cache_utility.EmptyCacheView()

        cached_channels = self._guild_channel_entries
        self._guild_channel_entries = collections.FreezableDict()

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.channels:
                guild_record.channels = None
                self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_channels)

    def clear_guild_channels_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.channels:
            return cache_utility.EmptyCacheView()

        cached_channels = {sf: self._guild_channel_entries.pop(sf) for sf in guild_record.channels}
        guild_record.channels = None
        self._remove_guild_record_if_empty(guild_id, guild_record)
        return cache_utility.CacheMappingView(cached_channels)

    def delete_guild_channel(
        self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel], /
    ) -&gt; typing.Optional[channels.GuildChannel]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return None

        channel_id = snowflakes.Snowflake(channel)
        channel = self._guild_channel_entries.pop(channel_id, None)

        if not channel:
            return None

        guild_record = self._guild_entries.get(channel.guild_id)
        if guild_record and guild_record.channels:
            guild_record.channels.remove(channel_id)
            if not guild_record.channels:
                guild_record.channels = None
                self._remove_guild_record_if_empty(channel.guild_id, guild_record)

        return channel

    def get_guild_channel(
        self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel], /
    ) -&gt; typing.Optional[channels.GuildChannel]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return None

        channel = self._guild_channel_entries.get(snowflakes.Snowflake(channel))
        return cache_utility.copy_guild_channel(channel) if channel else None

    def get_guild_channels_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        return cache_utility.CacheMappingView(
            self._guild_channel_entries.freeze(), builder=cache_utility.copy_guild_channel  # type: ignore[type-var]
        )

    def get_guild_channels_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return cache_utility.EmptyCacheView()

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.channels:
            return cache_utility.EmptyCacheView()

        cached_channels = {sf: self._guild_channel_entries[sf] for sf in guild_record.channels}

        def sorter(args: typing.Tuple[snowflakes.Snowflake, channels.GuildChannel]) -&gt; typing.Tuple[int, int, int]:
            channel = args[1]
            if isinstance(channel, channels.GuildCategory):
                return channel.position, -1, 0

            parent_position = -1 if channel.parent_id is None else cached_channels[channel.parent_id].position

            if not isinstance(channel, channels.GuildVoiceChannel):
                return parent_position, 0, channel.position

            return parent_position, 1, channel.position

        cached_channels = dict(sorted(cached_channels.items(), key=sorter))
        return cache_utility.CacheMappingView(
            cached_channels, builder=cache_utility.copy_guild_channel  # type: ignore[type-var]
        )

    def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return None

        self._guild_channel_entries[channel.id] = cache_utility.copy_guild_channel(channel)
        guild_record = self._get_or_create_guild_record(channel.guild_id)

        if guild_record.channels is None:
            guild_record.channels = collections.SnowflakeSet()

        guild_record.channels.add(channel.id)

    def update_guild_channel(
        self, channel: channels.GuildChannel, /
    ) -&gt; typing.Tuple[typing.Optional[channels.GuildChannel], typing.Optional[channels.GuildChannel]]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return None, None

        cached_channel = self.get_guild_channel(channel.id)
        self.set_guild_channel(channel)
        return cached_channel, self.get_guild_channel(channel.id)

    def _build_invite(
        self,
        invite_data: cache_utility.InviteData,
    ) -&gt; invites.InviteWithMetadata:
        return invite_data.build_entity(self._app)

    def _remove_invite_users(self, invite: cache_utility.InviteData) -&gt; None:
        if invite.inviter:
            self._garbage_collect_user(invite.inviter, decrement=1)

        if invite.target_user:
            self._garbage_collect_user(invite.target_user, decrement=1)

    def clear_invites(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        cached_invites = self._invite_entries
        self._invite_entries = collections.FreezableDict()

        for invite_data in cached_invites.values():
            self._remove_invite_users(invite_data)

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.invites:
                guild_record.invites = None
                self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)

    def clear_invites_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)

        if not guild_record or not guild_record.invites:
            return cache_utility.EmptyCacheView()

        cached_invites = {invite_code: self._invite_entries.pop(invite_code) for invite_code in guild_record.invites}
        guild_record.invites = None
        self._remove_guild_record_if_empty(guild_id, guild_record)

        for invite_data in cached_invites.values():
            self._remove_invite_users(invite_data)

        return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)

    def clear_invites_for_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
        /,
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        channel_id = snowflakes.Snowflake(channel)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.invites:
            return cache_utility.EmptyCacheView()

        cached_invites = {}

        for code in tuple(guild_record.invites):
            invite_data = self._invite_entries[code]
            if invite_data.channel_id != channel_id:
                continue

            cached_invites[code] = invite_data
            del self._invite_entries[code]
            guild_record.invites.remove(code)
            self._remove_invite_users(invite_data)

        if not guild_record.invites:
            guild_record.invites = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)

    def delete_invite(
        self, code: typing.Union[invites.InviteCode, str], /
    ) -&gt; typing.Optional[invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return None

        code = code if isinstance(code, str) else code.code
        invite_data = self._invite_entries.pop(code, None)
        if not invite_data:
            return None

        self._remove_invite_users(invite_data)

        if invite_data.guild_id is not None:  # TODO: test case when this is None?
            guild_record = self._guild_entries.get(invite_data.guild_id)
            if guild_record and guild_record.invites:
                guild_record.invites.remove(code)

                if not guild_record.invites:
                    guild_record.invites = None  # TODO: test when this is set to None
                    self._remove_guild_record_if_empty(invite_data.guild_id, guild_record)

        return self._build_invite(invite_data)

    def get_invite(self, code: typing.Union[invites.InviteCode, str], /) -&gt; typing.Optional[invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return None

        code = code if isinstance(code, str) else code.code
        invite_data = self._invite_entries.get(code)
        return self._build_invite(invite_data) if invite_data else None

    def get_invites_view(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(self._invite_entries.freeze(), builder=self._build_invite)

    def get_invites_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_entry = self._guild_entries.get(guild_id)
        if not guild_entry or not guild_entry.invites:
            return cache_utility.EmptyCacheView()

        cached_invites = {code: self._invite_entries[code] for code in guild_entry.invites}
        return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)

    def get_invites_view_for_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
        /,
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        channel_id = snowflakes.Snowflake(channel)
        guild_entry = self._guild_entries.get(guild_id)
        if not guild_entry or not guild_entry.invites:
            return cache_utility.EmptyCacheView()

        cached_invites = {
            invite.code: invite
            for invite in map(self._invite_entries.get, guild_entry.invites)
            if invite and invite.channel_id == channel_id
        }
        return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)

    def set_invite(self, invite: invites.InviteWithMetadata, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return None

        inviter: typing.Optional[cache_utility.RefCell[users.User]] = None
        if invite.inviter:
            inviter = self._set_user(invite.inviter)
            if invite.code not in self._invite_entries:
                self._increment_ref_count(inviter)

        target_user: typing.Optional[cache_utility.RefCell[users.User]] = None
        if invite.target_user:
            target_user = self._set_user(invite.target_user)
            if invite.code not in self._invite_entries:
                self._increment_ref_count(target_user)

        self._invite_entries[invite.code] = cache_utility.InviteData.build_from_entity(
            invite, inviter=inviter, target_user=target_user
        )
        if invite.guild_id:
            guild_entry = self._get_or_create_guild_record(invite.guild_id)

            if guild_entry.invites is None:
                guild_entry.invites = []

            guild_entry.invites.append(invite.code)

    def update_invite(
        self, invite: invites.InviteWithMetadata, /
    ) -&gt; typing.Tuple[typing.Optional[invites.InviteWithMetadata], typing.Optional[invites.InviteWithMetadata]]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return None, None

        cached_invite = self.get_invite(invite.code)
        self.set_invite(invite)
        return cached_invite, self.get_invite(invite.code)

    def delete_me(self) -&gt; typing.Optional[users.OwnUser]:
        cached_user = self._me
        self._me = None
        return cached_user

    def get_me(self) -&gt; typing.Optional[users.OwnUser]:
        return copy.copy(self._me)

    def set_me(self, user: users.OwnUser, /) -&gt; None:
        self._me = copy.copy(user)

    def update_me(
        self, user: users.OwnUser, /
    ) -&gt; typing.Tuple[typing.Optional[users.OwnUser], typing.Optional[users.OwnUser]]:
        _LOGGER.debug(&#34;setting my user to %s&#34;, user)
        cached_user = self.get_me()
        self.set_me(user)
        return cached_user, self._me

    def _build_member(
        self,
        member_data: cache_utility.RefCell[cache_utility.MemberData],
    ) -&gt; guilds.Member:
        return member_data.object.build_entity(self._app)

    @staticmethod
    def _can_remove_member(
        member: cache_utility.RefCell[cache_utility.MemberData],
    ) -&gt; bool:
        return member.ref_count &lt; 1 and member.object.has_been_deleted

    def _garbage_collect_member(
        self,
        guild_record: cache_utility.GuildRecord,
        member: cache_utility.RefCell[cache_utility.MemberData],
        *,
        decrement: typing.Optional[int] = None,
        deleting: bool = False,
    ) -&gt; typing.Optional[cache_utility.RefCell[cache_utility.MemberData]]:
        if deleting:
            member.object.has_been_deleted = True

        if decrement is not None:
            self._increment_ref_count(member, -decrement)

        user_id = member.object.user.object.id
        if not guild_record.members or user_id not in guild_record.members:
            return None

        if not self._can_remove_member(member):
            return None

        del guild_record.members[user_id]
        self._garbage_collect_user(member.object.user, decrement=1)

        if not guild_record.members:
            guild_record.members = None
            self._remove_guild_record_if_empty(member.object.guild_id, guild_record)

        return member

    def clear_members(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return cache_utility.EmptyCacheView()

        views = ((guild_id, self.clear_members_for_guild(guild_id)) for guild_id in self._guild_entries.freeze().keys())
        return cache_utility.CacheMappingView({guild_id: view for guild_id, view in views if view})

    def clear_members_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.members:
            return cache_utility.EmptyCacheView()

        cached_members = guild_record.members.freeze()
        members_gen = (self._garbage_collect_member(guild_record, m, deleting=True) for m in cached_members.values())
        # _garbage_collect_member will only return the member data object if they could be removed, else None.
        cached_members = {member.object.user.object.id: member for member in members_gen if member}
        self._remove_guild_record_if_empty(guild_id, guild_record)
        return cache_utility.CacheMappingView(cached_members, builder=self._build_member)  # type: ignore[type-var]

    def delete_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[guilds.Member]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.members:
            return None

        member_data = guild_record.members.get(user_id)
        if not member_data:
            return None

        if not guild_record.members:
            guild_record.members = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        # _garbage_collect_member will only return the member data object if they could be removed, else None.
        garbage_collected = self._garbage_collect_member(guild_record, member_data, deleting=True)
        return self._build_member(member_data) if garbage_collected else None

    def get_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[guilds.Member]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.members:
            return None

        member = guild_record.members.get(user_id)
        return self._build_member(member) if member else None

    def get_members_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return cache_utility.EmptyCacheView()

        views: typing.Mapping[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]] = {
            guild_id: cache_utility.CacheMappingView(view.members.freeze(), builder=self._build_member)  # type: ignore[type-var]
            for guild_id, view in self._guild_entries.items()
            if view.members
        }
        return cache_utility.Cache3DMappingView(views)

    def get_members_view_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild_id)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.members:
            return cache_utility.EmptyCacheView()

        cached_members = {
            user_id: member for user_id, member in guild_record.members.items() if not member.object.has_been_deleted
        }

        return cache_utility.CacheMappingView(cached_members, builder=self._build_member)  # type: ignore[type-var]

    def set_member(self, member: guilds.Member, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return None

        self._set_member(member, is_reference=False)

    def _set_member(
        self, member: guilds.Member, /, *, is_reference: bool = True
    ) -&gt; cache_utility.RefCell[cache_utility.MemberData]:
        guild_record = self._get_or_create_guild_record(member.guild_id)
        user = self._set_user(member.user)
        member_data = cache_utility.MemberData.build_from_entity(member, user=user)

        if guild_record.members is None:  # TODO: test when this is not None
            guild_record.members = collections.FreezableDict()

        if member.user.id not in guild_record.members:
            self._increment_ref_count(member_data.user)

        try:
            member_data.has_been_deleted = False
            if is_reference:
                member_data.has_been_deleted = guild_record.members[member.id].object.has_been_deleted

            guild_record.members[member.id].object = member_data

        except KeyError:
            member_data.has_been_deleted = is_reference
            guild_record.members[member.id] = cache_utility.RefCell(member_data)

        return guild_record.members[member.id]

    def update_member(
        self, member: guilds.Member, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.Member], typing.Optional[guilds.Member]]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return None, None

        cached_member = self.get_member(member.guild_id, member.user.id)
        self.set_member(member)
        return cached_member, self.get_member(member.guild_id, member.user.id)

    def _build_presence(
        self,
        presence_data: cache_utility.MemberPresenceData,
    ) -&gt; presences.MemberPresence:
        return presence_data.build_entity(self._app)

    def _garbage_collect_unknown_custom_emoji(
        self, emoji: cache_utility.RefCell[emojis.CustomEmoji], *, decrement: typing.Optional[int] = None
    ) -&gt; None:
        if decrement is not None:
            self._increment_ref_count(emoji, -decrement)

        if emoji.ref_count &lt; 1 and emoji.object.id in self._unknown_custom_emoji_entries:
            del self._unknown_custom_emoji_entries[emoji.object.id]

    def _remove_presence_assets(
        self,
        presence_data: cache_utility.MemberPresenceData,
    ) -&gt; None:
        for activity_data in presence_data.activities:
            if isinstance(activity_data.emoji, cache_utility.RefCell):
                self._garbage_collect_unknown_custom_emoji(activity_data.emoji, decrement=1)

    def clear_presences(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return cache_utility.EmptyCacheView()

        views = (
            (guild_id, self.clear_presences_for_guild(guild_id)) for guild_id in self._guild_entries.freeze().keys()
        )
        return cache_utility.CacheMappingView({guild_id: view for guild_id, view in views if view})

    def clear_presences_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.presences:
            return cache_utility.EmptyCacheView()

        cached_presences = guild_record.presences
        guild_record.presences = None

        for presence in cached_presences.values():
            self._remove_presence_assets(presence)

        self._remove_guild_record_if_empty(guild_id, guild_record)
        return cache_utility.CacheMappingView(cached_presences, builder=self._build_presence)

    def delete_presence(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[presences.MemberPresence]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.presences:
            return None

        presence_data = guild_record.presences.pop(user_id, None)

        if not presence_data:
            return None

        self._remove_presence_assets(presence_data)

        if not guild_record.presences:
            guild_record.presences = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        return self._build_presence(presence_data)

    def get_presence(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[presences.MemberPresence]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.presences:
            return None

        return self._build_presence(guild_record.presences[user_id]) if user_id in guild_record.presences else None

    def get_presences_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return cache_utility.EmptyCacheView()

        views = {
            guild_id: cache_utility.CacheMappingView(guild_record.presences.freeze(), builder=self._build_presence)
            for guild_id, guild_record in self._guild_entries.items()
            if guild_record.presences
        }
        return cache_utility.Cache3DMappingView(views)

    def get_presences_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return cache_utility.EmptyCacheView()

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.presences:
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(guild_record.presences.freeze(), builder=self._build_presence)

    def set_presence(self, presence: presences.MemberPresence, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return None

        presence_data = cache_utility.MemberPresenceData.build_from_entity(presence)
        for activity, activity_data in zip(presence.activities, presence_data.activities):
            emoji = activity.emoji
            if not isinstance(emoji, emojis.CustomEmoji):
                continue

            if emoji.id in self._unknown_custom_emoji_entries:
                self._unknown_custom_emoji_entries[emoji.id].object = copy.copy(emoji)
                emoji_data = self._unknown_custom_emoji_entries[emoji.id]

            else:
                emoji_data = cache_utility.RefCell(copy.copy(emoji))
                self._unknown_custom_emoji_entries[emoji.id] = emoji_data

            self._increment_ref_count(emoji_data)
            activity_data.emoji = emoji_data

        guild_record = self._get_or_create_guild_record(presence.guild_id)
        if guild_record.presences is None:
            guild_record.presences = collections.FreezableDict()

        guild_record.presences[presence.user_id] = presence_data

    def update_presence(
        self, presence: presences.MemberPresence, /
    ) -&gt; typing.Tuple[typing.Optional[presences.MemberPresence], typing.Optional[presences.MemberPresence]]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return None, None

        cached_presence = self.get_presence(presence.guild_id, presence.user_id)
        self.set_presence(presence)
        return cached_presence, self.get_presence(presence.guild_id, presence.user_id)

    def clear_roles(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES) or not self._role_entries:
            return cache_utility.EmptyCacheView()

        roles = self._role_entries
        self._role_entries = collections.FreezableDict()

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.roles:  # TODO: test coverage for when not this
                guild_record.roles = None
                self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(roles)

    def clear_roles_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.roles:
            return cache_utility.EmptyCacheView()

        view = cache_utility.CacheMappingView(
            {role_id: self._role_entries.pop(role_id) for role_id in guild_record.roles}
        )
        guild_record.roles = None
        self._remove_guild_record_if_empty(guild_id, guild_record)
        return view

    def delete_role(self, role: snowflakes.SnowflakeishOr[guilds.PartialRole], /) -&gt; typing.Optional[guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return None

        role_id = snowflakes.Snowflake(role)
        role = self._role_entries.pop(role_id, None)
        if not role:
            return None

        guild_record = self._guild_entries.get(role.guild_id)
        if guild_record and guild_record.roles:
            guild_record.roles.remove(role_id)

            if not guild_record.roles:
                guild_record.roles = None
                self._remove_guild_record_if_empty(role.guild_id, guild_record)

        return role

    def get_role(self, role: snowflakes.SnowflakeishOr[guilds.PartialRole], /) -&gt; typing.Optional[guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return None

        role = self._role_entries.get(snowflakes.Snowflake(role))
        return copy.copy(role) if role else None

    def get_roles_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(self._role_entries.freeze())

    def get_roles_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return cache_utility.EmptyCacheView()

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.roles:
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView({role_id: self._role_entries[role_id] for role_id in guild_record.roles})

    def set_role(self, role: guilds.Role, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return None

        self._role_entries[role.id] = role
        guild_record = self._get_or_create_guild_record(role.guild_id)

        if guild_record.roles is None:  # TODO: test when this is not None
            guild_record.roles = collections.SnowflakeSet()

        guild_record.roles.add(role.id)

    def update_role(
        self, role: guilds.Role, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.Role], typing.Optional[guilds.Role]]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return None, None

        cached_role = self.get_role(role.id)
        self.set_role(role)
        return cached_role, self.get_role(role.id)

    @staticmethod
    def _can_remove_user(user_data: cache_utility.RefCell[users.User]) -&gt; bool:
        return user_data.ref_count &lt; 1

    def _garbage_collect_user(
        self, user: cache_utility.RefCell[users.User], *, decrement: typing.Optional[int] = None
    ) -&gt; None:
        if decrement is not None:
            self._increment_ref_count(user, -decrement)

        if self._can_remove_user(user) and user.object.id in self._user_entries:
            del self._user_entries[user.object.id]
            self._dm_channel_entries.pop(user.object.id, None)

    def get_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; typing.Optional[users.User]:
        user = self._user_entries.get(snowflakes.Snowflake(user))
        return user.copy() if user else None

    def get_users_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, users.User]:
        if not self._user_entries:
            return cache_utility.EmptyCacheView()

        cached_users = self._user_entries.freeze()
        unwrapper = typing.cast(
            &#34;typing.Callable[[cache_utility.RefCell[users.User]], users.User]&#34;, cache_utility.unwrap_ref_cell
        )
        return cache_utility.CacheMappingView(cached_users, builder=unwrapper)  # type: ignore[type-var]

    def _set_user(self, user: users.User, /) -&gt; cache_utility.RefCell[users.User]:
        try:
            self._user_entries[user.id].object = copy.copy(user)
            cell = self._user_entries[user.id]
        except KeyError:
            cell = cache_utility.RefCell(copy.copy(user))
            self._user_entries[user.id] = cell

        return cell

    def _build_voice_state(
        self,
        voice_data: cache_utility.VoiceStateData,
    ) -&gt; voices.VoiceState:
        return voice_data.build_entity(self._app)

    def clear_voice_states(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        views = (
            (guild_id, self.clear_voice_states_for_guild(guild_id)) for guild_id in self._guild_entries.freeze().keys()
        )
        return cache_utility.CacheMappingView({guild_id: view for guild_id, view in views if view})

    def clear_voice_states_for_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
        /,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        channel_id = snowflakes.Snowflake(channel)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.voice_states:
            return cache_utility.EmptyCacheView()

        cached_voice_states = {}

        for user_id, voice_state in guild_record.voice_states.items():
            if voice_state.channel_id == channel_id:
                cached_voice_states[user_id] = voice_state
                self._garbage_collect_member(guild_record, voice_state.member, decrement=1)

        if not guild_record.voice_states:
            guild_record.voice_states = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_voice_states, builder=self._build_voice_state)

    def clear_voice_states_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)

        if not guild_record or not guild_record.voice_states:
            return cache_utility.EmptyCacheView()

        cached_voice_states = guild_record.voice_states
        guild_record.voice_states = None

        for voice_state in cached_voice_states.values():
            self._garbage_collect_member(guild_record, voice_state.member, decrement=1)

        self._remove_guild_record_if_empty(guild_id, guild_record)
        return cache_utility.CacheMappingView(cached_voice_states, builder=self._build_voice_state)

    def delete_voice_state(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.voice_states:
            return None

        voice_state_data = guild_record.voice_states.pop(user_id, None)
        if not voice_state_data:
            return None

        if not guild_record.voice_states:
            guild_record.voice_states = None

        self._garbage_collect_member(guild_record, voice_state_data.member, decrement=1)
        self._remove_guild_record_if_empty(guild_id, guild_record)
        return self._build_voice_state(voice_state_data)

    def get_voice_state(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        voice_data = guild_record.voice_states.get(user_id) if guild_record and guild_record.voice_states else None
        return self._build_voice_state(voice_data) if voice_data else None

    def get_voice_states_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        views = {
            guild_id: cache_utility.CacheMappingView(
                guild_record.voice_states.freeze(), builder=self._build_voice_state
            )
            for guild_id, guild_record in self._guild_entries.items()
            if guild_record.voice_states
        }
        return cache_utility.Cache3DMappingView(views)

    def get_voice_states_view_for_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
        /,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        channel_id = snowflakes.Snowflake(channel)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.voice_states:
            return cache_utility.EmptyCacheView()

        cached_voice_states = {
            user_id: voice_state
            for user_id, voice_state in guild_record.voice_states.items()
            if voice_state.channel_id == channel_id
        }

        return cache_utility.CacheMappingView(cached_voice_states, builder=self._build_voice_state)

    def get_voice_states_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.voice_states:
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(guild_record.voice_states.freeze(), builder=self._build_voice_state)

    def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return None

        guild_record = self._get_or_create_guild_record(voice_state.guild_id)

        if guild_record.voice_states is None:  # TODO: test when this is not None
            guild_record.voice_states = collections.FreezableDict()

        member = self._set_member(voice_state.member)
        voice_state_data = cache_utility.VoiceStateData.build_from_entity(voice_state, member=member)

        if voice_state.user_id not in guild_record.voice_states:
            self._increment_ref_count(member)

        guild_record.voice_states[voice_state.user_id] = voice_state_data

    def update_voice_state(
        self, voice_state: voices.VoiceState, /
    ) -&gt; typing.Tuple[typing.Optional[voices.VoiceState], typing.Optional[voices.VoiceState]]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return None, None

        cached_voice_state = self.get_voice_state(voice_state.guild_id, voice_state.user_id)
        self.set_voice_state(voice_state)
        return cached_voice_state, self.get_voice_state(voice_state.guild_id, voice_state.user_id)

    def _build_message(self, message_data: cache_utility.RefCell[cache_utility.MessageData]) -&gt; messages.Message:
        return message_data.object.build_entity(self._app)

    def _can_remove_message(self, message: cache_utility.RefCell[cache_utility.MessageData]) -&gt; bool:
        return message.object.id not in self._message_entries and message.ref_count &lt; 1

    def _garbage_collect_message(
        self,
        message: cache_utility.RefCell[cache_utility.MessageData],
        *,
        decrement: typing.Optional[int] = None,
        override_ref: bool = False,
    ) -&gt; typing.Optional[cache_utility.RefCell[cache_utility.MessageData]]:
        if decrement is not None:
            self._increment_ref_count(message, -decrement)

        if not self._can_remove_message(message) or override_ref:
            return None

        self._garbage_collect_user(message.object.author, decrement=1)

        if message.object.member:
            guild_record = self._guild_entries.get(message.object.member.object.guild_id)
            if guild_record:
                self._garbage_collect_member(guild_record, message.object.member, decrement=1)

        if message.object.referenced_message:
            self._garbage_collect_message(message.object.referenced_message, decrement=1)

        if message.object.mentions.users:
            for user in message.object.mentions.users.values():
                self._garbage_collect_user(user, decrement=1)

        # If we got this far the message won&#39;t be in _message_entries as that&#39;d infer that it hasn&#39;t been marked as
        # deleted yet.
        if message.object.id in self._referenced_messages:
            del self._referenced_messages[message.object.id]

        return message

    def _on_message_expire(self, message: cache_utility.RefCell[cache_utility.MessageData], /) -&gt; None:
        if not self._garbage_collect_message(message):
            self._referenced_messages[message.object.id] = message

    def clear_messages(self) -&gt; cache.CacheView[snowflakes.Snowflake, messages.Message]:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES) or not self._message_entries:
            return cache_utility.EmptyCacheView()

        # As the only entry which references messages is other messages, this is enough for now.
        cached_messages = self._message_entries.freeze()
        self._message_entries.clear()
        cached_messages.update(self._referenced_messages)
        self._referenced_messages.clear()

        for message in cached_messages.values():
            self._garbage_collect_message(message, override_ref=True)

        return cache_utility.CacheMappingView(cached_messages, builder=self._build_message)  # type: ignore[type-var]

    def delete_message(
        self, message: snowflakes.SnowflakeishOr[messages.PartialMessage], /
    ) -&gt; typing.Optional[messages.Message]:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
            return None

        message_id = snowflakes.Snowflake(message)
        message_data = self._message_entries.pop(message_id, None)

        if not message_data:
            return None

        if not self._garbage_collect_message(message_data):
            self._referenced_messages[message_id] = message_data
            return None

        return self._build_message(message_data)

    def get_message(
        self, message: snowflakes.SnowflakeishOr[messages.PartialMessage], /
    ) -&gt; typing.Optional[messages.Message]:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
            return None

        message_id = snowflakes.Snowflake(message)
        message_data = self._message_entries.get(message_id) or self._referenced_messages.get(message_id)
        return self._build_message(message_data) if message_data else None

    def get_messages_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, messages.Message]:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
            return cache_utility.EmptyCacheView()

        cached_messages = self._message_entries.freeze()
        cached_messages.update(self._referenced_messages)
        return cache_utility.CacheMappingView(cached_messages, builder=self._build_message)  # type: ignore[type-var]

    def _set_message(
        self, message: messages.Message, /, *, is_reference: bool = True
    ) -&gt; cache_utility.RefCell[cache_utility.MessageData]:
        author = self._set_user(message.author)
        member = self._set_member(message.member) if message.member else None

        mention_users: undefined.UndefinedOr[
            typing.Mapping[snowflakes.Snowflake, cache_utility.RefCell[users.User]]
        ] = undefined.UNDEFINED
        if message.mentions.users is not undefined.UNDEFINED:
            mention_users = {user_id: self._set_user(user) for user_id, user in message.mentions.users.items()}

        interaction_user: typing.Optional[cache_utility.RefCell[users.User]] = None
        if message.interaction:
            interaction_user = self._set_user(message.interaction.user)

        referenced_message: typing.Optional[cache_utility.RefCell[cache_utility.MessageData]] = None
        if message.referenced_message:
            referenced_message = self._set_message(message.referenced_message)

        # Only increment ref counts if this wasn&#39;t previously cached.
        if message.id not in self._referenced_messages and message.id not in self._message_entries:
            if member:
                self._increment_ref_count(member)

            if referenced_message:
                self._increment_ref_count(referenced_message)

            if mention_users is not undefined.UNDEFINED:
                for user in mention_users.values():
                    self._increment_ref_count(user)

            if interaction_user:
                self._increment_ref_count(interaction_user)

        message_data = cache_utility.MessageData.build_from_entity(
            message,
            author=author,
            member=member,
            mention_users=mention_users,
            referenced_message=referenced_message,
            interaction_user=interaction_user,
        )

        # Ensure any previously set message ref cell is in the right place before updating the cache.
        if not is_reference and message.id in self._referenced_messages:
            self._message_entries[message.id] = self._referenced_messages.pop(message.id)

        if message.id in self._message_entries:
            self._message_entries[message.id].object = message_data

        elif not is_reference:
            self._message_entries[message.id] = cache_utility.RefCell(message_data)

        elif message.id in self._referenced_messages:
            self._referenced_messages[message.id].object = message_data

        else:
            self._referenced_messages[message.id] = cache_utility.RefCell(message_data)

        return self._message_entries.get(message.id) or self._referenced_messages[message.id]

    def set_message(self, message: messages.Message, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
            return None

        self._set_message(message, is_reference=False)

    def update_message(
        self, message: typing.Union[messages.PartialMessage, messages.Message], /
    ) -&gt; typing.Tuple[typing.Optional[messages.Message], typing.Optional[messages.Message]]:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
            return None, None

        cached_message = self.get_message(message.id)

        if isinstance(message, messages.Message):
            self.set_message(message)

        elif cached_message_data := self._message_entries.get(message.id) or self._referenced_messages.get(message.id):
            mention_user: undefined.UndefinedOr[
                typing.Mapping[snowflakes.Snowflake, cache_utility.RefCell[users.User]]
            ] = undefined.UNDEFINED
            if message.mentions.users is not undefined.UNDEFINED:
                mention_user = {user_id: self._set_user(user) for user_id, user in message.mentions.users.items()}

                # We want to ensure that any previously mentioned users are garbage collected if they&#39;re no longer
                # being mentioned.
                if cached_message_data.object.mentions.users is not undefined.UNDEFINED:
                    for user_id, user in cached_message_data.object.mentions.users.items():
                        if user_id not in mention_user:
                            self._garbage_collect_user(user, decrement=1)

            cached_message_data.object.update(message, mention_users=mention_user)

        return cached_message, self.get_message(message.id)</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.impl.cache.CacheImpl" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="CacheImpl -- In-memory cache implementation …" href="#hikari.impl.cache.CacheImpl"
>CacheImpl</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.cache.CacheImpl" class="hljs python"><abbr title='A standard Python type.'>class</abbr> CacheImpl (
    app: <a href='../traits.html#hikari.traits.RESTAware'>traits.RESTAware</a>,
    settings: <a href='../config.html#hikari.config.CacheSettings'>config.CacheSettings</a>,
): ...</code></pre>
<p>In-memory cache implementation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code><a href='../traits.html#hikari.traits.RESTAware'>RESTAware</a></code></dt>
<dd>The object of the REST aware app this is bound to.</dd>
<dt><strong><code>settings</code></strong> :&ensp;<code><a href='../config.html#hikari.config.CacheSettings'>CacheSettings</a></code></dt>
<dd>The cache settings to use.</dd>
</dl>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L57-L1640" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class CacheImpl(cache.MutableCache):
    &#34;&#34;&#34;In-memory cache implementation.

    Parameters
    ----------
    app : hikari.traits.RESTAware
        The object of the REST aware app this is bound to.
    settings : hikari.config.CacheSettings
        The cache settings to use.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_app&#34;,
        &#34;_dm_channel_entries&#34;,
        &#34;_emoji_entries&#34;,
        &#34;_guild_channel_entries&#34;,
        &#34;_guild_entries&#34;,
        &#34;_intents&#34;,
        &#34;_invite_entries&#34;,
        &#34;_me&#34;,
        &#34;_role_entries&#34;,
        &#34;_unknown_custom_emoji_entries&#34;,
        &#34;_user_entries&#34;,
        &#34;_message_entries&#34;,
        &#34;_referenced_messages&#34;,
        &#34;_settings&#34;,
    )

    # For the sake of keeping things clean, the annotations are being kept separate from the assignment here.
    _me: typing.Optional[users.OwnUser]
    _emoji_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.KnownCustomEmojiData]
    _dm_channel_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, snowflakes.Snowflake]
    _guild_channel_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, channels.GuildChannel]
    _guild_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.GuildRecord]
    _invite_entries: collections.ExtendedMutableMapping[str, cache_utility.InviteData]
    _role_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, guilds.Role]
    _unknown_custom_emoji_entries: collections.ExtendedMutableMapping[
        snowflakes.Snowflake,
        cache_utility.RefCell[emojis.CustomEmoji],
    ]
    _user_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.RefCell[users.User]]
    _message_entries: collections.ExtendedMutableMapping[
        snowflakes.Snowflake, cache_utility.RefCell[cache_utility.MessageData]
    ]
    _referenced_messages: collections.ExtendedMutableMapping[
        snowflakes.Snowflake, cache_utility.RefCell[cache_utility.MessageData]
    ]

    def __init__(self, app: traits.RESTAware, settings: config.CacheSettings) -&gt; None:
        self._app = app
        self._settings = settings
        self._create_cache()

    @property
    def settings(self) -&gt; config.CacheSettings:
        return self._settings

    def _create_cache(self) -&gt; None:
        self._me = None
        self._dm_channel_entries = collections.LimitedCapacityCacheMap(limit=self._settings.max_dm_channel_ids)
        self._emoji_entries = collections.FreezableDict()
        self._guild_channel_entries = collections.FreezableDict()
        self._guild_entries = collections.FreezableDict()
        self._invite_entries = collections.FreezableDict()
        self._role_entries = collections.FreezableDict()
        # This is a purely internal cache used for handling the caching and de-duplicating of the unknown custom emojis
        # found attached to cached presence activities.
        self._unknown_custom_emoji_entries = collections.FreezableDict()
        self._user_entries = collections.FreezableDict()
        self._message_entries = collections.LimitedCapacityCacheMap(
            limit=self._settings.max_messages, on_expire=self._on_message_expire
        )
        self._referenced_messages = collections.FreezableDict()

    def _is_cache_enabled_for(self, required_flag: config.CacheComponents) -&gt; bool:
        return (self._settings.components &amp; required_flag) == required_flag

    @staticmethod
    def _increment_ref_count(obj: cache_utility.RefCell[typing.Any], increment: int = 1) -&gt; None:
        obj.ref_count += increment

    def clear(self) -&gt; None:
        if self._settings.components == config.CacheComponents.NONE:
            return None

        self._create_cache()

    def clear_dm_channel_ids(self) -&gt; cache.CacheView[snowflakes.Snowflake, snowflakes.Snowflake]:
        if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
            return cache_utility.EmptyCacheView()

        result = self._dm_channel_entries
        self._dm_channel_entries = collections.LimitedCapacityCacheMap(limit=self._settings.max_dm_channel_ids)
        return cache_utility.CacheMappingView(result)

    def delete_dm_channel_id(
        self, user: snowflakes.SnowflakeishOr[users.PartialUser], /
    ) -&gt; typing.Optional[snowflakes.Snowflake]:
        if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
            return None

        return self._dm_channel_entries.pop(snowflakes.Snowflake(user), None)

    def get_dm_channel_id(
        self, user: snowflakes.SnowflakeishOr[users.PartialUser], /
    ) -&gt; typing.Optional[snowflakes.Snowflake]:
        if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
            return None

        return self._dm_channel_entries.get(snowflakes.Snowflake(user))

    def get_dm_channel_ids_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, snowflakes.Snowflake]:
        if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(self._dm_channel_entries.freeze())

    def set_dm_channel_id(
        self,
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
        /,
    ) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
            return None

        self._dm_channel_entries[snowflakes.Snowflake(user)] = snowflakes.Snowflake(channel)

    def _build_emoji(
        self,
        emoji_data: cache_utility.KnownCustomEmojiData,
    ) -&gt; emojis.KnownCustomEmoji:
        return emoji_data.build_entity(self._app)

    def clear_emojis(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return cache_utility.EmptyCacheView()

        cached_emojis = self._emoji_entries
        self._emoji_entries = collections.FreezableDict()

        for emoji_data in cached_emojis.values():
            if emoji_data.user:
                self._garbage_collect_user(emoji_data.user, decrement=1)

        for guild_id, guild_record in self._guild_entries.freeze().items():
            guild_record.emojis = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_emojis, builder=self._build_emoji)

    def clear_emojis_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.emojis:
            return cache_utility.EmptyCacheView()

        cached_emojis = {emoji_id: self._emoji_entries.pop(emoji_id) for emoji_id in guild_record.emojis}
        guild_record.emojis = None
        self._remove_guild_record_if_empty(guild_id, guild_record)

        for emoji_data in cached_emojis.values():
            if emoji_data.user:
                self._garbage_collect_user(emoji_data.user, decrement=1)

        return cache_utility.CacheMappingView(cached_emojis, builder=self._build_emoji)

    def delete_emoji(
        self, emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji], /
    ) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return None

        emoji_id = snowflakes.Snowflake(emoji)
        emoji_data = self._emoji_entries.pop(emoji_id, None)
        if not emoji_data:
            return None

        if emoji_data.user:
            self._garbage_collect_user(emoji_data.user, decrement=1)

        guild_record = self._guild_entries.get(emoji_data.guild_id)
        if guild_record and guild_record.emojis:
            guild_record.emojis.remove(emoji_id)

            if not guild_record.emojis:
                guild_record.emojis = None

        return self._build_emoji(emoji_data)

    def get_emoji(
        self, emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji], /
    ) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return None

        emoji_data = self._emoji_entries.get(snowflakes.Snowflake(emoji))
        return self._build_emoji(emoji_data) if emoji_data else None

    def get_emojis_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(self._emoji_entries.freeze(), builder=self._build_emoji)

    def get_emojis_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return cache_utility.EmptyCacheView()

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.emojis:
            return cache_utility.EmptyCacheView()

        cached_emojis = {emoji_id: self._emoji_entries[emoji_id] for emoji_id in guild_record.emojis}
        return cache_utility.CacheMappingView(cached_emojis, builder=self._build_emoji)

    def set_emoji(self, emoji: emojis.KnownCustomEmoji, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return None

        user: typing.Optional[cache_utility.RefCell[users.User]] = None
        if emoji.user:
            user = self._set_user(emoji.user)
            if emoji.id not in self._emoji_entries:
                self._increment_ref_count(user)

        emoji_data = cache_utility.KnownCustomEmojiData.build_from_entity(emoji, user=user)
        self._emoji_entries[emoji.id] = emoji_data
        guild_record = self._get_or_create_guild_record(emoji.guild_id)

        if guild_record.emojis is None:  # TODO: add test cases when it is not None?
            guild_record.emojis = collections.SnowflakeSet()

        guild_record.emojis.add(emoji.id)

    def update_emoji(
        self, emoji: emojis.KnownCustomEmoji, /
    ) -&gt; typing.Tuple[typing.Optional[emojis.KnownCustomEmoji], typing.Optional[emojis.KnownCustomEmoji]]:
        if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
            return None, None

        cached_emoji = self.get_emoji(emoji.id)
        self.set_emoji(emoji)
        return cached_emoji, self.get_emoji(emoji.id)

    def _remove_guild_record_if_empty(
        self, guild_id: snowflakes.Snowflake, record: cache_utility.GuildRecord, /
    ) -&gt; None:
        if guild_id in self._guild_entries and record.empty():
            del self._guild_entries[guild_id]

    def _get_or_create_guild_record(self, guild_id: snowflakes.Snowflake) -&gt; cache_utility.GuildRecord:
        if guild_id not in self._guild_entries:
            self._guild_entries[guild_id] = cache_utility.GuildRecord()

        return self._guild_entries[guild_id]

    def clear_guilds(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return cache_utility.EmptyCacheView()

        cached_guilds = {}

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.guild:
                cached_guilds[guild_id] = guild_record.guild
                guild_record.guild = None
                guild_record.is_available = None
                self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_guilds) if cached_guilds else cache_utility.EmptyCacheView()

    def delete_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record:
            return None

        guild = guild_record.guild

        if guild:
            guild_record.guild = None
            guild_record.is_available = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        return guild

    def _get_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /, *, availability: bool
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.guild or guild_record.is_available is not availability:
            return None

        return copy.copy(guild_record.guild)

    def get_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        return copy.copy(guild_record.guild) if guild_record and guild_record.guild else None

    def get_available_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        return self._get_guild(guild, availability=True)

    def get_unavailable_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        return self._get_guild(guild, availability=False)

    def _get_guilds_view(self, *, availability: bool) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        # We may have a guild record without a guild object in cases where we&#39;re caching other entities that belong to
        # the guild therefore we want to make sure record.guild isn&#39;t None.
        results = {
            sf: guild_record.guild
            for sf, guild_record in self._guild_entries.items()
            if guild_record.guild and guild_record.is_available is availability
        }
        return cache_utility.CacheMappingView(results) if results else cache_utility.EmptyCacheView()

    def get_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        return cache_utility.CacheMappingView(
            {guild_id: record.guild for guild_id, record in self._guild_entries.items() if record.guild}
        )

    def get_available_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return cache_utility.EmptyCacheView()

        return self._get_guilds_view(availability=True)

    def get_unavailable_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return cache_utility.EmptyCacheView()

        return self._get_guilds_view(availability=False)

    def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        guild_record = self._get_or_create_guild_record(guild.id)
        guild_record.guild = copy.copy(guild)
        guild_record.is_available = True

    def set_guild_availability(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], is_available: bool, /
    ) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if guild_record and guild_record.guild:
            guild_record.is_available = is_available

    def update_guild(
        self, guild: guilds.GatewayGuild, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.GatewayGuild], typing.Optional[guilds.GatewayGuild]]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
            return None, None

        guild = copy.copy(guild)
        cached_guild = self.get_guild(guild.id)

        # We have to manually update these because Inconsistency is Discord&#39;s middle name.
        if cached_guild:
            guild.member_count = cached_guild.member_count
            guild.joined_at = cached_guild.joined_at
            guild.is_large = cached_guild.is_large

        self.set_guild(guild)
        return cached_guild, self.get_guild(guild.id)

    def clear_guild_channels(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return cache_utility.EmptyCacheView()

        cached_channels = self._guild_channel_entries
        self._guild_channel_entries = collections.FreezableDict()

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.channels:
                guild_record.channels = None
                self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_channels)

    def clear_guild_channels_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.channels:
            return cache_utility.EmptyCacheView()

        cached_channels = {sf: self._guild_channel_entries.pop(sf) for sf in guild_record.channels}
        guild_record.channels = None
        self._remove_guild_record_if_empty(guild_id, guild_record)
        return cache_utility.CacheMappingView(cached_channels)

    def delete_guild_channel(
        self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel], /
    ) -&gt; typing.Optional[channels.GuildChannel]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return None

        channel_id = snowflakes.Snowflake(channel)
        channel = self._guild_channel_entries.pop(channel_id, None)

        if not channel:
            return None

        guild_record = self._guild_entries.get(channel.guild_id)
        if guild_record and guild_record.channels:
            guild_record.channels.remove(channel_id)
            if not guild_record.channels:
                guild_record.channels = None
                self._remove_guild_record_if_empty(channel.guild_id, guild_record)

        return channel

    def get_guild_channel(
        self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel], /
    ) -&gt; typing.Optional[channels.GuildChannel]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return None

        channel = self._guild_channel_entries.get(snowflakes.Snowflake(channel))
        return cache_utility.copy_guild_channel(channel) if channel else None

    def get_guild_channels_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        return cache_utility.CacheMappingView(
            self._guild_channel_entries.freeze(), builder=cache_utility.copy_guild_channel  # type: ignore[type-var]
        )

    def get_guild_channels_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return cache_utility.EmptyCacheView()

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.channels:
            return cache_utility.EmptyCacheView()

        cached_channels = {sf: self._guild_channel_entries[sf] for sf in guild_record.channels}

        def sorter(args: typing.Tuple[snowflakes.Snowflake, channels.GuildChannel]) -&gt; typing.Tuple[int, int, int]:
            channel = args[1]
            if isinstance(channel, channels.GuildCategory):
                return channel.position, -1, 0

            parent_position = -1 if channel.parent_id is None else cached_channels[channel.parent_id].position

            if not isinstance(channel, channels.GuildVoiceChannel):
                return parent_position, 0, channel.position

            return parent_position, 1, channel.position

        cached_channels = dict(sorted(cached_channels.items(), key=sorter))
        return cache_utility.CacheMappingView(
            cached_channels, builder=cache_utility.copy_guild_channel  # type: ignore[type-var]
        )

    def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return None

        self._guild_channel_entries[channel.id] = cache_utility.copy_guild_channel(channel)
        guild_record = self._get_or_create_guild_record(channel.guild_id)

        if guild_record.channels is None:
            guild_record.channels = collections.SnowflakeSet()

        guild_record.channels.add(channel.id)

    def update_guild_channel(
        self, channel: channels.GuildChannel, /
    ) -&gt; typing.Tuple[typing.Optional[channels.GuildChannel], typing.Optional[channels.GuildChannel]]:
        if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
            return None, None

        cached_channel = self.get_guild_channel(channel.id)
        self.set_guild_channel(channel)
        return cached_channel, self.get_guild_channel(channel.id)

    def _build_invite(
        self,
        invite_data: cache_utility.InviteData,
    ) -&gt; invites.InviteWithMetadata:
        return invite_data.build_entity(self._app)

    def _remove_invite_users(self, invite: cache_utility.InviteData) -&gt; None:
        if invite.inviter:
            self._garbage_collect_user(invite.inviter, decrement=1)

        if invite.target_user:
            self._garbage_collect_user(invite.target_user, decrement=1)

    def clear_invites(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        cached_invites = self._invite_entries
        self._invite_entries = collections.FreezableDict()

        for invite_data in cached_invites.values():
            self._remove_invite_users(invite_data)

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.invites:
                guild_record.invites = None
                self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)

    def clear_invites_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)

        if not guild_record or not guild_record.invites:
            return cache_utility.EmptyCacheView()

        cached_invites = {invite_code: self._invite_entries.pop(invite_code) for invite_code in guild_record.invites}
        guild_record.invites = None
        self._remove_guild_record_if_empty(guild_id, guild_record)

        for invite_data in cached_invites.values():
            self._remove_invite_users(invite_data)

        return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)

    def clear_invites_for_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
        /,
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        channel_id = snowflakes.Snowflake(channel)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.invites:
            return cache_utility.EmptyCacheView()

        cached_invites = {}

        for code in tuple(guild_record.invites):
            invite_data = self._invite_entries[code]
            if invite_data.channel_id != channel_id:
                continue

            cached_invites[code] = invite_data
            del self._invite_entries[code]
            guild_record.invites.remove(code)
            self._remove_invite_users(invite_data)

        if not guild_record.invites:
            guild_record.invites = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)

    def delete_invite(
        self, code: typing.Union[invites.InviteCode, str], /
    ) -&gt; typing.Optional[invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return None

        code = code if isinstance(code, str) else code.code
        invite_data = self._invite_entries.pop(code, None)
        if not invite_data:
            return None

        self._remove_invite_users(invite_data)

        if invite_data.guild_id is not None:  # TODO: test case when this is None?
            guild_record = self._guild_entries.get(invite_data.guild_id)
            if guild_record and guild_record.invites:
                guild_record.invites.remove(code)

                if not guild_record.invites:
                    guild_record.invites = None  # TODO: test when this is set to None
                    self._remove_guild_record_if_empty(invite_data.guild_id, guild_record)

        return self._build_invite(invite_data)

    def get_invite(self, code: typing.Union[invites.InviteCode, str], /) -&gt; typing.Optional[invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return None

        code = code if isinstance(code, str) else code.code
        invite_data = self._invite_entries.get(code)
        return self._build_invite(invite_data) if invite_data else None

    def get_invites_view(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(self._invite_entries.freeze(), builder=self._build_invite)

    def get_invites_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_entry = self._guild_entries.get(guild_id)
        if not guild_entry or not guild_entry.invites:
            return cache_utility.EmptyCacheView()

        cached_invites = {code: self._invite_entries[code] for code in guild_entry.invites}
        return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)

    def get_invites_view_for_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
        /,
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        channel_id = snowflakes.Snowflake(channel)
        guild_entry = self._guild_entries.get(guild_id)
        if not guild_entry or not guild_entry.invites:
            return cache_utility.EmptyCacheView()

        cached_invites = {
            invite.code: invite
            for invite in map(self._invite_entries.get, guild_entry.invites)
            if invite and invite.channel_id == channel_id
        }
        return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)

    def set_invite(self, invite: invites.InviteWithMetadata, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return None

        inviter: typing.Optional[cache_utility.RefCell[users.User]] = None
        if invite.inviter:
            inviter = self._set_user(invite.inviter)
            if invite.code not in self._invite_entries:
                self._increment_ref_count(inviter)

        target_user: typing.Optional[cache_utility.RefCell[users.User]] = None
        if invite.target_user:
            target_user = self._set_user(invite.target_user)
            if invite.code not in self._invite_entries:
                self._increment_ref_count(target_user)

        self._invite_entries[invite.code] = cache_utility.InviteData.build_from_entity(
            invite, inviter=inviter, target_user=target_user
        )
        if invite.guild_id:
            guild_entry = self._get_or_create_guild_record(invite.guild_id)

            if guild_entry.invites is None:
                guild_entry.invites = []

            guild_entry.invites.append(invite.code)

    def update_invite(
        self, invite: invites.InviteWithMetadata, /
    ) -&gt; typing.Tuple[typing.Optional[invites.InviteWithMetadata], typing.Optional[invites.InviteWithMetadata]]:
        if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
            return None, None

        cached_invite = self.get_invite(invite.code)
        self.set_invite(invite)
        return cached_invite, self.get_invite(invite.code)

    def delete_me(self) -&gt; typing.Optional[users.OwnUser]:
        cached_user = self._me
        self._me = None
        return cached_user

    def get_me(self) -&gt; typing.Optional[users.OwnUser]:
        return copy.copy(self._me)

    def set_me(self, user: users.OwnUser, /) -&gt; None:
        self._me = copy.copy(user)

    def update_me(
        self, user: users.OwnUser, /
    ) -&gt; typing.Tuple[typing.Optional[users.OwnUser], typing.Optional[users.OwnUser]]:
        _LOGGER.debug(&#34;setting my user to %s&#34;, user)
        cached_user = self.get_me()
        self.set_me(user)
        return cached_user, self._me

    def _build_member(
        self,
        member_data: cache_utility.RefCell[cache_utility.MemberData],
    ) -&gt; guilds.Member:
        return member_data.object.build_entity(self._app)

    @staticmethod
    def _can_remove_member(
        member: cache_utility.RefCell[cache_utility.MemberData],
    ) -&gt; bool:
        return member.ref_count &lt; 1 and member.object.has_been_deleted

    def _garbage_collect_member(
        self,
        guild_record: cache_utility.GuildRecord,
        member: cache_utility.RefCell[cache_utility.MemberData],
        *,
        decrement: typing.Optional[int] = None,
        deleting: bool = False,
    ) -&gt; typing.Optional[cache_utility.RefCell[cache_utility.MemberData]]:
        if deleting:
            member.object.has_been_deleted = True

        if decrement is not None:
            self._increment_ref_count(member, -decrement)

        user_id = member.object.user.object.id
        if not guild_record.members or user_id not in guild_record.members:
            return None

        if not self._can_remove_member(member):
            return None

        del guild_record.members[user_id]
        self._garbage_collect_user(member.object.user, decrement=1)

        if not guild_record.members:
            guild_record.members = None
            self._remove_guild_record_if_empty(member.object.guild_id, guild_record)

        return member

    def clear_members(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return cache_utility.EmptyCacheView()

        views = ((guild_id, self.clear_members_for_guild(guild_id)) for guild_id in self._guild_entries.freeze().keys())
        return cache_utility.CacheMappingView({guild_id: view for guild_id, view in views if view})

    def clear_members_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.members:
            return cache_utility.EmptyCacheView()

        cached_members = guild_record.members.freeze()
        members_gen = (self._garbage_collect_member(guild_record, m, deleting=True) for m in cached_members.values())
        # _garbage_collect_member will only return the member data object if they could be removed, else None.
        cached_members = {member.object.user.object.id: member for member in members_gen if member}
        self._remove_guild_record_if_empty(guild_id, guild_record)
        return cache_utility.CacheMappingView(cached_members, builder=self._build_member)  # type: ignore[type-var]

    def delete_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[guilds.Member]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.members:
            return None

        member_data = guild_record.members.get(user_id)
        if not member_data:
            return None

        if not guild_record.members:
            guild_record.members = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        # _garbage_collect_member will only return the member data object if they could be removed, else None.
        garbage_collected = self._garbage_collect_member(guild_record, member_data, deleting=True)
        return self._build_member(member_data) if garbage_collected else None

    def get_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[guilds.Member]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.members:
            return None

        member = guild_record.members.get(user_id)
        return self._build_member(member) if member else None

    def get_members_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return cache_utility.EmptyCacheView()

        views: typing.Mapping[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]] = {
            guild_id: cache_utility.CacheMappingView(view.members.freeze(), builder=self._build_member)  # type: ignore[type-var]
            for guild_id, view in self._guild_entries.items()
            if view.members
        }
        return cache_utility.Cache3DMappingView(views)

    def get_members_view_for_guild(
        self, guild_id: snowflakes.Snowflakeish, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild_id)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.members:
            return cache_utility.EmptyCacheView()

        cached_members = {
            user_id: member for user_id, member in guild_record.members.items() if not member.object.has_been_deleted
        }

        return cache_utility.CacheMappingView(cached_members, builder=self._build_member)  # type: ignore[type-var]

    def set_member(self, member: guilds.Member, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return None

        self._set_member(member, is_reference=False)

    def _set_member(
        self, member: guilds.Member, /, *, is_reference: bool = True
    ) -&gt; cache_utility.RefCell[cache_utility.MemberData]:
        guild_record = self._get_or_create_guild_record(member.guild_id)
        user = self._set_user(member.user)
        member_data = cache_utility.MemberData.build_from_entity(member, user=user)

        if guild_record.members is None:  # TODO: test when this is not None
            guild_record.members = collections.FreezableDict()

        if member.user.id not in guild_record.members:
            self._increment_ref_count(member_data.user)

        try:
            member_data.has_been_deleted = False
            if is_reference:
                member_data.has_been_deleted = guild_record.members[member.id].object.has_been_deleted

            guild_record.members[member.id].object = member_data

        except KeyError:
            member_data.has_been_deleted = is_reference
            guild_record.members[member.id] = cache_utility.RefCell(member_data)

        return guild_record.members[member.id]

    def update_member(
        self, member: guilds.Member, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.Member], typing.Optional[guilds.Member]]:
        if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
            return None, None

        cached_member = self.get_member(member.guild_id, member.user.id)
        self.set_member(member)
        return cached_member, self.get_member(member.guild_id, member.user.id)

    def _build_presence(
        self,
        presence_data: cache_utility.MemberPresenceData,
    ) -&gt; presences.MemberPresence:
        return presence_data.build_entity(self._app)

    def _garbage_collect_unknown_custom_emoji(
        self, emoji: cache_utility.RefCell[emojis.CustomEmoji], *, decrement: typing.Optional[int] = None
    ) -&gt; None:
        if decrement is not None:
            self._increment_ref_count(emoji, -decrement)

        if emoji.ref_count &lt; 1 and emoji.object.id in self._unknown_custom_emoji_entries:
            del self._unknown_custom_emoji_entries[emoji.object.id]

    def _remove_presence_assets(
        self,
        presence_data: cache_utility.MemberPresenceData,
    ) -&gt; None:
        for activity_data in presence_data.activities:
            if isinstance(activity_data.emoji, cache_utility.RefCell):
                self._garbage_collect_unknown_custom_emoji(activity_data.emoji, decrement=1)

    def clear_presences(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return cache_utility.EmptyCacheView()

        views = (
            (guild_id, self.clear_presences_for_guild(guild_id)) for guild_id in self._guild_entries.freeze().keys()
        )
        return cache_utility.CacheMappingView({guild_id: view for guild_id, view in views if view})

    def clear_presences_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.presences:
            return cache_utility.EmptyCacheView()

        cached_presences = guild_record.presences
        guild_record.presences = None

        for presence in cached_presences.values():
            self._remove_presence_assets(presence)

        self._remove_guild_record_if_empty(guild_id, guild_record)
        return cache_utility.CacheMappingView(cached_presences, builder=self._build_presence)

    def delete_presence(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[presences.MemberPresence]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.presences:
            return None

        presence_data = guild_record.presences.pop(user_id, None)

        if not presence_data:
            return None

        self._remove_presence_assets(presence_data)

        if not guild_record.presences:
            guild_record.presences = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        return self._build_presence(presence_data)

    def get_presence(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[presences.MemberPresence]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.presences:
            return None

        return self._build_presence(guild_record.presences[user_id]) if user_id in guild_record.presences else None

    def get_presences_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return cache_utility.EmptyCacheView()

        views = {
            guild_id: cache_utility.CacheMappingView(guild_record.presences.freeze(), builder=self._build_presence)
            for guild_id, guild_record in self._guild_entries.items()
            if guild_record.presences
        }
        return cache_utility.Cache3DMappingView(views)

    def get_presences_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return cache_utility.EmptyCacheView()

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.presences:
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(guild_record.presences.freeze(), builder=self._build_presence)

    def set_presence(self, presence: presences.MemberPresence, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return None

        presence_data = cache_utility.MemberPresenceData.build_from_entity(presence)
        for activity, activity_data in zip(presence.activities, presence_data.activities):
            emoji = activity.emoji
            if not isinstance(emoji, emojis.CustomEmoji):
                continue

            if emoji.id in self._unknown_custom_emoji_entries:
                self._unknown_custom_emoji_entries[emoji.id].object = copy.copy(emoji)
                emoji_data = self._unknown_custom_emoji_entries[emoji.id]

            else:
                emoji_data = cache_utility.RefCell(copy.copy(emoji))
                self._unknown_custom_emoji_entries[emoji.id] = emoji_data

            self._increment_ref_count(emoji_data)
            activity_data.emoji = emoji_data

        guild_record = self._get_or_create_guild_record(presence.guild_id)
        if guild_record.presences is None:
            guild_record.presences = collections.FreezableDict()

        guild_record.presences[presence.user_id] = presence_data

    def update_presence(
        self, presence: presences.MemberPresence, /
    ) -&gt; typing.Tuple[typing.Optional[presences.MemberPresence], typing.Optional[presences.MemberPresence]]:
        if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
            return None, None

        cached_presence = self.get_presence(presence.guild_id, presence.user_id)
        self.set_presence(presence)
        return cached_presence, self.get_presence(presence.guild_id, presence.user_id)

    def clear_roles(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES) or not self._role_entries:
            return cache_utility.EmptyCacheView()

        roles = self._role_entries
        self._role_entries = collections.FreezableDict()

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.roles:  # TODO: test coverage for when not this
                guild_record.roles = None
                self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(roles)

    def clear_roles_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.roles:
            return cache_utility.EmptyCacheView()

        view = cache_utility.CacheMappingView(
            {role_id: self._role_entries.pop(role_id) for role_id in guild_record.roles}
        )
        guild_record.roles = None
        self._remove_guild_record_if_empty(guild_id, guild_record)
        return view

    def delete_role(self, role: snowflakes.SnowflakeishOr[guilds.PartialRole], /) -&gt; typing.Optional[guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return None

        role_id = snowflakes.Snowflake(role)
        role = self._role_entries.pop(role_id, None)
        if not role:
            return None

        guild_record = self._guild_entries.get(role.guild_id)
        if guild_record and guild_record.roles:
            guild_record.roles.remove(role_id)

            if not guild_record.roles:
                guild_record.roles = None
                self._remove_guild_record_if_empty(role.guild_id, guild_record)

        return role

    def get_role(self, role: snowflakes.SnowflakeishOr[guilds.PartialRole], /) -&gt; typing.Optional[guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return None

        role = self._role_entries.get(snowflakes.Snowflake(role))
        return copy.copy(role) if role else None

    def get_roles_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(self._role_entries.freeze())

    def get_roles_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return cache_utility.EmptyCacheView()

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.roles:
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView({role_id: self._role_entries[role_id] for role_id in guild_record.roles})

    def set_role(self, role: guilds.Role, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return None

        self._role_entries[role.id] = role
        guild_record = self._get_or_create_guild_record(role.guild_id)

        if guild_record.roles is None:  # TODO: test when this is not None
            guild_record.roles = collections.SnowflakeSet()

        guild_record.roles.add(role.id)

    def update_role(
        self, role: guilds.Role, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.Role], typing.Optional[guilds.Role]]:
        if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
            return None, None

        cached_role = self.get_role(role.id)
        self.set_role(role)
        return cached_role, self.get_role(role.id)

    @staticmethod
    def _can_remove_user(user_data: cache_utility.RefCell[users.User]) -&gt; bool:
        return user_data.ref_count &lt; 1

    def _garbage_collect_user(
        self, user: cache_utility.RefCell[users.User], *, decrement: typing.Optional[int] = None
    ) -&gt; None:
        if decrement is not None:
            self._increment_ref_count(user, -decrement)

        if self._can_remove_user(user) and user.object.id in self._user_entries:
            del self._user_entries[user.object.id]
            self._dm_channel_entries.pop(user.object.id, None)

    def get_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; typing.Optional[users.User]:
        user = self._user_entries.get(snowflakes.Snowflake(user))
        return user.copy() if user else None

    def get_users_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, users.User]:
        if not self._user_entries:
            return cache_utility.EmptyCacheView()

        cached_users = self._user_entries.freeze()
        unwrapper = typing.cast(
            &#34;typing.Callable[[cache_utility.RefCell[users.User]], users.User]&#34;, cache_utility.unwrap_ref_cell
        )
        return cache_utility.CacheMappingView(cached_users, builder=unwrapper)  # type: ignore[type-var]

    def _set_user(self, user: users.User, /) -&gt; cache_utility.RefCell[users.User]:
        try:
            self._user_entries[user.id].object = copy.copy(user)
            cell = self._user_entries[user.id]
        except KeyError:
            cell = cache_utility.RefCell(copy.copy(user))
            self._user_entries[user.id] = cell

        return cell

    def _build_voice_state(
        self,
        voice_data: cache_utility.VoiceStateData,
    ) -&gt; voices.VoiceState:
        return voice_data.build_entity(self._app)

    def clear_voice_states(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        views = (
            (guild_id, self.clear_voice_states_for_guild(guild_id)) for guild_id in self._guild_entries.freeze().keys()
        )
        return cache_utility.CacheMappingView({guild_id: view for guild_id, view in views if view})

    def clear_voice_states_for_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
        /,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        channel_id = snowflakes.Snowflake(channel)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.voice_states:
            return cache_utility.EmptyCacheView()

        cached_voice_states = {}

        for user_id, voice_state in guild_record.voice_states.items():
            if voice_state.channel_id == channel_id:
                cached_voice_states[user_id] = voice_state
                self._garbage_collect_member(guild_record, voice_state.member, decrement=1)

        if not guild_record.voice_states:
            guild_record.voice_states = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

        return cache_utility.CacheMappingView(cached_voice_states, builder=self._build_voice_state)

    def clear_voice_states_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        guild_record = self._guild_entries.get(guild_id)

        if not guild_record or not guild_record.voice_states:
            return cache_utility.EmptyCacheView()

        cached_voice_states = guild_record.voice_states
        guild_record.voice_states = None

        for voice_state in cached_voice_states.values():
            self._garbage_collect_member(guild_record, voice_state.member, decrement=1)

        self._remove_guild_record_if_empty(guild_id, guild_record)
        return cache_utility.CacheMappingView(cached_voice_states, builder=self._build_voice_state)

    def delete_voice_state(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.voice_states:
            return None

        voice_state_data = guild_record.voice_states.pop(user_id, None)
        if not voice_state_data:
            return None

        if not guild_record.voice_states:
            guild_record.voice_states = None

        self._garbage_collect_member(guild_record, voice_state_data.member, decrement=1)
        self._remove_guild_record_if_empty(guild_id, guild_record)
        return self._build_voice_state(voice_state_data)

    def get_voice_state(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        /,
    ) -&gt; typing.Optional[voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return None

        guild_id = snowflakes.Snowflake(guild)
        user_id = snowflakes.Snowflake(user)
        guild_record = self._guild_entries.get(guild_id)
        voice_data = guild_record.voice_states.get(user_id) if guild_record and guild_record.voice_states else None
        return self._build_voice_state(voice_data) if voice_data else None

    def get_voice_states_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        views = {
            guild_id: cache_utility.CacheMappingView(
                guild_record.voice_states.freeze(), builder=self._build_voice_state
            )
            for guild_id, guild_record in self._guild_entries.items()
            if guild_record.voice_states
        }
        return cache_utility.Cache3DMappingView(views)

    def get_voice_states_view_for_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
        /,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        guild_id = snowflakes.Snowflake(guild)
        channel_id = snowflakes.Snowflake(channel)
        guild_record = self._guild_entries.get(guild_id)
        if not guild_record or not guild_record.voice_states:
            return cache_utility.EmptyCacheView()

        cached_voice_states = {
            user_id: voice_state
            for user_id, voice_state in guild_record.voice_states.items()
            if voice_state.channel_id == channel_id
        }

        return cache_utility.CacheMappingView(cached_voice_states, builder=self._build_voice_state)

    def get_voice_states_view_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return cache_utility.EmptyCacheView()

        guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
        if not guild_record or not guild_record.voice_states:
            return cache_utility.EmptyCacheView()

        return cache_utility.CacheMappingView(guild_record.voice_states.freeze(), builder=self._build_voice_state)

    def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return None

        guild_record = self._get_or_create_guild_record(voice_state.guild_id)

        if guild_record.voice_states is None:  # TODO: test when this is not None
            guild_record.voice_states = collections.FreezableDict()

        member = self._set_member(voice_state.member)
        voice_state_data = cache_utility.VoiceStateData.build_from_entity(voice_state, member=member)

        if voice_state.user_id not in guild_record.voice_states:
            self._increment_ref_count(member)

        guild_record.voice_states[voice_state.user_id] = voice_state_data

    def update_voice_state(
        self, voice_state: voices.VoiceState, /
    ) -&gt; typing.Tuple[typing.Optional[voices.VoiceState], typing.Optional[voices.VoiceState]]:
        if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
            return None, None

        cached_voice_state = self.get_voice_state(voice_state.guild_id, voice_state.user_id)
        self.set_voice_state(voice_state)
        return cached_voice_state, self.get_voice_state(voice_state.guild_id, voice_state.user_id)

    def _build_message(self, message_data: cache_utility.RefCell[cache_utility.MessageData]) -&gt; messages.Message:
        return message_data.object.build_entity(self._app)

    def _can_remove_message(self, message: cache_utility.RefCell[cache_utility.MessageData]) -&gt; bool:
        return message.object.id not in self._message_entries and message.ref_count &lt; 1

    def _garbage_collect_message(
        self,
        message: cache_utility.RefCell[cache_utility.MessageData],
        *,
        decrement: typing.Optional[int] = None,
        override_ref: bool = False,
    ) -&gt; typing.Optional[cache_utility.RefCell[cache_utility.MessageData]]:
        if decrement is not None:
            self._increment_ref_count(message, -decrement)

        if not self._can_remove_message(message) or override_ref:
            return None

        self._garbage_collect_user(message.object.author, decrement=1)

        if message.object.member:
            guild_record = self._guild_entries.get(message.object.member.object.guild_id)
            if guild_record:
                self._garbage_collect_member(guild_record, message.object.member, decrement=1)

        if message.object.referenced_message:
            self._garbage_collect_message(message.object.referenced_message, decrement=1)

        if message.object.mentions.users:
            for user in message.object.mentions.users.values():
                self._garbage_collect_user(user, decrement=1)

        # If we got this far the message won&#39;t be in _message_entries as that&#39;d infer that it hasn&#39;t been marked as
        # deleted yet.
        if message.object.id in self._referenced_messages:
            del self._referenced_messages[message.object.id]

        return message

    def _on_message_expire(self, message: cache_utility.RefCell[cache_utility.MessageData], /) -&gt; None:
        if not self._garbage_collect_message(message):
            self._referenced_messages[message.object.id] = message

    def clear_messages(self) -&gt; cache.CacheView[snowflakes.Snowflake, messages.Message]:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES) or not self._message_entries:
            return cache_utility.EmptyCacheView()

        # As the only entry which references messages is other messages, this is enough for now.
        cached_messages = self._message_entries.freeze()
        self._message_entries.clear()
        cached_messages.update(self._referenced_messages)
        self._referenced_messages.clear()

        for message in cached_messages.values():
            self._garbage_collect_message(message, override_ref=True)

        return cache_utility.CacheMappingView(cached_messages, builder=self._build_message)  # type: ignore[type-var]

    def delete_message(
        self, message: snowflakes.SnowflakeishOr[messages.PartialMessage], /
    ) -&gt; typing.Optional[messages.Message]:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
            return None

        message_id = snowflakes.Snowflake(message)
        message_data = self._message_entries.pop(message_id, None)

        if not message_data:
            return None

        if not self._garbage_collect_message(message_data):
            self._referenced_messages[message_id] = message_data
            return None

        return self._build_message(message_data)

    def get_message(
        self, message: snowflakes.SnowflakeishOr[messages.PartialMessage], /
    ) -&gt; typing.Optional[messages.Message]:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
            return None

        message_id = snowflakes.Snowflake(message)
        message_data = self._message_entries.get(message_id) or self._referenced_messages.get(message_id)
        return self._build_message(message_data) if message_data else None

    def get_messages_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, messages.Message]:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
            return cache_utility.EmptyCacheView()

        cached_messages = self._message_entries.freeze()
        cached_messages.update(self._referenced_messages)
        return cache_utility.CacheMappingView(cached_messages, builder=self._build_message)  # type: ignore[type-var]

    def _set_message(
        self, message: messages.Message, /, *, is_reference: bool = True
    ) -&gt; cache_utility.RefCell[cache_utility.MessageData]:
        author = self._set_user(message.author)
        member = self._set_member(message.member) if message.member else None

        mention_users: undefined.UndefinedOr[
            typing.Mapping[snowflakes.Snowflake, cache_utility.RefCell[users.User]]
        ] = undefined.UNDEFINED
        if message.mentions.users is not undefined.UNDEFINED:
            mention_users = {user_id: self._set_user(user) for user_id, user in message.mentions.users.items()}

        interaction_user: typing.Optional[cache_utility.RefCell[users.User]] = None
        if message.interaction:
            interaction_user = self._set_user(message.interaction.user)

        referenced_message: typing.Optional[cache_utility.RefCell[cache_utility.MessageData]] = None
        if message.referenced_message:
            referenced_message = self._set_message(message.referenced_message)

        # Only increment ref counts if this wasn&#39;t previously cached.
        if message.id not in self._referenced_messages and message.id not in self._message_entries:
            if member:
                self._increment_ref_count(member)

            if referenced_message:
                self._increment_ref_count(referenced_message)

            if mention_users is not undefined.UNDEFINED:
                for user in mention_users.values():
                    self._increment_ref_count(user)

            if interaction_user:
                self._increment_ref_count(interaction_user)

        message_data = cache_utility.MessageData.build_from_entity(
            message,
            author=author,
            member=member,
            mention_users=mention_users,
            referenced_message=referenced_message,
            interaction_user=interaction_user,
        )

        # Ensure any previously set message ref cell is in the right place before updating the cache.
        if not is_reference and message.id in self._referenced_messages:
            self._message_entries[message.id] = self._referenced_messages.pop(message.id)

        if message.id in self._message_entries:
            self._message_entries[message.id].object = message_data

        elif not is_reference:
            self._message_entries[message.id] = cache_utility.RefCell(message_data)

        elif message.id in self._referenced_messages:
            self._referenced_messages[message.id].object = message_data

        else:
            self._referenced_messages[message.id] = cache_utility.RefCell(message_data)

        return self._message_entries.get(message.id) or self._referenced_messages[message.id]

    def set_message(self, message: messages.Message, /) -&gt; None:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
            return None

        self._set_message(message, is_reference=False)

    def update_message(
        self, message: typing.Union[messages.PartialMessage, messages.Message], /
    ) -&gt; typing.Tuple[typing.Optional[messages.Message], typing.Optional[messages.Message]]:
        if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
            return None, None

        cached_message = self.get_message(message.id)

        if isinstance(message, messages.Message):
            self.set_message(message)

        elif cached_message_data := self._message_entries.get(message.id) or self._referenced_messages.get(message.id):
            mention_user: undefined.UndefinedOr[
                typing.Mapping[snowflakes.Snowflake, cache_utility.RefCell[users.User]]
            ] = undefined.UNDEFINED
            if message.mentions.users is not undefined.UNDEFINED:
                mention_user = {user_id: self._set_user(user) for user_id, user in message.mentions.users.items()}

                # We want to ensure that any previously mentioned users are garbage collected if they&#39;re no longer
                # being mentioned.
                if cached_message_data.object.mentions.users is not undefined.UNDEFINED:
                    for user_id, user in cached_message_data.object.mentions.users.items():
                        if user_id not in mention_user:
                            self._garbage_collect_user(user, decrement=1)

            cached_message_data.object.update(message, mention_users=mention_user)

        return cached_message, self.get_message(message.id)</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="CacheImpl -- In-memory cache implementation …" href="#hikari.impl.cache.CacheImpl"
>CacheImpl</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></dt>
<dd class="nested"><p>Cache that exposes read-only operations as well as mutation operations …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Cache -- Interface describing the operations a cache component should provide …" href="../api/cache.html#hikari.api.cache.Cache"
>Cache</a></dt>
<dd class="nested"><p>Interface describing the operations a cache component should provide …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.impl.cache.CacheImpl.settings" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="settings -- " href="#hikari.impl.cache.CacheImpl.settings"  >settings</a> : <a href='../config.html#hikari.config.CacheSettings'>CacheSettings</a></code></pre>
</dt>
<dd></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.impl.cache.CacheImpl.clear" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear" href="#hikari.impl.cache.CacheImpl.clear" id="hikari.impl.cache.CacheImpl.clear">clear</a>() -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear -- Clear the full cache." href="../api/cache.html#hikari.api.cache.MutableCache.clear"
>clear</a></code>
</p>
<p>Clear the full cache.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L138-L142" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    if self._settings.components == config.CacheComponents.NONE:
        return None

    self._create_cache()</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_dm_channel_ids" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_dm_channel_ids" href="#hikari.impl.cache.CacheImpl.clear_dm_channel_ids" id="hikari.impl.cache.CacheImpl.clear_dm_channel_ids">clear_dm_channel_ids</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_dm_channel_ids -- Remove all the cached DM channel IDs …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_dm_channel_ids"
>clear_dm_channel_ids</a></code>
</p>
<p>Remove all the cached DM channel IDs.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>]</code></dt>
<dd>Cache view of user IDs to DM channel IDs which were cleared from
the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L144-L150" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_dm_channel_ids(self) -&gt; cache.CacheView[snowflakes.Snowflake, snowflakes.Snowflake]:
    if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
        return cache_utility.EmptyCacheView()

    result = self._dm_channel_entries
    self._dm_channel_entries = collections.LimitedCapacityCacheMap(limit=self._settings.max_dm_channel_ids)
    return cache_utility.CacheMappingView(result)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_emojis" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_emojis" href="#hikari.impl.cache.CacheImpl.clear_emojis" id="hikari.impl.cache.CacheImpl.clear_emojis">clear_emojis</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_emojis -- Remove all the known custom emoji objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_emojis"
>clear_emojis</a></code>
</p>
<p>Remove all the known custom emoji objects from the cache.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will skip emojis that are being kept alive by a reference
on a presence entry.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>A cache view of emoji IDs to objects of the emojis that were
removed from the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L191-L206" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_emojis(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
    if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
        return cache_utility.EmptyCacheView()

    cached_emojis = self._emoji_entries
    self._emoji_entries = collections.FreezableDict()

    for emoji_data in cached_emojis.values():
        if emoji_data.user:
            self._garbage_collect_user(emoji_data.user, decrement=1)

    for guild_id, guild_record in self._guild_entries.freeze().items():
        guild_record.emojis = None
        self._remove_guild_record_if_empty(guild_id, guild_record)

    return cache_utility.CacheMappingView(cached_emojis, builder=self._build_emoji)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_emojis_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_emojis_for_guild" href="#hikari.impl.cache.CacheImpl.clear_emojis_for_guild" id="hikari.impl.cache.CacheImpl.clear_emojis_for_guild">clear_emojis_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>emojis.KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_emojis_for_guild -- Remove the known custom emoji objects cached for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_emojis_for_guild"
>clear_emojis_for_guild</a></code>
</p>
<p>Remove the known custom emoji objects cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove the cached emoji objects for.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will skip emojis that are being kept alive by a reference
on a presence entry.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>A view of emoji IDs to objects of the emojis that were removed
from the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L208-L227" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_emojis_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
    if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.emojis:
        return cache_utility.EmptyCacheView()

    cached_emojis = {emoji_id: self._emoji_entries.pop(emoji_id) for emoji_id in guild_record.emojis}
    guild_record.emojis = None
    self._remove_guild_record_if_empty(guild_id, guild_record)

    for emoji_data in cached_emojis.values():
        if emoji_data.user:
            self._garbage_collect_user(emoji_data.user, decrement=1)

    return cache_utility.CacheMappingView(cached_emojis, builder=self._build_emoji)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_guild_channels" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_guild_channels" href="#hikari.impl.cache.CacheImpl.clear_guild_channels" id="hikari.impl.cache.CacheImpl.clear_guild_channels">clear_guild_channels</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_guild_channels -- Remove all guild channels from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_guild_channels"
>clear_guild_channels</a></code>
</p>
<p>Remove all guild channels from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>A view of channel IDs to objects of the guild channels that were
removed from the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L453-L465" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_guild_channels(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
        return cache_utility.EmptyCacheView()

    cached_channels = self._guild_channel_entries
    self._guild_channel_entries = collections.FreezableDict()

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if guild_record.channels:
            guild_record.channels = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

    return cache_utility.CacheMappingView(cached_channels)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_guild_channels_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_guild_channels_for_guild" href="#hikari.impl.cache.CacheImpl.clear_guild_channels_for_guild" id="hikari.impl.cache.CacheImpl.clear_guild_channels_for_guild">clear_guild_channels_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_guild_channels_for_guild -- Remove guild channels from the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_guild_channels_for_guild"
>clear_guild_channels_for_guild</a></code>
</p>
<p>Remove guild channels from the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove cached channels for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>A view of channel IDs to objects of the guild channels that were
removed from the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L467-L481" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_guild_channels_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.channels:
        return cache_utility.EmptyCacheView()

    cached_channels = {sf: self._guild_channel_entries.pop(sf) for sf in guild_record.channels}
    guild_record.channels = None
    self._remove_guild_record_if_empty(guild_id, guild_record)
    return cache_utility.CacheMappingView(cached_channels)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_guilds" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_guilds" href="#hikari.impl.cache.CacheImpl.clear_guilds" id="hikari.impl.cache.CacheImpl.clear_guilds">clear_guilds</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_guilds -- Remove all the guild objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_guilds"
>clear_guilds</a></code>
</p>
<p>Remove all the guild objects from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The cache view of guild IDs to guild objects that were removed from
the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L321-L334" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_guilds(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
        return cache_utility.EmptyCacheView()

    cached_guilds = {}

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if guild_record.guild:
            cached_guilds[guild_id] = guild_record.guild
            guild_record.guild = None
            guild_record.is_available = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

    return cache_utility.CacheMappingView(cached_guilds) if cached_guilds else cache_utility.EmptyCacheView()</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_invites" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_invites" href="#hikari.impl.cache.CacheImpl.clear_invites" id="hikari.impl.cache.CacheImpl.clear_invites">clear_invites</a>() -> cache.CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_invites -- Remove all the invite objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_invites"
>clear_invites</a></code>
</p>
<p>Remove all the invite objects from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>A view of invite code strings to objects of the invites that were
removed from the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L582-L597" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_invites(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
        return cache_utility.EmptyCacheView()

    cached_invites = self._invite_entries
    self._invite_entries = collections.FreezableDict()

    for invite_data in cached_invites.values():
        self._remove_invite_users(invite_data)

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if guild_record.invites:
            guild_record.invites = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

    return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_invites_for_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_invites_for_channel" href="#hikari.impl.cache.CacheImpl.clear_invites_for_channel" id="hikari.impl.cache.CacheImpl.clear_invites_for_channel">clear_invites_for_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
    /,
) -> cache.CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_invites_for_channel -- Remove the invite objects in the cache for a specific channel …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_invites_for_channel"
>clear_invites_for_channel</a></code>
</p>
<p>Remove the invite objects in the cache for a specific channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove invite objects for.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>Object or ID of the channel to remove invite objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>A view of invite code strings to objects of the invites that were
removed from the cache for the specified channel.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L620-L651" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_invites_for_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
    /,
) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    channel_id = snowflakes.Snowflake(channel)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.invites:
        return cache_utility.EmptyCacheView()

    cached_invites = {}

    for code in tuple(guild_record.invites):
        invite_data = self._invite_entries[code]
        if invite_data.channel_id != channel_id:
            continue

        cached_invites[code] = invite_data
        del self._invite_entries[code]
        guild_record.invites.remove(code)
        self._remove_invite_users(invite_data)

    if not guild_record.invites:
        guild_record.invites = None
        self._remove_guild_record_if_empty(guild_id, guild_record)

    return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_invites_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_invites_for_guild" href="#hikari.impl.cache.CacheImpl.clear_invites_for_guild" id="hikari.impl.cache.CacheImpl.clear_invites_for_guild">clear_invites_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_invites_for_guild -- Remove the invite objects in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_invites_for_guild"
>clear_invites_for_guild</a></code>
</p>
<p>Remove the invite objects in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove invite objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>A view of invite code strings to objects of the invites that were
removed from the cache for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L599-L618" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_invites_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    guild_record = self._guild_entries.get(guild_id)

    if not guild_record or not guild_record.invites:
        return cache_utility.EmptyCacheView()

    cached_invites = {invite_code: self._invite_entries.pop(invite_code) for invite_code in guild_record.invites}
    guild_record.invites = None
    self._remove_guild_record_if_empty(guild_id, guild_record)

    for invite_data in cached_invites.values():
        self._remove_invite_users(invite_data)

    return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_members" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_members" href="#hikari.impl.cache.CacheImpl.clear_members" id="hikari.impl.cache.CacheImpl.clear_members">clear_members</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_members -- Remove all the guild members in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_members"
>clear_members</a></code>
</p>
<p>Remove all the guild members in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the members
that were removed from the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L825-L832" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_members(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
    if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
        return cache_utility.EmptyCacheView()

    views = ((guild_id, self.clear_members_for_guild(guild_id)) for guild_id in self._guild_entries.freeze().keys())
    return cache_utility.CacheMappingView({guild_id: view for guild_id, view in views if view})</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_members_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_members_for_guild" href="#hikari.impl.cache.CacheImpl.clear_members_for_guild" id="hikari.impl.cache.CacheImpl.clear_members_for_guild">clear_members_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_members_for_guild -- Remove the members for a specific guild from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_members_for_guild"
>clear_members_for_guild</a></code>
</p>
<p>Remove the members for a specific guild from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove cached members for.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will skip members that are being referenced by other entries in
the cache; a matching voice state will keep a member entry alive.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>The view of user IDs to the member objects that were removed from
the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L834-L850" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_members_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
    if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.members:
        return cache_utility.EmptyCacheView()

    cached_members = guild_record.members.freeze()
    members_gen = (self._garbage_collect_member(guild_record, m, deleting=True) for m in cached_members.values())
    # _garbage_collect_member will only return the member data object if they could be removed, else None.
    cached_members = {member.object.user.object.id: member for member in members_gen if member}
    self._remove_guild_record_if_empty(guild_id, guild_record)
    return cache_utility.CacheMappingView(cached_members, builder=self._build_member)  # type: ignore[type-var]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_messages" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_messages" href="#hikari.impl.cache.CacheImpl.clear_messages" id="hikari.impl.cache.CacheImpl.clear_messages">clear_messages</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../messages.html#hikari.messages.Message'>Message</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_messages -- Remove all message objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_messages"
>clear_messages</a></code>
</p>
<p>Remove all message objects from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>A view of message objects that were removed from the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1494-L1507" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_messages(self) -&gt; cache.CacheView[snowflakes.Snowflake, messages.Message]:
    if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES) or not self._message_entries:
        return cache_utility.EmptyCacheView()

    # As the only entry which references messages is other messages, this is enough for now.
    cached_messages = self._message_entries.freeze()
    self._message_entries.clear()
    cached_messages.update(self._referenced_messages)
    self._referenced_messages.clear()

    for message in cached_messages.values():
        self._garbage_collect_message(message, override_ref=True)

    return cache_utility.CacheMappingView(cached_messages, builder=self._build_message)  # type: ignore[type-var]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_presences" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_presences" href="#hikari.impl.cache.CacheImpl.clear_presences" id="hikari.impl.cache.CacheImpl.clear_presences">clear_presences</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_presences -- Remove all the presences in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_presences"
>clear_presences</a></code>
</p>
<p>Remove all the presences in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the presences
that were removed from the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L992-L1001" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_presences(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
    if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
        return cache_utility.EmptyCacheView()

    views = (
        (guild_id, self.clear_presences_for_guild(guild_id)) for guild_id in self._guild_entries.freeze().keys()
    )
    return cache_utility.CacheMappingView({guild_id: view for guild_id, view in views if view})</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_presences_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_presences_for_guild" href="#hikari.impl.cache.CacheImpl.clear_presences_for_guild" id="hikari.impl.cache.CacheImpl.clear_presences_for_guild">clear_presences_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_presences_for_guild -- Remove the presences in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_presences_for_guild"
>clear_presences_for_guild</a></code>
</p>
<p>Remove the presences in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove presences for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]</code></dt>
<dd>A view of user IDs to objects of the presences that were removed
from the cache for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1003-L1021" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_presences_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
    if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.presences:
        return cache_utility.EmptyCacheView()

    cached_presences = guild_record.presences
    guild_record.presences = None

    for presence in cached_presences.values():
        self._remove_presence_assets(presence)

    self._remove_guild_record_if_empty(guild_id, guild_record)
    return cache_utility.CacheMappingView(cached_presences, builder=self._build_presence)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_roles" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_roles" href="#hikari.impl.cache.CacheImpl.clear_roles" id="hikari.impl.cache.CacheImpl.clear_roles">clear_roles</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_roles -- Remove all role objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_roles"
>clear_roles</a></code>
</p>
<p>Remove all role objects from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>A view of role IDs to objects of the roles that were removed from
the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1130-L1142" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_roles(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
    if not self._is_cache_enabled_for(config.CacheComponents.ROLES) or not self._role_entries:
        return cache_utility.EmptyCacheView()

    roles = self._role_entries
    self._role_entries = collections.FreezableDict()

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if guild_record.roles:  # TODO: test coverage for when not this
            guild_record.roles = None
            self._remove_guild_record_if_empty(guild_id, guild_record)

    return cache_utility.CacheMappingView(roles)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_roles_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_roles_for_guild" href="#hikari.impl.cache.CacheImpl.clear_roles_for_guild" id="hikari.impl.cache.CacheImpl.clear_roles_for_guild">clear_roles_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_roles_for_guild -- Remove role objects from the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_roles_for_guild"
>clear_roles_for_guild</a></code>
</p>
<p>Remove role objects from the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove roles for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>A view of role IDs to objects of the roles that were removed from
the cache for the specific guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1144-L1160" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_roles_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
    if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.roles:
        return cache_utility.EmptyCacheView()

    view = cache_utility.CacheMappingView(
        {role_id: self._role_entries.pop(role_id) for role_id in guild_record.roles}
    )
    guild_record.roles = None
    self._remove_guild_record_if_empty(guild_id, guild_record)
    return view</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_voice_states" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_voice_states" href="#hikari.impl.cache.CacheImpl.clear_voice_states" id="hikari.impl.cache.CacheImpl.clear_voice_states">clear_voice_states</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_voice_states -- Remove all voice state objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_voice_states"
>clear_voice_states</a></code>
</p>
<p>Remove all voice state objects from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the voice
states that were removed from the states.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1272-L1281" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_voice_states(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
    if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
        return cache_utility.EmptyCacheView()

    views = (
        (guild_id, self.clear_voice_states_for_guild(guild_id)) for guild_id in self._guild_entries.freeze().keys()
    )
    return cache_utility.CacheMappingView({guild_id: view for guild_id, view in views if view})</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_voice_states_for_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_voice_states_for_channel" href="#hikari.impl.cache.CacheImpl.clear_voice_states_for_channel" id="hikari.impl.cache.CacheImpl.clear_voice_states_for_channel">clear_voice_states_for_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_voice_states_for_channel -- Remove the voice state objects cached for a specific channel …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_voice_states_for_channel"
>clear_voice_states_for_channel</a></code>
</p>
<p>Remove the voice state objects cached for a specific channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove voice states for.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>Object or ID of the channel to remove voice states for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>A view of user IDs to objects of the voice state that were removed
from the cache for the specified channel.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1283-L1309" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_voice_states_for_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
    /,
) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
    if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    channel_id = snowflakes.Snowflake(channel)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.voice_states:
        return cache_utility.EmptyCacheView()

    cached_voice_states = {}

    for user_id, voice_state in guild_record.voice_states.items():
        if voice_state.channel_id == channel_id:
            cached_voice_states[user_id] = voice_state
            self._garbage_collect_member(guild_record, voice_state.member, decrement=1)

    if not guild_record.voice_states:
        guild_record.voice_states = None
        self._remove_guild_record_if_empty(guild_id, guild_record)

    return cache_utility.CacheMappingView(cached_voice_states, builder=self._build_voice_state)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.clear_voice_states_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_voice_states_for_guild" href="#hikari.impl.cache.CacheImpl.clear_voice_states_for_guild" id="hikari.impl.cache.CacheImpl.clear_voice_states_for_guild">clear_voice_states_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_voice_states_for_guild -- Clear the voice state objects cached for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_voice_states_for_guild"
>clear_voice_states_for_guild</a></code>
</p>
<p>Clear the voice state objects cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove cached voice states for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>A view of user IDs to the voice state objects that were removed from
the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1311-L1330" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_voice_states_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
    if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    guild_record = self._guild_entries.get(guild_id)

    if not guild_record or not guild_record.voice_states:
        return cache_utility.EmptyCacheView()

    cached_voice_states = guild_record.voice_states
    guild_record.voice_states = None

    for voice_state in cached_voice_states.values():
        self._garbage_collect_member(guild_record, voice_state.member, decrement=1)

    self._remove_guild_record_if_empty(guild_id, guild_record)
    return cache_utility.CacheMappingView(cached_voice_states, builder=self._build_voice_state)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_dm_channel_id" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_dm_channel_id" href="#hikari.impl.cache.CacheImpl.delete_dm_channel_id" id="hikari.impl.cache.CacheImpl.delete_dm_channel_id">delete_dm_channel_id</a>(
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_dm_channel_id -- Remove a DM channel ID from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_dm_channel_id"
>delete_dm_channel_id</a></code>
</p>
<p>Remove a DM channel ID from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user to remove the cached DM channel ID for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>]</code></dt>
<dd>The DM channel ID which was removed from the cache if found, else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L152-L158" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_dm_channel_id(
    self, user: snowflakes.SnowflakeishOr[users.PartialUser], /
) -&gt; typing.Optional[snowflakes.Snowflake]:
    if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
        return None

    return self._dm_channel_entries.pop(snowflakes.Snowflake(user), None)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_emoji" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_emoji" href="#hikari.impl.cache.CacheImpl.delete_emoji" id="hikari.impl.cache.CacheImpl.delete_emoji">delete_emoji</a>(
    emoji: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
    /,
) -> Optional[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_emoji -- Remove a known custom emoji from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_emoji"
>delete_emoji</a></code>
</p>
<p>Remove a known custom emoji from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]</code></dt>
<dd>Object or ID of the emoji to remove from the cache.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will not delete emojis that are being kept alive by a reference
on a presence entry.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>The object of the emoji that was removed from the cache or
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L229-L250" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_emoji(
    self, emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji], /
) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
    if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
        return None

    emoji_id = snowflakes.Snowflake(emoji)
    emoji_data = self._emoji_entries.pop(emoji_id, None)
    if not emoji_data:
        return None

    if emoji_data.user:
        self._garbage_collect_user(emoji_data.user, decrement=1)

    guild_record = self._guild_entries.get(emoji_data.guild_id)
    if guild_record and guild_record.emojis:
        guild_record.emojis.remove(emoji_id)

        if not guild_record.emojis:
            guild_record.emojis = None

    return self._build_emoji(emoji_data)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_guild" href="#hikari.impl.cache.CacheImpl.delete_guild" id="hikari.impl.cache.CacheImpl.delete_guild">delete_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_guild -- Remove a guild object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_guild"
>delete_guild</a></code>
</p>
<p>Remove a guild object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The object of the guild that was removed from the cache, will be
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if not found.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L336-L354" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; typing.Optional[guilds.GatewayGuild]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
        return None

    guild_id = snowflakes.Snowflake(guild)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record:
        return None

    guild = guild_record.guild

    if guild:
        guild_record.guild = None
        guild_record.is_available = None
        self._remove_guild_record_if_empty(guild_id, guild_record)

    return guild</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_guild_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_guild_channel" href="#hikari.impl.cache.CacheImpl.delete_guild_channel" id="hikari.impl.cache.CacheImpl.delete_guild_channel">delete_guild_channel</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
    /,
) -> Optional[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_guild_channel -- Remove a guild channel from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_guild_channel"
>delete_guild_channel</a></code>
</p>
<p>Remove a guild channel from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>Object or ID of the guild channel to remove from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The object of the guild channel that was removed from the cache if
found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L483-L502" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_guild_channel(
    self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel], /
) -&gt; typing.Optional[channels.GuildChannel]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
        return None

    channel_id = snowflakes.Snowflake(channel)
    channel = self._guild_channel_entries.pop(channel_id, None)

    if not channel:
        return None

    guild_record = self._guild_entries.get(channel.guild_id)
    if guild_record and guild_record.channels:
        guild_record.channels.remove(channel_id)
        if not guild_record.channels:
            guild_record.channels = None
            self._remove_guild_record_if_empty(channel.guild_id, guild_record)

    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_invite" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_invite" href="#hikari.impl.cache.CacheImpl.delete_invite" id="hikari.impl.cache.CacheImpl.delete_invite">delete_invite</a>(
    code: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../invites.html#hikari.invites.InviteCode'>invites.InviteCode</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_invite -- Remove an invite object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_invite"
>delete_invite</a></code>
</p>
<p>Remove an invite object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../invites.html#hikari.invites.InviteCode'>InviteCode</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>Object or string code of the invite to remove from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>The object of the invite that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L653-L675" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_invite(
    self, code: typing.Union[invites.InviteCode, str], /
) -&gt; typing.Optional[invites.InviteWithMetadata]:
    if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
        return None

    code = code if isinstance(code, str) else code.code
    invite_data = self._invite_entries.pop(code, None)
    if not invite_data:
        return None

    self._remove_invite_users(invite_data)

    if invite_data.guild_id is not None:  # TODO: test case when this is None?
        guild_record = self._guild_entries.get(invite_data.guild_id)
        if guild_record and guild_record.invites:
            guild_record.invites.remove(code)

            if not guild_record.invites:
                guild_record.invites = None  # TODO: test when this is set to None
                self._remove_guild_record_if_empty(invite_data.guild_id, guild_record)

    return self._build_invite(invite_data)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_me" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_me" href="#hikari.impl.cache.CacheImpl.delete_me" id="hikari.impl.cache.CacheImpl.delete_me">delete_me</a>() -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>users.OwnUser</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_me -- Remove the own user object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_me"
>delete_me</a></code>
</p>
<p>Remove the own user object from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>]</code></dt>
<dd>The own user object that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L764-L767" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_me(self) -&gt; typing.Optional[users.OwnUser]:
    cached_user = self._me
    self._me = None
    return cached_user</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_member" href="#hikari.impl.cache.CacheImpl.delete_member" id="hikari.impl.cache.CacheImpl.delete_member">delete_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_member -- Remove a member object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_member"
>delete_member</a></code>
</p>
<p>Remove a member object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove a member from the cache for.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user to remove a member from the cache for.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>You cannot delete a member entry that's being referenced by other
entries in the cache; a matching voice state will keep a member
entry alive.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>The object of the member that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L852-L877" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    /,
) -&gt; typing.Optional[guilds.Member]:
    if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
        return None

    guild_id = snowflakes.Snowflake(guild)
    user_id = snowflakes.Snowflake(user)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.members:
        return None

    member_data = guild_record.members.get(user_id)
    if not member_data:
        return None

    if not guild_record.members:
        guild_record.members = None
        self._remove_guild_record_if_empty(guild_id, guild_record)

    # _garbage_collect_member will only return the member data object if they could be removed, else None.
    garbage_collected = self._garbage_collect_member(guild_record, member_data, deleting=True)
    return self._build_member(member_data) if garbage_collected else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_message" href="#hikari.impl.cache.CacheImpl.delete_message" id="hikari.impl.cache.CacheImpl.delete_message">delete_message</a>(
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages.PartialMessage</a>],
    /,
) -> Optional[<a href='../messages.html#hikari.messages.Message'>Message</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_message -- Remove a message object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_message"
>delete_message</a></code>
</p>
<p>Remove a message object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>Object or ID of the messages to remove the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The object of the message that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1509-L1525" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_message(
    self, message: snowflakes.SnowflakeishOr[messages.PartialMessage], /
) -&gt; typing.Optional[messages.Message]:
    if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
        return None

    message_id = snowflakes.Snowflake(message)
    message_data = self._message_entries.pop(message_id, None)

    if not message_data:
        return None

    if not self._garbage_collect_message(message_data):
        self._referenced_messages[message_id] = message_data
        return None

    return self._build_message(message_data)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_presence" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_presence" href="#hikari.impl.cache.CacheImpl.delete_presence" id="hikari.impl.cache.CacheImpl.delete_presence">delete_presence</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_presence -- Remove a presence from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_presence"
>delete_presence</a></code>
</p>
<p>Remove a presence from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to remove a presence for.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user to remove a presence for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]</code></dt>
<dd>The object of the presence that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1023-L1049" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_presence(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    /,
) -&gt; typing.Optional[presences.MemberPresence]:
    if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
        return None

    guild_id = snowflakes.Snowflake(guild)
    user_id = snowflakes.Snowflake(user)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.presences:
        return None

    presence_data = guild_record.presences.pop(user_id, None)

    if not presence_data:
        return None

    self._remove_presence_assets(presence_data)

    if not guild_record.presences:
        guild_record.presences = None
        self._remove_guild_record_if_empty(guild_id, guild_record)

    return self._build_presence(presence_data)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_role" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_role" href="#hikari.impl.cache.CacheImpl.delete_role" id="hikari.impl.cache.CacheImpl.delete_role">delete_role</a>(
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_role -- Remove a role object form the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_role"
>delete_role</a></code>
</p>
<p>Remove a role object form the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]</code></dt>
<dd>Object or ID of the role to remove from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>The object of the role that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1162-L1179" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_role(self, role: snowflakes.SnowflakeishOr[guilds.PartialRole], /) -&gt; typing.Optional[guilds.Role]:
    if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
        return None

    role_id = snowflakes.Snowflake(role)
    role = self._role_entries.pop(role_id, None)
    if not role:
        return None

    guild_record = self._guild_entries.get(role.guild_id)
    if guild_record and guild_record.roles:
        guild_record.roles.remove(role_id)

        if not guild_record.roles:
            guild_record.roles = None
            self._remove_guild_record_if_empty(role.guild_id, guild_record)

    return role</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.delete_voice_state" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_voice_state" href="#hikari.impl.cache.CacheImpl.delete_voice_state" id="hikari.impl.cache.CacheImpl.delete_voice_state">delete_voice_state</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_voice_state -- Remove a voice state object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_voice_state"
>delete_voice_state</a></code>
</p>
<p>Remove a voice state object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild the voice state to remove is related to.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user who the voice state to remove belongs to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>The object of the voice state that was removed from the cache if
found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1332-L1356" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_voice_state(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    /,
) -&gt; typing.Optional[voices.VoiceState]:
    if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
        return None

    guild_id = snowflakes.Snowflake(guild)
    user_id = snowflakes.Snowflake(user)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.voice_states:
        return None

    voice_state_data = guild_record.voice_states.pop(user_id, None)
    if not voice_state_data:
        return None

    if not guild_record.voice_states:
        guild_record.voice_states = None

    self._garbage_collect_member(guild_record, voice_state_data.member, decrement=1)
    self._remove_guild_record_if_empty(guild_id, guild_record)
    return self._build_voice_state(voice_state_data)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_available_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_available_guild" href="#hikari.impl.cache.CacheImpl.get_available_guild" id="hikari.impl.cache.CacheImpl.get_available_guild">get_available_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_available_guild -- Get the object of an available guild from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_available_guild"
>get_available_guild</a></code>
</p>
<p>Get the object of an available guild from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The object of the guild if found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L374-L380" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_available_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; typing.Optional[guilds.GatewayGuild]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
        return None

    return self._get_guild(guild, availability=True)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_available_guilds_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_available_guilds_view" href="#hikari.impl.cache.CacheImpl.get_available_guilds_view" id="hikari.impl.cache.CacheImpl.get_available_guilds_view">get_available_guilds_view</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_available_guilds_view -- Get a view of the available guild objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_available_guilds_view"
>get_available_guilds_view</a></code>
</p>
<p>Get a view of the available guild objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>A view of guild IDs to the guild objects found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L405-L409" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_available_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
        return cache_utility.EmptyCacheView()

    return self._get_guilds_view(availability=True)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_dm_channel_id" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_dm_channel_id" href="#hikari.impl.cache.CacheImpl.get_dm_channel_id" id="hikari.impl.cache.CacheImpl.get_dm_channel_id">get_dm_channel_id</a>(
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_dm_channel_id -- Get the DM channel ID for a user …" href="../api/cache.html#hikari.api.cache.Cache.get_dm_channel_id"
>get_dm_channel_id</a></code>
</p>
<p>Get the DM channel ID for a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user to get the DM channel ID for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>]</code></dt>
<dd>ID of the DM channel which was found cached for the supplied user or
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L160-L166" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_dm_channel_id(
    self, user: snowflakes.SnowflakeishOr[users.PartialUser], /
) -&gt; typing.Optional[snowflakes.Snowflake]:
    if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
        return None

    return self._dm_channel_entries.get(snowflakes.Snowflake(user))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_dm_channel_ids_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_dm_channel_ids_view" href="#hikari.impl.cache.CacheImpl.get_dm_channel_ids_view" id="hikari.impl.cache.CacheImpl.get_dm_channel_ids_view">get_dm_channel_ids_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_dm_channel_ids_view -- Get a view of the cached DM channel IDs …" href="../api/cache.html#hikari.api.cache.Cache.get_dm_channel_ids_view"
>get_dm_channel_ids_view</a></code>
</p>
<p>Get a view of the cached DM channel IDs.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>]</code></dt>
<dd>Cache view of user IDs to DM channel IDs.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L168-L172" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_dm_channel_ids_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, snowflakes.Snowflake]:
    if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
        return cache_utility.EmptyCacheView()

    return cache_utility.CacheMappingView(self._dm_channel_entries.freeze())</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_emoji" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_emoji" href="#hikari.impl.cache.CacheImpl.get_emoji" id="hikari.impl.cache.CacheImpl.get_emoji">get_emoji</a>(
    emoji: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
    /,
) -> Optional[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_emoji -- Get a known custom emoji from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_emoji"
>get_emoji</a></code>
</p>
<p>Get a known custom emoji from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]</code></dt>
<dd>Object or ID of the emoji to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>The object of the emoji that was found in the cache or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L252-L259" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_emoji(
    self, emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji], /
) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
    if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
        return None

    emoji_data = self._emoji_entries.get(snowflakes.Snowflake(emoji))
    return self._build_emoji(emoji_data) if emoji_data else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_emojis_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_emojis_view" href="#hikari.impl.cache.CacheImpl.get_emojis_view" id="hikari.impl.cache.CacheImpl.get_emojis_view">get_emojis_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_emojis_view -- Get a view of the known custom emoji objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_emojis_view"
>get_emojis_view</a></code>
</p>
<p>Get a view of the known custom emoji objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>A view of emoji IDs to objects of the known custom emojis found in
the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L261-L265" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_emojis_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
    if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
        return cache_utility.EmptyCacheView()

    return cache_utility.CacheMappingView(self._emoji_entries.freeze(), builder=self._build_emoji)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_emojis_view_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_emojis_view_for_guild" href="#hikari.impl.cache.CacheImpl.get_emojis_view_for_guild" id="hikari.impl.cache.CacheImpl.get_emojis_view_for_guild">get_emojis_view_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>emojis.KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_emojis_view_for_guild -- Get a view of the known custom emojis cached for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_emojis_view_for_guild"
>get_emojis_view_for_guild</a></code>
</p>
<p>Get a view of the known custom emojis cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get the cached emoji objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>A view of emoji IDs to objects of emojis found in the cache for the
specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L267-L278" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_emojis_view_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
    if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
        return cache_utility.EmptyCacheView()

    guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
    if not guild_record or not guild_record.emojis:
        return cache_utility.EmptyCacheView()

    cached_emojis = {emoji_id: self._emoji_entries[emoji_id] for emoji_id in guild_record.emojis}
    return cache_utility.CacheMappingView(cached_emojis, builder=self._build_emoji)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_guild" href="#hikari.impl.cache.CacheImpl.get_guild" id="hikari.impl.cache.CacheImpl.get_guild">get_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_guild -- Get a guild from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_guild"
>get_guild</a></code>
</p>
<p>Get a guild from the cache.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>This will return a guild regardless of whether it is available or
not. To only query available guilds, use <code>get_available_guild</code>
instead. Likewise, to only query unavailable guilds, use
<code>get_unavailable_guild</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The object of the guild if found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L365-L372" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; typing.Optional[guilds.GatewayGuild]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
        return None

    guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
    return copy.copy(guild_record.guild) if guild_record and guild_record.guild else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_guild_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_guild_channel" href="#hikari.impl.cache.CacheImpl.get_guild_channel" id="hikari.impl.cache.CacheImpl.get_guild_channel">get_guild_channel</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
    /,
) -> Optional[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_guild_channel -- Get a guild channel from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_guild_channel"
>get_guild_channel</a></code>
</p>
<p>Get a guild channel from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>Object or ID of the guild channel to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The object of the guild channel that was found in the cache or
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L504-L511" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_guild_channel(
    self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel], /
) -&gt; typing.Optional[channels.GuildChannel]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
        return None

    channel = self._guild_channel_entries.get(snowflakes.Snowflake(channel))
    return cache_utility.copy_guild_channel(channel) if channel else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_guild_channels_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_guild_channels_view" href="#hikari.impl.cache.CacheImpl.get_guild_channels_view" id="hikari.impl.cache.CacheImpl.get_guild_channels_view">get_guild_channels_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_guild_channels_view -- Get a view of the guild channels in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_guild_channels_view"
>get_guild_channels_view</a></code>
</p>
<p>Get a view of the guild channels in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>A view of channel IDs to objects of the guild channels found in the
cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L513-L516" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_guild_channels_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
    return cache_utility.CacheMappingView(
        self._guild_channel_entries.freeze(), builder=cache_utility.copy_guild_channel  # type: ignore[type-var]
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_guild_channels_view_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_guild_channels_view_for_guild" href="#hikari.impl.cache.CacheImpl.get_guild_channels_view_for_guild" id="hikari.impl.cache.CacheImpl.get_guild_channels_view_for_guild">get_guild_channels_view_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_guild_channels_view_for_guild -- Get a view of the guild channels in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_guild_channels_view_for_guild"
>get_guild_channels_view_for_guild</a></code>
</p>
<p>Get a view of the guild channels in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get the cached channels for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>A view of channel IDs to objects of the guild channels found in the
cache for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L518-L545" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_guild_channels_view_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
        return cache_utility.EmptyCacheView()

    guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
    if not guild_record or not guild_record.channels:
        return cache_utility.EmptyCacheView()

    cached_channels = {sf: self._guild_channel_entries[sf] for sf in guild_record.channels}

    def sorter(args: typing.Tuple[snowflakes.Snowflake, channels.GuildChannel]) -&gt; typing.Tuple[int, int, int]:
        channel = args[1]
        if isinstance(channel, channels.GuildCategory):
            return channel.position, -1, 0

        parent_position = -1 if channel.parent_id is None else cached_channels[channel.parent_id].position

        if not isinstance(channel, channels.GuildVoiceChannel):
            return parent_position, 0, channel.position

        return parent_position, 1, channel.position

    cached_channels = dict(sorted(cached_channels.items(), key=sorter))
    return cache_utility.CacheMappingView(
        cached_channels, builder=cache_utility.copy_guild_channel  # type: ignore[type-var]
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_guilds_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_guilds_view" href="#hikari.impl.cache.CacheImpl.get_guilds_view" id="hikari.impl.cache.CacheImpl.get_guilds_view">get_guilds_view</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_guilds_view -- Get a view of all the guild objects in the cache regardless if availability …" href="../api/cache.html#hikari.api.cache.Cache.get_guilds_view"
>get_guilds_view</a></code>
</p>
<p>Get a view of all the guild objects in the cache regardless if availability.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>A view of guild IDs to the guild objects found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L400-L403" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
    return cache_utility.CacheMappingView(
        {guild_id: record.guild for guild_id, record in self._guild_entries.items() if record.guild}
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_invite" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_invite" href="#hikari.impl.cache.CacheImpl.get_invite" id="hikari.impl.cache.CacheImpl.get_invite">get_invite</a>(
    code: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../invites.html#hikari.invites.InviteCode'>invites.InviteCode</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_invite -- Get an invite object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_invite"
>get_invite</a></code>
</p>
<p>Get an invite object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../invites.html#hikari.invites.InviteCode'>InviteCode</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The object or string code of the invite to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>The object of the invite that was found in the cache or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L677-L683" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_invite(self, code: typing.Union[invites.InviteCode, str], /) -&gt; typing.Optional[invites.InviteWithMetadata]:
    if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
        return None

    code = code if isinstance(code, str) else code.code
    invite_data = self._invite_entries.get(code)
    return self._build_invite(invite_data) if invite_data else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_invites_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_invites_view" href="#hikari.impl.cache.CacheImpl.get_invites_view" id="hikari.impl.cache.CacheImpl.get_invites_view">get_invites_view</a>() -> cache.CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_invites_view -- Get a view of the invite objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_invites_view"
>get_invites_view</a></code>
</p>
<p>Get a view of the invite objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>A view of string codes to objects of the invites that were found in
the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L685-L689" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_invites_view(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
        return cache_utility.EmptyCacheView()

    return cache_utility.CacheMappingView(self._invite_entries.freeze(), builder=self._build_invite)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_invites_view_for_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_invites_view_for_channel" href="#hikari.impl.cache.CacheImpl.get_invites_view_for_channel" id="hikari.impl.cache.CacheImpl.get_invites_view_for_channel">get_invites_view_for_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
    /,
) -> cache.CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_invites_view_for_channel -- Get a view of the invite objects in the cache for a specified channel …" href="../api/cache.html#hikari.api.cache.Cache.get_invites_view_for_channel"
>get_invites_view_for_channel</a></code>
</p>
<p>Get a view of the invite objects in the cache for a specified channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get invite objects for.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>Object or ID of the channel to get invite objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]</code></dt>
<dd>A view of string codes to objects of the invites there were found in
the cache for the specified channel.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L705-L725" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_invites_view_for_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
    /,
) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    channel_id = snowflakes.Snowflake(channel)
    guild_entry = self._guild_entries.get(guild_id)
    if not guild_entry or not guild_entry.invites:
        return cache_utility.EmptyCacheView()

    cached_invites = {
        invite.code: invite
        for invite in map(self._invite_entries.get, guild_entry.invites)
        if invite and invite.channel_id == channel_id
    }
    return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_invites_view_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_invites_view_for_guild" href="#hikari.impl.cache.CacheImpl.get_invites_view_for_guild" id="hikari.impl.cache.CacheImpl.get_invites_view_for_guild">get_invites_view_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_invites_view_for_guild -- Get a view of the invite objects in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_invites_view_for_guild"
>get_invites_view_for_guild</a></code>
</p>
<p>Get a view of the invite objects in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get invite objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>A view of string code to objects of the invites that were found in
the cache for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L691-L703" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_invites_view_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    guild_entry = self._guild_entries.get(guild_id)
    if not guild_entry or not guild_entry.invites:
        return cache_utility.EmptyCacheView()

    cached_invites = {code: self._invite_entries[code] for code in guild_entry.invites}
    return cache_utility.CacheMappingView(cached_invites, builder=self._build_invite)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_me" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_me" href="#hikari.impl.cache.CacheImpl.get_me" id="hikari.impl.cache.CacheImpl.get_me">get_me</a>() -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>users.OwnUser</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_me -- Get the own user object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_me"
>get_me</a></code>
</p>
<p>Get the own user object from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>]</code></dt>
<dd>The own user object that was found in the cache, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L769-L770" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_me(self) -&gt; typing.Optional[users.OwnUser]:
    return copy.copy(self._me)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_member" href="#hikari.impl.cache.CacheImpl.get_member" id="hikari.impl.cache.CacheImpl.get_member">get_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_member -- Get a member object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_member"
>get_member</a></code>
</p>
<p>Get a member object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get a cached member for.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user to get a cached member for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>The object of the member found in the cache, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L879-L895" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    /,
) -&gt; typing.Optional[guilds.Member]:
    if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
        return None

    guild_id = snowflakes.Snowflake(guild)
    user_id = snowflakes.Snowflake(user)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.members:
        return None

    member = guild_record.members.get(user_id)
    return self._build_member(member) if member else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_members_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_members_view" href="#hikari.impl.cache.CacheImpl.get_members_view" id="hikari.impl.cache.CacheImpl.get_members_view">get_members_view</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_members_view -- Get a view of all the members objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_members_view"
>get_members_view</a></code>
</p>
<p>Get a view of all the members objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the members
that were found from the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L897-L908" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_members_view(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
    if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
        return cache_utility.EmptyCacheView()

    views: typing.Mapping[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]] = {
        guild_id: cache_utility.CacheMappingView(view.members.freeze(), builder=self._build_member)  # type: ignore[type-var]
        for guild_id, view in self._guild_entries.items()
        if view.members
    }
    return cache_utility.Cache3DMappingView(views)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_members_view_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_members_view_for_guild" href="#hikari.impl.cache.CacheImpl.get_members_view_for_guild" id="hikari.impl.cache.CacheImpl.get_members_view_for_guild">get_members_view_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>,
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_members_view_for_guild -- Get a view of the members cached for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_members_view_for_guild"
>get_members_view_for_guild</a></code>
</p>
<p>Get a view of the members cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a></code></dt>
<dd>The ID of the guild to get the cached member view for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>The view of user IDs to the members cached for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L910-L925" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_members_view_for_guild(
    self, guild_id: snowflakes.Snowflakeish, /
) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
    if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild_id)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.members:
        return cache_utility.EmptyCacheView()

    cached_members = {
        user_id: member for user_id, member in guild_record.members.items() if not member.object.has_been_deleted
    }

    return cache_utility.CacheMappingView(cached_members, builder=self._build_member)  # type: ignore[type-var]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_message" href="#hikari.impl.cache.CacheImpl.get_message" id="hikari.impl.cache.CacheImpl.get_message">get_message</a>(
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages.PartialMessage</a>],
    /,
) -> Optional[<a href='../messages.html#hikari.messages.Message'>Message</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_message -- Get a message object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_message"
>get_message</a></code>
</p>
<p>Get a message object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>Object or ID of the message to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The object of the message found in the cache or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1527-L1535" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_message(
    self, message: snowflakes.SnowflakeishOr[messages.PartialMessage], /
) -&gt; typing.Optional[messages.Message]:
    if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
        return None

    message_id = snowflakes.Snowflake(message)
    message_data = self._message_entries.get(message_id) or self._referenced_messages.get(message_id)
    return self._build_message(message_data) if message_data else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_messages_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_messages_view" href="#hikari.impl.cache.CacheImpl.get_messages_view" id="hikari.impl.cache.CacheImpl.get_messages_view">get_messages_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../messages.html#hikari.messages.Message'>Message</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_messages_view -- Get a view of all the message objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_messages_view"
>get_messages_view</a></code>
</p>
<p>Get a view of all the message objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>A view of message objects found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1537-L1543" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_messages_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, messages.Message]:
    if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
        return cache_utility.EmptyCacheView()

    cached_messages = self._message_entries.freeze()
    cached_messages.update(self._referenced_messages)
    return cache_utility.CacheMappingView(cached_messages, builder=self._build_message)  # type: ignore[type-var]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_presence" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_presence" href="#hikari.impl.cache.CacheImpl.get_presence" id="hikari.impl.cache.CacheImpl.get_presence">get_presence</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_presence -- Get a presence object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_presence"
>get_presence</a></code>
</p>
<p>Get a presence object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get a presence for.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user to get a presence for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]</code></dt>
<dd>The object of the presence that was found in the cache or
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1051-L1066" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_presence(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    /,
) -&gt; typing.Optional[presences.MemberPresence]:
    if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
        return None

    guild_id = snowflakes.Snowflake(guild)
    user_id = snowflakes.Snowflake(user)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.presences:
        return None

    return self._build_presence(guild_record.presences[user_id]) if user_id in guild_record.presences else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_presences_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_presences_view" href="#hikari.impl.cache.CacheImpl.get_presences_view" id="hikari.impl.cache.CacheImpl.get_presences_view">get_presences_view</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_presences_view -- Get a view of all the presence objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_presences_view"
>get_presences_view</a></code>
</p>
<p>Get a view of all the presence objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the presences
found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1068-L1079" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_presences_view(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
    if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
        return cache_utility.EmptyCacheView()

    views = {
        guild_id: cache_utility.CacheMappingView(guild_record.presences.freeze(), builder=self._build_presence)
        for guild_id, guild_record in self._guild_entries.items()
        if guild_record.presences
    }
    return cache_utility.Cache3DMappingView(views)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_presences_view_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_presences_view_for_guild" href="#hikari.impl.cache.CacheImpl.get_presences_view_for_guild" id="hikari.impl.cache.CacheImpl.get_presences_view_for_guild">get_presences_view_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_presences_view_for_guild -- Get a view of the presence objects in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_presences_view_for_guild"
>get_presences_view_for_guild</a></code>
</p>
<p>Get a view of the presence objects in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get the cached presence objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]</code></dt>
<dd>A view of user IDs to objects of the presence found in the cache
for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1081-L1091" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_presences_view_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
    if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
        return cache_utility.EmptyCacheView()

    guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
    if not guild_record or not guild_record.presences:
        return cache_utility.EmptyCacheView()

    return cache_utility.CacheMappingView(guild_record.presences.freeze(), builder=self._build_presence)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_role" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_role" href="#hikari.impl.cache.CacheImpl.get_role" id="hikari.impl.cache.CacheImpl.get_role">get_role</a>(
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_role -- Get a role object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_role"
>get_role</a></code>
</p>
<p>Get a role object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]</code></dt>
<dd>Object or ID of the role to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>The object of the role found in the cache or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1181-L1186" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_role(self, role: snowflakes.SnowflakeishOr[guilds.PartialRole], /) -&gt; typing.Optional[guilds.Role]:
    if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
        return None

    role = self._role_entries.get(snowflakes.Snowflake(role))
    return copy.copy(role) if role else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_roles_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_roles_view" href="#hikari.impl.cache.CacheImpl.get_roles_view" id="hikari.impl.cache.CacheImpl.get_roles_view">get_roles_view</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_roles_view -- Get a view of all the role objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_roles_view"
>get_roles_view</a></code>
</p>
<p>Get a view of all the role objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>A view of role IDs to objects of the roles found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1188-L1192" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_roles_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
    if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
        return cache_utility.EmptyCacheView()

    return cache_utility.CacheMappingView(self._role_entries.freeze())</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_roles_view_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_roles_view_for_guild" href="#hikari.impl.cache.CacheImpl.get_roles_view_for_guild" id="hikari.impl.cache.CacheImpl.get_roles_view_for_guild">get_roles_view_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_roles_view_for_guild -- Get a view of the roles in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_roles_view_for_guild"
>get_roles_view_for_guild</a></code>
</p>
<p>Get a view of the roles in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get the cached roles for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>A view of role IDs to objects of the roles that were found in the
cache for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1194-L1204" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_roles_view_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
    if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
        return cache_utility.EmptyCacheView()

    guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
    if not guild_record or not guild_record.roles:
        return cache_utility.EmptyCacheView()

    return cache_utility.CacheMappingView({role_id: self._role_entries[role_id] for role_id in guild_record.roles})</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_unavailable_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_unavailable_guild" href="#hikari.impl.cache.CacheImpl.get_unavailable_guild" id="hikari.impl.cache.CacheImpl.get_unavailable_guild">get_unavailable_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_unavailable_guild -- Get the object of a unavailable guild from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_unavailable_guild"
>get_unavailable_guild</a></code>
</p>
<p>Get the object of a unavailable guild from the cache.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Unlike <code>Cache.get_available_guild</code>, the objects returned by this
method will likely be out of date and inaccurate as they are
considered unavailable, meaning that we are not receiving gateway
events for this guild.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The object of the guild if found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L382-L388" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_unavailable_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; typing.Optional[guilds.GatewayGuild]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
        return None

    return self._get_guild(guild, availability=False)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_unavailable_guilds_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_unavailable_guilds_view" href="#hikari.impl.cache.CacheImpl.get_unavailable_guilds_view" id="hikari.impl.cache.CacheImpl.get_unavailable_guilds_view">get_unavailable_guilds_view</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_unavailable_guilds_view -- Get a view of the unavailable guild objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_unavailable_guilds_view"
>get_unavailable_guilds_view</a></code>
</p>
<p>Get a view of the unavailable guild objects in the cache.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Unlike <code>Cache.get_available_guilds_view</code>, the objects returned by
this method will likely be out of date and inaccurate as they are
considered unavailable, meaning that we are not receiving gateway
events for this guild.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>A view of guild IDs to the guild objects found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L411-L415" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_unavailable_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
        return cache_utility.EmptyCacheView()

    return self._get_guilds_view(availability=False)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_user" href="#hikari.impl.cache.CacheImpl.get_user" id="hikari.impl.cache.CacheImpl.get_user">get_user</a>(
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>users.User</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_user -- Get a user object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_user"
>get_user</a></code>
</p>
<p>Get a user object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>The object of the user that was found in the cache, else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1242-L1244" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; typing.Optional[users.User]:
    user = self._user_entries.get(snowflakes.Snowflake(user))
    return user.copy() if user else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_users_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_users_view" href="#hikari.impl.cache.CacheImpl.get_users_view" id="hikari.impl.cache.CacheImpl.get_users_view">get_users_view</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../users.html#hikari.users.User'>users.User</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_users_view -- Get a view of the user objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_users_view"
>get_users_view</a></code>
</p>
<p>Get a view of the user objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>The view of user IDs to the users found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1246-L1254" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_users_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, users.User]:
    if not self._user_entries:
        return cache_utility.EmptyCacheView()

    cached_users = self._user_entries.freeze()
    unwrapper = typing.cast(
        &#34;typing.Callable[[cache_utility.RefCell[users.User]], users.User]&#34;, cache_utility.unwrap_ref_cell
    )
    return cache_utility.CacheMappingView(cached_users, builder=unwrapper)  # type: ignore[type-var]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_voice_state" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_voice_state" href="#hikari.impl.cache.CacheImpl.get_voice_state" id="hikari.impl.cache.CacheImpl.get_voice_state">get_voice_state</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_voice_state -- Get a voice state object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_voice_state"
>get_voice_state</a></code>
</p>
<p>Get a voice state object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get a voice state for.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user to get a voice state for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>The object of the voice state that was found in the cache, or
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1358-L1371" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_voice_state(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    /,
) -&gt; typing.Optional[voices.VoiceState]:
    if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
        return None

    guild_id = snowflakes.Snowflake(guild)
    user_id = snowflakes.Snowflake(user)
    guild_record = self._guild_entries.get(guild_id)
    voice_data = guild_record.voice_states.get(user_id) if guild_record and guild_record.voice_states else None
    return self._build_voice_state(voice_data) if voice_data else None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_voice_states_view" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_voice_states_view" href="#hikari.impl.cache.CacheImpl.get_voice_states_view" id="hikari.impl.cache.CacheImpl.get_voice_states_view">get_voice_states_view</a>() -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_voice_states_view -- Get a view of all the voice state objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_voice_states_view"
>get_voice_states_view</a></code>
</p>
<p>Get a view of all the voice state objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the voice
states that were found in the cache,</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1373-L1386" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_voice_states_view(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
    if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
        return cache_utility.EmptyCacheView()

    views = {
        guild_id: cache_utility.CacheMappingView(
            guild_record.voice_states.freeze(), builder=self._build_voice_state
        )
        for guild_id, guild_record in self._guild_entries.items()
        if guild_record.voice_states
    }
    return cache_utility.Cache3DMappingView(views)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_voice_states_view_for_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_voice_states_view_for_channel" href="#hikari.impl.cache.CacheImpl.get_voice_states_view_for_channel" id="hikari.impl.cache.CacheImpl.get_voice_states_view_for_channel">get_voice_states_view_for_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_voice_states_view_for_channel -- Get a view of the voice states cached for a specific channel …" href="../api/cache.html#hikari.api.cache.Cache.get_voice_states_view_for_channel"
>get_voice_states_view_for_channel</a></code>
</p>
<p>Get a view of the voice states cached for a specific channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get the cached voice states for.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>Object or ID of the channel to get the cached voice states for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>A view of user IDs to objects of the voice states found cached for
the specified channel.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1388-L1409" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_voice_states_view_for_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
    /,
) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
    if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
        return cache_utility.EmptyCacheView()

    guild_id = snowflakes.Snowflake(guild)
    channel_id = snowflakes.Snowflake(channel)
    guild_record = self._guild_entries.get(guild_id)
    if not guild_record or not guild_record.voice_states:
        return cache_utility.EmptyCacheView()

    cached_voice_states = {
        user_id: voice_state
        for user_id, voice_state in guild_record.voice_states.items()
        if voice_state.channel_id == channel_id
    }

    return cache_utility.CacheMappingView(cached_voice_states, builder=self._build_voice_state)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.get_voice_states_view_for_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_voice_states_view_for_guild" href="#hikari.impl.cache.CacheImpl.get_voice_states_view_for_guild" id="hikari.impl.cache.CacheImpl.get_voice_states_view_for_guild">get_voice_states_view_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> cache.CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_voice_states_view_for_guild -- Get a view of the voice states cached for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_voice_states_view_for_guild"
>get_voice_states_view_for_guild</a></code>
</p>
<p>Get a view of the voice states cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to get the cached voice states for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>A view of user IDs to objects of the voice states found cached for
the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1411-L1421" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_voice_states_view_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /
) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
    if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
        return cache_utility.EmptyCacheView()

    guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
    if not guild_record or not guild_record.voice_states:
        return cache_utility.EmptyCacheView()

    return cache_utility.CacheMappingView(guild_record.voice_states.freeze(), builder=self._build_voice_state)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_dm_channel_id" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_dm_channel_id" href="#hikari.impl.cache.CacheImpl.set_dm_channel_id" id="hikari.impl.cache.CacheImpl.set_dm_channel_id">set_dm_channel_id</a>(
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_dm_channel_id -- Add a DM channel ID to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_dm_channel_id"
>set_dm_channel_id</a></code>
</p>
<p>Add a DM channel ID to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>Object or ID of the user to add a DM channel ID to the cache for.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>Object or ID of the DM channel to add to the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L174-L183" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_dm_channel_id(
    self,
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    channel: snowflakes.SnowflakeishOr[channels.PartialChannel],
    /,
) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.DM_CHANNEL_IDS):
        return None

    self._dm_channel_entries[snowflakes.Snowflake(user)] = snowflakes.Snowflake(channel)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_emoji" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_emoji" href="#hikari.impl.cache.CacheImpl.set_emoji" id="hikari.impl.cache.CacheImpl.set_emoji">set_emoji</a>(
    emoji: <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>emojis.KnownCustomEmoji</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_emoji -- Add a known custom emoji to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_emoji"
>set_emoji</a></code>
</p>
<p>Add a known custom emoji to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a></code></dt>
<dd>The object of the known custom emoji to add to the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L280-L297" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_emoji(self, emoji: emojis.KnownCustomEmoji, /) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
        return None

    user: typing.Optional[cache_utility.RefCell[users.User]] = None
    if emoji.user:
        user = self._set_user(emoji.user)
        if emoji.id not in self._emoji_entries:
            self._increment_ref_count(user)

    emoji_data = cache_utility.KnownCustomEmojiData.build_from_entity(emoji, user=user)
    self._emoji_entries[emoji.id] = emoji_data
    guild_record = self._get_or_create_guild_record(emoji.guild_id)

    if guild_record.emojis is None:  # TODO: add test cases when it is not None?
        guild_record.emojis = collections.SnowflakeSet()

    guild_record.emojis.add(emoji.id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_guild" href="#hikari.impl.cache.CacheImpl.set_guild" id="hikari.impl.cache.CacheImpl.set_guild">set_guild</a>(
    guild: <a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_guild -- Add a guild object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_guild"
>set_guild</a></code>
</p>
<p>Add a guild object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a></code></dt>
<dd>The object of the guild to add to the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L417-L423" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
        return None

    guild_record = self._get_or_create_guild_record(guild.id)
    guild_record.guild = copy.copy(guild)
    guild_record.is_available = True</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_guild_availability" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_guild_availability" href="#hikari.impl.cache.CacheImpl.set_guild_availability" id="hikari.impl.cache.CacheImpl.set_guild_availability">set_guild_availability</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    is_available: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_guild_availability -- Set whether a cached guild is available or not …" href="../api/cache.html#hikari.api.cache.MutableCache.set_guild_availability"
>set_guild_availability</a></code>
</p>
<p>Set whether a cached guild is available or not.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>Object or ID of the guild to set the availability for.</dd>
<dt><strong><code>is_available</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>The availability to set for the guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L425-L433" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_guild_availability(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], is_available: bool, /
) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
        return None

    guild_record = self._guild_entries.get(snowflakes.Snowflake(guild))
    if guild_record and guild_record.guild:
        guild_record.is_available = is_available</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_guild_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_guild_channel" href="#hikari.impl.cache.CacheImpl.set_guild_channel" id="hikari.impl.cache.CacheImpl.set_guild_channel">set_guild_channel</a>(
    channel: <a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_guild_channel -- Add a guild channel to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_guild_channel"
>set_guild_channel</a></code>
</p>
<p>Add a guild channel to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a></code></dt>
<dd>The guild channel based object to add to the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L547-L557" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
        return None

    self._guild_channel_entries[channel.id] = cache_utility.copy_guild_channel(channel)
    guild_record = self._get_or_create_guild_record(channel.guild_id)

    if guild_record.channels is None:
        guild_record.channels = collections.SnowflakeSet()

    guild_record.channels.add(channel.id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_invite" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_invite" href="#hikari.impl.cache.CacheImpl.set_invite" id="hikari.impl.cache.CacheImpl.set_invite">set_invite</a>(
    invite: <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_invite -- Add an invite object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_invite"
>set_invite</a></code>
</p>
<p>Add an invite object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code><a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a></code></dt>
<dd>The object of the invite to add to the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L727-L752" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_invite(self, invite: invites.InviteWithMetadata, /) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
        return None

    inviter: typing.Optional[cache_utility.RefCell[users.User]] = None
    if invite.inviter:
        inviter = self._set_user(invite.inviter)
        if invite.code not in self._invite_entries:
            self._increment_ref_count(inviter)

    target_user: typing.Optional[cache_utility.RefCell[users.User]] = None
    if invite.target_user:
        target_user = self._set_user(invite.target_user)
        if invite.code not in self._invite_entries:
            self._increment_ref_count(target_user)

    self._invite_entries[invite.code] = cache_utility.InviteData.build_from_entity(
        invite, inviter=inviter, target_user=target_user
    )
    if invite.guild_id:
        guild_entry = self._get_or_create_guild_record(invite.guild_id)

        if guild_entry.invites is None:
            guild_entry.invites = []

        guild_entry.invites.append(invite.code)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_me" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_me" href="#hikari.impl.cache.CacheImpl.set_me" id="hikari.impl.cache.CacheImpl.set_me">set_me</a>(
    user: <a href='../users.html#hikari.users.OwnUser'>users.OwnUser</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_me -- Set the own user object in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_me"
>set_me</a></code>
</p>
<p>Set the own user object in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../users.html#hikari.users.OwnUser'>OwnUser</a></code></dt>
<dd>The own user object to set in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L772-L773" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_me(self, user: users.OwnUser, /) -&gt; None:
    self._me = copy.copy(user)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_member" href="#hikari.impl.cache.CacheImpl.set_member" id="hikari.impl.cache.CacheImpl.set_member">set_member</a>(
    member: <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_member -- Add a member object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_member"
>set_member</a></code>
</p>
<p>Add a member object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>member</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code></dt>
<dd>The object of the member to add to the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L927-L931" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_member(self, member: guilds.Member, /) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
        return None

    self._set_member(member, is_reference=False)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_message" href="#hikari.impl.cache.CacheImpl.set_message" id="hikari.impl.cache.CacheImpl.set_message">set_message</a>(
    message: <a href='../messages.html#hikari.messages.Message'>messages.Message</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_message -- Add a message object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_message"
>set_message</a></code>
</p>
<p>Add a message object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The object of the message to add to the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1607-L1611" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_message(self, message: messages.Message, /) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
        return None

    self._set_message(message, is_reference=False)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_presence" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_presence" href="#hikari.impl.cache.CacheImpl.set_presence" id="hikari.impl.cache.CacheImpl.set_presence">set_presence</a>(
    presence: <a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_presence -- Add a presence object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_presence"
>set_presence</a></code>
</p>
<p>Add a presence object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>presence</code></strong> :&ensp;<code><a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a></code></dt>
<dd>The object of the presence to add to the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1093-L1118" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_presence(self, presence: presences.MemberPresence, /) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
        return None

    presence_data = cache_utility.MemberPresenceData.build_from_entity(presence)
    for activity, activity_data in zip(presence.activities, presence_data.activities):
        emoji = activity.emoji
        if not isinstance(emoji, emojis.CustomEmoji):
            continue

        if emoji.id in self._unknown_custom_emoji_entries:
            self._unknown_custom_emoji_entries[emoji.id].object = copy.copy(emoji)
            emoji_data = self._unknown_custom_emoji_entries[emoji.id]

        else:
            emoji_data = cache_utility.RefCell(copy.copy(emoji))
            self._unknown_custom_emoji_entries[emoji.id] = emoji_data

        self._increment_ref_count(emoji_data)
        activity_data.emoji = emoji_data

    guild_record = self._get_or_create_guild_record(presence.guild_id)
    if guild_record.presences is None:
        guild_record.presences = collections.FreezableDict()

    guild_record.presences[presence.user_id] = presence_data</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_role" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_role" href="#hikari.impl.cache.CacheImpl.set_role" id="hikari.impl.cache.CacheImpl.set_role">set_role</a>(
    role: <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_role -- Add a role object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_role"
>set_role</a></code>
</p>
<p>Add a role object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Role'>Role</a></code></dt>
<dd>The object of the role to add to the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1206-L1216" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_role(self, role: guilds.Role, /) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
        return None

    self._role_entries[role.id] = role
    guild_record = self._get_or_create_guild_record(role.guild_id)

    if guild_record.roles is None:  # TODO: test when this is not None
        guild_record.roles = collections.SnowflakeSet()

    guild_record.roles.add(role.id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.set_voice_state" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_voice_state" href="#hikari.impl.cache.CacheImpl.set_voice_state" id="hikari.impl.cache.CacheImpl.set_voice_state">set_voice_state</a>(
    voice_state: <a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_voice_state -- Add a voice state object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_voice_state"
>set_voice_state</a></code>
</p>
<p>Add a voice state object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>voice_state</code></strong> :&ensp;<code><a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a></code></dt>
<dd>The object of the voice state to add to the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1423-L1438" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
    if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
        return None

    guild_record = self._get_or_create_guild_record(voice_state.guild_id)

    if guild_record.voice_states is None:  # TODO: test when this is not None
        guild_record.voice_states = collections.FreezableDict()

    member = self._set_member(voice_state.member)
    voice_state_data = cache_utility.VoiceStateData.build_from_entity(voice_state, member=member)

    if voice_state.user_id not in guild_record.voice_states:
        self._increment_ref_count(member)

    guild_record.voice_states[voice_state.user_id] = voice_state_data</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.update_emoji" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_emoji" href="#hikari.impl.cache.CacheImpl.update_emoji" id="hikari.impl.cache.CacheImpl.update_emoji">update_emoji</a>(
    emoji: <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>emojis.KnownCustomEmoji</a>,
    /,
) -> Tuple[Optional[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>], Optional[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_emoji -- Update an emoji object in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_emoji"
>update_emoji</a></code>
</p>
<p>Update an emoji object in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a></code></dt>
<dd>The object of the emoji to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]]</code></dt>
<dd>A tuple of the old cached emoji object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the new cached emoji object if it could be cached (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L299-L307" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_emoji(
    self, emoji: emojis.KnownCustomEmoji, /
) -&gt; typing.Tuple[typing.Optional[emojis.KnownCustomEmoji], typing.Optional[emojis.KnownCustomEmoji]]:
    if not self._is_cache_enabled_for(config.CacheComponents.EMOJIS):
        return None, None

    cached_emoji = self.get_emoji(emoji.id)
    self.set_emoji(emoji)
    return cached_emoji, self.get_emoji(emoji.id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.update_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_guild" href="#hikari.impl.cache.CacheImpl.update_guild" id="hikari.impl.cache.CacheImpl.update_guild">update_guild</a>(
    guild: <a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>,
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_guild -- Update a guild in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_guild"
>update_guild</a></code>
</p>
<p>Update a guild in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a></code></dt>
<dd>The object of the guild to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]]</code></dt>
<dd>A tuple of the old cached guild object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the object of the guild that was added to the cache if it could
be added (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L435-L451" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_guild(
    self, guild: guilds.GatewayGuild, /
) -&gt; typing.Tuple[typing.Optional[guilds.GatewayGuild], typing.Optional[guilds.GatewayGuild]]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILDS):
        return None, None

    guild = copy.copy(guild)
    cached_guild = self.get_guild(guild.id)

    # We have to manually update these because Inconsistency is Discord&#39;s middle name.
    if cached_guild:
        guild.member_count = cached_guild.member_count
        guild.joined_at = cached_guild.joined_at
        guild.is_large = cached_guild.is_large

    self.set_guild(guild)
    return cached_guild, self.get_guild(guild.id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.update_guild_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_guild_channel" href="#hikari.impl.cache.CacheImpl.update_guild_channel" id="hikari.impl.cache.CacheImpl.update_guild_channel">update_guild_channel</a>(
    channel: <a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>,
    /,
) -> Tuple[Optional[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>], Optional[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_guild_channel -- Update a guild channel in the cache, …" href="../api/cache.html#hikari.api.cache.MutableCache.update_guild_channel"
>update_guild_channel</a></code>
</p>
<p>Update a guild channel in the cache,</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a></code></dt>
<dd>The object of the channel to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]]</code></dt>
<dd>A tuple of the old cached guild channel if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the new cached guild channel if it could be cached
(else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L559-L567" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_guild_channel(
    self, channel: channels.GuildChannel, /
) -&gt; typing.Tuple[typing.Optional[channels.GuildChannel], typing.Optional[channels.GuildChannel]]:
    if not self._is_cache_enabled_for(config.CacheComponents.GUILD_CHANNELS):
        return None, None

    cached_channel = self.get_guild_channel(channel.id)
    self.set_guild_channel(channel)
    return cached_channel, self.get_guild_channel(channel.id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.update_invite" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_invite" href="#hikari.impl.cache.CacheImpl.update_invite" id="hikari.impl.cache.CacheImpl.update_invite">update_invite</a>(
    invite: <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>,
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_invite -- Update an invite in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_invite"
>update_invite</a></code>
</p>
<p>Update an invite in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code><a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a></code></dt>
<dd>The object of the invite to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]]</code></dt>
<dd>A tuple of the old cached invite object if found (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>) and the new cached invite object if it could be
cached (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L754-L762" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_invite(
    self, invite: invites.InviteWithMetadata, /
) -&gt; typing.Tuple[typing.Optional[invites.InviteWithMetadata], typing.Optional[invites.InviteWithMetadata]]:
    if not self._is_cache_enabled_for(config.CacheComponents.INVITES):
        return None, None

    cached_invite = self.get_invite(invite.code)
    self.set_invite(invite)
    return cached_invite, self.get_invite(invite.code)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.update_me" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_me" href="#hikari.impl.cache.CacheImpl.update_me" id="hikari.impl.cache.CacheImpl.update_me">update_me</a>(
    user: <a href='../users.html#hikari.users.OwnUser'>users.OwnUser</a>,
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>users.OwnUser</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>users.OwnUser</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_me -- Update the own user entry in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_me"
>update_me</a></code>
</p>
<p>Update the own user entry in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../users.html#hikari.users.OwnUser'>OwnUser</a></code></dt>
<dd>The own user object to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>]]</code></dt>
<dd>A tuple of the old cached own user object if found (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>) and the new cached own user object if it could be
cached, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L775-L781" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_me(
    self, user: users.OwnUser, /
) -&gt; typing.Tuple[typing.Optional[users.OwnUser], typing.Optional[users.OwnUser]]:
    _LOGGER.debug(&#34;setting my user to %s&#34;, user)
    cached_user = self.get_me()
    self.set_me(user)
    return cached_user, self._me</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.update_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_member" href="#hikari.impl.cache.CacheImpl.update_member" id="hikari.impl.cache.CacheImpl.update_member">update_member</a>(
    member: <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>,
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_member -- Update a member in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_member"
>update_member</a></code>
</p>
<p>Update a member in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>member</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code></dt>
<dd>The object of the member to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]]</code></dt>
<dd>A tuple of the old cached member object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the new cached member object if it could be cached (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L959-L967" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_member(
    self, member: guilds.Member, /
) -&gt; typing.Tuple[typing.Optional[guilds.Member], typing.Optional[guilds.Member]]:
    if not self._is_cache_enabled_for(config.CacheComponents.MEMBERS):
        return None, None

    cached_member = self.get_member(member.guild_id, member.user.id)
    self.set_member(member)
    return cached_member, self.get_member(member.guild_id, member.user.id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.update_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_message" href="#hikari.impl.cache.CacheImpl.update_message" id="hikari.impl.cache.CacheImpl.update_message">update_message</a>(
    message: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages.PartialMessage</a>, <a href='../messages.html#hikari.messages.Message'>messages.Message</a>],
    /,
) -> Tuple[Optional[<a href='../messages.html#hikari.messages.Message'>Message</a>], Optional[<a href='../messages.html#hikari.messages.Message'>Message</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_message -- Update a message in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_message"
>update_message</a></code>
</p>
<p>Update a message in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>, <a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The object of the message to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]]</code></dt>
<dd>A tuple of the old cached message object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the new cached message object if it could be cached (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1613-L1640" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_message(
    self, message: typing.Union[messages.PartialMessage, messages.Message], /
) -&gt; typing.Tuple[typing.Optional[messages.Message], typing.Optional[messages.Message]]:
    if not self._is_cache_enabled_for(config.CacheComponents.MESSAGES):
        return None, None

    cached_message = self.get_message(message.id)

    if isinstance(message, messages.Message):
        self.set_message(message)

    elif cached_message_data := self._message_entries.get(message.id) or self._referenced_messages.get(message.id):
        mention_user: undefined.UndefinedOr[
            typing.Mapping[snowflakes.Snowflake, cache_utility.RefCell[users.User]]
        ] = undefined.UNDEFINED
        if message.mentions.users is not undefined.UNDEFINED:
            mention_user = {user_id: self._set_user(user) for user_id, user in message.mentions.users.items()}

            # We want to ensure that any previously mentioned users are garbage collected if they&#39;re no longer
            # being mentioned.
            if cached_message_data.object.mentions.users is not undefined.UNDEFINED:
                for user_id, user in cached_message_data.object.mentions.users.items():
                    if user_id not in mention_user:
                        self._garbage_collect_user(user, decrement=1)

        cached_message_data.object.update(message, mention_users=mention_user)

    return cached_message, self.get_message(message.id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.update_presence" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_presence" href="#hikari.impl.cache.CacheImpl.update_presence" id="hikari.impl.cache.CacheImpl.update_presence">update_presence</a>(
    presence: <a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>,
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_presence -- Update a presence object in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_presence"
>update_presence</a></code>
</p>
<p>Update a presence object in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>presence</code></strong> :&ensp;<code><a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a></code></dt>
<dd>The object of the presence to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]]</code></dt>
<dd>A tuple of the old cached invite object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>
and the new cached invite object if it could be cached ( else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1120-L1128" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_presence(
    self, presence: presences.MemberPresence, /
) -&gt; typing.Tuple[typing.Optional[presences.MemberPresence], typing.Optional[presences.MemberPresence]]:
    if not self._is_cache_enabled_for(config.CacheComponents.PRESENCES):
        return None, None

    cached_presence = self.get_presence(presence.guild_id, presence.user_id)
    self.set_presence(presence)
    return cached_presence, self.get_presence(presence.guild_id, presence.user_id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.update_role" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_role" href="#hikari.impl.cache.CacheImpl.update_role" id="hikari.impl.cache.CacheImpl.update_role">update_role</a>(
    role: <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>,
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_role -- Update a role in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_role"
>update_role</a></code>
</p>
<p>Update a role in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Role'>Role</a></code></dt>
<dd>The object of the role to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>Role</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>Role</a>]]</code></dt>
<dd>A tuple of the old cached role object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>
and the new cached role object if it could be cached (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1218-L1226" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_role(
    self, role: guilds.Role, /
) -&gt; typing.Tuple[typing.Optional[guilds.Role], typing.Optional[guilds.Role]]:
    if not self._is_cache_enabled_for(config.CacheComponents.ROLES):
        return None, None

    cached_role = self.get_role(role.id)
    self.set_role(role)
    return cached_role, self.get_role(role.id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.impl.cache.CacheImpl.update_voice_state" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_voice_state" href="#hikari.impl.cache.CacheImpl.update_voice_state" id="hikari.impl.cache.CacheImpl.update_voice_state">update_voice_state</a>(
    voice_state: <a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>,
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_voice_state -- Update a voice state object in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_voice_state"
>update_voice_state</a></code>
</p>
<p>Update a voice state object in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>voice_state</code></strong> :&ensp;<code><a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a></code></dt>
<dd>The object of the voice state to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]]</code></dt>
<dd>A tuple of the old cached voice state if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the new cached voice state object if it could be cached
(else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/impl/cache.py#L1440-L1448" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_voice_state(
    self, voice_state: voices.VoiceState, /
) -&gt; typing.Tuple[typing.Optional[voices.VoiceState], typing.Optional[voices.VoiceState]]:
    if not self._is_cache_enabled_for(config.CacheComponents.VOICE_STATES):
        return None, None

    cached_voice_state = self.get_voice_state(voice_state.guild_id, voice_state.user_id)
    self.set_voice_state(voice_state)
    return cached_voice_state, self.get_voice_state(voice_state.guild_id, voice_state.user_id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
</dl>
</section>
</div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>