{"urls": ["cli", "users", "traits", "config", "colours", "urls", "applications", "messages", "guilds", "events", "events/base_events", "events/guild_events", "events/reaction_events", "events/interaction_events", "events/member_events", "events/voice_events", "events/lifetime_events", "events/message_events", "events/channel_events", "events/shard_events", "events/role_events", "events/user_events", "events/typing_events", "api", "api/cache", "api/entity_factory", "api/special_endpoints", "api/event_manager", "api/voice", "api/rest", "api/interaction_server", "api/shard", "api/event_factory", "channels", "interactions", "interactions/component_interactions", "interactions/base_interactions", "interactions/command_interactions", "voices", "emojis", "iterators", "invites", "impl", "impl/cache", "impl/entity_factory", "impl/rate_limits", "impl/special_endpoints", "impl/event_manager", "impl/voice", "impl/rest", "impl/bot", "impl/event_manager_base", "impl/interaction_server", "impl/buckets", "impl/shard", "impl/event_factory", "impl/rest_bot", "templates", "colors", "commands", "files", "permissions", "audit_logs", "embeds", "internal", "internal/cache", "internal/deprecation", "internal/data_binding", "internal/net", "internal/reflect", "internal/attr_extensions", "internal/spel", "internal/routes", "internal/enums", "internal/ux", "internal/fast_protocol", "internal/mentions", "internal/ed25519", "internal/collections", "internal/aio", "internal/time", "snowflakes", "sessions", "presences", "intents", "webhooks", "stickers", "undefined", "errors"], "index": [{"r": "hikari.cli", "u": 0, "d": "Provides the python -m hikari and hikari commands to the shell."}, {"r": "hikari.cli.main", "u": 0, "d": "Print package info and exit.", "f": 1}, {"r": "hikari.users", "u": 1, "d": "Application and entities that are used to describe Users on Discord."}, {"r": "hikari.users.PartialUser", "u": 1, "d": "A partial interface for a user. Fields may or may not be present, and should be explicitly checked\nbefore using them to ensure they are not hikari.undefined.UNDEFINED . This is used for endpoints and events that only expose partial user\ninformation. For full user info, consider calling the fetch_self method to perform an\nAPI call."}, {"r": "hikari.users.PartialUser.app", "u": 1, "d": "Client application that models may use for procedures."}, {"r": "hikari.users.PartialUser.avatar_hash", "u": 1, "d": "Avatar hash for the user, if they have one, otherwise builtins.None ."}, {"r": "hikari.users.PartialUser.discriminator", "u": 1, "d": "Discriminator for the user."}, {"r": "hikari.users.PartialUser.username", "u": 1, "d": "Username for the user."}, {"r": "hikari.users.PartialUser.is_bot", "u": 1, "d": " builtins.True if this user is a bot account, builtins.False otherwise."}, {"r": "hikari.users.PartialUser.is_system", "u": 1, "d": " builtins.True if this user is a system account, builtins.False otherwise."}, {"r": "hikari.users.PartialUser.flags", "u": 1, "d": "Flag bits that are set for the user."}, {"r": "hikari.users.PartialUser.mention", "u": 1, "d": "Return a raw mention string for the given user. Example  \n>>> some_user.mention\n'<@123456789123456789>' Returns builtins.str The mention string to use."}, {"r": "hikari.users.PartialUser.fetch_dm_channel", "u": 1, "d": "Fetch the DM channel for this user. Returns hikari.channels.DMChannel The requested channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.users.PartialUser.fetch_self", "u": 1, "d": "Get this user's up-to-date object by performing an API call. Returns hikari.users.User The requested user object. Raises hikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.users.PartialUser.send", "u": 1, "d": "Send a message to this user in DM's. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nnonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled.\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.users.PartialUser.id", "u": 1, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.users.PartialUser.created_at", "u": 1, "d": "When the object was created."}, {"r": "hikari.users.User", "u": 1, "d": "Interface for any user-like object. This does not include partial users, as they may not be fully formed."}, {"r": "hikari.users.User.app", "u": 1, "d": "Client application that models may use for procedures."}, {"r": "hikari.users.User.avatar_hash", "u": 1, "d": "Avatar hash for the user, if they have one, otherwise builtins.None ."}, {"r": "hikari.users.User.avatar_url", "u": 1, "d": "Avatar URL for the user, if they have one set. May be builtins.None if no custom avatar is set. In this case, you\nshould use default_avatar_url instead."}, {"r": "hikari.users.User.default_avatar_url", "u": 1, "d": "Default avatar URL for this user."}, {"r": "hikari.users.User.discriminator", "u": 1, "d": "Discriminator for the user."}, {"r": "hikari.users.User.flags", "u": 1, "d": "Flag bits that are set for the user."}, {"r": "hikari.users.User.is_bot", "u": 1, "d": " builtins.True if this user is a bot account, builtins.False otherwise."}, {"r": "hikari.users.User.is_system", "u": 1, "d": " builtins.True if this user is a system account, builtins.False otherwise."}, {"r": "hikari.users.User.mention", "u": 1, "d": "Return a raw mention string for the given user. Example  \n>>> some_user.mention\n'<@123456789123456789>' Returns builtins.str The mention string to use."}, {"r": "hikari.users.User.username", "u": 1, "d": "Username for the user."}, {"r": "hikari.users.User.make_avatar_url", "u": 1, "d": "Generate the avatar URL for this user, if set. If no custom avatar is set, this returns builtins.None . You can then\nuse the default_avatar_url attribute instead to fetch the displayed\nURL. Parameters ext : typing.Optional[builtins.str] The ext to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). Will be ignored for default avatars which can only be png . If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns typing.Optional[hikari.files.URL] The URL to the avatar, or builtins.None if not present. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.users.User.fetch_dm_channel", "u": 1, "d": "Fetch the DM channel for this user. Returns hikari.channels.DMChannel The requested channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.users.User.fetch_self", "u": 1, "d": "Get this user's up-to-date object by performing an API call. Returns hikari.users.User The requested user object. Raises hikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.users.User.send", "u": 1, "d": "Send a message to this user in DM's. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nnonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled.\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.users.User.id", "u": 1, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.users.User.created_at", "u": 1, "d": "When the object was created."}, {"r": "hikari.users.OwnUser", "u": 1, "d": "Represents a user with extended OAuth2 information. Method generated by attrs for class OwnUser."}, {"r": "hikari.users.OwnUser.fetch_self", "u": 1, "d": "Get this user's up-to-date object. Returns hikari.users.OwnUser The requested user object. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.users.OwnUser.fetch_dm_channel", "u": 1, "d": "Fetch the DM channel for this user. Returns hikari.channels.DMChannel The requested channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.users.OwnUser.send", "u": 1, "d": "Send a message to this user in DM's. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nnonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled.\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.users.OwnUser.email", "u": 1, "d": "The user's set email. Will be builtins.None if retrieved through OAuth2 flow without the email scope. Will always be builtins.None for bot users."}, {"r": "hikari.users.OwnUser.is_mfa_enabled", "u": 1, "d": "Whether the user's account has multi-factor authentication enabled."}, {"r": "hikari.users.OwnUser.is_verified", "u": 1, "d": "Whether the email for this user's account has been verified. Will be builtins.None if retrieved through the OAuth2 flow without the email scope."}, {"r": "hikari.users.OwnUser.locale", "u": 1, "d": "The user's set language. This is not provided by the READY event."}, {"r": "hikari.users.OwnUser.premium_type", "u": 1, "d": "The type of Nitro Subscription this user account had. This will always be builtins.None for bots."}, {"r": "hikari.users.OwnUser.app", "u": 1, "d": "Client application that models may use for procedures."}, {"r": "hikari.users.OwnUser.avatar_hash", "u": 1, "d": "Avatar hash for the user, if they have one, otherwise builtins.None ."}, {"r": "hikari.users.OwnUser.avatar_url", "u": 1, "d": "Avatar URL for the user, if they have one set. May be builtins.None if no custom avatar is set. In this case, you\nshould use default_avatar_url instead."}, {"r": "hikari.users.OwnUser.default_avatar_url", "u": 1, "d": "Default avatar URL for this user."}, {"r": "hikari.users.OwnUser.discriminator", "u": 1, "d": "Discriminator for the user."}, {"r": "hikari.users.OwnUser.flags", "u": 1, "d": "Flag bits that are set for the user."}, {"r": "hikari.users.OwnUser.is_bot", "u": 1, "d": " builtins.True if this user is a bot account, builtins.False otherwise."}, {"r": "hikari.users.OwnUser.is_system", "u": 1, "d": " builtins.True if this user is a system account, builtins.False otherwise."}, {"r": "hikari.users.OwnUser.mention", "u": 1, "d": "Return a raw mention string for the given user. Example  \n>>> some_user.mention\n'<@123456789123456789>' Returns builtins.str The mention string to use."}, {"r": "hikari.users.OwnUser.username", "u": 1, "d": "Username for the user."}, {"r": "hikari.users.OwnUser.make_avatar_url", "u": 1, "d": "Generate the avatar URL for this user, if set. If no custom avatar is set, this returns builtins.None . You can then\nuse the default_avatar_url attribute instead to fetch the displayed\nURL. Parameters ext : typing.Optional[builtins.str] The ext to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). Will be ignored for default avatars which can only be png . If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns typing.Optional[hikari.files.URL] The URL to the avatar, or builtins.None if not present. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.users.OwnUser.id", "u": 1, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.users.OwnUser.created_at", "u": 1, "d": "When the object was created."}, {"r": "hikari.users.UserFlag", "u": 1, "d": "The known user flags that represent account badges."}, {"r": "hikari.users.UserFlag.name", "u": 1, "d": "Return the name of the flag combination as a builtins.str ."}, {"r": "hikari.users.UserFlag.value", "u": 1, "d": "Return the builtins.int value of the flag."}, {"r": "hikari.users.UserFlag.all", "u": 1, "d": "Check if all of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.users.UserFlag.any", "u": 1, "d": "Check if any of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.users.UserFlag.difference", "u": 1, "d": "Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction - operator.", "f": 1}, {"r": "hikari.users.UserFlag.intersection", "u": 1, "d": "Return a combination of flags that are set for both given values. Equivalent to using the \"AND\" & operator.", "f": 1}, {"r": "hikari.users.UserFlag.invert", "u": 1, "d": "Return a set of all flags not in the current set.", "f": 1}, {"r": "hikari.users.UserFlag.is_disjoint", "u": 1, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.users.UserFlag.is_subset", "u": 1, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.users.UserFlag.is_superset", "u": 1, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.users.UserFlag.none", "u": 1, "d": "Check if none of the given flags are part of this value. ! note This is essentially the opposite of Flag.any . Returns builtins.bool builtins.True if none of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.users.UserFlag.split", "u": 1, "d": "Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted typing.Sequence of each membe", "f": 1}, {"r": "hikari.users.UserFlag.symmetric_difference", "u": 1, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.users.UserFlag.union", "u": 1, "d": "Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\" ~ operator.", "f": 1}, {"r": "hikari.users.UserFlag.isdisjoint", "u": 1, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.users.UserFlag.issubset", "u": 1, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.users.UserFlag.issuperset", "u": 1, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.users.UserFlag.symmetricdifference", "u": 1, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.users.UserFlag.NONE", "u": 1, "d": "None"}, {"r": "hikari.users.UserFlag.DISCORD_EMPLOYEE", "u": 1, "d": "Discord Employee."}, {"r": "hikari.users.UserFlag.PARTNERED_SERVER_OWNER", "u": 1, "d": "Owner of a partnered Discord server."}, {"r": "hikari.users.UserFlag.HYPESQUAD_EVENTS", "u": 1, "d": "HypeSquad Events."}, {"r": "hikari.users.UserFlag.BUG_HUNTER_LEVEL_1", "u": 1, "d": "Bug Hunter Level 1."}, {"r": "hikari.users.UserFlag.HYPESQUAD_BRAVERY", "u": 1, "d": "House of Bravery."}, {"r": "hikari.users.UserFlag.HYPESQUAD_BRILLIANCE", "u": 1, "d": "House of Brilliance."}, {"r": "hikari.users.UserFlag.HYPESQUAD_BALANCE", "u": 1, "d": "House of Balance."}, {"r": "hikari.users.UserFlag.EARLY_SUPPORTER", "u": 1, "d": "Early Supporter."}, {"r": "hikari.users.UserFlag.TEAM_USER", "u": 1, "d": "Team user."}, {"r": "hikari.users.UserFlag.BUG_HUNTER_LEVEL_2", "u": 1, "d": "Bug Hunter Level 2."}, {"r": "hikari.users.UserFlag.VERIFIED_BOT", "u": 1, "d": "Verified Bot."}, {"r": "hikari.users.UserFlag.EARLY_VERIFIED_DEVELOPER", "u": 1, "d": "Early verified Bot Developer. Only applies to users that verified their account before 20th August 2019."}, {"r": "hikari.users.UserFlag.DISCORD_CERTIFIED_MODERATOR", "u": 1, "d": "Discord Certified Moderator."}, {"r": "hikari.users.PremiumType", "u": 1, "d": "The types of Nitro."}, {"r": "hikari.users.PremiumType.name", "u": 1, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.users.PremiumType.value", "u": 1, "d": "Return the value of the enum member."}, {"r": "hikari.users.PremiumType.NONE", "u": 1, "d": "No premium."}, {"r": "hikari.users.PremiumType.NITRO_CLASSIC", "u": 1, "d": "Premium including basic perks like animated emojis and avatars."}, {"r": "hikari.users.PremiumType.NITRO", "u": 1, "d": "Premium including all perks (e.g. 2 server boosts)."}, {"r": "hikari.traits", "u": 2, "d": "Core app interface for application implementations."}, {"r": "hikari.traits.CacheAware", "u": 2, "d": "Structural supertype for a cache-aware object. Any cache-aware objects are able to access the Discord application cache."}, {"r": "hikari.traits.CacheAware.cache", "u": 2, "d": "Return the immutable cache implementation for this object. Returns hikari.api.cache.Cache The cache component for this object."}, {"r": "hikari.traits.EventManagerAware", "u": 2, "d": "Structural supertype for a event manager-aware object. event manager-aware components are able to manage event listeners and waiters."}, {"r": "hikari.traits.EventManagerAware.event_manager", "u": 2, "d": "Return the event manager for this object. Returns hikari.api.event_manager.EventManager The event manager component."}, {"r": "hikari.traits.EntityFactoryAware", "u": 2, "d": "Structural supertype for an entity factory-aware object. These components will be able to construct library entities."}, {"r": "hikari.traits.EntityFactoryAware.entity_factory", "u": 2, "d": "Return the entity factory implementation for this object. Returns hikari.api.entity_factory.EntityFactory The entity factory component."}, {"r": "hikari.traits.EventFactoryAware", "u": 2, "d": "Structural supertype for an event factory-aware object. These components are able to construct library events."}, {"r": "hikari.traits.EventFactoryAware.event_factory", "u": 2, "d": "Return the event factory component. Returns hikari.api.event_factory.EventFactory The event factory component."}, {"r": "hikari.traits.ExecutorAware", "u": 2, "d": "Structural supertype for an executor-aware object. These components will contain an executor attribute that may return\na concurrent.futures.Executor or builtins.None if the\ndefault asyncio thread pool for the event loop is used."}, {"r": "hikari.traits.ExecutorAware.executor", "u": 2, "d": "Return the executor to use for blocking operations. This may return builtins.None if the default asyncio thread pool\nshould be used instead. Returns typing.Optional[concurrent.futures.Executor] The executor to use, or builtins.None to use the asyncio default instead."}, {"r": "hikari.traits.GatewayBotAware", "u": 2, "d": "Structural supertype for a component that has all the gateway components."}, {"r": "hikari.traits.GatewayBotAware.join", "u": 2, "d": "Wait indefinitely until the application closes. This can be placed in a task and cancelled without affecting the\napplication runtime itself. Any exceptions raised by shards will be\npropagated to here. Other Parameters until_close : builtins.bool Defaults to builtins.True . If set, the waiter will stop as soon as a request for shut down is processed. This can allow you to break and begin closing your own resources. If builtins.False , then this will wait until all shards' tasks have died.", "f": 1}, {"r": "hikari.traits.GatewayBotAware.run", "u": 2, "d": "Start the bot and block until it's finished running. Other Parameters activity : typing.Optional[hikari.presences.Activity] The initial activity to display in the bot user presence, or builtins.None (default) to not show any.\nafk : builtins.bool The initial AFK state to display in the bot user presence, or builtins.False (default) to not show any.\nclose_executor : builtins.bool Defaults to builtins.False . If builtins.True , any custom concurrent.futures.Executor passed to the constructor will be shut down when the application terminates. This does not affect the default executor associated with the event loop, and will not do anything if you do not provide a custom executor to the constructor.\nidle_since : typing.Optional[datetime.datetime] The datetime.datetime the user should be marked as being idle since, or builtins.None (default) to not show this.\nignore_session_start_limit : builtins.bool Defaults to builtins.False . If builtins.False , then attempting to start more sessions than you are allowed in a 24 hour window will throw a hikari.errors.GatewayError rather than going ahead and hitting the IDENTIFY limit, which may result in your token being reset. Setting to builtins.True disables this behavior.\nlarge_threshold : builtins.int Threshold for members in a guild before it is treated as being \"large\" and no longer sending member details in the GUILD CREATE event. Defaults to 250 .\nshard_ids : typing.Optional[typing.AbstractSet[builtins.int The shard IDs to create shards for. If not builtins.None , then a non- None  shard_count must ALSO be provided. Defaults to builtins.None , which means the Discord-recommended count is used for your application instead.\nshard_count : typing.Optional[builtins.int] The number of shards to use in the entire distributed application. Defaults to builtins.None which results in the count being determined dynamically on startup.\nstatus : hikari.presences.Status The initial status to show for the user presence on startup. Defaults to hikari.presences.Status.ONLINE .", "f": 1}, {"r": "hikari.traits.GatewayBotAware.start", "u": 2, "d": "Start the bot, wait for all shards to become ready, and then return. Other Parameters activity : typing.Optional[hikari.presences.Activity] The initial activity to display in the bot user presence, or builtins.None (default) to not show any.\nafk : builtins.bool The initial AFK state to display in the bot user presence, or builtins.False (default) to not show any.\nidle_since : typing.Optional[datetime.datetime] The datetime.datetime the user should be marked as being idle since, or builtins.None (default) to not show this.\nignore_session_start_limit : builtins.bool Defaults to builtins.False . If builtins.False , then attempting to start more sessions than you are allowed in a 24 hour window will throw a hikari.errors.GatewayError rather than going ahead and hitting the IDENTIFY limit, which may result in your token being reset. Setting to builtins.True disables this behavior.\nlarge_threshold : builtins.int Threshold for members in a guild before it is treated as being \"large\" and no longer sending member details in the GUILD CREATE event. Defaults to 250 .\nshard_ids : typing.Optional[typing.AbstractSet[builtins.int The shard IDs to create shards for. If not builtins.None , then a non- None  shard_count must ALSO be provided. Defaults to builtins.None , which means the Discord-recommended count is used for your application instead.\nshard_count : typing.Optional[builtins.int] The number of shards to use in the entire distributed application. Defaults to builtins.None which results in the count being determined dynamically on startup.\nstatus : hikari.presences.Status The initial status to show for the user presence on startup. Defaults to hikari.presences.Status.ONLINE .", "f": 1}, {"r": "hikari.traits.GatewayBotAware.rest", "u": 2, "d": "Return the REST client to use for HTTP requests. Returns hikari.api.rest.RESTClient The REST client to use."}, {"r": "hikari.traits.GatewayBotAware.entity_factory", "u": 2, "d": "Return the entity factory implementation for this object. Returns hikari.api.entity_factory.EntityFactory The entity factory component."}, {"r": "hikari.traits.GatewayBotAware.http_settings", "u": 2, "d": "Return the HTTP settings in use by this component. Returns hikari.config.HTTPSettings The HTTP settings in use."}, {"r": "hikari.traits.GatewayBotAware.proxy_settings", "u": 2, "d": "Return the proxy settings in use by this component. Returns hikari.config.ProxySettings The proxy settings in use."}, {"r": "hikari.traits.GatewayBotAware.executor", "u": 2, "d": "Return the executor to use for blocking operations. This may return builtins.None if the default asyncio thread pool\nshould be used instead. Returns typing.Optional[concurrent.futures.Executor] The executor to use, or builtins.None to use the asyncio default instead."}, {"r": "hikari.traits.GatewayBotAware.is_alive", "u": 2, "d": "Check whether the application is running or not. This is useful as some functions might raise hikari.errors.ComponentStateConflictError if this is builtins.False . Returns builtins.bool Whether the bot is running or not."}, {"r": "hikari.traits.GatewayBotAware.close", "u": 2, "d": "Kill the application by shutting all components down.", "f": 1}, {"r": "hikari.traits.GatewayBotAware.heartbeat_latencies", "u": 2, "d": "Return a mapping of shard ID to heartbeat latency. Any shards that are not yet started will be float('nan') . Returns typing.Mapping[builtins.int, builtins.float] Each shard ID mapped to the corresponding heartbeat latency. Each latency is measured in seconds."}, {"r": "hikari.traits.GatewayBotAware.heartbeat_latency", "u": 2, "d": "Return the average heartbeat latency of all started shards. If no shards are started, this will return float('nan') . Returns builtins.float The average heartbeat latency of all started shards, or float('nan') if no shards are started. This is measured in seconds."}, {"r": "hikari.traits.GatewayBotAware.shards", "u": 2, "d": "Return a mapping of shards in this application instance. Each shard ID is mapped to the corresponding shard instance. If the application has not started, it is acceptable to assume the\nresult of this call will be an empty mapping. Returns typing.Mapping[int, hikari.api.shard.GatewayShard] The shard mapping."}, {"r": "hikari.traits.GatewayBotAware.shard_count", "u": 2, "d": "Return the number of shards in the total application. This may not be the same as the size of shards . If the application\nis auto-sharded, this may be 0 until the shards are started. Returns builtins.int The number of shards in the total application."}, {"r": "hikari.traits.GatewayBotAware.get_me", "u": 2, "d": "Return the bot user, if known. This should be available as soon as the bot has fired the hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be builtins.None . Returns typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise builtins.None .", "f": 1}, {"r": "hikari.traits.GatewayBotAware.update_presence", "u": 2, "d": "Update the presence on all shards. This call will patch the presence on each shard. This means that\nunless you explicitly specify a parameter, the previous value will be\nretained. This means you do not have to track the global presence\nin your code. Other Parameters idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed.\nafk : hikari.undefined.UndefinedOr[builtins.bool] If builtins.True , the user is marked as AFK. If builtins.False , the user is marked as being active. If undefined, this will not be changed.\nactivity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed.\nstatus : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed. ! note This will only send the update payloads to shards that are alive. Any shards that are not alive will cache the new presence for when they do start. ! note If you want to set presences per shard, access the shard you wish to update (e.g. by using GatewayBot.shards ), and call hikari.api.shard.GatewayShard.update_presence on that shard. This method is simply a facade to make performing this in bulk simpler.", "f": 1}, {"r": "hikari.traits.GatewayBotAware.update_voice_state", "u": 2, "d": "Update the voice state for this bot in a given guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild or guild ID to update the voice state for.\nchannel : typing.Optional[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel The channel or channel ID to update the voice state for. If builtins.None then the bot will leave the voice channel that it is in for the given guild.\nself_mute : builtins.bool If specified and builtins.True , the bot will mute itself in that voice channel. If builtins.False , then it will unmute itself.\nself_deaf : builtins.bool If specified and builtins.True , the bot will deafen itself in that voice channel. If builtins.False , then it will undeafen itself. Raises builtins.RuntimeError If the guild passed isn't covered by any of the shards in this sharded client.", "f": 1}, {"r": "hikari.traits.GatewayBotAware.request_guild_members", "u": 2, "d": "Request for a guild chunk. Parameters guild: hikari.guilds.Guild The guild to request chunk for. Other Parameters include_presences: hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences.\nquery: builtins.str If not   , request the members which username starts with the string.\nlimit: builtins.int Maximum number of members to send matching the query.\nusers: hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.users.User If provided, the users to request for.\nnonce: hikari.undefined.UndefinedOr[builtins.str] If provided, the nonce to be sent with guild chunks. ! note To request the full list of members, set query to   (empty string) and limit to 0 . Raises ValueError When trying to specify users with query / limit , if limit is not between 0 and 100, both inclusive or if users length is over 100.\nhikari.errors.MissingIntentError When trying to request presences without the GUILD_MEMBERS or when trying to request the full list of members without GUILD_PRESENCES .\nbuiltins.RuntimeError If the guild passed isn't covered by any of the shards in this sharded client.", "f": 1}, {"r": "hikari.traits.GatewayBotAware.intents", "u": 2, "d": "Return the intents registered for the application. Returns hikari.intents.Intents The intents registered on this application."}, {"r": "hikari.traits.GatewayBotAware.voice", "u": 2, "d": "Return the voice connection manager component for this application. Returns hikari.api.voice.VoiceComponent The voice component for the application."}, {"r": "hikari.traits.GatewayBotAware.event_factory", "u": 2, "d": "Return the event factory component. Returns hikari.api.event_factory.EventFactory The event factory component."}, {"r": "hikari.traits.GatewayBotAware.event_manager", "u": 2, "d": "Return the event manager for this object. Returns hikari.api.event_manager.EventManager The event manager component."}, {"r": "hikari.traits.GatewayBotAware.cache", "u": 2, "d": "Return the immutable cache implementation for this object. Returns hikari.api.cache.Cache The cache component for this object."}, {"r": "hikari.traits.IntentsAware", "u": 2, "d": "A component that is aware of the application intents."}, {"r": "hikari.traits.IntentsAware.intents", "u": 2, "d": "Return the intents registered for the application. Returns hikari.intents.Intents The intents registered on this application."}, {"r": "hikari.traits.NetworkSettingsAware", "u": 2, "d": "Structural supertype for any component aware of network settings."}, {"r": "hikari.traits.NetworkSettingsAware.http_settings", "u": 2, "d": "Return the HTTP settings in use by this component. Returns hikari.config.HTTPSettings The HTTP settings in use."}, {"r": "hikari.traits.NetworkSettingsAware.proxy_settings", "u": 2, "d": "Return the proxy settings in use by this component. Returns hikari.config.ProxySettings The proxy settings in use."}, {"r": "hikari.traits.RESTAware", "u": 2, "d": "Structural supertype for a REST-aware object. These are able to perform REST API calls."}, {"r": "hikari.traits.RESTAware.rest", "u": 2, "d": "Return the REST client to use for HTTP requests. Returns hikari.api.rest.RESTClient The REST client to use."}, {"r": "hikari.traits.RESTAware.entity_factory", "u": 2, "d": "Return the entity factory implementation for this object. Returns hikari.api.entity_factory.EntityFactory The entity factory component."}, {"r": "hikari.traits.RESTAware.http_settings", "u": 2, "d": "Return the HTTP settings in use by this component. Returns hikari.config.HTTPSettings The HTTP settings in use."}, {"r": "hikari.traits.RESTAware.proxy_settings", "u": 2, "d": "Return the proxy settings in use by this component. Returns hikari.config.ProxySettings The proxy settings in use."}, {"r": "hikari.traits.RESTAware.executor", "u": 2, "d": "Return the executor to use for blocking operations. This may return builtins.None if the default asyncio thread pool\nshould be used instead. Returns typing.Optional[concurrent.futures.Executor] The executor to use, or builtins.None to use the asyncio default instead."}, {"r": "hikari.traits.RESTBotAware", "u": 2, "d": "Structural supertype for a component that has all the RESTful components."}, {"r": "hikari.traits.RESTBotAware.interaction_server", "u": 2, "d": "Interaction server this app is bound to. Returns hikari.api.interaction_server.InteractionServer The interaction server this app is bound to."}, {"r": "hikari.traits.RESTBotAware.rest", "u": 2, "d": "Return the REST client to use for HTTP requests. Returns hikari.api.rest.RESTClient The REST client to use."}, {"r": "hikari.traits.RESTBotAware.entity_factory", "u": 2, "d": "Return the entity factory implementation for this object. Returns hikari.api.entity_factory.EntityFactory The entity factory component."}, {"r": "hikari.traits.RESTBotAware.http_settings", "u": 2, "d": "Return the HTTP settings in use by this component. Returns hikari.config.HTTPSettings The HTTP settings in use."}, {"r": "hikari.traits.RESTBotAware.proxy_settings", "u": 2, "d": "Return the proxy settings in use by this component. Returns hikari.config.ProxySettings The proxy settings in use."}, {"r": "hikari.traits.RESTBotAware.executor", "u": 2, "d": "Return the executor to use for blocking operations. This may return builtins.None if the default asyncio thread pool\nshould be used instead. Returns typing.Optional[concurrent.futures.Executor] The executor to use, or builtins.None to use the asyncio default instead."}, {"r": "hikari.traits.RESTBotAware.is_alive", "u": 2, "d": "Check whether the application is running or not. This is useful as some functions might raise hikari.errors.ComponentStateConflictError if this is builtins.False . Returns builtins.bool Whether the bot is running or not."}, {"r": "hikari.traits.RESTBotAware.close", "u": 2, "d": "Kill the application by shutting all components down.", "f": 1}, {"r": "hikari.traits.RESTBotAware.join", "u": 2, "d": "Wait indefinitely until the application closes. This can be placed in a task and cancelled without affecting the\napplication runtime itself. Any exceptions raised by shards will be\npropagated to here.", "f": 1}, {"r": "hikari.traits.RESTBotAware.run", "u": 2, "d": "Start the application and block until it's finished running.", "f": 1}, {"r": "hikari.traits.RESTBotAware.start", "u": 2, "d": "Start the application and then return.", "f": 1}, {"r": "hikari.traits.Runnable", "u": 2, "d": "Structural super-type for an application which can be run independently."}, {"r": "hikari.traits.Runnable.is_alive", "u": 2, "d": "Check whether the application is running or not. This is useful as some functions might raise hikari.errors.ComponentStateConflictError if this is builtins.False . Returns builtins.bool Whether the bot is running or not."}, {"r": "hikari.traits.Runnable.close", "u": 2, "d": "Kill the application by shutting all components down.", "f": 1}, {"r": "hikari.traits.Runnable.join", "u": 2, "d": "Wait indefinitely until the application closes. This can be placed in a task and cancelled without affecting the\napplication runtime itself. Any exceptions raised by shards will be\npropagated to here.", "f": 1}, {"r": "hikari.traits.Runnable.run", "u": 2, "d": "Start the application and block until it's finished running.", "f": 1}, {"r": "hikari.traits.Runnable.start", "u": 2, "d": "Start the application and then return.", "f": 1}, {"r": "hikari.traits.InteractionServerAware", "u": 2, "d": "Structural supertype for a interaction REST server-aware object."}, {"r": "hikari.traits.InteractionServerAware.interaction_server", "u": 2, "d": "Interaction server this app is bound to. Returns hikari.api.interaction_server.InteractionServer The interaction server this app is bound to."}, {"r": "hikari.traits.InteractionServerAware.rest", "u": 2, "d": "Return the REST client to use for HTTP requests. Returns hikari.api.rest.RESTClient The REST client to use."}, {"r": "hikari.traits.InteractionServerAware.entity_factory", "u": 2, "d": "Return the entity factory implementation for this object. Returns hikari.api.entity_factory.EntityFactory The entity factory component."}, {"r": "hikari.traits.InteractionServerAware.http_settings", "u": 2, "d": "Return the HTTP settings in use by this component. Returns hikari.config.HTTPSettings The HTTP settings in use."}, {"r": "hikari.traits.InteractionServerAware.proxy_settings", "u": 2, "d": "Return the proxy settings in use by this component. Returns hikari.config.ProxySettings The proxy settings in use."}, {"r": "hikari.traits.InteractionServerAware.executor", "u": 2, "d": "Return the executor to use for blocking operations. This may return builtins.None if the default asyncio thread pool\nshould be used instead. Returns typing.Optional[concurrent.futures.Executor] The executor to use, or builtins.None to use the asyncio default instead."}, {"r": "hikari.traits.ShardAware", "u": 2, "d": "Structural supertype for a shard-aware object. These will expose a mapping of shards, the intents in use\nand the bot user object."}, {"r": "hikari.traits.ShardAware.heartbeat_latencies", "u": 2, "d": "Return a mapping of shard ID to heartbeat latency. Any shards that are not yet started will be float('nan') . Returns typing.Mapping[builtins.int, builtins.float] Each shard ID mapped to the corresponding heartbeat latency. Each latency is measured in seconds."}, {"r": "hikari.traits.ShardAware.heartbeat_latency", "u": 2, "d": "Return the average heartbeat latency of all started shards. If no shards are started, this will return float('nan') . Returns builtins.float The average heartbeat latency of all started shards, or float('nan') if no shards are started. This is measured in seconds."}, {"r": "hikari.traits.ShardAware.shards", "u": 2, "d": "Return a mapping of shards in this application instance. Each shard ID is mapped to the corresponding shard instance. If the application has not started, it is acceptable to assume the\nresult of this call will be an empty mapping. Returns typing.Mapping[int, hikari.api.shard.GatewayShard] The shard mapping."}, {"r": "hikari.traits.ShardAware.shard_count", "u": 2, "d": "Return the number of shards in the total application. This may not be the same as the size of shards . If the application\nis auto-sharded, this may be 0 until the shards are started. Returns builtins.int The number of shards in the total application."}, {"r": "hikari.traits.ShardAware.get_me", "u": 2, "d": "Return the bot user, if known. This should be available as soon as the bot has fired the hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be builtins.None . Returns typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise builtins.None .", "f": 1}, {"r": "hikari.traits.ShardAware.update_presence", "u": 2, "d": "Update the presence on all shards. This call will patch the presence on each shard. This means that\nunless you explicitly specify a parameter, the previous value will be\nretained. This means you do not have to track the global presence\nin your code. Other Parameters idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed.\nafk : hikari.undefined.UndefinedOr[builtins.bool] If builtins.True , the user is marked as AFK. If builtins.False , the user is marked as being active. If undefined, this will not be changed.\nactivity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed.\nstatus : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed. ! note This will only send the update payloads to shards that are alive. Any shards that are not alive will cache the new presence for when they do start. ! note If you want to set presences per shard, access the shard you wish to update (e.g. by using GatewayBot.shards ), and call hikari.api.shard.GatewayShard.update_presence on that shard. This method is simply a facade to make performing this in bulk simpler.", "f": 1}, {"r": "hikari.traits.ShardAware.update_voice_state", "u": 2, "d": "Update the voice state for this bot in a given guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild or guild ID to update the voice state for.\nchannel : typing.Optional[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel The channel or channel ID to update the voice state for. If builtins.None then the bot will leave the voice channel that it is in for the given guild.\nself_mute : builtins.bool If specified and builtins.True , the bot will mute itself in that voice channel. If builtins.False , then it will unmute itself.\nself_deaf : builtins.bool If specified and builtins.True , the bot will deafen itself in that voice channel. If builtins.False , then it will undeafen itself. Raises builtins.RuntimeError If the guild passed isn't covered by any of the shards in this sharded client.", "f": 1}, {"r": "hikari.traits.ShardAware.request_guild_members", "u": 2, "d": "Request for a guild chunk. Parameters guild: hikari.guilds.Guild The guild to request chunk for. Other Parameters include_presences: hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences.\nquery: builtins.str If not   , request the members which username starts with the string.\nlimit: builtins.int Maximum number of members to send matching the query.\nusers: hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.users.User If provided, the users to request for.\nnonce: hikari.undefined.UndefinedOr[builtins.str] If provided, the nonce to be sent with guild chunks. ! note To request the full list of members, set query to   (empty string) and limit to 0 . Raises ValueError When trying to specify users with query / limit , if limit is not between 0 and 100, both inclusive or if users length is over 100.\nhikari.errors.MissingIntentError When trying to request presences without the GUILD_MEMBERS or when trying to request the full list of members without GUILD_PRESENCES .\nbuiltins.RuntimeError If the guild passed isn't covered by any of the shards in this sharded client.", "f": 1}, {"r": "hikari.traits.ShardAware.intents", "u": 2, "d": "Return the intents registered for the application. Returns hikari.intents.Intents The intents registered on this application."}, {"r": "hikari.traits.ShardAware.http_settings", "u": 2, "d": "Return the HTTP settings in use by this component. Returns hikari.config.HTTPSettings The HTTP settings in use."}, {"r": "hikari.traits.ShardAware.proxy_settings", "u": 2, "d": "Return the proxy settings in use by this component. Returns hikari.config.ProxySettings The proxy settings in use."}, {"r": "hikari.traits.ShardAware.executor", "u": 2, "d": "Return the executor to use for blocking operations. This may return builtins.None if the default asyncio thread pool\nshould be used instead. Returns typing.Optional[concurrent.futures.Executor] The executor to use, or builtins.None to use the asyncio default instead."}, {"r": "hikari.traits.ShardAware.voice", "u": 2, "d": "Return the voice connection manager component for this application. Returns hikari.api.voice.VoiceComponent The voice component for the application."}, {"r": "hikari.traits.VoiceAware", "u": 2, "d": "Structural supertype for a voice-aware object. This is an object that provides a voice property to allow the creation\nof custom voice client instances."}, {"r": "hikari.traits.VoiceAware.voice", "u": 2, "d": "Return the voice connection manager component for this application. Returns hikari.api.voice.VoiceComponent The voice component for the application."}, {"r": "hikari.config", "u": 3, "d": "Data class containing network-related configuration settings."}, {"r": "hikari.config.BasicAuthHeader", "u": 3, "d": "An object that can be set as a producer for a basic auth header. Method generated by attrs for class BasicAuthHeader."}, {"r": "hikari.config.BasicAuthHeader.header", "u": 3, "d": "Create the full Authentication header value. Returns builtins.str A base64-encoded string containing \"{username}:{password}\" ."}, {"r": "hikari.config.BasicAuthHeader.charset", "u": 3, "d": "Encoding to use for the username and password. Default is \"utf-8\" , but you may choose to use something else,\nincluding third-party encodings (e.g. IBM's EBCDIC codepages). Returns builtins.str The encoding to use."}, {"r": "hikari.config.BasicAuthHeader.password", "u": 3, "d": "Password to use. Returns builtins.str The password to use."}, {"r": "hikari.config.BasicAuthHeader.username", "u": 3, "d": "Username for the header. Returns builtins.str The username to use. This must not contain \":\" ."}, {"r": "hikari.config.ProxySettings", "u": 3, "d": "Settings for configuring an HTTP-based proxy. Method generated by attrs for class ProxySettings."}, {"r": "hikari.config.ProxySettings.all_headers", "u": 3, "d": "Return all proxy headers. Returns typing.Optional[hikari.internal.data_binding.Headers] Any headers that are set, or builtins.None if no headers are to be sent with any request."}, {"r": "hikari.config.ProxySettings.auth", "u": 3, "d": "Authentication header value to use. When cast to a builtins.str , this should provide the full value\nfor the authentication header. If you are using basic auth, you should consider using the BasicAuthHeader helper object here, as this will provide any\ntransformations you may require into a base64 string. The default is to have this set to builtins.None , which will\nresult in no authentication being provided. Returns typing.Any The value for the Authentication header, or builtins.None to disable."}, {"r": "hikari.config.ProxySettings.headers", "u": 3, "d": "Additional headers to use for requests via a proxy, if required."}, {"r": "hikari.config.ProxySettings.trust_env", "u": 3, "d": "Toggle whether to look for a netrc file or environment variables. If builtins.True , and no url is given on this object, then HTTP_PROXY and HTTPS_PROXY will be used from the environment\nvariables, or a netrc file may be read to determine credentials. If builtins.False , then this information is instead ignored. Defaults to builtins.False to prevent potentially unwanted behavior. ! note For more details of using netrc , visit: https: www.gnu.org/software/inetutils/manual/html_node/The-_002enetrc-file.html Returns builtins.bool builtins.True if allowing the use of environment variables and/or netrc to determine proxy settings; builtins.False if this should be disabled explicitly."}, {"r": "hikari.config.ProxySettings.url", "u": 3, "d": "Proxy URL to use. Defaults to builtins.None which disables the use of an explicit proxy. Returns typing.Union[builtins.None, builtins.str, yarl.URL] The proxy URL to use, or builtins.None to disable it."}, {"r": "hikari.config.HTTPTimeoutSettings", "u": 3, "d": "Settings to control HTTP request timeouts. Method generated by attrs for class HTTPTimeoutSettings."}, {"r": "hikari.config.HTTPTimeoutSettings.acquire_and_connect", "u": 3, "d": "Timeout for request_socket_connect PLUS connection acquisition. By default, this has no timeout allocated. Returns typing.Optional[builtins.float] The timeout, or builtins.None to disable it."}, {"r": "hikari.config.HTTPTimeoutSettings.request_socket_connect", "u": 3, "d": "Timeout for connecting a socket. By default, this has no timeout allocated. Returns typing.Optional[builtins.float] The timeout, or builtins.None to disable it."}, {"r": "hikari.config.HTTPTimeoutSettings.request_socket_read", "u": 3, "d": "Timeout for reading a socket. By default, this has no timeout allocated. Returns typing.Optional[builtins.float] The timeout, or builtins.None to disable it."}, {"r": "hikari.config.HTTPTimeoutSettings.total", "u": 3, "d": "Total timeout for entire request. By default, this has a 30 second timeout allocated. Returns typing.Optional[builtins.float] The timeout, or builtins.None to disable it."}, {"r": "hikari.config.HTTPSettings", "u": 3, "d": "Settings to control HTTP clients. Method generated by attrs for class HTTPSettings."}, {"r": "hikari.config.HTTPSettings.enable_cleanup_closed", "u": 3, "d": "Toggle whether to clean up closed transports. This defaults to builtins.True to combat various protocol and asyncio\nissues present when using Microsoft Windows. If you are sure you know\nwhat you are doing, you may instead set this to False to disable this\nbehavior internally. Returns builtins.bool builtins.True to enable this behavior, builtins.False to disable it."}, {"r": "hikari.config.HTTPSettings.force_close_transports", "u": 3, "d": "Toggle whether to force close transports on shutdown. This defaults to builtins.True to combat various protocol and asyncio\nissues present when using Microsoft Windows. If you are sure you know\nwhat you are doing, you may instead set this to False to disable this\nbehavior internally. Returns builtins.bool builtins.True to enable this behavior, builtins.False to disable it."}, {"r": "hikari.config.HTTPSettings.max_redirects", "u": 3, "d": "Behavior for handling redirect HTTP responses. If a builtins.int , allow following redirects from 3xx HTTP responses\nfor up to this many redirects. Exceeding this value will raise an\nexception. If builtins.None , then disallow any redirects. The default is to disallow this behavior for security reasons. Generally, it is safer to keep this disabled. You may find a case in the\nfuture where you need to enable this if Discord change their URL without\nwarning. ! note This will only apply to the REST API. WebSockets remain unaffected by any value set here. Returns typing.Optional[builtins.int] The number of redirects to allow at a maximum per request. builtins.None disables the handling of redirects and will result in exceptions being raised instead should one occur."}, {"r": "hikari.config.HTTPSettings.ssl", "u": 3, "d": "SSL context to use. This may be __assigned__ a builtins.bool or an ssl.SSLContext object. If assigned to builtins.True , a default SSL context is generated by\nthis class that will enforce SSL verification. This is then stored in\nthis field. If builtins.False , then a default SSL context is generated by this\nclass that will NOT enforce SSL verification. This is then stored\nin this field. If an instance of ssl.SSLContext , then this context will be used. ! warning Setting a custom value here may have security implications, or may result in the application being unable to connect to Discord at all. ! warning Disabling SSL verification is almost always unadvised. This is because your application will no longer check whether you are connecting to Discord, or to some third party spoof designed to steal personal credentials such as your application token. There may be cases where SSL certificates do not get updated, and in this case, you may find that disabling this explicitly allows you to work around any issues that are occurring, but you should immediately seek a better solution where possible if any form of personal security is in your interest. Returns ssl.SSLContext The SSL context to use for this application."}, {"r": "hikari.config.HTTPSettings.timeouts", "u": 3, "d": "Settings to control HTTP request timeouts. The behaviour if this is not explicitly defined is to use sane\ndefaults that are most efficient for optimal use of this library. Returns HTTPTimeoutSettings The HTTP timeout settings to use for connection timeouts."}, {"r": "hikari.config.CacheComponents", "u": 3, "d": "Flags to control the cache components."}, {"r": "hikari.config.CacheComponents.name", "u": 3, "d": "Return the name of the flag combination as a builtins.str ."}, {"r": "hikari.config.CacheComponents.value", "u": 3, "d": "Return the builtins.int value of the flag."}, {"r": "hikari.config.CacheComponents.all", "u": 3, "d": "Check if all of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.config.CacheComponents.any", "u": 3, "d": "Check if any of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.config.CacheComponents.difference", "u": 3, "d": "Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction - operator.", "f": 1}, {"r": "hikari.config.CacheComponents.intersection", "u": 3, "d": "Return a combination of flags that are set for both given values. Equivalent to using the \"AND\" & operator.", "f": 1}, {"r": "hikari.config.CacheComponents.invert", "u": 3, "d": "Return a set of all flags not in the current set.", "f": 1}, {"r": "hikari.config.CacheComponents.is_disjoint", "u": 3, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.config.CacheComponents.is_subset", "u": 3, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.config.CacheComponents.is_superset", "u": 3, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.config.CacheComponents.none", "u": 3, "d": "Check if none of the given flags are part of this value. ! note This is essentially the opposite of Flag.any . Returns builtins.bool builtins.True if none of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.config.CacheComponents.split", "u": 3, "d": "Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted typing.Sequence of each membe", "f": 1}, {"r": "hikari.config.CacheComponents.symmetric_difference", "u": 3, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.config.CacheComponents.union", "u": 3, "d": "Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\" ~ operator.", "f": 1}, {"r": "hikari.config.CacheComponents.isdisjoint", "u": 3, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.config.CacheComponents.issubset", "u": 3, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.config.CacheComponents.issuperset", "u": 3, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.config.CacheComponents.symmetricdifference", "u": 3, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.config.CacheComponents.NONE", "u": 3, "d": "Disables the cache."}, {"r": "hikari.config.CacheComponents.GUILDS", "u": 3, "d": "Enables the guild cache."}, {"r": "hikari.config.CacheComponents.GUILD_CHANNELS", "u": 3, "d": "Enables the guild channels cache."}, {"r": "hikari.config.CacheComponents.MEMBERS", "u": 3, "d": "Enables the members cache."}, {"r": "hikari.config.CacheComponents.ROLES", "u": 3, "d": "Enables the roles cache."}, {"r": "hikari.config.CacheComponents.INVITES", "u": 3, "d": "Enables the invites cache."}, {"r": "hikari.config.CacheComponents.EMOJIS", "u": 3, "d": "Enables the emojis cache."}, {"r": "hikari.config.CacheComponents.PRESENCES", "u": 3, "d": "Enables the presences cache."}, {"r": "hikari.config.CacheComponents.VOICE_STATES", "u": 3, "d": "Enables the voice states cache."}, {"r": "hikari.config.CacheComponents.MESSAGES", "u": 3, "d": "Enables the messages cache."}, {"r": "hikari.config.CacheComponents.DM_CHANNEL_IDS", "u": 3, "d": "Enables the DM channel IDs cache."}, {"r": "hikari.config.CacheComponents.ALL", "u": 3, "d": "Fully enables the cache."}, {"r": "hikari.config.CacheSettings", "u": 3, "d": "Settings to control the cache. Method generated by attrs for class CacheSettings."}, {"r": "hikari.config.CacheSettings.components", "u": 3, "d": "The cache components to use. Defaults to CacheComponents.ALL ."}, {"r": "hikari.config.CacheSettings.max_dm_channel_ids", "u": 3, "d": "The maximum number of channel IDs to store in the cache at once. This will have no effect if the channel IDs cache is not enabled. Defaults to 50 ."}, {"r": "hikari.config.CacheSettings.max_messages", "u": 3, "d": "The maximum number of messages to store in the cache at once. This will have no effect if the messages cache is not enabled. Defaults to 300 ."}, {"r": "hikari.colours", "u": 4, "d": "Alias for the hikari.colors module."}, {"r": "hikari.colours.Color", "u": 4, "d": "Representation of a color. This value is immutable. This is a specialization of builtins.int which provides alternative overrides for\ncommon methods and color system conversions. This currently supports: RGB RGB (float) 3-digit hex codes (e.g. 0xF1A web safe) 6-digit hex codes (e.g. 0xFF11AA) 3-digit RGB strings (e.g. 1A2 web safe) 6-digit RGB hash strings (e.g. 1A2B3C) Examples Examples of conversions to given formats include: py\n>>> c = Color(0xFF051A)\nColor(r=0xff, g=0x5, b=0x1a) >>> hex(c)\n0xff051a >>> c.hex_code FF051A >>> str(c) FF051A >>> int(c)\n16712986 >>> c.rgb\n(255, 5, 26) >>> c.rgb_float\n(1.0, 0.0196078431372549, 0.10196078431372549) Alternatively, if you have an arbitrary input in one of the above formats\nthat you wish to become a color, you can use Color.of on the class itself\nto automatically attempt to resolve the color: py\n>>> Color.of(0xFF051A)\nColor(r=0xff, g=0x5, b=0x1a) >>> Color.of(16712986)\nColor(r=0xff, g=0x5, b=0x1a) >>> c = Color.of 255, 5, 26 Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of(255, 5, 26)\nColor(r=0xff, g=0x5, b=1xa) >>> c = Color.of([0xFF, 0x5, 0x1a])\nColor(r=0xff, g=0x5, b=1xa) >>> c = Color.of(\" 1a2b3c\")\nColor(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.of(\" 1AB\")\nColor(r=0x11, g=0xaa, b=0xbb) >>> c = Color.of 1.0, 0.0196078431372549, 0.10196078431372549 Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of([1.0, 0.0196078431372549, 0.10196078431372549])\nColor(r=0xff, g=0x5, b=0x1a) Examples of initialization of Color objects from given formats include: py\n>>> c = Color(16712986)\nColor(r=0xff, g=0x5, b=0x1a) >>> c = Color.from_rgb(255, 5, 26)\nColor(r=0xff, g=0x5, b=1xa) >>> c = Color.from_hex_code(\" 1a2b3c\")\nColor(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.from_hex_code(\" 1AB\")\nColor(r=0x11, g=0xaa, b=0xbb) >>> c = Color.from_rgb_float(1.0, 0.0196078431372549, 0.10196078431372549)\nColor(r=0xff, g=0x5, b=0x1a) "}, {"r": "hikari.colours.Color.rgb", "u": 4, "d": "The RGB representation of this Color. Represented as a tuple of R, G, B. Each value is\nin the range [0, 0xFF]. Example  (123, 234, 47) "}, {"r": "hikari.colours.Color.rgb_float", "u": 4, "d": "Return the floating-point RGB representation of this Color. Represented as a tuple of R, G, B. Each value is in the range [0, 1]. Example  (0.1, 0.2, 0.76) "}, {"r": "hikari.colours.Color.hex_code", "u": 4, "d": "Six-digit hexadecimal color code for this Color. This is prepended with a symbol, and will be in upper case. Example  1A2B3C "}, {"r": "hikari.colours.Color.raw_hex_code", "u": 4, "d": "Raw hex code. Example  1A2B3C "}, {"r": "hikari.colours.Color.is_web_safe", "u": 4, "d": " builtins.True if the color is web safe, builtins.False otherwise."}, {"r": "hikari.colours.Color.from_rgb", "u": 4, "d": "Convert the given RGB to a Color object. Each channel must be within the range [0, 255] (0x0, 0xFF). Parameters red : builtins.int Red channel.\ngreen : builtins.int Green channel.\nblue : builtins.int Blue channel. Returns Color A Color object. Raises builtins.ValueError If red, green, or blue are outside the range [0x0, 0xFF].", "f": 1}, {"r": "hikari.colours.Color.from_rgb_float", "u": 4, "d": "Convert the given RGB to a Color object. The color-space represented values have to be within the\nrange [0, 1]. Parameters red : builtins.float Red channel.\ngreen : builtins.float Green channel.\nblue : builtins.float Blue channel. Returns Color A Color object. Raises builtins.ValueError If red, green or blue are outside the range [0, 1].", "f": 1}, {"r": "hikari.colours.Color.from_hex_code", "u": 4, "d": "Convert the given hexadecimal color code to a Color . The inputs may be of the following format (case insensitive): 1a2 , 1a2 , 0x1a2 (for web-safe colors), or 1a2b3c , 1a2b3c , 0x1a2b3c (for regular 3-byte color-codes). Parameters hex_code : builtins.str A hexadecimal color code to parse. This may optionally start with a case insensitive 0x or . Returns Color A corresponding Color object. Raises builtins.ValueError If hex_code is not a hexadecimal or is a invalid length.", "f": 1}, {"r": "hikari.colours.Color.from_int", "u": 4, "d": "Convert the given typing.SupportsInt to a Color . Parameters integer : typing.SupportsInt The raw color integer. Returns Color The Color object.", "f": 1}, {"r": "hikari.colours.Color.from_tuple_string", "u": 4, "d": "Convert a string in a tuple-like format to a Color . This allows formats that are optionally enclosed by () , {} , or [] , and contain three floats or ints, either space separated or\ncomma separated. If comma separated, trailing and leading whitespace around each member\nis truncated. This is provided to allow command frontends to directly pass user\ninput for representing a given colour into this class safely. Examples   Floats\n\"1.0 1.0 1.0\"\n\"(1.0 1.0 1.0)\"\n\"[1.0 1.0 1.0]\"\n\"{1.0 1.0 1.0}\"\n\"1.0, 1.0, 1.0\"\n\"(1.0, 1.0, 1.0)\"\n\"[1.0, 1.0, 1.0]\"\n\"{1.0, 1.0, 1.0}\" Ints\n\"252 252 252\"\n\"(252 252 252)\"\n\"[252 252 252]\"\n\"{252 252 252}\"\n\"252, 252, 252\"\n\"(252, 252, 252)\"\n\"[252, 252, 252]\"\n\"{252, 252, 252}\" Parameters tuple_str : builtins.str The string to parse. Returns Color The parsed colour object. Raises ValueError If an invalid format is given, or if any values exceed 1.0 for floats or 255 for ints.", "f": 1}, {"r": "hikari.colours.Color.from_bytes", "u": 4, "d": "Convert the bytes to a Color . Parameters bytes_ : typing.Iterable[builtins.int] A iterable of int byte values.\nbyteorder : builtins.str The endianness of the value represented by the bytes. Can be \"big\" endian or \"little\" endian.\nsigned : builtins.bool Whether the value is signed or unsigned. Returns Color The Color object.", "f": 1}, {"r": "hikari.colours.Color.of", "u": 4, "d": "Convert the value to a Color . This attempts to determine the correct data format based on the\ninformation provided. Parameters value : Colorish A color compatible values. Examples  \n>>> Color.of(0xFF051A)\nColor(r=0xff, g=0x5, b=0x1a) >>> Color.of(16712986)\nColor(r=0xff, g=0x5, b=0x1a) >>> c = Color.of 255, 5, 26 Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of([0xFF, 0x5, 0x1a])\nColor(r=0xff, g=0x5, b=1xa) >>> c = Color.of(\" 1a2b3c\")\nColor(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.of(\" 1AB\")\nColor(r=0x11, g=0xaa, b=0xbb) >>> c = Color.of 1.0, 0.0196078431372549, 0.10196078431372549 Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of([1.0, 0.0196078431372549, 0.10196078431372549])\nColor(r=0xff, g=0x5, b=0x1a) Commas and brackets are optional, whitespace is ignored, and these are compatible with all-ints between 0-255 or all-floats between 0.0 and 1.0 only.\n>>> c = Color.of(\"5, 22, 33\")\nColor(r=0x5, g=0x16, b=0x21)\n>>> c = Color.of(\"(5, 22, 33)\")\nColor(r=0x5, g=0x16, b=0x21)\n>>> c = Color.of(\"[5, 22, 33]\")\nColor(r=0x5, g=0x16, b=0x21)\n>>> c = Color.of(\"{5, 22, 33}\")\nColor(r=0x5, g=0x16, b=0x21) Returns Color The Color object.", "f": 1}, {"r": "hikari.colours.Color.to_bytes", "u": 4, "d": "Convert the color code to bytes. Parameters length : builtins.int The number of bytes to produce. Should be around 3 , but not less.\nbyteorder : builtins.str The endianness of the value represented by the bytes. Can be \"big\" endian or \"little\" endian.\nsigned : builtins.bool Whether the value is signed or unsigned. Returns builtins.bytes The bytes representation of the Color.", "f": 1}, {"r": "hikari.urls", "u": 5, "d": "API-wide URLs."}, {"r": "hikari.urls.BASE_URL", "u": 5, "d": "The base URL."}, {"r": "hikari.urls.REST_API_URL", "u": 5, "d": "The REST API URL."}, {"r": "hikari.urls.OAUTH2_API_URL", "u": 5, "d": "The OAUTH2 API URL."}, {"r": "hikari.urls.CDN_URL", "u": 5, "d": "The CDN URL."}, {"r": "hikari.applications", "u": 6, "d": "Application and entities related to discord's OAuth2 flow."}, {"r": "hikari.applications.InviteApplication", "u": 6, "d": "Represents the information of an Invite Application. Method generated by attrs for class InviteApplication."}, {"r": "hikari.applications.InviteApplication.cover_image_url", "u": 6, "d": "Cover image URL used in the store or for embedded games. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no cover image exists."}, {"r": "hikari.applications.InviteApplication.make_cover_image_url", "u": 6, "d": "Generate the cover image URL used in the store or for embedded games, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no cover image exists. Raises builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.applications.InviteApplication.app", "u": 6, "d": "The client application that models may use for procedures."}, {"r": "hikari.applications.InviteApplication.cover_image_hash", "u": 6, "d": "The CDN's hash of this application's cover image, used in the store or for embedded games."}, {"r": "hikari.applications.InviteApplication.public_key", "u": 6, "d": "The key used for verifying interaction and GameSDK payload signatures."}, {"r": "hikari.applications.InviteApplication.icon_url", "u": 6, "d": "Team icon URL, if there is one. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists."}, {"r": "hikari.applications.InviteApplication.make_icon_url", "u": 6, "d": "Generate the icon URL for this application. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists. Raises builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.applications.InviteApplication.description", "u": 6, "d": "The description of this application, if any."}, {"r": "hikari.applications.InviteApplication.icon_hash", "u": 6, "d": "The CDN hash of this application's icon, if set."}, {"r": "hikari.applications.InviteApplication.id", "u": 6, "d": "The ID of this entity."}, {"r": "hikari.applications.InviteApplication.name", "u": 6, "d": "The name of this application."}, {"r": "hikari.applications.InviteApplication.summary", "u": 6, "d": "This summary for this application's primary SKU if it's sold on Discord, if any."}, {"r": "hikari.applications.InviteApplication.created_at", "u": 6, "d": "When the object was created."}, {"r": "hikari.applications.Application", "u": 6, "d": "Represents the information of an Oauth2 Application. Method generated by attrs for class Application."}, {"r": "hikari.applications.Application.cover_image_url", "u": 6, "d": "Cover image URL used in the store or for embedded games. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no cover image exists."}, {"r": "hikari.applications.Application.make_cover_image_url", "u": 6, "d": "Generate the cover image URL used in the store or for embedded games, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no cover image exists. Raises builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.applications.Application.fetch_guild", "u": 6, "d": "Fetch the guild this application is linked to if sold on Discord. Returns typing.Optional[hikari.guilds.RESTGuild] The requested guild if the application is linked to a guild, else builtins.None . Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.Application.fetch_guild_preview", "u": 6, "d": "Fetch the preview of the guild this application is linked to if sold on Discord. Returns typing.Optional[hikari.guilds.GuildPreview] The requested guild preview if the application is linked to a guild, else builtins.None . ! note This will only work if you are a part of that guild or it is public. Raises hikari.errors.NotFoundError If the guild is not found or you are not part of the guild.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.Application.app", "u": 6, "d": "The client application that models may use for procedures."}, {"r": "hikari.applications.Application.cover_image_hash", "u": 6, "d": "The CDN's hash of this application's cover image, used in the store or for embedded games."}, {"r": "hikari.applications.Application.guild_id", "u": 6, "d": "The ID of the guild this application is linked to if sold on Discord."}, {"r": "hikari.applications.Application.is_bot_code_grant_required", "u": 6, "d": " builtins.True if this application's bot is requiring code grant for invites."}, {"r": "hikari.applications.Application.is_bot_public", "u": 6, "d": " builtins.True if the bot associated with this application is public."}, {"r": "hikari.applications.Application.owner", "u": 6, "d": "The application's owner."}, {"r": "hikari.applications.Application.primary_sku_id", "u": 6, "d": "The ID of the primary \"Game SKU\" of a game that's sold on Discord."}, {"r": "hikari.applications.Application.privacy_policy_url", "u": 6, "d": "The URL of this application's privacy policy."}, {"r": "hikari.applications.Application.public_key", "u": 6, "d": "The key used for verifying interaction and GameSDK payload signatures."}, {"r": "hikari.applications.Application.rpc_origins", "u": 6, "d": "A collection of this application's RPC origin URLs, if RPC is enabled."}, {"r": "hikari.applications.Application.slug", "u": 6, "d": "The URL \"slug\" that is used to point to this application's store page. Only applicable to applications sold on Discord."}, {"r": "hikari.applications.Application.team", "u": 6, "d": "The team this application belongs to. If the application is not part of a team, this will be builtins.None ."}, {"r": "hikari.applications.Application.terms_of_service_url", "u": 6, "d": "The URL of this application's terms of service."}, {"r": "hikari.applications.Application.icon_url", "u": 6, "d": "Team icon URL, if there is one. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists."}, {"r": "hikari.applications.Application.make_icon_url", "u": 6, "d": "Generate the icon URL for this application. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists. Raises builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.applications.Application.description", "u": 6, "d": "The description of this application, if any."}, {"r": "hikari.applications.Application.icon_hash", "u": 6, "d": "The CDN hash of this application's icon, if set."}, {"r": "hikari.applications.Application.id", "u": 6, "d": "The ID of this entity."}, {"r": "hikari.applications.Application.name", "u": 6, "d": "The name of this application."}, {"r": "hikari.applications.Application.summary", "u": 6, "d": "This summary for this application's primary SKU if it's sold on Discord, if any."}, {"r": "hikari.applications.Application.created_at", "u": 6, "d": "When the object was created."}, {"r": "hikari.applications.ApplicationFlags", "u": 6, "d": "The known application flag bits."}, {"r": "hikari.applications.ApplicationFlags.name", "u": 6, "d": "Return the name of the flag combination as a builtins.str ."}, {"r": "hikari.applications.ApplicationFlags.value", "u": 6, "d": "Return the builtins.int value of the flag."}, {"r": "hikari.applications.ApplicationFlags.all", "u": 6, "d": "Check if all of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.applications.ApplicationFlags.any", "u": 6, "d": "Check if any of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.applications.ApplicationFlags.difference", "u": 6, "d": "Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction - operator.", "f": 1}, {"r": "hikari.applications.ApplicationFlags.intersection", "u": 6, "d": "Return a combination of flags that are set for both given values. Equivalent to using the \"AND\" & operator.", "f": 1}, {"r": "hikari.applications.ApplicationFlags.invert", "u": 6, "d": "Return a set of all flags not in the current set.", "f": 1}, {"r": "hikari.applications.ApplicationFlags.is_disjoint", "u": 6, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.applications.ApplicationFlags.is_subset", "u": 6, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.applications.ApplicationFlags.is_superset", "u": 6, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.applications.ApplicationFlags.none", "u": 6, "d": "Check if none of the given flags are part of this value. ! note This is essentially the opposite of Flag.any . Returns builtins.bool builtins.True if none of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.applications.ApplicationFlags.split", "u": 6, "d": "Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted typing.Sequence of each membe", "f": 1}, {"r": "hikari.applications.ApplicationFlags.symmetric_difference", "u": 6, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.applications.ApplicationFlags.union", "u": 6, "d": "Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\" ~ operator.", "f": 1}, {"r": "hikari.applications.ApplicationFlags.isdisjoint", "u": 6, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.applications.ApplicationFlags.issubset", "u": 6, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.applications.ApplicationFlags.issuperset", "u": 6, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.applications.ApplicationFlags.symmetricdifference", "u": 6, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.applications.ApplicationFlags.VERIFIED_FOR_GUILD_PRESENCES", "u": 6, "d": "Denotes that a verified application can use the GUILD_PRESENCES intent."}, {"r": "hikari.applications.ApplicationFlags.GUILD_PRESENCES_INTENT", "u": 6, "d": "Denotes that the application has the GUILD_PRESENCES intent enabled in it's dashboard."}, {"r": "hikari.applications.ApplicationFlags.VERIFIED_FOR_GUILD_MEMBERS_INTENT", "u": 6, "d": "Denotes that a verified application can use the GUILD_MEMBERS intent."}, {"r": "hikari.applications.ApplicationFlags.GUILD_MEMBERS_INTENT", "u": 6, "d": "Denotes that the application has the GUILD_MEMBERS intent enabled in it's dashboard."}, {"r": "hikari.applications.ApplicationFlags.VERIFICATION_PENDING_GUILD_LIMIT", "u": 6, "d": "Denotes that the application's verification is pending."}, {"r": "hikari.applications.ApplicationFlags.EMBEDDED", "u": 6, "d": "Denotes that the application has functionality that's specially embedded in Discord's client."}, {"r": "hikari.applications.AuthorizationApplication", "u": 6, "d": "The application model found attached to AuthorizationInformation . Method generated by attrs for class AuthorizationApplication."}, {"r": "hikari.applications.AuthorizationApplication.is_bot_code_grant_required", "u": 6, "d": " builtins.True if this application's bot is requiring code grant for invites. Will be builtins.None if this application doesn't have a bot."}, {"r": "hikari.applications.AuthorizationApplication.is_bot_public", "u": 6, "d": " builtins.True if the bot associated with this application is public. Will be builtins.None if this application doesn't have an associated bot."}, {"r": "hikari.applications.AuthorizationApplication.privacy_policy_url", "u": 6, "d": "The URL of this application's privacy policy."}, {"r": "hikari.applications.AuthorizationApplication.public_key", "u": 6, "d": "The key used for verifying interaction and GameSDK payload signatures."}, {"r": "hikari.applications.AuthorizationApplication.terms_of_service_url", "u": 6, "d": "The URL of this application's terms of service."}, {"r": "hikari.applications.AuthorizationApplication.icon_url", "u": 6, "d": "Team icon URL, if there is one. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists."}, {"r": "hikari.applications.AuthorizationApplication.make_icon_url", "u": 6, "d": "Generate the icon URL for this application. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists. Raises builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.applications.AuthorizationApplication.description", "u": 6, "d": "The description of this application, if any."}, {"r": "hikari.applications.AuthorizationApplication.icon_hash", "u": 6, "d": "The CDN hash of this application's icon, if set."}, {"r": "hikari.applications.AuthorizationApplication.id", "u": 6, "d": "The ID of this entity."}, {"r": "hikari.applications.AuthorizationApplication.name", "u": 6, "d": "The name of this application."}, {"r": "hikari.applications.AuthorizationApplication.summary", "u": 6, "d": "This summary for this application's primary SKU if it's sold on Discord, if any."}, {"r": "hikari.applications.AuthorizationApplication.created_at", "u": 6, "d": "When the object was created."}, {"r": "hikari.applications.AuthorizationInformation", "u": 6, "d": "Model for the data returned by Get Current Authorization Information. Method generated by attrs for class AuthorizationInformation."}, {"r": "hikari.applications.AuthorizationInformation.application", "u": 6, "d": "The current application."}, {"r": "hikari.applications.AuthorizationInformation.expires_at", "u": 6, "d": "When the access token this data was retrieved with expires."}, {"r": "hikari.applications.AuthorizationInformation.scopes", "u": 6, "d": "A sequence of the scopes the current user has authorized the application for."}, {"r": "hikari.applications.AuthorizationInformation.user", "u": 6, "d": "The user who has authorized this token if they included the identify scope."}, {"r": "hikari.applications.ConnectionVisibility", "u": 6, "d": "Describes who can see a connection with a third party account."}, {"r": "hikari.applications.ConnectionVisibility.name", "u": 6, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.applications.ConnectionVisibility.value", "u": 6, "d": "Return the value of the enum member."}, {"r": "hikari.applications.ConnectionVisibility.NONE", "u": 6, "d": "Implies that only you can see the corresponding connection."}, {"r": "hikari.applications.ConnectionVisibility.EVERYONE", "u": 6, "d": "Everyone can see the connection."}, {"r": "hikari.applications.OAuth2AuthorizationToken", "u": 6, "d": "Model for the OAuth2 token data returned by the authorization grant flow. Method generated by attrs for class OAuth2AuthorizationToken."}, {"r": "hikari.applications.OAuth2AuthorizationToken.guild", "u": 6, "d": "Object of the guild the user was added to. This will only be present if this token was authorized with the bot scope, otherwise this will be builtins.None ."}, {"r": "hikari.applications.OAuth2AuthorizationToken.refresh_token", "u": 6, "d": "Refresh token used to obtain new access tokens with the same grant."}, {"r": "hikari.applications.OAuth2AuthorizationToken.webhook", "u": 6, "d": "Object of the webhook that was created. This will only be present if this token was authorized with the webhooks.incoming scope, otherwise this will be builtins.None ."}, {"r": "hikari.applications.OAuth2AuthorizationToken.access_token", "u": 6, "d": "Access token issued by the authorization server."}, {"r": "hikari.applications.OAuth2AuthorizationToken.expires_in", "u": 6, "d": "Lifetime of this access token."}, {"r": "hikari.applications.OAuth2AuthorizationToken.scopes", "u": 6, "d": "Scopes the access token has access to."}, {"r": "hikari.applications.OAuth2AuthorizationToken.token_type", "u": 6, "d": "Type of token issued by the authorization server."}, {"r": "hikari.applications.OAuth2ImplicitToken", "u": 6, "d": "Model for the OAuth2 token data returned by the implicit grant flow. Method generated by attrs for class OAuth2ImplicitToken."}, {"r": "hikari.applications.OAuth2ImplicitToken.state", "u": 6, "d": "State parameter that was present in the authorization request if provided."}, {"r": "hikari.applications.OAuth2ImplicitToken.access_token", "u": 6, "d": "Access token issued by the authorization server."}, {"r": "hikari.applications.OAuth2ImplicitToken.expires_in", "u": 6, "d": "Lifetime of this access token."}, {"r": "hikari.applications.OAuth2ImplicitToken.scopes", "u": 6, "d": "Scopes the access token has access to."}, {"r": "hikari.applications.OAuth2ImplicitToken.token_type", "u": 6, "d": "Type of token issued by the authorization server."}, {"r": "hikari.applications.OAuth2Scope", "u": 6, "d": "OAuth2 Scopes that Discord allows. These are categories of permissions for applications using the OAuth2 API\ndirectly. Most users will only ever need the BOT scope when developing\nbots."}, {"r": "hikari.applications.OAuth2Scope.name", "u": 6, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.applications.OAuth2Scope.value", "u": 6, "d": "Return the value of the enum member."}, {"r": "hikari.applications.OAuth2Scope.ACTIVITIES_READ", "u": 6, "d": "Enables fetching the \"Now Playing/Recently Played\" list. ! note You must be whitelisted to use this scope."}, {"r": "hikari.applications.OAuth2Scope.ACTIVITIES_WRITE", "u": 6, "d": "Enables updating a user's activity. ! note You must be whitelisted to use this scope. ! note This is not required to use the GameSDK activity manager."}, {"r": "hikari.applications.OAuth2Scope.APPLICATIONS_BUILDS_READ", "u": 6, "d": "Enables reading build data for a user's applications. ! note You must be whitelisted to use this scope."}, {"r": "hikari.applications.OAuth2Scope.APPLICATIONS_BUILDS_UPLOAD", "u": 6, "d": "Enables uploading/updating builds for a user's applications. ! note You must be whitelisted to use this scope."}, {"r": "hikari.applications.OAuth2Scope.APPLICATIONS_COMMANDS", "u": 6, "d": "Allows your application's (slash) commands to be used in a guild. This is used in Discord's special Bot Authorization Flow like OAuth2Scope.BOT in-order to join an application into a guild as an\napplication command providing integration."}, {"r": "hikari.applications.OAuth2Scope.APPLICATIONS_COMMANDS_UPDATE", "u": 6, "d": "Allows your application to update it's (slash) commands via a bearer token."}, {"r": "hikari.applications.OAuth2Scope.APPLICATIONS_ENTITLEMENTS", "u": 6, "d": "Enables reading entitlements for a user's applications."}, {"r": "hikari.applications.OAuth2Scope.APPLICATIONS_STORE_UPDATE", "u": 6, "d": "Enables reading/updating store data for the user's applications. This includes store listings, achievements, SKU's, etc. ! note The store API is deprecated and may be removed in the future."}, {"r": "hikari.applications.OAuth2Scope.BOT", "u": 6, "d": "Enables adding a bot application to a guild. ! note This requires you to have set up a bot account for your application."}, {"r": "hikari.applications.OAuth2Scope.CONNECTIONS", "u": 6, "d": "Enables viewing third-party linked accounts such as Twitch."}, {"r": "hikari.applications.OAuth2Scope.EMAIL", "u": 6, "d": "Enable the application to view the user's email and application info."}, {"r": "hikari.applications.OAuth2Scope.GROUP_DM_JOIN", "u": 6, "d": "Enables joining users into a group DM. ! warning This cannot add the bot to a group DM."}, {"r": "hikari.applications.OAuth2Scope.GUILDS", "u": 6, "d": "Enables viewing the guilds the user is in."}, {"r": "hikari.applications.OAuth2Scope.GUILDS_JOIN", "u": 6, "d": "Enables adding the user to a specific guild. ! note This requires you to have set up a bot account for your application."}, {"r": "hikari.applications.OAuth2Scope.IDENTIFY", "u": 6, "d": "Enables viewing info about itself. ! note This does not include email address info. Use the EMAIL scope instead to retrieve this information."}, {"r": "hikari.applications.OAuth2Scope.RELATIONSHIPS_READ", "u": 6, "d": "Enables viewing a user's friend list. ! note You must be whitelisted to use this scope."}, {"r": "hikari.applications.OAuth2Scope.RPC", "u": 6, "d": "Enables the RPC application to control the local user's Discord client. ! note You must be whitelisted to use this scope."}, {"r": "hikari.applications.OAuth2Scope.RPC_MESSAGES_READ", "u": 6, "d": "Enables the RPC application to read messages from all channels the user is in."}, {"r": "hikari.applications.OAuth2Scope.RPC_NOTIFICATIONS_READ", "u": 6, "d": "Enables the RPC application to read from all channels the user is in. ! note You must be whitelisted to use this scope."}, {"r": "hikari.applications.OAuth2Scope.WEBHOOK_INCOMING", "u": 6, "d": "Used to generate a webhook that is returned in the OAuth2 token response. This is used during authorization code grants."}, {"r": "hikari.applications.OwnConnection", "u": 6, "d": "Represents a user's connection with a third party account. Returned by the GET Current User Connections endpoint. Method generated by attrs for class OwnConnection."}, {"r": "hikari.applications.OwnConnection.id", "u": 6, "d": "The string ID of the third party connected account. ! warning Seeing as this is a third party ID, it will not be a snowflakes."}, {"r": "hikari.applications.OwnConnection.integrations", "u": 6, "d": "A sequence of the partial guild integration objects this connection has."}, {"r": "hikari.applications.OwnConnection.is_activity_visible", "u": 6, "d": " builtins.True if this connection's activities are shown in the user's presence."}, {"r": "hikari.applications.OwnConnection.is_friend_sync_enabled", "u": 6, "d": " builtins.True if friends should be added based on this connection."}, {"r": "hikari.applications.OwnConnection.is_revoked", "u": 6, "d": " builtins.True if the connection has been revoked."}, {"r": "hikari.applications.OwnConnection.is_verified", "u": 6, "d": " builtins.True if the connection has been verified."}, {"r": "hikari.applications.OwnConnection.name", "u": 6, "d": "The username of the connected account."}, {"r": "hikari.applications.OwnConnection.type", "u": 6, "d": "The type of service this connection is for."}, {"r": "hikari.applications.OwnConnection.visibility", "u": 6, "d": "The visibility of the connection."}, {"r": "hikari.applications.OwnGuild", "u": 6, "d": "Represents a user bound partial guild object. Method generated by attrs for class OwnGuild."}, {"r": "hikari.applications.OwnGuild.features", "u": 6, "d": "A list of the features in this guild."}, {"r": "hikari.applications.OwnGuild.is_owner", "u": 6, "d": " builtins.True when the current user owns this guild."}, {"r": "hikari.applications.OwnGuild.my_permissions", "u": 6, "d": "The guild-level permissions that apply to the current user or bot."}, {"r": "hikari.applications.OwnGuild.icon_url", "u": 6, "d": "Icon URL for the guild, if set; otherwise builtins.None ."}, {"r": "hikari.applications.OwnGuild.shard_id", "u": 6, "d": "Return the ID of the shard this guild is served by. This may return None if the application does not have a gateway\nconnection."}, {"r": "hikari.applications.OwnGuild.make_icon_url", "u": 6, "d": "Generate the guild's icon URL, if set. Parameters ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the resource, or builtins.None if no icon is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.applications.OwnGuild.ban", "u": 6, "d": "Ban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to ban from the guild Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.unban", "u": 6, "d": "Unban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to unban from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.kick", "u": 6, "d": "Kicks the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to kick from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.edit", "u": 6, "d": "Edits the guild. Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild.\nverification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level.\ndefault_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level.\nexplicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level.\nafk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires afk_timeout to be set to work.\nafk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout.\nicon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature.\nowner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner. ! warning You need to be the owner of the server to use this.\nsplash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the INVITE_SPLASH feature.\nbanner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the BANNER feature.\nsystem_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel.\nrules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel.\npublic_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel.\npreferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.RESTGuild The edited guild. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission or if you tried to pass ownership without being the server owner.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.fetch_emojis", "u": 6, "d": "Fetch the emojis of the guild. Returns typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.fetch_emoji", "u": 6, "d": "Fetch an emoji from the guild. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns hikari.emojis.KnownCustomEmoji The requested emoji. Raises hikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.fetch_stickers", "u": 6, "d": "Fetch the stickers of the guild. Returns typing.Sequence[hikari.stickers.GuildSticker] The requested stickers. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.fetch_sticker", "u": 6, "d": "Fetch a sticker from the guild. Parameters sticker : snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns hikari.stickers.GuildSticker The requested sticker. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.create_sticker", "u": 6, "d": "Create a sticker in a guild. Parameters name : builtins.str The name for the sticker.\ntag : builtins.str The tag for the sticker.\nimage : hikari.files.Resourceish The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie. ! note Lottie support is only available for verified and partnered servers. Other Parameters description: hikari.undefined.UndefinedOr[builtins.str] If provided, the description of the sticker.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The created sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.edit_sticker", "u": 6, "d": "Edit a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to edit. This can be a sticker object or the ID of an existing sticker. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the sticker.\ndescription : hikari.undefined.UndefinedOr[builtins.str] If provided, the new description for the sticker.\ntag : hikari.undefined.UndefinedOr[builtins.str] If provided, the new sticker tag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The edited sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.delete_sticker", "u": 6, "d": "Delete a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to delete. This can be a sticker object or the ID of an existing sticker. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.create_category", "u": 6, "d": "Create a category in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildCategory The created category. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.create_text_channel", "u": 6, "d": "Create a text channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildTextChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.create_news_channel", "u": 6, "d": "Create a news channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildNewsChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.create_voice_channel", "u": 6, "d": "Create a voice channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildVoiceChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the gui ld is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.create_stage_channel", "u": 6, "d": "Create a stage channel in the guild. Parameters name : builtins.str The channel's name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildStageChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.delete_channel", "u": 6, "d": "Delete a channel in the guild. ! note This method can also be used for deleting guild categories as well. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel or category to delete. This may be the object or the ID of an existing channel. Returns hikari.channels.GuildChannel Object of the channel or category that was deleted. Raises hikari.errors.UnauthorizedError, or close a DM. If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.applications.OwnGuild.fetch_self", "u": 6, "d": "Fetch the guild. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.fetch_roles", "u": 6, "d": "Fetch the roles of the guild. Returns typing.Sequence[hikari.guilds.Role] The requested roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.OwnGuild.app", "u": 6, "d": "The client application that models may use for procedures."}, {"r": "hikari.applications.OwnGuild.icon_hash", "u": 6, "d": "The hash for the guild icon, if there is one."}, {"r": "hikari.applications.OwnGuild.id", "u": 6, "d": "The ID of this entity."}, {"r": "hikari.applications.OwnGuild.name", "u": 6, "d": "The name of the guild."}, {"r": "hikari.applications.OwnGuild.created_at", "u": 6, "d": "When the object was created."}, {"r": "hikari.applications.PartialOAuth2Token", "u": 6, "d": "Model for partial OAuth2 token data returned by the API. This will generally only be returned when by the client credentials OAuth2\nflow. Method generated by attrs for class PartialOAuth2Token."}, {"r": "hikari.applications.PartialOAuth2Token.access_token", "u": 6, "d": "Access token issued by the authorization server."}, {"r": "hikari.applications.PartialOAuth2Token.expires_in", "u": 6, "d": "Lifetime of this access token."}, {"r": "hikari.applications.PartialOAuth2Token.scopes", "u": 6, "d": "Scopes the access token has access to."}, {"r": "hikari.applications.PartialOAuth2Token.token_type", "u": 6, "d": "Type of token issued by the authorization server."}, {"r": "hikari.applications.Team", "u": 6, "d": "Represents a development team, along with all its members. Method generated by attrs for class Team."}, {"r": "hikari.applications.Team.icon_url", "u": 6, "d": "Team icon URL. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists."}, {"r": "hikari.applications.Team.make_icon_url", "u": 6, "d": "Generate the icon URL for this team if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096 inclusive. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists. Raises builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.applications.Team.app", "u": 6, "d": "The client application that models may use for procedures."}, {"r": "hikari.applications.Team.icon_hash", "u": 6, "d": "The CDN hash of this team's icon. If no icon is provided, this will be builtins.None ."}, {"r": "hikari.applications.Team.id", "u": 6, "d": "The ID of this entity."}, {"r": "hikari.applications.Team.members", "u": 6, "d": "A mapping containing each member in this team. The mapping maps keys containing the member's ID to values containing the\nmember object."}, {"r": "hikari.applications.Team.name", "u": 6, "d": "The name of this team."}, {"r": "hikari.applications.Team.owner_id", "u": 6, "d": "The ID of this team's owner."}, {"r": "hikari.applications.Team.created_at", "u": 6, "d": "When the object was created."}, {"r": "hikari.applications.TeamMember", "u": 6, "d": "Represents a member of a Team. Method generated by attrs for class TeamMember."}, {"r": "hikari.applications.TeamMember.app", "u": 6, "d": "Return the app that is bound to the user object."}, {"r": "hikari.applications.TeamMember.avatar_hash", "u": 6, "d": "Avatar hash for the user, if they have one, otherwise builtins.None ."}, {"r": "hikari.applications.TeamMember.avatar_url", "u": 6, "d": "Avatar URL for the user, if they have one set. May be builtins.None if no custom avatar is set. In this case, you\nshould use default_avatar_url instead."}, {"r": "hikari.applications.TeamMember.default_avatar_url", "u": 6, "d": "Default avatar URL for this user."}, {"r": "hikari.applications.TeamMember.discriminator", "u": 6, "d": "Discriminator for the user."}, {"r": "hikari.applications.TeamMember.flags", "u": 6, "d": "Flag bits that are set for the user."}, {"r": "hikari.applications.TeamMember.id", "u": 6, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.applications.TeamMember.is_bot", "u": 6, "d": " builtins.True if this user is a bot account, builtins.False otherwise."}, {"r": "hikari.applications.TeamMember.is_system", "u": 6, "d": " builtins.True if this user is a system account, builtins.False otherwise."}, {"r": "hikari.applications.TeamMember.mention", "u": 6, "d": "Return a raw mention string for the given user. Example  \n>>> some_user.mention\n'<@123456789123456789>' Returns builtins.str The mention string to use."}, {"r": "hikari.applications.TeamMember.username", "u": 6, "d": "Username for the user."}, {"r": "hikari.applications.TeamMember.membership_state", "u": 6, "d": "The state of this user's membership."}, {"r": "hikari.applications.TeamMember.permissions", "u": 6, "d": "This member's permissions within a team. At the time of writing, this will always be a sequence of one builtins.str ,\nwhich will always be \" \" . This may change in the future, however."}, {"r": "hikari.applications.TeamMember.team_id", "u": 6, "d": "The ID of the team this member belongs to."}, {"r": "hikari.applications.TeamMember.user", "u": 6, "d": "The user representation of this team member."}, {"r": "hikari.applications.TeamMember.make_avatar_url", "u": 6, "d": "Generate the avatar URL for this user, if set. If no custom avatar is set, this returns builtins.None . You can then\nuse the default_avatar_url attribute instead to fetch the displayed\nURL. Parameters ext : typing.Optional[builtins.str] The ext to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). Will be ignored for default avatars which can only be png . If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns typing.Optional[hikari.files.URL] The URL to the avatar, or builtins.None if not present. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.applications.TeamMember.fetch_dm_channel", "u": 6, "d": "Fetch the DM channel for this user. Returns hikari.channels.DMChannel The requested channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.TeamMember.fetch_self", "u": 6, "d": "Get this user's up-to-date object by performing an API call. Returns hikari.users.User The requested user object. Raises hikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.TeamMember.send", "u": 6, "d": "Send a message to this user in DM's. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nnonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled.\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.applications.TeamMember.created_at", "u": 6, "d": "When the object was created."}, {"r": "hikari.applications.TeamMembershipState", "u": 6, "d": "Represents the state of a user's team membership."}, {"r": "hikari.applications.TeamMembershipState.name", "u": 6, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.applications.TeamMembershipState.value", "u": 6, "d": "Return the value of the enum member."}, {"r": "hikari.applications.TeamMembershipState.INVITED", "u": 6, "d": "Denotes the user has been invited to the team but has yet to accept."}, {"r": "hikari.applications.TeamMembershipState.ACCEPTED", "u": 6, "d": "Denotes the user has accepted the invite and is now a member."}, {"r": "hikari.applications.TokenType", "u": 6, "d": "Token types used within Hikari clients."}, {"r": "hikari.applications.TokenType.name", "u": 6, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.applications.TokenType.value", "u": 6, "d": "Return the value of the enum member."}, {"r": "hikari.applications.TokenType.BOT", "u": 6, "d": "Bot token type."}, {"r": "hikari.applications.TokenType.BASIC", "u": 6, "d": "OAuth2 basic token type."}, {"r": "hikari.applications.TokenType.BEARER", "u": 6, "d": "OAuth2 bearer token type."}, {"r": "hikari.applications.get_token_id", "u": 6, "d": "Try to get the bot ID stored in a token. Returns hikari.snowflakes.Snowflake The ID that was extracted from the token. Raises builtins.ValueError If the passed token has an unexpected format.", "f": 1}, {"r": "hikari.messages", "u": 7, "d": "Application and entities that are used to describe messages on Discord."}, {"r": "hikari.messages.MessageType", "u": 7, "d": "The type of a message."}, {"r": "hikari.messages.MessageType.name", "u": 7, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.messages.MessageType.value", "u": 7, "d": "Return the value of the enum member."}, {"r": "hikari.messages.MessageType.DEFAULT", "u": 7, "d": "A normal message."}, {"r": "hikari.messages.MessageType.RECIPIENT_ADD", "u": 7, "d": "A message to denote a new recipient in a group."}, {"r": "hikari.messages.MessageType.RECIPIENT_REMOVE", "u": 7, "d": "A message to denote that a recipient left the group."}, {"r": "hikari.messages.MessageType.CALL", "u": 7, "d": "A message to denote a VoIP call."}, {"r": "hikari.messages.MessageType.CHANNEL_NAME_CHANGE", "u": 7, "d": "A message to denote that the name of a channel changed."}, {"r": "hikari.messages.MessageType.CHANNEL_ICON_CHANGE", "u": 7, "d": "A message to denote that the icon of a channel changed."}, {"r": "hikari.messages.MessageType.CHANNEL_PINNED_MESSAGE", "u": 7, "d": "A message to denote that a message was pinned."}, {"r": "hikari.messages.MessageType.GUILD_MEMBER_JOIN", "u": 7, "d": "A message to denote that a member joined the guild."}, {"r": "hikari.messages.MessageType.USER_PREMIUM_GUILD_SUBSCRIPTION", "u": 7, "d": "A message to denote a Nitro subscription."}, {"r": "hikari.messages.MessageType.USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1", "u": 7, "d": "A message to denote a tier 1 Nitro subscription."}, {"r": "hikari.messages.MessageType.USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2", "u": 7, "d": "A message to denote a tier 2 Nitro subscription."}, {"r": "hikari.messages.MessageType.USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3", "u": 7, "d": "A message to denote a tier 3 Nitro subscription."}, {"r": "hikari.messages.MessageType.CHANNEL_FOLLOW_ADD", "u": 7, "d": "Channel follow add."}, {"r": "hikari.messages.MessageType.GUILD_DISCOVERY_DISQUALIFIED", "u": 7, "d": "A message to indicate that a guild has been disqualified from discovery."}, {"r": "hikari.messages.MessageType.GUILD_DISCOVERY_REQUALIFIED", "u": 7, "d": "A message to indicate that a guild has re-qualified for discovery."}, {"r": "hikari.messages.MessageType.GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING", "u": 7, "d": "A message to indicate that the grace period before removal from discovery has started."}, {"r": "hikari.messages.MessageType.GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING", "u": 7, "d": "A message to indicate the final warning before removal from discovery."}, {"r": "hikari.messages.MessageType.REPLY", "u": 7, "d": "A message that replies to another message."}, {"r": "hikari.messages.MessageType.CHAT_INPUT", "u": 7, "d": "A message sent to indicate a chat input application command has been executed."}, {"r": "hikari.messages.MessageType.GUILD_INVITE_REMINDER", "u": 7, "d": "A message sent to remind to invite people to the guild."}, {"r": "hikari.messages.MessageType.CONTEXT_MENU_COMMAND", "u": 7, "d": "A message sent to indicate a context menu has been executed."}, {"r": "hikari.messages.MessageFlag", "u": 7, "d": "Additional flags for message options."}, {"r": "hikari.messages.MessageFlag.name", "u": 7, "d": "Return the name of the flag combination as a builtins.str ."}, {"r": "hikari.messages.MessageFlag.value", "u": 7, "d": "Return the builtins.int value of the flag."}, {"r": "hikari.messages.MessageFlag.all", "u": 7, "d": "Check if all of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.messages.MessageFlag.any", "u": 7, "d": "Check if any of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.messages.MessageFlag.difference", "u": 7, "d": "Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction - operator.", "f": 1}, {"r": "hikari.messages.MessageFlag.intersection", "u": 7, "d": "Return a combination of flags that are set for both given values. Equivalent to using the \"AND\" & operator.", "f": 1}, {"r": "hikari.messages.MessageFlag.invert", "u": 7, "d": "Return a set of all flags not in the current set.", "f": 1}, {"r": "hikari.messages.MessageFlag.is_disjoint", "u": 7, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.messages.MessageFlag.is_subset", "u": 7, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.messages.MessageFlag.is_superset", "u": 7, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.messages.MessageFlag.none", "u": 7, "d": "Check if none of the given flags are part of this value. ! note This is essentially the opposite of Flag.any . Returns builtins.bool builtins.True if none of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.messages.MessageFlag.split", "u": 7, "d": "Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted typing.Sequence of each membe", "f": 1}, {"r": "hikari.messages.MessageFlag.symmetric_difference", "u": 7, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.messages.MessageFlag.union", "u": 7, "d": "Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\" ~ operator.", "f": 1}, {"r": "hikari.messages.MessageFlag.isdisjoint", "u": 7, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.messages.MessageFlag.issubset", "u": 7, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.messages.MessageFlag.issuperset", "u": 7, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.messages.MessageFlag.symmetricdifference", "u": 7, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.messages.MessageFlag.NONE", "u": 7, "d": "None"}, {"r": "hikari.messages.MessageFlag.CROSSPOSTED", "u": 7, "d": "This message has been published to subscribed channels via channel following."}, {"r": "hikari.messages.MessageFlag.IS_CROSSPOST", "u": 7, "d": "This message originated from a message in another channel via channel following."}, {"r": "hikari.messages.MessageFlag.SUPPRESS_EMBEDS", "u": 7, "d": "Any embeds on this message should be omitted when serializing the message."}, {"r": "hikari.messages.MessageFlag.SOURCE_MESSAGE_DELETED", "u": 7, "d": "The message this crosspost originated from was deleted via channel following."}, {"r": "hikari.messages.MessageFlag.URGENT", "u": 7, "d": "This message came from the urgent message system."}, {"r": "hikari.messages.MessageFlag.EPHEMERAL", "u": 7, "d": "This message is only visible to the user that invoked the interaction."}, {"r": "hikari.messages.MessageFlag.LOADING", "u": 7, "d": "This message symbolizes that the interaction is 'thinking'."}, {"r": "hikari.messages.MessageActivityType", "u": 7, "d": "The type of a rich presence message activity."}, {"r": "hikari.messages.MessageActivityType.name", "u": 7, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.messages.MessageActivityType.value", "u": 7, "d": "Return the value of the enum member."}, {"r": "hikari.messages.MessageActivityType.NONE", "u": 7, "d": "No activity."}, {"r": "hikari.messages.MessageActivityType.JOIN", "u": 7, "d": "Join an activity."}, {"r": "hikari.messages.MessageActivityType.SPECTATE", "u": 7, "d": "Spectating something."}, {"r": "hikari.messages.MessageActivityType.LISTEN", "u": 7, "d": "Listening to something."}, {"r": "hikari.messages.MessageActivityType.JOIN_REQUEST", "u": 7, "d": "Request to join an activity."}, {"r": "hikari.messages.Attachment", "u": 7, "d": "Represents a file attached to a message. You can use this object in the same way as a hikari.files.WebResource ,\nby passing it as an attached file when creating a message, etc. Method generated by attrs for class Attachment."}, {"r": "hikari.messages.Attachment.filename", "u": 7, "d": "The name of the file."}, {"r": "hikari.messages.Attachment.height", "u": 7, "d": "The height of the image (if the file is an image)."}, {"r": "hikari.messages.Attachment.id", "u": 7, "d": "The ID of this entity."}, {"r": "hikari.messages.Attachment.media_type", "u": 7, "d": "The media type of the file."}, {"r": "hikari.messages.Attachment.proxy_url", "u": 7, "d": "The proxied URL of file."}, {"r": "hikari.messages.Attachment.size", "u": 7, "d": "The size of the file in bytes."}, {"r": "hikari.messages.Attachment.url", "u": 7, "d": "The source URL of file."}, {"r": "hikari.messages.Attachment.width", "u": 7, "d": "The width of the image (if the file is an image)."}, {"r": "hikari.messages.Attachment.created_at", "u": 7, "d": "When the object was created."}, {"r": "hikari.messages.Attachment.stream", "u": 7, "d": "Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource,\nor just to view any metadata that may be provided. Parameters executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples Downloading an entire resource at once into memory: py\nasync with obj.stream() as stream: data = await stream.read() Checking the metadata: py\nasync with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None: .\nelif mimetype not in whitelisted_mimetypes: .\nelse: . Fetching the data-uri of a resource: py\nasync with obj.stream() as stream: data_uri = await stream.data_uri() Returns AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises hikari.errors.BadRequestError If a 400 is returned.\nhikari.errors.UnauthorizedError If a 401 is returned.\nhikari.errors.ForbiddenError If a 403 is returned.\nhikari.errors.NotFoundError If a 404 is returned.\nhikari.errors.ClientHTTPResponseError If any other 4xx is returned.\nhikari.errors.InternalServerError If any other 5xx is returned.\nhikari.errors.HTTPResponseError If any other unexpected response code is returned.", "f": 1}, {"r": "hikari.messages.Attachment.extension", "u": 7, "d": "File extension, if there is one."}, {"r": "hikari.messages.Attachment.read", "u": 7, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.messages.Reaction", "u": 7, "d": "Represents a reaction in a message. Method generated by attrs for class Reaction."}, {"r": "hikari.messages.Reaction.count", "u": 7, "d": "The number of times the emoji has been used to react."}, {"r": "hikari.messages.Reaction.emoji", "u": 7, "d": "The emoji used to react."}, {"r": "hikari.messages.Reaction.is_me", "u": 7, "d": "Whether the current user reacted using this emoji."}, {"r": "hikari.messages.MessageActivity", "u": 7, "d": "Represents the activity of a rich presence-enabled message. Method generated by attrs for class MessageActivity."}, {"r": "hikari.messages.MessageActivity.party_id", "u": 7, "d": "The party ID of the message activity."}, {"r": "hikari.messages.MessageActivity.type", "u": 7, "d": "The type of message activity."}, {"r": "hikari.messages.Mentions", "u": 7, "d": "Description of mentions that exist in the message. Method generated by attrs for class Mentions."}, {"r": "hikari.messages.Mentions.channels_ids", "u": 7, "d": ""}, {"r": "hikari.messages.Mentions.user_ids", "u": 7, "d": ""}, {"r": "hikari.messages.Mentions.get_members", "u": 7, "d": "Discover any cached members notified by this message. If this message was sent in a DM, this will always be empty. ! warning This will only return valid results on gateway events. For REST endpoints, this will potentially be empty. This is a limitation of Discord's API, as they do not consistently notify of the ID of the guild a message was sent in. ! note If you are using a stateless application such as a stateless bot or a REST-only client, this will always be empty. Furthermore, if you are running a stateful bot and have the GUILD_MEMBERS intent disabled, this will also be empty. Members that are not cached will not appear in this mapping. This means that there is a very small chance that some users provided in notified_users may not be present here.", "f": 1}, {"r": "hikari.messages.Mentions.get_roles", "u": 7, "d": "Attempt to look up the roles that are notified by this message. If this message was sent in a DM, this will always be empty. ! warning This will only return valid results on gateway events. For REST endpoints, this will potentially be empty. This is a limitation of Discord's API, as they do not consistently notify of the ID of the guild a message was sent in. ! note If you are using a stateless application such as a stateless bot or a REST-only client, this will always be empty. Furthermore, if you are running a stateful bot and have the GUILD intent disabled, this will also be empty. Roles that are not cached will not appear in this mapping. This means that there is a very small chance that some role IDs provided in notifies_role_ids may not be present here. This is a limitation of Discord, again.", "f": 1}, {"r": "hikari.messages.Mentions.channels", "u": 7, "d": "Channel mentions that reference channels in the target crosspost's guild. If the message is not crossposted, this will always be empty."}, {"r": "hikari.messages.Mentions.everyone", "u": 7, "d": "Whether the message notifies using @everyone or @here ."}, {"r": "hikari.messages.Mentions.role_ids", "u": 7, "d": "IDs of roles that were notified by their mention in the message."}, {"r": "hikari.messages.Mentions.users", "u": 7, "d": "Users who were notified by their mention in the message."}, {"r": "hikari.messages.MessageInteraction", "u": 7, "d": "Representation of information provided for a message from an interaction. Method generated by attrs for class MessageInteraction."}, {"r": "hikari.messages.MessageInteraction.id", "u": 7, "d": "ID of the interaction this message was sent by."}, {"r": "hikari.messages.MessageInteraction.name", "u": 7, "d": "Name of the application command the interaction is tied to."}, {"r": "hikari.messages.MessageInteraction.type", "u": 7, "d": "The type of interaction this message was created by."}, {"r": "hikari.messages.MessageInteraction.user", "u": 7, "d": "Object of the user who invoked this interaction."}, {"r": "hikari.messages.MessageReference", "u": 7, "d": "Represents information about a referenced message. This will be included in crossposted messages, channel follow add\nmessage, pin add messages and replies. Method generated by attrs for class MessageReference."}, {"r": "hikari.messages.MessageReference.app", "u": 7, "d": "The client application that models may use for procedures."}, {"r": "hikari.messages.MessageReference.channel_id", "u": 7, "d": "The ID of the channel that the original message originated from."}, {"r": "hikari.messages.MessageReference.guild_id", "u": 7, "d": "The ID of the guild that the message originated from. This will be builtins.None when the original message is not from\na guild."}, {"r": "hikari.messages.MessageReference.id", "u": 7, "d": "The ID of the original message. This will be builtins.None for channel follow add messages. This may\npoint to a deleted message."}, {"r": "hikari.messages.PartialMessage", "u": 7, "d": "A message representation containing partially populated information. This contains arbitrary fields that may be updated in a MessageUpdateEvent , but for all other purposes should be treated as\nbeing optionally specified. ! warning All fields on this model except channel and id may be set to hikari.undefined.UNDEFINED (a singleton) if we have not received information about their state from Discord alongside field nullability. Method generated by attrs for class PartialMessage."}, {"r": "hikari.messages.PartialMessage.make_link", "u": 7, "d": "Generate a jump link to this message. Other Parameters guild : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild this message is in or builtins.None to generate a DM message link. ! note This parameter is necessary since PartialMessage.guild_id isn't returned by the REST API regardless of whether the message is in a DM or not. Returns builtins.str The jump link to the message.", "f": 1}, {"r": "hikari.messages.PartialMessage.fetch_channel", "u": 7, "d": "Fetch the channel this message was created in. Returns hikari.channels.PartialChannel The object of the channel this message belongs to. Raises hikari.errors.BadRequestError If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.ForbiddenError If you don't have access to the channel this message belongs to.\nhikari.errors.NotFoundError If the channel this message was created in does not exist.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.messages.PartialMessage.edit", "u": 7, "d": "Edit an existing message in a given channel. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message content to update with. If hikari.undefined.UNDEFINED , then the content will not be changed. If builtins.None , then the content will be removed. Any other value will be cast to a builtins.str before sending. If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] Sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if this is not a reply message.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Sanitation for user mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , all valid user mentions will behave as mentions. If builtins.False , all valid user mentions will not behave as mentions. You may alternatively pass a collection of hikari.snowflakes.Snowflake user IDs, or hikari.users.PartialUser -derived objects.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool Sanitation for role mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , all valid role mentions will behave as mentions. If builtins.False , all valid role mentions will not behave as mentions. You may alternatively pass a collection of hikari.snowflakes.Snowflake role IDs, or hikari.guilds.PartialRole -derived objects.\nflags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag] Optional flags to set on the message. If hikari.undefined.UNDEFINED , then nothing is changed. Note that some flags may not be able to be set. Currently the only flags that can be set are NONE and SUPPRESS_EMBEDS . If you have MANAGE_MESSAGES permissions, you can use this call to suppress embeds on another user's message. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all four of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all four of them each time. ! warning If the message was not sent by your user, the only parameter you may provide to this call is the flags parameter. Anything else will result in a hikari.errors.ForbiddenError being raised. Returns hikari.messages.Message The edited message. Raises hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to send messages in the given channel; if you try to change the contents of another user's message; or if you try to edit the flags on another user's message without the permissions to manage messages.\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.messages.PartialMessage.respond", "u": 7, "d": "Create a message in the channel this message belongs to. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech).\nnonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending.\nreply : typing.Union[hikari.undefined.UndefinedType, hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], builtins.bool] If provided and builtins.True , reply to this message. If provided and not builtins.bool , the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to send messages in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.\nbuiltins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.messages.PartialMessage.delete", "u": 7, "d": "Delete this message. Raises hikari.errors.NotFoundError If the channel this message was created in is not found, or if the message has already been deleted.\nhikari.errors.ForbiddenError If you lack the permissions to delete the message.", "f": 1}, {"r": "hikari.messages.PartialMessage.add_reaction", "u": 7, "d": "Add a reaction to this message. Parameters emoji: typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to react with. Note that if the emoji is an hikari.emojis.CustomEmoji and is not from a guild the bot user is in, then this will fail. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to react with. This should only be provided when a custom emoji's name is passed for emoji . Note that this will fail if the emoji is from a guild the bot isn't in. Examples   Using a unicode emoji.\nawait message.add_reaction(\"\ud83d\udc4c\") Using a unicode emoji name.\nawait message.add_reaction(\"\\N{OK HAND SIGN}\") Using the name and id.\nawait message.add_reaction(\"rooAYAYA\", 705837374319493284) Using an Emoji-derived object.\nawait message.add_reaction(some_emoji_object) Raises hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly.\nhikari.errors.ForbiddenError If this is the first reaction using this specific emoji on this message and you lack the ADD_REACTIONS permission. If you lack READ_MESSAGE_HISTORY , this may also raise this error.\nhikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found. This will also occur if you try to add an emoji from a guild you are not part of if no one else has previously reacted with the same emoji.", "f": 1}, {"r": "hikari.messages.PartialMessage.remove_reaction", "u": 7, "d": "Remove a reaction from this message. Parameters emoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to remove the reaction for. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to remove the reaction for. This should only be provided when a custom emoji's name is passed for emoji .\nuser : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser The user of the reaction to remove. If unspecified, then the bot's reaction is removed instead. Examples  Using a unicode emoji and removing the bot's reaction from this reaction. await message.remove_reaction(\"\\N{OK HAND SIGN}\") Using a unicode emoji and removing a specific user from this reaction. await message.remove_reaction(\"\\N{OK HAND SIGN}\", some_user) Using the name and id. await message.add_reaction(\"rooAYAYA\", 705837374319493284) Using an Emoji object and removing a specific user from this reaction. await message.remove_reaction(some_emoji_object, some_user) Raises hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.ForbiddenError If this is the first reaction using this specific emoji on this message and you lack the ADD_REACTIONS permission. If you lack READ_MESSAGE_HISTORY , this may also raise this error. If you remove the reaction of another user without MANAGE_MESSAGES , this will be raised.\nhikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found.", "f": 1}, {"r": "hikari.messages.PartialMessage.remove_all_reactions", "u": 7, "d": "Remove all users' reactions for a specific emoji from the message. Other Parameters emoji : hikari.undefined.UndefinedOr[typing.Union[builtins.str, hikari.emojis.Emoji Object or name of the emoji to get the reactions for. If not specified then all reactions are removed.\nemoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to react with. This should only be provided when a custom emoji's name is passed for emoji . Example  Using a unicode emoji and removing all \ud83d\udc4c reacts from the message. reaction. await message.remove_all_reactions(\"\\N{OK HAND SIGN}\") Using the name and id. await message.add_reaction(\"rooAYAYA\", 705837374319493284) Removing all reactions entirely. await message.remove_all_reactions() Raises hikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission, or the permission to view the channel\nhikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found.\nhikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.", "f": 1}, {"r": "hikari.messages.PartialMessage.activity", "u": 7, "d": "The message activity. ! note This will only be provided for messages with rich-presence related chat embeds."}, {"r": "hikari.messages.PartialMessage.app", "u": 7, "d": "The client application that models may use for procedures."}, {"r": "hikari.messages.PartialMessage.application", "u": 7, "d": "The message application. ! note This will only be provided for messages with rich-presence related chat embeds."}, {"r": "hikari.messages.PartialMessage.application_id", "u": 7, "d": "ID of the application this message was sent by. ! note This will only be provided for interaction messages."}, {"r": "hikari.messages.PartialMessage.attachments", "u": 7, "d": "The message attachments."}, {"r": "hikari.messages.PartialMessage.author", "u": 7, "d": "The author of this message. This will also be hikari.undefined.UNDEFINED in some cases such as when Discord\nupdates a message with an embed URL preview or in messages fetched from the REST API."}, {"r": "hikari.messages.PartialMessage.channel_id", "u": 7, "d": "The ID of the channel that the message was sent in."}, {"r": "hikari.messages.PartialMessage.components", "u": 7, "d": "Sequence of the components attached to this message."}, {"r": "hikari.messages.PartialMessage.content", "u": 7, "d": "The content of the message."}, {"r": "hikari.messages.PartialMessage.edited_timestamp", "u": 7, "d": "The timestamp that the message was last edited at. Will be builtins.None if the message wasn't ever edited, or undefined if the info is not available."}, {"r": "hikari.messages.PartialMessage.embeds", "u": 7, "d": "The message embeds."}, {"r": "hikari.messages.PartialMessage.flags", "u": 7, "d": "The message flags."}, {"r": "hikari.messages.PartialMessage.guild_id", "u": 7, "d": "The ID of the guild that the message was sent in or builtins.None for messages out of guilds. ! warning This will also be builtins.None for messages received from the REST API. This is a Discord limitation as stated here https: github.com/discord/discord-api-docs/issues/912"}, {"r": "hikari.messages.PartialMessage.id", "u": 7, "d": "The ID of this entity."}, {"r": "hikari.messages.PartialMessage.interaction", "u": 7, "d": "Information about the interaction this message was created by."}, {"r": "hikari.messages.PartialMessage.is_pinned", "u": 7, "d": "Whether the message is pinned."}, {"r": "hikari.messages.PartialMessage.is_tts", "u": 7, "d": "Whether the message is a TTS message."}, {"r": "hikari.messages.PartialMessage.member", "u": 7, "d": "The member for the author who created the message. If the message is not in a guild, this will be builtins.None . This will also be hikari.undefined.UNDEFINED in some cases such as when Discord\nupdates a message with an embed URL preview. ! warning This will also be builtins.None for messages received from the REST API. This is a Discord limitation as stated here https: github.com/discord/discord-api-docs/issues/912"}, {"r": "hikari.messages.PartialMessage.mentions", "u": 7, "d": "Description of who is mentioned in a message. ! warning If the contents have not mutated and this is a message update event, some fields that are not affected may be empty instead. This is a Discord limitation."}, {"r": "hikari.messages.PartialMessage.message_reference", "u": 7, "d": "The message reference data."}, {"r": "hikari.messages.PartialMessage.nonce", "u": 7, "d": "The message nonce. This is a string used for validating a message was sent."}, {"r": "hikari.messages.PartialMessage.reactions", "u": 7, "d": "The message reactions."}, {"r": "hikari.messages.PartialMessage.referenced_message", "u": 7, "d": "The message that was replied to. If type is MessageType.REPLY and hikari.undefined.UNDEFINED , Discord's\nbackend didn't attempt to fetch the message, so the status is unknown. If type is MessageType.REPLY and builtins.None , the message was deleted."}, {"r": "hikari.messages.PartialMessage.stickers", "u": 7, "d": "The stickers sent with this message."}, {"r": "hikari.messages.PartialMessage.timestamp", "u": 7, "d": "The timestamp that the message was sent at."}, {"r": "hikari.messages.PartialMessage.type", "u": 7, "d": "The message type."}, {"r": "hikari.messages.PartialMessage.webhook_id", "u": 7, "d": "If the message was generated by a webhook, the webhook's ID."}, {"r": "hikari.messages.PartialMessage.created_at", "u": 7, "d": "When the object was created."}, {"r": "hikari.messages.Message", "u": 7, "d": "Represents a message with all known details. Method generated by attrs for class Message."}, {"r": "hikari.messages.Message.author", "u": 7, "d": "The author of this message."}, {"r": "hikari.messages.Message.member", "u": 7, "d": "The member properties for the message's author."}, {"r": "hikari.messages.Message.content", "u": 7, "d": "The content of the message."}, {"r": "hikari.messages.Message.timestamp", "u": 7, "d": "The timestamp that the message was sent at."}, {"r": "hikari.messages.Message.edited_timestamp", "u": 7, "d": "The timestamp that the message was last edited at. Will be builtins.None if it wasn't ever edited."}, {"r": "hikari.messages.Message.is_tts", "u": 7, "d": "Whether the message is a TTS message."}, {"r": "hikari.messages.Message.mentions", "u": 7, "d": "Who is mentioned in a message."}, {"r": "hikari.messages.Message.attachments", "u": 7, "d": "The message attachments."}, {"r": "hikari.messages.Message.embeds", "u": 7, "d": "The message embeds."}, {"r": "hikari.messages.Message.reactions", "u": 7, "d": "The message reactions."}, {"r": "hikari.messages.Message.is_pinned", "u": 7, "d": "Whether the message is pinned."}, {"r": "hikari.messages.Message.webhook_id", "u": 7, "d": "If the message was generated by a webhook, the webhook's id."}, {"r": "hikari.messages.Message.type", "u": 7, "d": "The message type."}, {"r": "hikari.messages.Message.activity", "u": 7, "d": "The message activity. ! note This will only be provided for messages with rich-presence related chat embeds."}, {"r": "hikari.messages.Message.application", "u": 7, "d": "The message application. ! note This will only be provided for messages with rich-presence related chat embeds."}, {"r": "hikari.messages.Message.message_reference", "u": 7, "d": "The message reference data."}, {"r": "hikari.messages.Message.flags", "u": 7, "d": "The message flags."}, {"r": "hikari.messages.Message.stickers", "u": 7, "d": "The stickers sent with this message."}, {"r": "hikari.messages.Message.nonce", "u": 7, "d": "The message nonce. This is a string used for validating a message was sent."}, {"r": "hikari.messages.Message.referenced_message", "u": 7, "d": "The message that was replied to."}, {"r": "hikari.messages.Message.interaction", "u": 7, "d": "Information about the interaction this message was created by."}, {"r": "hikari.messages.Message.application_id", "u": 7, "d": "ID of the application this message was sent by. ! note This will only be provided for interaction messages."}, {"r": "hikari.messages.Message.components", "u": 7, "d": "Sequence of the components attached to this message."}, {"r": "hikari.messages.Message.make_link", "u": 7, "d": "Generate a jump link to this message. Other Parameters guild : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild this message is in or builtins.None to generate a DM message link. ! note This parameter is necessary since PartialMessage.guild_id isn't returned by the REST API regardless of whether the message is in a DM or not. Returns builtins.str The jump link to the message.", "f": 1}, {"r": "hikari.messages.Message.fetch_channel", "u": 7, "d": "Fetch the channel this message was created in. Returns hikari.channels.PartialChannel The object of the channel this message belongs to. Raises hikari.errors.BadRequestError If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.ForbiddenError If you don't have access to the channel this message belongs to.\nhikari.errors.NotFoundError If the channel this message was created in does not exist.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.messages.Message.edit", "u": 7, "d": "Edit an existing message in a given channel. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message content to update with. If hikari.undefined.UNDEFINED , then the content will not be changed. If builtins.None , then the content will be removed. Any other value will be cast to a builtins.str before sending. If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] Sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if this is not a reply message.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Sanitation for user mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , all valid user mentions will behave as mentions. If builtins.False , all valid user mentions will not behave as mentions. You may alternatively pass a collection of hikari.snowflakes.Snowflake user IDs, or hikari.users.PartialUser -derived objects.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool Sanitation for role mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , all valid role mentions will behave as mentions. If builtins.False , all valid role mentions will not behave as mentions. You may alternatively pass a collection of hikari.snowflakes.Snowflake role IDs, or hikari.guilds.PartialRole -derived objects.\nflags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag] Optional flags to set on the message. If hikari.undefined.UNDEFINED , then nothing is changed. Note that some flags may not be able to be set. Currently the only flags that can be set are NONE and SUPPRESS_EMBEDS . If you have MANAGE_MESSAGES permissions, you can use this call to suppress embeds on another user's message. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all four of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all four of them each time. ! warning If the message was not sent by your user, the only parameter you may provide to this call is the flags parameter. Anything else will result in a hikari.errors.ForbiddenError being raised. Returns hikari.messages.Message The edited message. Raises hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to send messages in the given channel; if you try to change the contents of another user's message; or if you try to edit the flags on another user's message without the permissions to manage messages.\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.messages.Message.respond", "u": 7, "d": "Create a message in the channel this message belongs to. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech).\nnonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending.\nreply : typing.Union[hikari.undefined.UndefinedType, hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], builtins.bool] If provided and builtins.True , reply to this message. If provided and not builtins.bool , the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to send messages in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.\nbuiltins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.messages.Message.delete", "u": 7, "d": "Delete this message. Raises hikari.errors.NotFoundError If the channel this message was created in is not found, or if the message has already been deleted.\nhikari.errors.ForbiddenError If you lack the permissions to delete the message.", "f": 1}, {"r": "hikari.messages.Message.add_reaction", "u": 7, "d": "Add a reaction to this message. Parameters emoji: typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to react with. Note that if the emoji is an hikari.emojis.CustomEmoji and is not from a guild the bot user is in, then this will fail. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to react with. This should only be provided when a custom emoji's name is passed for emoji . Note that this will fail if the emoji is from a guild the bot isn't in. Examples   Using a unicode emoji.\nawait message.add_reaction(\"\ud83d\udc4c\") Using a unicode emoji name.\nawait message.add_reaction(\"\\N{OK HAND SIGN}\") Using the name and id.\nawait message.add_reaction(\"rooAYAYA\", 705837374319493284) Using an Emoji-derived object.\nawait message.add_reaction(some_emoji_object) Raises hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly.\nhikari.errors.ForbiddenError If this is the first reaction using this specific emoji on this message and you lack the ADD_REACTIONS permission. If you lack READ_MESSAGE_HISTORY , this may also raise this error.\nhikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found. This will also occur if you try to add an emoji from a guild you are not part of if no one else has previously reacted with the same emoji.", "f": 1}, {"r": "hikari.messages.Message.remove_reaction", "u": 7, "d": "Remove a reaction from this message. Parameters emoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to remove the reaction for. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to remove the reaction for. This should only be provided when a custom emoji's name is passed for emoji .\nuser : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser The user of the reaction to remove. If unspecified, then the bot's reaction is removed instead. Examples  Using a unicode emoji and removing the bot's reaction from this reaction. await message.remove_reaction(\"\\N{OK HAND SIGN}\") Using a unicode emoji and removing a specific user from this reaction. await message.remove_reaction(\"\\N{OK HAND SIGN}\", some_user) Using the name and id. await message.add_reaction(\"rooAYAYA\", 705837374319493284) Using an Emoji object and removing a specific user from this reaction. await message.remove_reaction(some_emoji_object, some_user) Raises hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.ForbiddenError If this is the first reaction using this specific emoji on this message and you lack the ADD_REACTIONS permission. If you lack READ_MESSAGE_HISTORY , this may also raise this error. If you remove the reaction of another user without MANAGE_MESSAGES , this will be raised.\nhikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found.", "f": 1}, {"r": "hikari.messages.Message.remove_all_reactions", "u": 7, "d": "Remove all users' reactions for a specific emoji from the message. Other Parameters emoji : hikari.undefined.UndefinedOr[typing.Union[builtins.str, hikari.emojis.Emoji Object or name of the emoji to get the reactions for. If not specified then all reactions are removed.\nemoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to react with. This should only be provided when a custom emoji's name is passed for emoji . Example  Using a unicode emoji and removing all \ud83d\udc4c reacts from the message. reaction. await message.remove_all_reactions(\"\\N{OK HAND SIGN}\") Using the name and id. await message.add_reaction(\"rooAYAYA\", 705837374319493284) Removing all reactions entirely. await message.remove_all_reactions() Raises hikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission, or the permission to view the channel\nhikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found.\nhikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.", "f": 1}, {"r": "hikari.messages.Message.app", "u": 7, "d": "The client application that models may use for procedures."}, {"r": "hikari.messages.Message.channel_id", "u": 7, "d": "The ID of the channel that the message was sent in."}, {"r": "hikari.messages.Message.guild_id", "u": 7, "d": "The ID of the guild that the message was sent in or builtins.None for messages out of guilds. ! warning This will also be builtins.None for messages received from the REST API. This is a Discord limitation as stated here https: github.com/discord/discord-api-docs/issues/912"}, {"r": "hikari.messages.Message.id", "u": 7, "d": "The ID of this entity."}, {"r": "hikari.messages.Message.created_at", "u": 7, "d": "When the object was created."}, {"r": "hikari.messages.ActionRowComponent", "u": 7, "d": "Represents a row of components attached to a message. ! note This is a top-level container component and will never be found within another component. Method generated by attrs for class ActionRowComponent."}, {"r": "hikari.messages.ActionRowComponent.components", "u": 7, "d": "Sequence of the components contained within this row."}, {"r": "hikari.messages.ActionRowComponent.type", "u": 7, "d": "The type of component this is."}, {"r": "hikari.messages.ButtonComponent", "u": 7, "d": "Represents a message button component. ! note This is an embedded component and will only ever be found within top-level container components such as ActionRowComponent . Method generated by attrs for class ButtonComponent."}, {"r": "hikari.messages.ButtonComponent.custom_id", "u": 7, "d": "Developer defined identifier for this button (will be >= 100 characters). ! note This is required for the following button styles:  ButtonStyle.PRIMARY   ButtonStyle.SECONDARY   ButtonStyle.SUCCESS   ButtonStyle.DANGER "}, {"r": "hikari.messages.ButtonComponent.emoji", "u": 7, "d": "Custom or unicode emoji which appears on the button."}, {"r": "hikari.messages.ButtonComponent.is_disabled", "u": 7, "d": "Whether the button is disabled."}, {"r": "hikari.messages.ButtonComponent.label", "u": 7, "d": "Text label which appears on the button."}, {"r": "hikari.messages.ButtonComponent.style", "u": 7, "d": "The button's style."}, {"r": "hikari.messages.ButtonComponent.url", "u": 7, "d": "Url for ButtonStyle.LINK style buttons."}, {"r": "hikari.messages.ButtonComponent.type", "u": 7, "d": "The type of component this is."}, {"r": "hikari.messages.ButtonStyle", "u": 7, "d": "Enum of the available button styles. More information, such as how these look, can be found at\nhttps: discord.com/developers/docs/interactions/message-components buttons-button-styles"}, {"r": "hikari.messages.ButtonStyle.name", "u": 7, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.messages.ButtonStyle.value", "u": 7, "d": "Return the value of the enum member."}, {"r": "hikari.messages.ButtonStyle.PRIMARY", "u": 7, "d": "A blurple \"call to action\" button."}, {"r": "hikari.messages.ButtonStyle.SECONDARY", "u": 7, "d": "A grey neutral button."}, {"r": "hikari.messages.ButtonStyle.SUCCESS", "u": 7, "d": "A green button."}, {"r": "hikari.messages.ButtonStyle.DANGER", "u": 7, "d": "A red button (usually indicates a destructive action)."}, {"r": "hikari.messages.ButtonStyle.LINK", "u": 7, "d": "A grey button which navigates to a URL. ! warning Unlike the other button styles, clicking this one will not trigger an interaction and custom_id shouldn't be included for this style."}, {"r": "hikari.messages.SelectMenuOption", "u": 7, "d": "Represents an option for a SelectMenuComponent . Method generated by attrs for class SelectMenuOption."}, {"r": "hikari.messages.SelectMenuOption.description", "u": 7, "d": "Optional description of the option, max 100 characters."}, {"r": "hikari.messages.SelectMenuOption.emoji", "u": 7, "d": "Custom or unicode emoji which appears on the button."}, {"r": "hikari.messages.SelectMenuOption.is_default", "u": 7, "d": "Whether this option will be selected by default."}, {"r": "hikari.messages.SelectMenuOption.label", "u": 7, "d": "User-facing name of the option, max 100 characters."}, {"r": "hikari.messages.SelectMenuOption.value", "u": 7, "d": "Dev-defined value of the option, max 100 characters."}, {"r": "hikari.messages.SelectMenuComponent", "u": 7, "d": "Represents a message button component. ! note This is an embedded component and will only ever be found within top-level container components such as ActionRowComponent . Method generated by attrs for class SelectMenuComponent."}, {"r": "hikari.messages.SelectMenuComponent.custom_id", "u": 7, "d": "Developer defined identifier for this menu (will be >= 100 characters)."}, {"r": "hikari.messages.SelectMenuComponent.is_disabled", "u": 7, "d": "Whether the select menu is disabled."}, {"r": "hikari.messages.SelectMenuComponent.max_values", "u": 7, "d": "The minimum amount of options which must be chosen for this menu. This will be greater than or equal to 0 and will be less than or equal to SelectMenuComponent.min_values ."}, {"r": "hikari.messages.SelectMenuComponent.min_values", "u": 7, "d": "The minimum amount of options which must be chosen for this menu. This will be less than or equal to 25 and will be greater than or equal to SelectMenuComponent.max_values ."}, {"r": "hikari.messages.SelectMenuComponent.options", "u": 7, "d": "Sequence of up to 25 of the options set for this menu."}, {"r": "hikari.messages.SelectMenuComponent.placeholder", "u": 7, "d": "Custom placeholder text shown if nothing is selected, max 100 characters."}, {"r": "hikari.messages.SelectMenuComponent.type", "u": 7, "d": "The type of component this is."}, {"r": "hikari.messages.InteractiveButtonTypes", "u": 7, "d": "Set of the ButtonType s which are valid for interactive buttons. The following values are included in this:  ButtonStyle.PRIMARY   ButtonStyle.SECONDARY   ButtonStyle.SUCCESS   ButtonStyle.DANGER "}, {"r": "hikari.messages.InteractiveButtonTypesT", "u": 7, "d": "Type hints of the ButtonStyle values which are valid for interactive buttons. The following values are valid for this:  ButtonStyle.PRIMARY / 1   ButtonStyle.SECONDARY / 2   ButtonStyle.SUCCESS / 3   ButtonStyle.DANGER / 4 "}, {"r": "hikari.messages.ComponentType", "u": 7, "d": "Types of components found within Discord."}, {"r": "hikari.messages.ComponentType.name", "u": 7, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.messages.ComponentType.value", "u": 7, "d": "Return the value of the enum member."}, {"r": "hikari.messages.ComponentType.ACTION_ROW", "u": 7, "d": "A non-interactive container component for other types of components. ! note As this is a container component it can never be contained within another component and therefore will always be top-level. ! note As of writing this can only contain one component type."}, {"r": "hikari.messages.ComponentType.BUTTON", "u": 7, "d": "A button component. ! note This cannot be top-level and must be within a container component such as ComponentType.ACTION_ROW ."}, {"r": "hikari.messages.ComponentType.SELECT_MENU", "u": 7, "d": "A select menu component. ! note This cannot be top-level and must be within a container component such as ComponentType.ACTION_ROW ."}, {"r": "hikari.messages.PartialComponent", "u": 7, "d": "Base class for all component entities. Method generated by attrs for class PartialComponent."}, {"r": "hikari.messages.PartialComponent.type", "u": 7, "d": "The type of component this is."}, {"r": "hikari.guilds", "u": 8, "d": "Application and entities that are used to describe guilds on Discord."}, {"r": "hikari.guilds.Guild", "u": 8, "d": "A representation of a guild on Discord. Method generated by attrs for class Guild."}, {"r": "hikari.guilds.Guild.banner_url", "u": 8, "d": "Banner URL for the guild, if set."}, {"r": "hikari.guilds.Guild.discovery_splash_url", "u": 8, "d": "Discovery splash URL for the guild, if set."}, {"r": "hikari.guilds.Guild.splash_url", "u": 8, "d": "Splash URL for the guild, if set."}, {"r": "hikari.guilds.Guild.get_members", "u": 8, "d": "Get the members cached for the guild. typing.Mapping[hikari.snowflakes.Snowflake, Member] A mapping of user IDs to objects of the members cached for the guild.", "f": 1}, {"r": "hikari.guilds.Guild.get_presences", "u": 8, "d": "Get the presences cached for the guild. typing.Mapping[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A mapping of user IDs to objects of the presences cached for the guild.", "f": 1}, {"r": "hikari.guilds.Guild.get_channels", "u": 8, "d": "Get the channels cached for the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A mapping of channel IDs to objects of the channels cached for the guild.", "f": 1}, {"r": "hikari.guilds.Guild.get_voice_states", "u": 8, "d": "Get the voice states cached for the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A mapping of user IDs to objects of the voice states cached for the guild.", "f": 1}, {"r": "hikari.guilds.Guild.get_emojis", "u": 8, "d": "Return the emojis in this guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A mapping of emoji IDs to the objects of emojis in this guild.", "f": 1}, {"r": "hikari.guilds.Guild.get_roles", "u": 8, "d": "Return the roles in this guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, Role] A mapping of role IDs to the objects of roles in this guild.", "f": 1}, {"r": "hikari.guilds.Guild.make_banner_url", "u": 8, "d": "Generate the guild's banner image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL of the banner, or builtins.None if no banner is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.Guild.make_discovery_splash_url", "u": 8, "d": "Generate the guild's discovery splash image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The string URL. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.Guild.make_splash_url", "u": 8, "d": "Generate the guild's splash image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the splash, or builtins.None if not set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.Guild.get_channel", "u": 8, "d": "Get a cached channel that belongs to the guild by it's ID or object. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The object or ID of the guild channel to get from the cache. Returns typing.Optional[hikari.channels.GuildChannel] The object of the guild channel found in cache or builtins.None.", "f": 1}, {"r": "hikari.guilds.Guild.get_member", "u": 8, "d": "Get a cached member that belongs to the guild by it's user ID or object. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The object or ID of the user to get the cached member for. Returns typing.Optional[Member] The cached member object if found, else builtins.None .", "f": 1}, {"r": "hikari.guilds.Guild.get_my_member", "u": 8, "d": "Return the cached member for the bot user in this guild, if known. Returns typing.Optional[Member] The cached member for this guild, or builtins.None if not known.", "f": 1}, {"r": "hikari.guilds.Guild.get_presence", "u": 8, "d": "Get a cached presence that belongs to the guild by it's user ID or object. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The object or ID of the user to get the cached presence for. Returns typing.Optional[hikari.presences.MemberPresence] The cached presence object if found, else builtins.None .", "f": 1}, {"r": "hikari.guilds.Guild.get_voice_state", "u": 8, "d": "Get a cached voice state that belongs to the guild by it's user. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The object or ID of the user to get the cached voice state for. Returns typing.Optional[hikari.voices.VoiceState] The cached voice state object if found, else builtins.None .", "f": 1}, {"r": "hikari.guilds.Guild.get_emoji", "u": 8, "d": "Get a cached role that belongs to the guild by it's ID or object. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The object or ID of the emoji to get from the cache. Returns typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the custom emoji if found in cache, else builtins.None .", "f": 1}, {"r": "hikari.guilds.Guild.get_role", "u": 8, "d": "Get a cached role that belongs to the guild by it's ID or object. Parameters role : hikari.snowflakes.SnowflakeishOr[PartialRole] The object or ID of the role to get for this guild from the cache. Returns typing.Optional[Role] The object of the role found in cache, else builtins.None .", "f": 1}, {"r": "hikari.guilds.Guild.fetch_owner", "u": 8, "d": "Fetch the owner of the guild. Returns hikari.guilds.Member The guild owner. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or the user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_widget_channel", "u": 8, "d": "Fetch the widget channel. This will be builtins.None if not set. Returns typing.Optional[hikari.channels.GuildChannel] The channel the widget is linked to or else builtins.None . Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_afk_channel", "u": 8, "d": "Fetch the channel that AFK voice users get sent to. Returns typing.Optional[hikari.channels.GuildVoiceChannel] The AFK channel or builtins.None if not enabled. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_system_channel", "u": 8, "d": "Fetch the system channel. Returns typing.Optional[hikari.channels.GuildTextChannel] The system channel for this guild or builtins.None if not enabled. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_rules_channel", "u": 8, "d": "Fetch the channel where guilds display rules and guidelines. If the GuildFeature.COMMUNITY feature is not defined, then this is builtins.None . Returns typing.Optional[hikari.channels.GuildTextChannel] The channel where the rules of the guild are specified or else builtins.None . Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_public_updates_channel", "u": 8, "d": "Fetch channel ID of the channel where admins and moderators receive notices from Discord. This is only present if GuildFeature.COMMUNITY is in Guild.features for\nthis guild. For all other purposes, it should be considered to be builtins.None . Returns typing.Optional[hikari.channels.GuildTextChannel] The channel where discord sents relevant updates to moderators and admins. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.afk_channel_id", "u": 8, "d": "The ID for the channel that AFK voice users get sent to. If builtins.None , then no AFK channel is set up for this guild."}, {"r": "hikari.guilds.Guild.afk_timeout", "u": 8, "d": "Timeout for activity before a member is classed as AFK. How long a voice user has to be AFK for before they are classed as being\nAFK and are moved to the AFK channel ( Guild.afk_channel_id )."}, {"r": "hikari.guilds.Guild.application_id", "u": 8, "d": "The ID of the application that created this guild. This will always be builtins.None for guilds that weren't created by a bot."}, {"r": "hikari.guilds.Guild.banner_hash", "u": 8, "d": "The hash for the guild's banner. This is only present if the guild has GuildFeature.BANNER in Guild.features for this guild. For all other purposes, it is builtins.None ."}, {"r": "hikari.guilds.Guild.default_message_notifications", "u": 8, "d": "The default setting for message notifications in this guild."}, {"r": "hikari.guilds.Guild.description", "u": 8, "d": "The guild's description. This is only present if certain GuildFeature 's are set in Guild.features for this guild. Otherwise, this will always be builtins.None ."}, {"r": "hikari.guilds.Guild.discovery_splash_hash", "u": 8, "d": "The hash of the discovery splash for the guild, if there is one."}, {"r": "hikari.guilds.Guild.explicit_content_filter", "u": 8, "d": "The setting for the explicit content filter in this guild."}, {"r": "hikari.guilds.Guild.features", "u": 8, "d": "A list of the features in this guild."}, {"r": "hikari.guilds.Guild.is_widget_enabled", "u": 8, "d": "Describes whether the guild widget is enabled or not. If this information is not present, this will be builtins.None ."}, {"r": "hikari.guilds.Guild.max_video_channel_users", "u": 8, "d": "The maximum number of users allowed in a video channel together. This information may not be present, in which case, it will be builtins.None ."}, {"r": "hikari.guilds.Guild.mfa_level", "u": 8, "d": "The required MFA level for users wishing to participate in this guild."}, {"r": "hikari.guilds.Guild.nsfw_level", "u": 8, "d": "The NSFW level of the guild."}, {"r": "hikari.guilds.Guild.owner_id", "u": 8, "d": "The ID of the owner of this guild."}, {"r": "hikari.guilds.Guild.preferred_locale", "u": 8, "d": "The preferred locale to use for this guild. This can only be change if GuildFeature.COMMUNITY is in Guild.features for this guild and will otherwise default to en-US ."}, {"r": "hikari.guilds.Guild.premium_subscription_count", "u": 8, "d": "The number of nitro boosts that the server currently has. This information may not be present, in which case, it will be builtins.None ."}, {"r": "hikari.guilds.Guild.premium_tier", "u": 8, "d": "The premium tier for this guild."}, {"r": "hikari.guilds.Guild.public_updates_channel_id", "u": 8, "d": "The channel ID of the channel where admins and moderators receive notices\nfrom Discord. This is only present if GuildFeature.COMMUNITY is in Guild.features for\nthis guild. For all other purposes, it should be considered to be builtins.None ."}, {"r": "hikari.guilds.Guild.rules_channel_id", "u": 8, "d": "The ID of the channel where guilds with the GuildFeature.COMMUNITY  features display rules and guidelines. If the GuildFeature.COMMUNITY feature is not defined, then this is builtins.None ."}, {"r": "hikari.guilds.Guild.splash_hash", "u": 8, "d": "The hash of the splash for the guild, if there is one."}, {"r": "hikari.guilds.Guild.system_channel_flags", "u": 8, "d": "Return flags for the guild system channel. These are used to describe which notifications are suppressed. Returns GuildSystemChannelFlag The system channel flags for this channel."}, {"r": "hikari.guilds.Guild.system_channel_id", "u": 8, "d": "The ID of the system channel or builtins.None if it is not enabled. Welcome messages and Nitro boost messages may be sent to this channel."}, {"r": "hikari.guilds.Guild.vanity_url_code", "u": 8, "d": "The vanity URL code for the guild's vanity URL. This is only present if GuildFeature.VANITY_URL is in Guild.features for\nthis guild. If not, this will always be builtins.None ."}, {"r": "hikari.guilds.Guild.verification_level", "u": 8, "d": "The verification level needed for a user to participate in this guild."}, {"r": "hikari.guilds.Guild.widget_channel_id", "u": 8, "d": "The channel ID that the widget's generated invite will send the user to. If this information is unavailable or this is not enabled for the guild then\nthis will be builtins.None ."}, {"r": "hikari.guilds.Guild.icon_url", "u": 8, "d": "Icon URL for the guild, if set; otherwise builtins.None ."}, {"r": "hikari.guilds.Guild.shard_id", "u": 8, "d": "Return the ID of the shard this guild is served by. This may return None if the application does not have a gateway\nconnection."}, {"r": "hikari.guilds.Guild.make_icon_url", "u": 8, "d": "Generate the guild's icon URL, if set. Parameters ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the resource, or builtins.None if no icon is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.Guild.ban", "u": 8, "d": "Ban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to ban from the guild Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.unban", "u": 8, "d": "Unban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to unban from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.kick", "u": 8, "d": "Kicks the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to kick from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.edit", "u": 8, "d": "Edits the guild. Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild.\nverification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level.\ndefault_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level.\nexplicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level.\nafk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires afk_timeout to be set to work.\nafk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout.\nicon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature.\nowner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner. ! warning You need to be the owner of the server to use this.\nsplash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the INVITE_SPLASH feature.\nbanner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the BANNER feature.\nsystem_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel.\nrules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel.\npublic_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel.\npreferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.RESTGuild The edited guild. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission or if you tried to pass ownership without being the server owner.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_emojis", "u": 8, "d": "Fetch the emojis of the guild. Returns typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_emoji", "u": 8, "d": "Fetch an emoji from the guild. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns hikari.emojis.KnownCustomEmoji The requested emoji. Raises hikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_stickers", "u": 8, "d": "Fetch the stickers of the guild. Returns typing.Sequence[hikari.stickers.GuildSticker] The requested stickers. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_sticker", "u": 8, "d": "Fetch a sticker from the guild. Parameters sticker : snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns hikari.stickers.GuildSticker The requested sticker. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.create_sticker", "u": 8, "d": "Create a sticker in a guild. Parameters name : builtins.str The name for the sticker.\ntag : builtins.str The tag for the sticker.\nimage : hikari.files.Resourceish The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie. ! note Lottie support is only available for verified and partnered servers. Other Parameters description: hikari.undefined.UndefinedOr[builtins.str] If provided, the description of the sticker.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The created sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.edit_sticker", "u": 8, "d": "Edit a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to edit. This can be a sticker object or the ID of an existing sticker. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the sticker.\ndescription : hikari.undefined.UndefinedOr[builtins.str] If provided, the new description for the sticker.\ntag : hikari.undefined.UndefinedOr[builtins.str] If provided, the new sticker tag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The edited sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.delete_sticker", "u": 8, "d": "Delete a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to delete. This can be a sticker object or the ID of an existing sticker. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.create_category", "u": 8, "d": "Create a category in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildCategory The created category. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.create_text_channel", "u": 8, "d": "Create a text channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildTextChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.create_news_channel", "u": 8, "d": "Create a news channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildNewsChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.create_voice_channel", "u": 8, "d": "Create a voice channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildVoiceChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the gui ld is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.create_stage_channel", "u": 8, "d": "Create a stage channel in the guild. Parameters name : builtins.str The channel's name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildStageChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.delete_channel", "u": 8, "d": "Delete a channel in the guild. ! note This method can also be used for deleting guild categories as well. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel or category to delete. This may be the object or the ID of an existing channel. Returns hikari.channels.GuildChannel Object of the channel or category that was deleted. Raises hikari.errors.UnauthorizedError, or close a DM. If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_self", "u": 8, "d": "Fetch the guild. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.fetch_roles", "u": 8, "d": "Fetch the roles of the guild. Returns typing.Sequence[hikari.guilds.Role] The requested roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Guild.app", "u": 8, "d": "The client application that models may use for procedures."}, {"r": "hikari.guilds.Guild.icon_hash", "u": 8, "d": "The hash for the guild icon, if there is one."}, {"r": "hikari.guilds.Guild.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.Guild.name", "u": 8, "d": "The name of the guild."}, {"r": "hikari.guilds.Guild.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.RESTGuild", "u": 8, "d": "Guild specialization that is sent via the REST API only. Method generated by attrs for class RESTGuild."}, {"r": "hikari.guilds.RESTGuild.approximate_active_member_count", "u": 8, "d": "The approximate number of members in the guild that are not offline. This will be builtins.None when creating a guild."}, {"r": "hikari.guilds.RESTGuild.approximate_member_count", "u": 8, "d": "The approximate number of members in the guild. This will be builtins.None when creating a guild."}, {"r": "hikari.guilds.RESTGuild.emojis", "u": 8, "d": "A mapping of emoji IDs to the objects of the emojis this guild provides."}, {"r": "hikari.guilds.RESTGuild.max_members", "u": 8, "d": "The maximum number of members allowed in this guild."}, {"r": "hikari.guilds.RESTGuild.max_presences", "u": 8, "d": "The maximum number of presences for the guild. If builtins.None , then there is no limit."}, {"r": "hikari.guilds.RESTGuild.roles", "u": 8, "d": "The roles in this guild, represented as a mapping of role ID to role object."}, {"r": "hikari.guilds.RESTGuild.banner_url", "u": 8, "d": "Banner URL for the guild, if set."}, {"r": "hikari.guilds.RESTGuild.discovery_splash_url", "u": 8, "d": "Discovery splash URL for the guild, if set."}, {"r": "hikari.guilds.RESTGuild.splash_url", "u": 8, "d": "Splash URL for the guild, if set."}, {"r": "hikari.guilds.RESTGuild.get_members", "u": 8, "d": "Get the members cached for the guild. typing.Mapping[hikari.snowflakes.Snowflake, Member] A mapping of user IDs to objects of the members cached for the guild.", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_presences", "u": 8, "d": "Get the presences cached for the guild. typing.Mapping[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A mapping of user IDs to objects of the presences cached for the guild.", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_channels", "u": 8, "d": "Get the channels cached for the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A mapping of channel IDs to objects of the channels cached for the guild.", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_voice_states", "u": 8, "d": "Get the voice states cached for the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A mapping of user IDs to objects of the voice states cached for the guild.", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_emojis", "u": 8, "d": "Return the emojis in this guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A mapping of emoji IDs to the objects of emojis in this guild.", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_roles", "u": 8, "d": "Return the roles in this guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, Role] A mapping of role IDs to the objects of roles in this guild.", "f": 1}, {"r": "hikari.guilds.RESTGuild.make_banner_url", "u": 8, "d": "Generate the guild's banner image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL of the banner, or builtins.None if no banner is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.RESTGuild.make_discovery_splash_url", "u": 8, "d": "Generate the guild's discovery splash image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The string URL. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.RESTGuild.make_splash_url", "u": 8, "d": "Generate the guild's splash image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the splash, or builtins.None if not set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_channel", "u": 8, "d": "Get a cached channel that belongs to the guild by it's ID or object. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The object or ID of the guild channel to get from the cache. Returns typing.Optional[hikari.channels.GuildChannel] The object of the guild channel found in cache or builtins.None.", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_member", "u": 8, "d": "Get a cached member that belongs to the guild by it's user ID or object. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The object or ID of the user to get the cached member for. Returns typing.Optional[Member] The cached member object if found, else builtins.None .", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_my_member", "u": 8, "d": "Return the cached member for the bot user in this guild, if known. Returns typing.Optional[Member] The cached member for this guild, or builtins.None if not known.", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_presence", "u": 8, "d": "Get a cached presence that belongs to the guild by it's user ID or object. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The object or ID of the user to get the cached presence for. Returns typing.Optional[hikari.presences.MemberPresence] The cached presence object if found, else builtins.None .", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_voice_state", "u": 8, "d": "Get a cached voice state that belongs to the guild by it's user. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The object or ID of the user to get the cached voice state for. Returns typing.Optional[hikari.voices.VoiceState] The cached voice state object if found, else builtins.None .", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_emoji", "u": 8, "d": "Get a cached role that belongs to the guild by it's ID or object. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The object or ID of the emoji to get from the cache. Returns typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the custom emoji if found in cache, else builtins.None .", "f": 1}, {"r": "hikari.guilds.RESTGuild.get_role", "u": 8, "d": "Get a cached role that belongs to the guild by it's ID or object. Parameters role : hikari.snowflakes.SnowflakeishOr[PartialRole] The object or ID of the role to get for this guild from the cache. Returns typing.Optional[Role] The object of the role found in cache, else builtins.None .", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_owner", "u": 8, "d": "Fetch the owner of the guild. Returns hikari.guilds.Member The guild owner. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or the user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_widget_channel", "u": 8, "d": "Fetch the widget channel. This will be builtins.None if not set. Returns typing.Optional[hikari.channels.GuildChannel] The channel the widget is linked to or else builtins.None . Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_afk_channel", "u": 8, "d": "Fetch the channel that AFK voice users get sent to. Returns typing.Optional[hikari.channels.GuildVoiceChannel] The AFK channel or builtins.None if not enabled. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_system_channel", "u": 8, "d": "Fetch the system channel. Returns typing.Optional[hikari.channels.GuildTextChannel] The system channel for this guild or builtins.None if not enabled. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_rules_channel", "u": 8, "d": "Fetch the channel where guilds display rules and guidelines. If the GuildFeature.COMMUNITY feature is not defined, then this is builtins.None . Returns typing.Optional[hikari.channels.GuildTextChannel] The channel where the rules of the guild are specified or else builtins.None . Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_public_updates_channel", "u": 8, "d": "Fetch channel ID of the channel where admins and moderators receive notices from Discord. This is only present if GuildFeature.COMMUNITY is in Guild.features for\nthis guild. For all other purposes, it should be considered to be builtins.None . Returns typing.Optional[hikari.channels.GuildTextChannel] The channel where discord sents relevant updates to moderators and admins. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.afk_channel_id", "u": 8, "d": "The ID for the channel that AFK voice users get sent to. If builtins.None , then no AFK channel is set up for this guild."}, {"r": "hikari.guilds.RESTGuild.afk_timeout", "u": 8, "d": "Timeout for activity before a member is classed as AFK. How long a voice user has to be AFK for before they are classed as being\nAFK and are moved to the AFK channel ( Guild.afk_channel_id )."}, {"r": "hikari.guilds.RESTGuild.application_id", "u": 8, "d": "The ID of the application that created this guild. This will always be builtins.None for guilds that weren't created by a bot."}, {"r": "hikari.guilds.RESTGuild.banner_hash", "u": 8, "d": "The hash for the guild's banner. This is only present if the guild has GuildFeature.BANNER in Guild.features for this guild. For all other purposes, it is builtins.None ."}, {"r": "hikari.guilds.RESTGuild.default_message_notifications", "u": 8, "d": "The default setting for message notifications in this guild."}, {"r": "hikari.guilds.RESTGuild.description", "u": 8, "d": "The guild's description. This is only present if certain GuildFeature 's are set in Guild.features for this guild. Otherwise, this will always be builtins.None ."}, {"r": "hikari.guilds.RESTGuild.discovery_splash_hash", "u": 8, "d": "The hash of the discovery splash for the guild, if there is one."}, {"r": "hikari.guilds.RESTGuild.explicit_content_filter", "u": 8, "d": "The setting for the explicit content filter in this guild."}, {"r": "hikari.guilds.RESTGuild.features", "u": 8, "d": "A list of the features in this guild."}, {"r": "hikari.guilds.RESTGuild.is_widget_enabled", "u": 8, "d": "Describes whether the guild widget is enabled or not. If this information is not present, this will be builtins.None ."}, {"r": "hikari.guilds.RESTGuild.max_video_channel_users", "u": 8, "d": "The maximum number of users allowed in a video channel together. This information may not be present, in which case, it will be builtins.None ."}, {"r": "hikari.guilds.RESTGuild.mfa_level", "u": 8, "d": "The required MFA level for users wishing to participate in this guild."}, {"r": "hikari.guilds.RESTGuild.nsfw_level", "u": 8, "d": "The NSFW level of the guild."}, {"r": "hikari.guilds.RESTGuild.owner_id", "u": 8, "d": "The ID of the owner of this guild."}, {"r": "hikari.guilds.RESTGuild.preferred_locale", "u": 8, "d": "The preferred locale to use for this guild. This can only be change if GuildFeature.COMMUNITY is in Guild.features for this guild and will otherwise default to en-US ."}, {"r": "hikari.guilds.RESTGuild.premium_subscription_count", "u": 8, "d": "The number of nitro boosts that the server currently has. This information may not be present, in which case, it will be builtins.None ."}, {"r": "hikari.guilds.RESTGuild.premium_tier", "u": 8, "d": "The premium tier for this guild."}, {"r": "hikari.guilds.RESTGuild.public_updates_channel_id", "u": 8, "d": "The channel ID of the channel where admins and moderators receive notices\nfrom Discord. This is only present if GuildFeature.COMMUNITY is in Guild.features for\nthis guild. For all other purposes, it should be considered to be builtins.None ."}, {"r": "hikari.guilds.RESTGuild.rules_channel_id", "u": 8, "d": "The ID of the channel where guilds with the GuildFeature.COMMUNITY  features display rules and guidelines. If the GuildFeature.COMMUNITY feature is not defined, then this is builtins.None ."}, {"r": "hikari.guilds.RESTGuild.splash_hash", "u": 8, "d": "The hash of the splash for the guild, if there is one."}, {"r": "hikari.guilds.RESTGuild.system_channel_flags", "u": 8, "d": "Return flags for the guild system channel. These are used to describe which notifications are suppressed. Returns GuildSystemChannelFlag The system channel flags for this channel."}, {"r": "hikari.guilds.RESTGuild.system_channel_id", "u": 8, "d": "The ID of the system channel or builtins.None if it is not enabled. Welcome messages and Nitro boost messages may be sent to this channel."}, {"r": "hikari.guilds.RESTGuild.vanity_url_code", "u": 8, "d": "The vanity URL code for the guild's vanity URL. This is only present if GuildFeature.VANITY_URL is in Guild.features for\nthis guild. If not, this will always be builtins.None ."}, {"r": "hikari.guilds.RESTGuild.verification_level", "u": 8, "d": "The verification level needed for a user to participate in this guild."}, {"r": "hikari.guilds.RESTGuild.widget_channel_id", "u": 8, "d": "The channel ID that the widget's generated invite will send the user to. If this information is unavailable or this is not enabled for the guild then\nthis will be builtins.None ."}, {"r": "hikari.guilds.RESTGuild.icon_url", "u": 8, "d": "Icon URL for the guild, if set; otherwise builtins.None ."}, {"r": "hikari.guilds.RESTGuild.shard_id", "u": 8, "d": "Return the ID of the shard this guild is served by. This may return None if the application does not have a gateway\nconnection."}, {"r": "hikari.guilds.RESTGuild.make_icon_url", "u": 8, "d": "Generate the guild's icon URL, if set. Parameters ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the resource, or builtins.None if no icon is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.RESTGuild.ban", "u": 8, "d": "Ban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to ban from the guild Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.unban", "u": 8, "d": "Unban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to unban from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.kick", "u": 8, "d": "Kicks the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to kick from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.edit", "u": 8, "d": "Edits the guild. Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild.\nverification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level.\ndefault_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level.\nexplicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level.\nafk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires afk_timeout to be set to work.\nafk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout.\nicon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature.\nowner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner. ! warning You need to be the owner of the server to use this.\nsplash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the INVITE_SPLASH feature.\nbanner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the BANNER feature.\nsystem_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel.\nrules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel.\npublic_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel.\npreferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.RESTGuild The edited guild. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission or if you tried to pass ownership without being the server owner.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_emojis", "u": 8, "d": "Fetch the emojis of the guild. Returns typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_emoji", "u": 8, "d": "Fetch an emoji from the guild. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns hikari.emojis.KnownCustomEmoji The requested emoji. Raises hikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_stickers", "u": 8, "d": "Fetch the stickers of the guild. Returns typing.Sequence[hikari.stickers.GuildSticker] The requested stickers. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_sticker", "u": 8, "d": "Fetch a sticker from the guild. Parameters sticker : snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns hikari.stickers.GuildSticker The requested sticker. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.create_sticker", "u": 8, "d": "Create a sticker in a guild. Parameters name : builtins.str The name for the sticker.\ntag : builtins.str The tag for the sticker.\nimage : hikari.files.Resourceish The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie. ! note Lottie support is only available for verified and partnered servers. Other Parameters description: hikari.undefined.UndefinedOr[builtins.str] If provided, the description of the sticker.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The created sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.edit_sticker", "u": 8, "d": "Edit a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to edit. This can be a sticker object or the ID of an existing sticker. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the sticker.\ndescription : hikari.undefined.UndefinedOr[builtins.str] If provided, the new description for the sticker.\ntag : hikari.undefined.UndefinedOr[builtins.str] If provided, the new sticker tag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The edited sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.delete_sticker", "u": 8, "d": "Delete a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to delete. This can be a sticker object or the ID of an existing sticker. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.create_category", "u": 8, "d": "Create a category in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildCategory The created category. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.create_text_channel", "u": 8, "d": "Create a text channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildTextChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.create_news_channel", "u": 8, "d": "Create a news channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildNewsChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.create_voice_channel", "u": 8, "d": "Create a voice channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildVoiceChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the gui ld is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.create_stage_channel", "u": 8, "d": "Create a stage channel in the guild. Parameters name : builtins.str The channel's name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildStageChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.delete_channel", "u": 8, "d": "Delete a channel in the guild. ! note This method can also be used for deleting guild categories as well. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel or category to delete. This may be the object or the ID of an existing channel. Returns hikari.channels.GuildChannel Object of the channel or category that was deleted. Raises hikari.errors.UnauthorizedError, or close a DM. If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_self", "u": 8, "d": "Fetch the guild. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.fetch_roles", "u": 8, "d": "Fetch the roles of the guild. Returns typing.Sequence[hikari.guilds.Role] The requested roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.RESTGuild.app", "u": 8, "d": "The client application that models may use for procedures."}, {"r": "hikari.guilds.RESTGuild.icon_hash", "u": 8, "d": "The hash for the guild icon, if there is one."}, {"r": "hikari.guilds.RESTGuild.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.RESTGuild.name", "u": 8, "d": "The name of the guild."}, {"r": "hikari.guilds.RESTGuild.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.GatewayGuild", "u": 8, "d": "Guild specialization that is sent via the gateway only. Method generated by attrs for class GatewayGuild."}, {"r": "hikari.guilds.GatewayGuild.is_large", "u": 8, "d": "Whether the guild is considered to be large or not. This information is only available if the guild was sent via a GUILD_CREATE event. If the guild is received from any other place, this will always be builtins.None . The implications of a large guild are that presence information will not be\nsent about members who are offline or invisible."}, {"r": "hikari.guilds.GatewayGuild.joined_at", "u": 8, "d": "The date and time that the bot user joined this guild. This information is only available if the guild was sent via a GUILD_CREATE event. If the guild is received from any other place, this will always be builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.member_count", "u": 8, "d": "The number of members in this guild. This information is only available if the guild was sent via a GUILD_CREATE event. If the guild is received from any other place, this will always be builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.banner_url", "u": 8, "d": "Banner URL for the guild, if set."}, {"r": "hikari.guilds.GatewayGuild.discovery_splash_url", "u": 8, "d": "Discovery splash URL for the guild, if set."}, {"r": "hikari.guilds.GatewayGuild.splash_url", "u": 8, "d": "Splash URL for the guild, if set."}, {"r": "hikari.guilds.GatewayGuild.get_members", "u": 8, "d": "Get the members cached for the guild. typing.Mapping[hikari.snowflakes.Snowflake, Member] A mapping of user IDs to objects of the members cached for the guild.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_presences", "u": 8, "d": "Get the presences cached for the guild. typing.Mapping[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A mapping of user IDs to objects of the presences cached for the guild.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_channels", "u": 8, "d": "Get the channels cached for the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A mapping of channel IDs to objects of the channels cached for the guild.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_voice_states", "u": 8, "d": "Get the voice states cached for the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A mapping of user IDs to objects of the voice states cached for the guild.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_emojis", "u": 8, "d": "Return the emojis in this guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A mapping of emoji IDs to the objects of emojis in this guild.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_roles", "u": 8, "d": "Return the roles in this guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, Role] A mapping of role IDs to the objects of roles in this guild.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.make_banner_url", "u": 8, "d": "Generate the guild's banner image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL of the banner, or builtins.None if no banner is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.make_discovery_splash_url", "u": 8, "d": "Generate the guild's discovery splash image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The string URL. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.make_splash_url", "u": 8, "d": "Generate the guild's splash image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the splash, or builtins.None if not set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_channel", "u": 8, "d": "Get a cached channel that belongs to the guild by it's ID or object. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The object or ID of the guild channel to get from the cache. Returns typing.Optional[hikari.channels.GuildChannel] The object of the guild channel found in cache or builtins.None.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_member", "u": 8, "d": "Get a cached member that belongs to the guild by it's user ID or object. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The object or ID of the user to get the cached member for. Returns typing.Optional[Member] The cached member object if found, else builtins.None .", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_my_member", "u": 8, "d": "Return the cached member for the bot user in this guild, if known. Returns typing.Optional[Member] The cached member for this guild, or builtins.None if not known.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_presence", "u": 8, "d": "Get a cached presence that belongs to the guild by it's user ID or object. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The object or ID of the user to get the cached presence for. Returns typing.Optional[hikari.presences.MemberPresence] The cached presence object if found, else builtins.None .", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_voice_state", "u": 8, "d": "Get a cached voice state that belongs to the guild by it's user. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The object or ID of the user to get the cached voice state for. Returns typing.Optional[hikari.voices.VoiceState] The cached voice state object if found, else builtins.None .", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_emoji", "u": 8, "d": "Get a cached role that belongs to the guild by it's ID or object. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The object or ID of the emoji to get from the cache. Returns typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the custom emoji if found in cache, else builtins.None .", "f": 1}, {"r": "hikari.guilds.GatewayGuild.get_role", "u": 8, "d": "Get a cached role that belongs to the guild by it's ID or object. Parameters role : hikari.snowflakes.SnowflakeishOr[PartialRole] The object or ID of the role to get for this guild from the cache. Returns typing.Optional[Role] The object of the role found in cache, else builtins.None .", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_owner", "u": 8, "d": "Fetch the owner of the guild. Returns hikari.guilds.Member The guild owner. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or the user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_widget_channel", "u": 8, "d": "Fetch the widget channel. This will be builtins.None if not set. Returns typing.Optional[hikari.channels.GuildChannel] The channel the widget is linked to or else builtins.None . Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_afk_channel", "u": 8, "d": "Fetch the channel that AFK voice users get sent to. Returns typing.Optional[hikari.channels.GuildVoiceChannel] The AFK channel or builtins.None if not enabled. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_system_channel", "u": 8, "d": "Fetch the system channel. Returns typing.Optional[hikari.channels.GuildTextChannel] The system channel for this guild or builtins.None if not enabled. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_rules_channel", "u": 8, "d": "Fetch the channel where guilds display rules and guidelines. If the GuildFeature.COMMUNITY feature is not defined, then this is builtins.None . Returns typing.Optional[hikari.channels.GuildTextChannel] The channel where the rules of the guild are specified or else builtins.None . Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_public_updates_channel", "u": 8, "d": "Fetch channel ID of the channel where admins and moderators receive notices from Discord. This is only present if GuildFeature.COMMUNITY is in Guild.features for\nthis guild. For all other purposes, it should be considered to be builtins.None . Returns typing.Optional[hikari.channels.GuildTextChannel] The channel where discord sents relevant updates to moderators and admins. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.afk_channel_id", "u": 8, "d": "The ID for the channel that AFK voice users get sent to. If builtins.None , then no AFK channel is set up for this guild."}, {"r": "hikari.guilds.GatewayGuild.afk_timeout", "u": 8, "d": "Timeout for activity before a member is classed as AFK. How long a voice user has to be AFK for before they are classed as being\nAFK and are moved to the AFK channel ( Guild.afk_channel_id )."}, {"r": "hikari.guilds.GatewayGuild.application_id", "u": 8, "d": "The ID of the application that created this guild. This will always be builtins.None for guilds that weren't created by a bot."}, {"r": "hikari.guilds.GatewayGuild.banner_hash", "u": 8, "d": "The hash for the guild's banner. This is only present if the guild has GuildFeature.BANNER in Guild.features for this guild. For all other purposes, it is builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.default_message_notifications", "u": 8, "d": "The default setting for message notifications in this guild."}, {"r": "hikari.guilds.GatewayGuild.description", "u": 8, "d": "The guild's description. This is only present if certain GuildFeature 's are set in Guild.features for this guild. Otherwise, this will always be builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.discovery_splash_hash", "u": 8, "d": "The hash of the discovery splash for the guild, if there is one."}, {"r": "hikari.guilds.GatewayGuild.explicit_content_filter", "u": 8, "d": "The setting for the explicit content filter in this guild."}, {"r": "hikari.guilds.GatewayGuild.features", "u": 8, "d": "A list of the features in this guild."}, {"r": "hikari.guilds.GatewayGuild.is_widget_enabled", "u": 8, "d": "Describes whether the guild widget is enabled or not. If this information is not present, this will be builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.max_video_channel_users", "u": 8, "d": "The maximum number of users allowed in a video channel together. This information may not be present, in which case, it will be builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.mfa_level", "u": 8, "d": "The required MFA level for users wishing to participate in this guild."}, {"r": "hikari.guilds.GatewayGuild.nsfw_level", "u": 8, "d": "The NSFW level of the guild."}, {"r": "hikari.guilds.GatewayGuild.owner_id", "u": 8, "d": "The ID of the owner of this guild."}, {"r": "hikari.guilds.GatewayGuild.preferred_locale", "u": 8, "d": "The preferred locale to use for this guild. This can only be change if GuildFeature.COMMUNITY is in Guild.features for this guild and will otherwise default to en-US ."}, {"r": "hikari.guilds.GatewayGuild.premium_subscription_count", "u": 8, "d": "The number of nitro boosts that the server currently has. This information may not be present, in which case, it will be builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.premium_tier", "u": 8, "d": "The premium tier for this guild."}, {"r": "hikari.guilds.GatewayGuild.public_updates_channel_id", "u": 8, "d": "The channel ID of the channel where admins and moderators receive notices\nfrom Discord. This is only present if GuildFeature.COMMUNITY is in Guild.features for\nthis guild. For all other purposes, it should be considered to be builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.rules_channel_id", "u": 8, "d": "The ID of the channel where guilds with the GuildFeature.COMMUNITY  features display rules and guidelines. If the GuildFeature.COMMUNITY feature is not defined, then this is builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.splash_hash", "u": 8, "d": "The hash of the splash for the guild, if there is one."}, {"r": "hikari.guilds.GatewayGuild.system_channel_flags", "u": 8, "d": "Return flags for the guild system channel. These are used to describe which notifications are suppressed. Returns GuildSystemChannelFlag The system channel flags for this channel."}, {"r": "hikari.guilds.GatewayGuild.system_channel_id", "u": 8, "d": "The ID of the system channel or builtins.None if it is not enabled. Welcome messages and Nitro boost messages may be sent to this channel."}, {"r": "hikari.guilds.GatewayGuild.vanity_url_code", "u": 8, "d": "The vanity URL code for the guild's vanity URL. This is only present if GuildFeature.VANITY_URL is in Guild.features for\nthis guild. If not, this will always be builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.verification_level", "u": 8, "d": "The verification level needed for a user to participate in this guild."}, {"r": "hikari.guilds.GatewayGuild.widget_channel_id", "u": 8, "d": "The channel ID that the widget's generated invite will send the user to. If this information is unavailable or this is not enabled for the guild then\nthis will be builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.icon_url", "u": 8, "d": "Icon URL for the guild, if set; otherwise builtins.None ."}, {"r": "hikari.guilds.GatewayGuild.shard_id", "u": 8, "d": "Return the ID of the shard this guild is served by. This may return None if the application does not have a gateway\nconnection."}, {"r": "hikari.guilds.GatewayGuild.make_icon_url", "u": 8, "d": "Generate the guild's icon URL, if set. Parameters ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the resource, or builtins.None if no icon is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.ban", "u": 8, "d": "Ban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to ban from the guild Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.unban", "u": 8, "d": "Unban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to unban from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.kick", "u": 8, "d": "Kicks the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to kick from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.edit", "u": 8, "d": "Edits the guild. Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild.\nverification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level.\ndefault_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level.\nexplicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level.\nafk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires afk_timeout to be set to work.\nafk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout.\nicon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature.\nowner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner. ! warning You need to be the owner of the server to use this.\nsplash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the INVITE_SPLASH feature.\nbanner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the BANNER feature.\nsystem_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel.\nrules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel.\npublic_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel.\npreferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.RESTGuild The edited guild. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission or if you tried to pass ownership without being the server owner.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_emojis", "u": 8, "d": "Fetch the emojis of the guild. Returns typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_emoji", "u": 8, "d": "Fetch an emoji from the guild. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns hikari.emojis.KnownCustomEmoji The requested emoji. Raises hikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_stickers", "u": 8, "d": "Fetch the stickers of the guild. Returns typing.Sequence[hikari.stickers.GuildSticker] The requested stickers. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_sticker", "u": 8, "d": "Fetch a sticker from the guild. Parameters sticker : snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns hikari.stickers.GuildSticker The requested sticker. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.create_sticker", "u": 8, "d": "Create a sticker in a guild. Parameters name : builtins.str The name for the sticker.\ntag : builtins.str The tag for the sticker.\nimage : hikari.files.Resourceish The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie. ! note Lottie support is only available for verified and partnered servers. Other Parameters description: hikari.undefined.UndefinedOr[builtins.str] If provided, the description of the sticker.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The created sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.edit_sticker", "u": 8, "d": "Edit a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to edit. This can be a sticker object or the ID of an existing sticker. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the sticker.\ndescription : hikari.undefined.UndefinedOr[builtins.str] If provided, the new description for the sticker.\ntag : hikari.undefined.UndefinedOr[builtins.str] If provided, the new sticker tag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The edited sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.delete_sticker", "u": 8, "d": "Delete a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to delete. This can be a sticker object or the ID of an existing sticker. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.create_category", "u": 8, "d": "Create a category in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildCategory The created category. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.create_text_channel", "u": 8, "d": "Create a text channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildTextChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.create_news_channel", "u": 8, "d": "Create a news channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildNewsChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.create_voice_channel", "u": 8, "d": "Create a voice channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildVoiceChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the gui ld is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.create_stage_channel", "u": 8, "d": "Create a stage channel in the guild. Parameters name : builtins.str The channel's name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildStageChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.delete_channel", "u": 8, "d": "Delete a channel in the guild. ! note This method can also be used for deleting guild categories as well. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel or category to delete. This may be the object or the ID of an existing channel. Returns hikari.channels.GuildChannel Object of the channel or category that was deleted. Raises hikari.errors.UnauthorizedError, or close a DM. If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_self", "u": 8, "d": "Fetch the guild. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.fetch_roles", "u": 8, "d": "Fetch the roles of the guild. Returns typing.Sequence[hikari.guilds.Role] The requested roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GatewayGuild.app", "u": 8, "d": "The client application that models may use for procedures."}, {"r": "hikari.guilds.GatewayGuild.icon_hash", "u": 8, "d": "The hash for the guild icon, if there is one."}, {"r": "hikari.guilds.GatewayGuild.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.GatewayGuild.name", "u": 8, "d": "The name of the guild."}, {"r": "hikari.guilds.GatewayGuild.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.GuildWidget", "u": 8, "d": "Represents a guild widget. Method generated by attrs for class GuildWidget."}, {"r": "hikari.guilds.GuildWidget.fetch_channel", "u": 8, "d": "Fetch the widget channel. This will be builtins.None if not set. Returns typing.Optional[hikari.channels.GuildChannel] The requested channel. You can check the type of the channel by using builtins.isinstance . Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildWidget.app", "u": 8, "d": "The client application that models may use for procedures."}, {"r": "hikari.guilds.GuildWidget.channel_id", "u": 8, "d": "The ID of the channel the invite for this embed targets, if enabled."}, {"r": "hikari.guilds.GuildWidget.is_enabled", "u": 8, "d": "Whether this embed is enabled."}, {"r": "hikari.guilds.Role", "u": 8, "d": "Represents a guild bound Role object. Method generated by attrs for class Role."}, {"r": "hikari.guilds.Role.colour", "u": 8, "d": "Alias for the color field."}, {"r": "hikari.guilds.Role.bot_id", "u": 8, "d": "The ID of the bot this role belongs to. If builtins.None , this is not a bot role."}, {"r": "hikari.guilds.Role.color", "u": 8, "d": "The colour of this role. This will be applied to a member's name in chat if it's their top coloured role."}, {"r": "hikari.guilds.Role.guild_id", "u": 8, "d": "The ID of the guild this role belongs to"}, {"r": "hikari.guilds.Role.integration_id", "u": 8, "d": "The ID of the integration this role belongs to. If builtins.None , this is not a integration role."}, {"r": "hikari.guilds.Role.is_hoisted", "u": 8, "d": "Whether this role is hoisting the members it's attached to in the member list. members will be hoisted under their highest role where this is set to builtins.True ."}, {"r": "hikari.guilds.Role.is_managed", "u": 8, "d": "Whether this role is managed by an integration."}, {"r": "hikari.guilds.Role.is_mentionable", "u": 8, "d": "Whether this role can be mentioned by all regardless of permissions."}, {"r": "hikari.guilds.Role.is_premium_subscriber_role", "u": 8, "d": "Whether this role is the guild's nitro subscriber role."}, {"r": "hikari.guilds.Role.permissions", "u": 8, "d": "The guild wide permissions this role gives to the members it's attached to, This may be overridden by channel overwrites."}, {"r": "hikari.guilds.Role.position", "u": 8, "d": "The position of this role in the role hierarchy. This will start at 0 for the lowest role (@everyone)\nand increase as you go up the hierarchy."}, {"r": "hikari.guilds.Role.mention", "u": 8, "d": "Return a raw mention string for the role. Returns builtins.str The mention string to use."}, {"r": "hikari.guilds.Role.app", "u": 8, "d": "The client application that models may use for procedures."}, {"r": "hikari.guilds.Role.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.Role.name", "u": 8, "d": "The role's name."}, {"r": "hikari.guilds.Role.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.GuildFeature", "u": 8, "d": "Features that a guild can provide."}, {"r": "hikari.guilds.GuildFeature.name", "u": 8, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.guilds.GuildFeature.value", "u": 8, "d": "Return the value of the enum member."}, {"r": "hikari.guilds.GuildFeature.ANIMATED_ICON", "u": 8, "d": "Guild has access to set an animated guild icon."}, {"r": "hikari.guilds.GuildFeature.BANNER", "u": 8, "d": "Guild has access to set a guild banner image."}, {"r": "hikari.guilds.GuildFeature.COMMERCE", "u": 8, "d": "Guild has access to use commerce features (i.e. create store channels)."}, {"r": "hikari.guilds.GuildFeature.COMMUNITY", "u": 8, "d": "Guild has community features enabled."}, {"r": "hikari.guilds.GuildFeature.DISCOVERABLE", "u": 8, "d": "Guild is able to be discovered in the directory. This also implies the guild can be viewed without joining."}, {"r": "hikari.guilds.GuildFeature.FEATURABLE", "u": 8, "d": "Guild is able to be featured in the directory."}, {"r": "hikari.guilds.GuildFeature.INVITE_SPLASH", "u": 8, "d": "Guild has access to set an invite splash background."}, {"r": "hikari.guilds.GuildFeature.MORE_EMOJI", "u": 8, "d": "More emojis can be hosted in this guild than normal."}, {"r": "hikari.guilds.GuildFeature.NEWS", "u": 8, "d": "Guild has access to create news channels."}, {"r": "hikari.guilds.GuildFeature.PARTNERED", "u": 8, "d": "Guild is partnered."}, {"r": "hikari.guilds.GuildFeature.RELAY_ENABLED", "u": 8, "d": "Guild is using relays. Relays are new infrastructure designed to handle large guilds more\nefficiently server-side."}, {"r": "hikari.guilds.GuildFeature.VANITY_URL", "u": 8, "d": "Guild has access to set a vanity URL."}, {"r": "hikari.guilds.GuildFeature.VERIFIED", "u": 8, "d": "Guild is verified."}, {"r": "hikari.guilds.GuildFeature.VIP_REGIONS", "u": 8, "d": "Guild has access to set 384kbps bitrate in voice. Previously gave access to VIP voice servers."}, {"r": "hikari.guilds.GuildFeature.WELCOME_SCREEN_ENABLED", "u": 8, "d": "Guild has enabled the welcome screen."}, {"r": "hikari.guilds.GuildFeature.MEMBER_VERIFICATION_GATE_ENABLED", "u": 8, "d": "Guild has enabled Membership Screening."}, {"r": "hikari.guilds.GuildFeature.PREVIEW_ENABLED", "u": 8, "d": "Guild can be viewed before Membership Screening is complete."}, {"r": "hikari.guilds.GuildFeature.TICKETED_EVENTS_ENABLED", "u": 8, "d": "Guild has enabled ticketed events."}, {"r": "hikari.guilds.GuildFeature.MONETIZATION_ENABLED", "u": 8, "d": "Guild has enabled monetization."}, {"r": "hikari.guilds.GuildFeature.MORE_STICKERS", "u": 8, "d": "Guild has an increased custom stickers slots."}, {"r": "hikari.guilds.GuildSystemChannelFlag", "u": 8, "d": "Defines which features are suppressed in the system channel."}, {"r": "hikari.guilds.GuildSystemChannelFlag.name", "u": 8, "d": "Return the name of the flag combination as a builtins.str ."}, {"r": "hikari.guilds.GuildSystemChannelFlag.value", "u": 8, "d": "Return the builtins.int value of the flag."}, {"r": "hikari.guilds.GuildSystemChannelFlag.all", "u": 8, "d": "Check if all of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.any", "u": 8, "d": "Check if any of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.difference", "u": 8, "d": "Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction - operator.", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.intersection", "u": 8, "d": "Return a combination of flags that are set for both given values. Equivalent to using the \"AND\" & operator.", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.invert", "u": 8, "d": "Return a set of all flags not in the current set.", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.is_disjoint", "u": 8, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.is_subset", "u": 8, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.is_superset", "u": 8, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.none", "u": 8, "d": "Check if none of the given flags are part of this value. ! note This is essentially the opposite of Flag.any . Returns builtins.bool builtins.True if none of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.split", "u": 8, "d": "Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted typing.Sequence of each membe", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.symmetric_difference", "u": 8, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.union", "u": 8, "d": "Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\" ~ operator.", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.isdisjoint", "u": 8, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.issubset", "u": 8, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.issuperset", "u": 8, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.symmetricdifference", "u": 8, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.guilds.GuildSystemChannelFlag.NONE", "u": 8, "d": "Nothing is suppressed."}, {"r": "hikari.guilds.GuildSystemChannelFlag.SUPPRESS_USER_JOIN", "u": 8, "d": "Suppress displaying a message about new users joining."}, {"r": "hikari.guilds.GuildSystemChannelFlag.SUPPRESS_PREMIUM_SUBSCRIPTION", "u": 8, "d": "Suppress displaying a message when the guild is Nitro boosted."}, {"r": "hikari.guilds.GuildSystemChannelFlag.SUPPRESS_GUILD_REMINDER", "u": 8, "d": "Suppress displaying messages with guild setup tips."}, {"r": "hikari.guilds.GuildMessageNotificationsLevel", "u": 8, "d": "Represents the default notification level for new messages in a guild."}, {"r": "hikari.guilds.GuildMessageNotificationsLevel.name", "u": 8, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.guilds.GuildMessageNotificationsLevel.value", "u": 8, "d": "Return the value of the enum member."}, {"r": "hikari.guilds.GuildMessageNotificationsLevel.ALL_MESSAGES", "u": 8, "d": "Notify users when any message is sent."}, {"r": "hikari.guilds.GuildMessageNotificationsLevel.ONLY_MENTIONS", "u": 8, "d": "Only notify users when they are @mentioned."}, {"r": "hikari.guilds.GuildExplicitContentFilterLevel", "u": 8, "d": "Represents the explicit content filter setting for a guild."}, {"r": "hikari.guilds.GuildExplicitContentFilterLevel.name", "u": 8, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.guilds.GuildExplicitContentFilterLevel.value", "u": 8, "d": "Return the value of the enum member."}, {"r": "hikari.guilds.GuildExplicitContentFilterLevel.DISABLED", "u": 8, "d": "No explicit content filter."}, {"r": "hikari.guilds.GuildExplicitContentFilterLevel.MEMBERS_WITHOUT_ROLES", "u": 8, "d": "Filter posts from anyone without a role."}, {"r": "hikari.guilds.GuildExplicitContentFilterLevel.ALL_MEMBERS", "u": 8, "d": "Filter all posts."}, {"r": "hikari.guilds.GuildMFALevel", "u": 8, "d": "Represents the multi-factor authorization requirement for a guild."}, {"r": "hikari.guilds.GuildMFALevel.name", "u": 8, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.guilds.GuildMFALevel.value", "u": 8, "d": "Return the value of the enum member."}, {"r": "hikari.guilds.GuildMFALevel.NONE", "u": 8, "d": "No MFA requirement."}, {"r": "hikari.guilds.GuildMFALevel.ELEVATED", "u": 8, "d": "MFA requirement."}, {"r": "hikari.guilds.GuildVerificationLevel", "u": 8, "d": "Represents the level of verification of a guild."}, {"r": "hikari.guilds.GuildVerificationLevel.name", "u": 8, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.guilds.GuildVerificationLevel.value", "u": 8, "d": "Return the value of the enum member."}, {"r": "hikari.guilds.GuildVerificationLevel.NONE", "u": 8, "d": "Unrestricted."}, {"r": "hikari.guilds.GuildVerificationLevel.LOW", "u": 8, "d": "Must have a verified email on their account."}, {"r": "hikari.guilds.GuildVerificationLevel.MEDIUM", "u": 8, "d": "Must have been registered on Discord for more than 5 minutes."}, {"r": "hikari.guilds.GuildVerificationLevel.HIGH", "u": 8, "d": "Must also be a member of the guild for longer than 10 minutes."}, {"r": "hikari.guilds.GuildVerificationLevel.VERY_HIGH", "u": 8, "d": "Must have a verified phone number."}, {"r": "hikari.guilds.GuildPremiumTier", "u": 8, "d": "Tier for Discord Nitro boosting in a guild."}, {"r": "hikari.guilds.GuildPremiumTier.name", "u": 8, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.guilds.GuildPremiumTier.value", "u": 8, "d": "Return the value of the enum member."}, {"r": "hikari.guilds.GuildPremiumTier.NONE", "u": 8, "d": "No Nitro boost level."}, {"r": "hikari.guilds.GuildPremiumTier.TIER_1", "u": 8, "d": "Level 1 Nitro boost."}, {"r": "hikari.guilds.GuildPremiumTier.TIER_2", "u": 8, "d": "Level 2 Nitro boost."}, {"r": "hikari.guilds.GuildPremiumTier.TIER_3", "u": 8, "d": "Level 3 Nitro boost."}, {"r": "hikari.guilds.GuildPreview", "u": 8, "d": "A preview of a guild with the GuildFeature.DISCOVERABLE feature. Method generated by attrs for class GuildPreview."}, {"r": "hikari.guilds.GuildPreview.discovery_splash_url", "u": 8, "d": "Discovery URL splash for the guild, if set."}, {"r": "hikari.guilds.GuildPreview.splash_url", "u": 8, "d": "Splash URL for the guild, if set."}, {"r": "hikari.guilds.GuildPreview.make_discovery_splash_url", "u": 8, "d": "Generate the guild's discovery splash image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The string URL. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.GuildPreview.make_splash_url", "u": 8, "d": "Generate the guild's splash image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the splash, or builtins.None if not set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.GuildPreview.approximate_active_member_count", "u": 8, "d": "The approximate amount of presences in this guild."}, {"r": "hikari.guilds.GuildPreview.approximate_member_count", "u": 8, "d": "The approximate amount of members in this guild."}, {"r": "hikari.guilds.GuildPreview.description", "u": 8, "d": "The guild's description, if set."}, {"r": "hikari.guilds.GuildPreview.discovery_splash_hash", "u": 8, "d": "The hash of the discovery splash for the guild, if there is one."}, {"r": "hikari.guilds.GuildPreview.emojis", "u": 8, "d": "The mapping of IDs to the emojis this guild provides."}, {"r": "hikari.guilds.GuildPreview.features", "u": 8, "d": "A list of the features in this guild."}, {"r": "hikari.guilds.GuildPreview.splash_hash", "u": 8, "d": "The hash of the splash for the guild, if there is one."}, {"r": "hikari.guilds.GuildPreview.icon_url", "u": 8, "d": "Icon URL for the guild, if set; otherwise builtins.None ."}, {"r": "hikari.guilds.GuildPreview.shard_id", "u": 8, "d": "Return the ID of the shard this guild is served by. This may return None if the application does not have a gateway\nconnection."}, {"r": "hikari.guilds.GuildPreview.make_icon_url", "u": 8, "d": "Generate the guild's icon URL, if set. Parameters ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the resource, or builtins.None if no icon is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.GuildPreview.ban", "u": 8, "d": "Ban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to ban from the guild Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.unban", "u": 8, "d": "Unban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to unban from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.kick", "u": 8, "d": "Kicks the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to kick from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.edit", "u": 8, "d": "Edits the guild. Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild.\nverification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level.\ndefault_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level.\nexplicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level.\nafk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires afk_timeout to be set to work.\nafk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout.\nicon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature.\nowner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner. ! warning You need to be the owner of the server to use this.\nsplash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the INVITE_SPLASH feature.\nbanner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the BANNER feature.\nsystem_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel.\nrules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel.\npublic_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel.\npreferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.RESTGuild The edited guild. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission or if you tried to pass ownership without being the server owner.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.fetch_emojis", "u": 8, "d": "Fetch the emojis of the guild. Returns typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.fetch_emoji", "u": 8, "d": "Fetch an emoji from the guild. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns hikari.emojis.KnownCustomEmoji The requested emoji. Raises hikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.fetch_stickers", "u": 8, "d": "Fetch the stickers of the guild. Returns typing.Sequence[hikari.stickers.GuildSticker] The requested stickers. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.fetch_sticker", "u": 8, "d": "Fetch a sticker from the guild. Parameters sticker : snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns hikari.stickers.GuildSticker The requested sticker. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.create_sticker", "u": 8, "d": "Create a sticker in a guild. Parameters name : builtins.str The name for the sticker.\ntag : builtins.str The tag for the sticker.\nimage : hikari.files.Resourceish The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie. ! note Lottie support is only available for verified and partnered servers. Other Parameters description: hikari.undefined.UndefinedOr[builtins.str] If provided, the description of the sticker.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The created sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.edit_sticker", "u": 8, "d": "Edit a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to edit. This can be a sticker object or the ID of an existing sticker. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the sticker.\ndescription : hikari.undefined.UndefinedOr[builtins.str] If provided, the new description for the sticker.\ntag : hikari.undefined.UndefinedOr[builtins.str] If provided, the new sticker tag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The edited sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.delete_sticker", "u": 8, "d": "Delete a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to delete. This can be a sticker object or the ID of an existing sticker. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.create_category", "u": 8, "d": "Create a category in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildCategory The created category. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.create_text_channel", "u": 8, "d": "Create a text channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildTextChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.create_news_channel", "u": 8, "d": "Create a news channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildNewsChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.create_voice_channel", "u": 8, "d": "Create a voice channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildVoiceChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the gui ld is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.create_stage_channel", "u": 8, "d": "Create a stage channel in the guild. Parameters name : builtins.str The channel's name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildStageChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.delete_channel", "u": 8, "d": "Delete a channel in the guild. ! note This method can also be used for deleting guild categories as well. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel or category to delete. This may be the object or the ID of an existing channel. Returns hikari.channels.GuildChannel Object of the channel or category that was deleted. Raises hikari.errors.UnauthorizedError, or close a DM. If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.guilds.GuildPreview.fetch_self", "u": 8, "d": "Fetch the guild. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.fetch_roles", "u": 8, "d": "Fetch the roles of the guild. Returns typing.Sequence[hikari.guilds.Role] The requested roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.GuildPreview.app", "u": 8, "d": "The client application that models may use for procedures."}, {"r": "hikari.guilds.GuildPreview.icon_hash", "u": 8, "d": "The hash for the guild icon, if there is one."}, {"r": "hikari.guilds.GuildPreview.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.GuildPreview.name", "u": 8, "d": "The name of the guild."}, {"r": "hikari.guilds.GuildPreview.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.GuildBan", "u": 8, "d": "Used to represent guild bans. Method generated by attrs for class GuildBan."}, {"r": "hikari.guilds.GuildBan.reason", "u": 8, "d": "The reason for this ban, will be builtins.None if no reason was given."}, {"r": "hikari.guilds.GuildBan.user", "u": 8, "d": "The object of the user this ban targets."}, {"r": "hikari.guilds.GuildNSFWLevel", "u": 8, "d": "Represents the NSFW level of a guild."}, {"r": "hikari.guilds.GuildNSFWLevel.name", "u": 8, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.guilds.GuildNSFWLevel.value", "u": 8, "d": "Return the value of the enum member."}, {"r": "hikari.guilds.GuildNSFWLevel.DEFAULT", "u": 8, "d": "Guild has not been categorized yet."}, {"r": "hikari.guilds.GuildNSFWLevel.EXPLICIT", "u": 8, "d": "Guild contains explicit NSFW content."}, {"r": "hikari.guilds.GuildNSFWLevel.SAFE", "u": 8, "d": "Guild is safe of NSFW content."}, {"r": "hikari.guilds.GuildNSFWLevel.AGE_RESTRICTED", "u": 8, "d": "Guild may contain NSFW content."}, {"r": "hikari.guilds.Member", "u": 8, "d": "Used to represent a guild bound member. Method generated by attrs for class Member."}, {"r": "hikari.guilds.Member.app", "u": 8, "d": "Return the app that is bound to the user object."}, {"r": "hikari.guilds.Member.avatar_hash", "u": 8, "d": "Avatar hash for the user, if they have one, otherwise builtins.None ."}, {"r": "hikari.guilds.Member.avatar_url", "u": 8, "d": "Avatar URL for the user, if they have one set. May be builtins.None if no custom avatar is set. In this case, you\nshould use default_avatar_url instead."}, {"r": "hikari.guilds.Member.default_avatar_url", "u": 8, "d": "Default avatar URL for this user."}, {"r": "hikari.guilds.Member.discriminator", "u": 8, "d": "Discriminator for the user."}, {"r": "hikari.guilds.Member.display_name", "u": 8, "d": "Return the member's display name. If the member has a nickname, this will return that nickname.\nOtherwise, it will return the username instead. Returns builtins.str The member display name. See Also Nickname: Member.nickname Username: Member.username "}, {"r": "hikari.guilds.Member.flags", "u": 8, "d": "Flag bits that are set for the user."}, {"r": "hikari.guilds.Member.id", "u": 8, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.guilds.Member.is_bot", "u": 8, "d": " builtins.True if this user is a bot account, builtins.False otherwise."}, {"r": "hikari.guilds.Member.is_system", "u": 8, "d": " builtins.True if this user is a system account, builtins.False otherwise."}, {"r": "hikari.guilds.Member.mention", "u": 8, "d": "Return a raw mention string for the given member. If the member has a known nickname, we always return\na bang (\" ! \") before the ID part of the mention string. This\nmimics the behaviour Discord clients tend to provide. Example  \n>>> some_member_without_nickname.mention\n'<@123456789123456789>'\n>>> some_member_with_nickname.mention\n'<@!123456789123456789>' Returns builtins.str The mention string to use."}, {"r": "hikari.guilds.Member.get_presence", "u": 8, "d": "Get the cached presence for this member, if known. Presence info includes user status and activities. This requires the GUILD_PRESENCES intent to be enabled. Returns typing.Optional[hikari.presences.MemberPresence] The member presence, or builtins.None if not known.", "f": 1}, {"r": "hikari.guilds.Member.get_roles", "u": 8, "d": "Return the roles the user has. This will be empty if the roles are missing from the cache. Returns typing.Sequence[hikari.guilds.Role] The roles the users has.", "f": 1}, {"r": "hikari.guilds.Member.get_top_role", "u": 8, "d": "Return the highest role the member has. Returns typing.Optional[hikari.guilds.Role] builtins.None if the cache is missing the roles information or the highest role the user has.", "f": 1}, {"r": "hikari.guilds.Member.username", "u": 8, "d": "Username for the user."}, {"r": "hikari.guilds.Member.make_avatar_url", "u": 8, "d": "Generate the avatar URL for this user, if set. If no custom avatar is set, this returns builtins.None . You can then\nuse the default_avatar_url attribute instead to fetch the displayed\nURL. Parameters ext : typing.Optional[builtins.str] The ext to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). Will be ignored for default avatars which can only be png . If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns typing.Optional[hikari.files.URL] The URL to the avatar, or builtins.None if not present. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.Member.fetch_self", "u": 8, "d": "Fetch an up-to-date view of this member from the API. Returns hikari.guilds.Member An up-to-date view of this member. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the member is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Member.fetch_dm_channel", "u": 8, "d": "Fetch the DM channel for this user. Returns hikari.channels.DMChannel The requested channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Member.fetch_roles", "u": 8, "d": "Fetch an up-to-date view of this member's roles from the API. Returns typing.Sequence[hikari.guilds.Role] An up-to-date view of this member's roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the member is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Member.ban", "u": 8, "d": "Ban this member from this guild. Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Member.unban", "u": 8, "d": "Unban this member from the guild. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Member.kick", "u": 8, "d": "Kick this member from this guild. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Member.add_role", "u": 8, "d": "Add a role to the member. Parameters role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to add. This may be the object or the ID of an existing role. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild, user or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Member.remove_role", "u": 8, "d": "Remove a role from the member. Parameters role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to remove. This may be the object or the ID of an existing role. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild, user or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Member.edit", "u": 8, "d": "Edit the member. Other Parameters nick : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new nick for the member. If builtins.None , will remove the members nick. Requires the MANAGE_NICKNAMES permission.\nroles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, the new roles for the member. Requires the MANAGE_ROLES permission.\nmute : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server mute state for the member. Requires the MUTE_MEMBERS permission.\ndeaf : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server deaf state for the member. Requires the DEAFEN_MEMBERS permission.\nvoice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel ] If provided, builtins.None or the object or the ID of an existing voice channel to move the member to. If builtins.None , will disconnect the member from voice. Requires the MOVE_MEMBERS permission and the CONNECT permission in the original voice channel and the target voice channel. ! note If the member is not in a voice channel, this will take no effect.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.Member Object of the member that was updated. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing a permission to do an action.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or the user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Member.guild_id", "u": 8, "d": "The ID of the guild this member belongs to."}, {"r": "hikari.guilds.Member.is_deaf", "u": 8, "d": " builtins.True if this member is deafened in the current voice channel. This will be hikari.undefined.UNDEFINED if it's state is\nunknown."}, {"r": "hikari.guilds.Member.is_mute", "u": 8, "d": " builtins.True if this member is muted in the current voice channel. This will be hikari.undefined.UNDEFINED if it's state is unknown."}, {"r": "hikari.guilds.Member.is_pending", "u": 8, "d": "Whether the user has passed the guild's membership screening requirements. This will be hikari.undefined.UNDEFINED if it's state is unknown."}, {"r": "hikari.guilds.Member.joined_at", "u": 8, "d": "The datetime of when this member joined the guild they belong to."}, {"r": "hikari.guilds.Member.nickname", "u": 8, "d": "This member's nickname. This will be builtins.None if not set."}, {"r": "hikari.guilds.Member.premium_since", "u": 8, "d": "The datetime of when this member started \"boosting\" this guild. Will be builtins.None if the member is not a premium user."}, {"r": "hikari.guilds.Member.role_ids", "u": 8, "d": "A sequence of the IDs of the member's current roles."}, {"r": "hikari.guilds.Member.user", "u": 8, "d": "This member's corresponding user object."}, {"r": "hikari.guilds.Member.send", "u": 8, "d": "Send a message to this user in DM's. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nnonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled.\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.Member.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.Integration", "u": 8, "d": "Represents a guild integration object. Method generated by attrs for class Integration."}, {"r": "hikari.guilds.Integration.application", "u": 8, "d": "The bot/OAuth2 application associated with this integration. ! note This is only available for Discord integrations."}, {"r": "hikari.guilds.Integration.expire_behavior", "u": 8, "d": "How members should be treated after their connected subscription expires. This will not be enacted until after GuildIntegration.expire_grace_period passes. ! note This will always be builtins.None for Discord integrations."}, {"r": "hikari.guilds.Integration.expire_grace_period", "u": 8, "d": "How many days users with expired subscriptions are given until GuildIntegration.expire_behavior is enacted out on them. ! note This will always be builtins.None for Discord integrations."}, {"r": "hikari.guilds.Integration.guild_id", "u": 8, "d": "The ID of the guild this integration belongs to."}, {"r": "hikari.guilds.Integration.is_emojis_enabled", "u": 8, "d": "Whether users under this integration are allowed to use it's custom emojis."}, {"r": "hikari.guilds.Integration.is_enabled", "u": 8, "d": "Whether this integration is enabled."}, {"r": "hikari.guilds.Integration.is_revoked", "u": 8, "d": "Whether the integration has been revoked."}, {"r": "hikari.guilds.Integration.is_syncing", "u": 8, "d": "Whether this integration is syncing subscribers/emojis."}, {"r": "hikari.guilds.Integration.last_synced_at", "u": 8, "d": "The datetime of when this integration's subscribers were last synced."}, {"r": "hikari.guilds.Integration.role_id", "u": 8, "d": "The ID of the managed role used for this integration's subscribers."}, {"r": "hikari.guilds.Integration.subscriber_count", "u": 8, "d": "The number of subscribers this integration has."}, {"r": "hikari.guilds.Integration.user", "u": 8, "d": "The user this integration belongs to."}, {"r": "hikari.guilds.Integration.account", "u": 8, "d": "The account connected to this integration."}, {"r": "hikari.guilds.Integration.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.Integration.name", "u": 8, "d": "The name of this integration."}, {"r": "hikari.guilds.Integration.type", "u": 8, "d": "The type of this integration."}, {"r": "hikari.guilds.Integration.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.IntegrationAccount", "u": 8, "d": "An account that's linked to an integration. Method generated by attrs for class IntegrationAccount."}, {"r": "hikari.guilds.IntegrationAccount.id", "u": 8, "d": "The string ID of this (likely) third party account."}, {"r": "hikari.guilds.IntegrationAccount.name", "u": 8, "d": "The name of this account."}, {"r": "hikari.guilds.IntegrationType", "u": 8, "d": "The integration type."}, {"r": "hikari.guilds.IntegrationType.name", "u": 8, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.guilds.IntegrationType.value", "u": 8, "d": "Return the value of the enum member."}, {"r": "hikari.guilds.IntegrationType.TWITCH", "u": 8, "d": ""}, {"r": "hikari.guilds.IntegrationType.YOUTUBE", "u": 8, "d": ""}, {"r": "hikari.guilds.IntegrationType.DISCORD_BOT", "u": 8, "d": ""}, {"r": "hikari.guilds.IntegrationApplication", "u": 8, "d": "An application that's linked to an integration. Method generated by attrs for class IntegrationApplication."}, {"r": "hikari.guilds.IntegrationApplication.bot", "u": 8, "d": "The bot associated with this application."}, {"r": "hikari.guilds.IntegrationApplication.icon_url", "u": 8, "d": "Team icon URL, if there is one. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists."}, {"r": "hikari.guilds.IntegrationApplication.make_icon_url", "u": 8, "d": "Generate the icon URL for this application. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists. Raises builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.guilds.IntegrationApplication.description", "u": 8, "d": "The description of this application, if any."}, {"r": "hikari.guilds.IntegrationApplication.icon_hash", "u": 8, "d": "The CDN hash of this application's icon, if set."}, {"r": "hikari.guilds.IntegrationApplication.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.IntegrationApplication.name", "u": 8, "d": "The name of this application."}, {"r": "hikari.guilds.IntegrationApplication.summary", "u": 8, "d": "This summary for this application's primary SKU if it's sold on Discord, if any."}, {"r": "hikari.guilds.IntegrationApplication.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.IntegrationExpireBehaviour", "u": 8, "d": "Behavior for expiring integration subscribers."}, {"r": "hikari.guilds.IntegrationExpireBehaviour.name", "u": 8, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.guilds.IntegrationExpireBehaviour.value", "u": 8, "d": "Return the value of the enum member."}, {"r": "hikari.guilds.IntegrationExpireBehaviour.REMOVE_ROLE", "u": 8, "d": "Remove the role."}, {"r": "hikari.guilds.IntegrationExpireBehaviour.KICK", "u": 8, "d": "Kick the subscriber."}, {"r": "hikari.guilds.PartialApplication", "u": 8, "d": "A partial representation of a Discord application. Method generated by attrs for class PartialApplication."}, {"r": "hikari.guilds.PartialApplication.icon_url", "u": 8, "d": "Team icon URL, if there is one. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists."}, {"r": "hikari.guilds.PartialApplication.make_icon_url", "u": 8, "d": "Generate the icon URL for this application. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon exists. Raises builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.guilds.PartialApplication.description", "u": 8, "d": "The description of this application, if any."}, {"r": "hikari.guilds.PartialApplication.icon_hash", "u": 8, "d": "The CDN hash of this application's icon, if set."}, {"r": "hikari.guilds.PartialApplication.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.PartialApplication.name", "u": 8, "d": "The name of this application."}, {"r": "hikari.guilds.PartialApplication.summary", "u": 8, "d": "This summary for this application's primary SKU if it's sold on Discord, if any."}, {"r": "hikari.guilds.PartialApplication.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.PartialGuild", "u": 8, "d": "Base object for any partial guild objects. Method generated by attrs for class PartialGuild."}, {"r": "hikari.guilds.PartialGuild.icon_url", "u": 8, "d": "Icon URL for the guild, if set; otherwise builtins.None ."}, {"r": "hikari.guilds.PartialGuild.shard_id", "u": 8, "d": "Return the ID of the shard this guild is served by. This may return None if the application does not have a gateway\nconnection."}, {"r": "hikari.guilds.PartialGuild.make_icon_url", "u": 8, "d": "Generate the guild's icon URL, if set. Parameters ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the resource, or builtins.None if no icon is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.guilds.PartialGuild.ban", "u": 8, "d": "Ban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to ban from the guild Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.unban", "u": 8, "d": "Unban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to unban from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.kick", "u": 8, "d": "Kicks the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to kick from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.edit", "u": 8, "d": "Edits the guild. Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild.\nverification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level.\ndefault_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level.\nexplicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level.\nafk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires afk_timeout to be set to work.\nafk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout.\nicon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature.\nowner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner. ! warning You need to be the owner of the server to use this.\nsplash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the INVITE_SPLASH feature.\nbanner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the BANNER feature.\nsystem_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel.\nrules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel.\npublic_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel.\npreferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.RESTGuild The edited guild. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission or if you tried to pass ownership without being the server owner.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.fetch_emojis", "u": 8, "d": "Fetch the emojis of the guild. Returns typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.fetch_emoji", "u": 8, "d": "Fetch an emoji from the guild. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns hikari.emojis.KnownCustomEmoji The requested emoji. Raises hikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.fetch_stickers", "u": 8, "d": "Fetch the stickers of the guild. Returns typing.Sequence[hikari.stickers.GuildSticker] The requested stickers. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.fetch_sticker", "u": 8, "d": "Fetch a sticker from the guild. Parameters sticker : snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns hikari.stickers.GuildSticker The requested sticker. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.create_sticker", "u": 8, "d": "Create a sticker in a guild. Parameters name : builtins.str The name for the sticker.\ntag : builtins.str The tag for the sticker.\nimage : hikari.files.Resourceish The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie. ! note Lottie support is only available for verified and partnered servers. Other Parameters description: hikari.undefined.UndefinedOr[builtins.str] If provided, the description of the sticker.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The created sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.edit_sticker", "u": 8, "d": "Edit a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to edit. This can be a sticker object or the ID of an existing sticker. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the sticker.\ndescription : hikari.undefined.UndefinedOr[builtins.str] If provided, the new description for the sticker.\ntag : hikari.undefined.UndefinedOr[builtins.str] If provided, the new sticker tag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The edited sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.delete_sticker", "u": 8, "d": "Delete a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to delete. This can be a sticker object or the ID of an existing sticker. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.create_category", "u": 8, "d": "Create a category in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildCategory The created category. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.create_text_channel", "u": 8, "d": "Create a text channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildTextChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.create_news_channel", "u": 8, "d": "Create a news channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildNewsChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.create_voice_channel", "u": 8, "d": "Create a voice channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildVoiceChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the gui ld is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.create_stage_channel", "u": 8, "d": "Create a stage channel in the guild. Parameters name : builtins.str The channel's name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildStageChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.delete_channel", "u": 8, "d": "Delete a channel in the guild. ! note This method can also be used for deleting guild categories as well. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel or category to delete. This may be the object or the ID of an existing channel. Returns hikari.channels.GuildChannel Object of the channel or category that was deleted. Raises hikari.errors.UnauthorizedError, or close a DM. If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.guilds.PartialGuild.fetch_self", "u": 8, "d": "Fetch the guild. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.fetch_roles", "u": 8, "d": "Fetch the roles of the guild. Returns typing.Sequence[hikari.guilds.Role] The requested roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.guilds.PartialGuild.app", "u": 8, "d": "The client application that models may use for procedures."}, {"r": "hikari.guilds.PartialGuild.icon_hash", "u": 8, "d": "The hash for the guild icon, if there is one."}, {"r": "hikari.guilds.PartialGuild.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.PartialGuild.name", "u": 8, "d": "The name of the guild."}, {"r": "hikari.guilds.PartialGuild.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.PartialIntegration", "u": 8, "d": "A partial representation of an integration, found in audit logs. Method generated by attrs for class PartialIntegration."}, {"r": "hikari.guilds.PartialIntegration.account", "u": 8, "d": "The account connected to this integration."}, {"r": "hikari.guilds.PartialIntegration.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.PartialIntegration.name", "u": 8, "d": "The name of this integration."}, {"r": "hikari.guilds.PartialIntegration.type", "u": 8, "d": "The type of this integration."}, {"r": "hikari.guilds.PartialIntegration.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.PartialRole", "u": 8, "d": "Represents a partial guild bound Role object. Method generated by attrs for class PartialRole."}, {"r": "hikari.guilds.PartialRole.mention", "u": 8, "d": "Return a raw mention string for the role. Returns builtins.str The mention string to use."}, {"r": "hikari.guilds.PartialRole.app", "u": 8, "d": "The client application that models may use for procedures."}, {"r": "hikari.guilds.PartialRole.id", "u": 8, "d": "The ID of this entity."}, {"r": "hikari.guilds.PartialRole.name", "u": 8, "d": "The role's name."}, {"r": "hikari.guilds.PartialRole.created_at", "u": 8, "d": "When the object was created."}, {"r": "hikari.guilds.WelcomeScreen", "u": 8, "d": "Used to represent guild welcome screens on Discord. Method generated by attrs for class WelcomeScreen."}, {"r": "hikari.guilds.WelcomeScreen.channels", "u": 8, "d": "An array of up to 5 of the channels shown in the welcome screen."}, {"r": "hikari.guilds.WelcomeScreen.description", "u": 8, "d": "The guild's description shown in the welcome screen."}, {"r": "hikari.guilds.WelcomeChannel", "u": 8, "d": "Used to represent channels on guild welcome screens. Method generated by attrs for class WelcomeChannel."}, {"r": "hikari.guilds.WelcomeChannel.channel_id", "u": 8, "d": "ID of the channel shown in the welcome screen."}, {"r": "hikari.guilds.WelcomeChannel.description", "u": 8, "d": "The description shown for this channel."}, {"r": "hikari.guilds.WelcomeChannel.emoji_id", "u": 8, "d": "ID of the emoji shown in the welcome screen channel if it's set to a custom emoji."}, {"r": "hikari.guilds.WelcomeChannel.emoji_name", "u": 8, "d": "The emoji shown in the welcome screen channel if set to a unicode emoji. ! warning While it may also be present for custom emojis, this is neither guaranteed to be provided nor accurate."}, {"r": "hikari.events", "u": 9, "d": "Events that can be fired by Hikari's gateway implementation."}, {"r": "hikari.events.base_events", "u": 10, "d": "Base types and functions for events in Hikari."}, {"r": "hikari.events.base_events.Event", "u": 10, "d": "Base event type that all Hikari events should subclass."}, {"r": "hikari.events.base_events.Event.app", "u": 10, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.base_events.ExceptionEvent", "u": 10, "d": "Event that is raised when another event handler raises an Exception . ! note Only exceptions that derive from builtins.Exception will be caught. Other exceptions outside this range will propagate past this callback. This prevents event handlers interfering with critical exceptions such as KeyboardError which would have potentially undesired side-effects on the application runtime. ! warning Any exceptions raised by handlers for this event will be dumped to the application logger and silently discarded, preventing recursive loops produced by faulty exception event handling. Thus, it is imperative that you ensure any exceptions are explicitly caught within handlers for this event if they may occur. Method generated by attrs for class ExceptionEvent."}, {"r": "hikari.events.base_events.ExceptionEvent.app", "u": 10, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.base_events.ExceptionEvent.shard", "u": 10, "d": "Shard that received the event, if there was one associated. Returns typing.Optional[hikari.api.shard.GatewayShard] Shard that raised this exception. This may be builtins.None if no specific shard was the cause of this exception (e.g. when starting up or shutting down)."}, {"r": "hikari.events.base_events.ExceptionEvent.exc_info", "u": 10, "d": "Exception triplet that follows the same format as sys.exc_info . Returns builtins.tuple[typing.Type[Exception], Exception, typing.Optional[types.TracebackType The sys.exc_info -compatible tuple of the exception type, the exception instance, and the traceback of the exception."}, {"r": "hikari.events.base_events.ExceptionEvent.retry", "u": 10, "d": "Invoke the failed event again. If an exception is thrown this time, it will need to be manually\ncaught in-code, or will be discarded.", "f": 1}, {"r": "hikari.events.base_events.ExceptionEvent.exception", "u": 10, "d": "Exception that was raised. Returns builtins.Exception Exception that was raised in the event handler."}, {"r": "hikari.events.base_events.ExceptionEvent.failed_callback", "u": 10, "d": "Event callback that threw an exception. Returns callback Event callback that failed execution."}, {"r": "hikari.events.base_events.ExceptionEvent.failed_event", "u": 10, "d": "Event instance that caused the exception. Returns hikari.events.base_events.Event Event that was being processed when the exception occurred."}, {"r": "hikari.events.base_events.is_no_recursive_throw_event", "u": 10, "d": "Return True if this event is marked as ___norecursivethrow___ .", "f": 1}, {"r": "hikari.events.base_events.no_recursive_throw", "u": 10, "d": "Decorate an event type to indicate errors should not be handled. This is useful for exception event types that you do not want to\nhave invoked recursively.", "f": 1}, {"r": "hikari.events.base_events.get_required_intents_for", "u": 10, "d": "Retrieve the intents that are required to listen to an event type. Parameters event_type : typing.Type[Event] The event type to get required intents for. Returns typing.Collection[hikari.intents.Intents] Collection of acceptable subset combinations of intent needed to be able to receive the given event type.", "f": 1}, {"r": "hikari.events.base_events.requires_intents", "u": 10, "d": "Decorate an event type to define what intents it requires. Parameters first : hikari.intents.Intents First combination of intents that are acceptable in order to receive the decorated event type. rest : hikari.intents.Intents Zero or more additional combinations of intents to require for this event to be subscribed to.", "f": 1}, {"r": "hikari.events.guild_events", "u": 11, "d": "Events that fire when something occurs within a guild."}, {"r": "hikari.events.guild_events.GuildEvent", "u": 11, "d": "Event base for any guild-bound event. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS - hikari.intents.Intents.GUILD_BANS - hikari.intents.Intents.GUILD_EMOJIS - hikari.intents.Intents.GUILD_PRESENCES "}, {"r": "hikari.events.guild_events.GuildEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.GuildEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.GuildEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.GuildEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.GuildVisibilityEvent", "u": 11, "d": "Event base for any event that changes the visibility of a guild. This includes when a guild becomes available after an outage, when a\nguild becomes available on startup, when a guild becomes unavailable due\nto an outage, when the user is kicked/banned/leaves a guild, or when\nthe user joins a new guild. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS "}, {"r": "hikari.events.guild_events.GuildVisibilityEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.GuildVisibilityEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildVisibilityEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildVisibilityEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.GuildVisibilityEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.GuildVisibilityEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.GuildAvailableEvent", "u": 11, "d": "Event fired when a guild becomes available. This will occur on startup, after outages, and if the bot joins a new guild. ! note Some fields like members and presences are included here but not on the other GuildUpdateEvent and GuildUnavailableEvent guild visibility event models. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class GuildAvailableEvent."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.channels", "u": 11, "d": "Mapping of channel IDs to the channels in the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] The channels in the guild."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.chunk_nonce", "u": 11, "d": "Nonce used to request the member chunks for this guild. This will be builtins.None if no chunks were requested. ! note This is a synthetic field. Returns typing.Optional[builtins.str] The nonce used to request the member chunks."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.emojis", "u": 11, "d": "Mapping of emoji IDs to the emojis in the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] The emojis in the guild."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.guild", "u": 11, "d": "Guild that just became available. Returns hikari.guilds.Guild The guild that relates to this event."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.members", "u": 11, "d": "Mapping of user IDs to the members in the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.guilds.Member] The members in the guild."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.presences", "u": 11, "d": "Mapping of user IDs to the presences for the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] The member presences in the guild."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.roles", "u": 11, "d": "Mapping of role IDs to the roles in the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.guilds.Role] The roles in the guild."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.voice_states", "u": 11, "d": "Mapping of user IDs to the voice states active in this guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] The voice states active in the guild."}, {"r": "hikari.events.guild_events.GuildAvailableEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildAvailableEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildAvailableEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.GuildUnavailableEvent", "u": 11, "d": "Event fired when a guild becomes unavailable because of an outage. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class GuildUnavailableEvent."}, {"r": "hikari.events.guild_events.GuildUnavailableEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.GuildUnavailableEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.GuildUnavailableEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.GuildUnavailableEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildUnavailableEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildUnavailableEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.GuildLeaveEvent", "u": 11, "d": "Event fired when the bot is banned/kicked/leaves a guild. This will also fire if the guild was deleted. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class GuildLeaveEvent."}, {"r": "hikari.events.guild_events.GuildLeaveEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.GuildLeaveEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.GuildLeaveEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.GuildLeaveEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildLeaveEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildLeaveEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.GuildUpdateEvent", "u": 11, "d": "Event fired when an existing guild is updated. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class GuildUpdateEvent."}, {"r": "hikari.events.guild_events.GuildUpdateEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.GuildUpdateEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.GuildUpdateEvent.emojis", "u": 11, "d": "Mapping of emoji IDs to the emojis in the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] The emojis in the guild."}, {"r": "hikari.events.guild_events.GuildUpdateEvent.guild", "u": 11, "d": "Guild that was just updated. Returns hikari.guilds.Guild The guild that relates to this event."}, {"r": "hikari.events.guild_events.GuildUpdateEvent.old_guild", "u": 11, "d": "The old guild object. This will be builtins.None if the guild missing from the cache."}, {"r": "hikari.events.guild_events.GuildUpdateEvent.roles", "u": 11, "d": "Mapping of role IDs to the roles in the guild. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.guilds.Role] The roles in the guild."}, {"r": "hikari.events.guild_events.GuildUpdateEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.GuildUpdateEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildUpdateEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.GuildUpdateEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.BanEvent", "u": 11, "d": "Event base for any guild ban or unban. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_BANS "}, {"r": "hikari.events.guild_events.BanEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.BanEvent.user", "u": 11, "d": "User that this ban event affects. Returns hikari.users.User The user that this event concerns."}, {"r": "hikari.events.guild_events.BanEvent.fetch_user", "u": 11, "d": "Perform an API call to fetch the user this ban event affects. Returns hikari.users.User The user affected by this event.", "f": 1}, {"r": "hikari.events.guild_events.BanEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.BanEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.BanEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.BanEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.BanEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.BanCreateEvent", "u": 11, "d": "Event that is fired when a user is banned from a guild. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_BANS Method generated by attrs for class BanCreateEvent."}, {"r": "hikari.events.guild_events.BanCreateEvent.user_id", "u": 11, "d": "User ID of the user that got banned. Returns hikari.snowflakes.Snowflake ID of the user the event concerns."}, {"r": "hikari.events.guild_events.BanCreateEvent.fetch_ban", "u": 11, "d": "Perform an API call to fetch the details about this ban. This will include the optionally defined audit log reason for the\nban. Returns hikari.guilds.GuildBan The ban details.", "f": 1}, {"r": "hikari.events.guild_events.BanCreateEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.BanCreateEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.BanCreateEvent.user", "u": 11, "d": "User that this ban event affects. Returns hikari.users.User The user that this event concerns."}, {"r": "hikari.events.guild_events.BanCreateEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.BanCreateEvent.fetch_user", "u": 11, "d": "Perform an API call to fetch the user this ban event affects. Returns hikari.users.User The user affected by this event.", "f": 1}, {"r": "hikari.events.guild_events.BanCreateEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.BanCreateEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.BanCreateEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.BanDeleteEvent", "u": 11, "d": "Event that is fired when a user is unbanned from a guild. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_BANS Method generated by attrs for class BanDeleteEvent."}, {"r": "hikari.events.guild_events.BanDeleteEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.BanDeleteEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.BanDeleteEvent.user", "u": 11, "d": "User that this ban event affects. Returns hikari.users.User The user that this event concerns."}, {"r": "hikari.events.guild_events.BanDeleteEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.BanDeleteEvent.fetch_user", "u": 11, "d": "Perform an API call to fetch the user this ban event affects. Returns hikari.users.User The user affected by this event.", "f": 1}, {"r": "hikari.events.guild_events.BanDeleteEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.BanDeleteEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.BanDeleteEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.EmojisUpdateEvent", "u": 11, "d": "Event that is fired when the emojis in a guild are updated. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_EMOJIS Method generated by attrs for class EmojisUpdateEvent."}, {"r": "hikari.events.guild_events.EmojisUpdateEvent.fetch_emojis", "u": 11, "d": "Perform an API call to retrieve an up-to-date view of the emojis. Returns typing.Sequence[emojis_.KnownCustomEmoji] All emojis in the guild.", "f": 1}, {"r": "hikari.events.guild_events.EmojisUpdateEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.EmojisUpdateEvent.emojis", "u": 11, "d": "Sequence of all emojis in this guild. Returns typing.Sequence[emojis_.KnownCustomEmoji] All emojis in the guild."}, {"r": "hikari.events.guild_events.EmojisUpdateEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.EmojisUpdateEvent.old_emojis", "u": 11, "d": "Sequence of all old emojis in this guild. This will be builtins.None if it's missing from the cache."}, {"r": "hikari.events.guild_events.EmojisUpdateEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.EmojisUpdateEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.EmojisUpdateEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.EmojisUpdateEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationEvent", "u": 11, "d": "Event base for any integration related events. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_INTEGRATIONS "}, {"r": "hikari.events.guild_events.IntegrationEvent.application_id", "u": 11, "d": "ID of Discord bot application this integration is connected to. Returns typing.Optional[hikari.snowflakes.Snowflake] The ID of Discord bot application this integration is connected to."}, {"r": "hikari.events.guild_events.IntegrationEvent.id", "u": 11, "d": "ID of the integration. Returns hikari.snowflakes.Snowflake The ID of the integration."}, {"r": "hikari.events.guild_events.IntegrationEvent.fetch_integrations", "u": 11, "d": "Perform an API call to fetch some number of guild integrations. ! warning The results of this are not clearly defined by Discord. The current behaviour appears to be that only the first 50 integrations actually get returned. Discord have made it clear that they are not willing to fix this in https: github.com/discord/discord-api-docs/issues/1990. Returns typing.Sequence[hikari.guilds.Integration] Some possibly random subset of the integrations in a guild, probably.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.IntegrationEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.IntegrationEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.IntegrationCreateEvent", "u": 11, "d": "Event that is fired when an integration is created in a guild. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_INTEGRATIONS Method generated by attrs for class IntegrationCreateEvent."}, {"r": "hikari.events.guild_events.IntegrationCreateEvent.application_id", "u": 11, "d": "ID of Discord bot application this integration is connected to. Returns typing.Optional[hikari.snowflakes.Snowflake] The ID of Discord bot application this integration is connected to."}, {"r": "hikari.events.guild_events.IntegrationCreateEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.IntegrationCreateEvent.id", "u": 11, "d": "ID of the integration. Returns hikari.snowflakes.Snowflake The ID of the integration."}, {"r": "hikari.events.guild_events.IntegrationCreateEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.IntegrationCreateEvent.integration", "u": 11, "d": "Integration that was created."}, {"r": "hikari.events.guild_events.IntegrationCreateEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.IntegrationCreateEvent.fetch_integrations", "u": 11, "d": "Perform an API call to fetch some number of guild integrations. ! warning The results of this are not clearly defined by Discord. The current behaviour appears to be that only the first 50 integrations actually get returned. Discord have made it clear that they are not willing to fix this in https: github.com/discord/discord-api-docs/issues/1990. Returns typing.Sequence[hikari.guilds.Integration] Some possibly random subset of the integrations in a guild, probably.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationCreateEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationCreateEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationCreateEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationDeleteEvent", "u": 11, "d": "Event that is fired when an integration is deleted in a guild. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_INTEGRATIONS Method generated by attrs for class IntegrationDeleteEvent."}, {"r": "hikari.events.guild_events.IntegrationDeleteEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.IntegrationDeleteEvent.application_id", "u": 11, "d": "ID of Discord bot application this integration is connected to. Returns typing.Optional[hikari.snowflakes.Snowflake] The ID of Discord bot application this integration is connected to."}, {"r": "hikari.events.guild_events.IntegrationDeleteEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.IntegrationDeleteEvent.id", "u": 11, "d": "ID of the integration. Returns hikari.snowflakes.Snowflake The ID of the integration."}, {"r": "hikari.events.guild_events.IntegrationDeleteEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.IntegrationDeleteEvent.fetch_integrations", "u": 11, "d": "Perform an API call to fetch some number of guild integrations. ! warning The results of this are not clearly defined by Discord. The current behaviour appears to be that only the first 50 integrations actually get returned. Discord have made it clear that they are not willing to fix this in https: github.com/discord/discord-api-docs/issues/1990. Returns typing.Sequence[hikari.guilds.Integration] Some possibly random subset of the integrations in a guild, probably.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationDeleteEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationDeleteEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationDeleteEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent", "u": 11, "d": "Event that is fired when an integration is updated in a guild. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_INTEGRATIONS Method generated by attrs for class IntegrationUpdateEvent."}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent.application_id", "u": 11, "d": "ID of Discord bot application this integration is connected to. Returns typing.Optional[hikari.snowflakes.Snowflake] The ID of Discord bot application this integration is connected to."}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent.guild_id", "u": 11, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent.id", "u": 11, "d": "ID of the integration. Returns hikari.snowflakes.Snowflake The ID of the integration."}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent.integration", "u": 11, "d": "Integration that was updated."}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent.fetch_integrations", "u": 11, "d": "Perform an API call to fetch some number of guild integrations. ! warning The results of this are not clearly defined by Discord. The current behaviour appears to be that only the first 50 integrations actually get returned. Discord have made it clear that they are not willing to fix this in https: github.com/discord/discord-api-docs/issues/1990. Returns typing.Sequence[hikari.guilds.Integration] Some possibly random subset of the integrations in a guild, probably.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent.fetch_guild", "u": 11, "d": "Perform an API call to get the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent.fetch_guild_preview", "u": 11, "d": "Perform an API call to get the preview of the event's guild. Returns hikari.guilds.GuildPreview The preview of the guild this event occurred in.", "f": 1}, {"r": "hikari.events.guild_events.IntegrationUpdateEvent.get_guild", "u": 11, "d": "Get the cached guild that this event relates to, if known. If not known, this will return builtins.None instead. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or builtins.None if not known.", "f": 1}, {"r": "hikari.events.guild_events.PresenceUpdateEvent", "u": 11, "d": "Event fired when a user in a guild updates their presence in a guild. Sent when a guild member changes their presence in a specific guild. If the user is changed (e.g. new username), then this may fire many times\n(once for every guild the bot is part of). This is a limitation of how\nDiscord implements their event system, unfortunately. Furthermore, if the target user is a bot and the bot only updates their\npresence on specific shards, this will only fire for the corresponding\nshards that saw the presence update. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_PRESENCES Method generated by attrs for class PresenceUpdateEvent."}, {"r": "hikari.events.guild_events.PresenceUpdateEvent.app", "u": 11, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.guild_events.PresenceUpdateEvent.user_id", "u": 11, "d": "User ID of the user that updated their presence. Returns hikari.snowflakes.Snowflake ID of the user the event concerns."}, {"r": "hikari.events.guild_events.PresenceUpdateEvent.guild_id", "u": 11, "d": "Guild ID that the presence was updated in. Returns hikari.snowflakes.Snowflake ID of the guild the event occurred in."}, {"r": "hikari.events.guild_events.PresenceUpdateEvent.get_user", "u": 11, "d": "Get the full cached user, if it is available. Returns typing.Optional[hikari.users.User] The full cached user, or builtins.None if not cached.", "f": 1}, {"r": "hikari.events.guild_events.PresenceUpdateEvent.fetch_user", "u": 11, "d": "Perform an API call to fetch the user this event concerns. Returns hikari.users.User The user affected by this event.", "f": 1}, {"r": "hikari.events.guild_events.PresenceUpdateEvent.old_presence", "u": 11, "d": "The old member presence object. This will be builtins.None if the member presence missing from the cache."}, {"r": "hikari.events.guild_events.PresenceUpdateEvent.presence", "u": 11, "d": "Member presence. Returns hikari.presences.MemberPresence Presence for the user in this guild."}, {"r": "hikari.events.guild_events.PresenceUpdateEvent.shard", "u": 11, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.guild_events.PresenceUpdateEvent.user", "u": 11, "d": "User that was updated. This is a partial user object that only contains the fields that were\nupdated on the user profile. Will be builtins.None if the user itself did not change.\nThis is always the case if the user only updated their member\nrepresentation and did not change their user profile directly. Returns typing.Optional[hikari.users.PartialUser] The partial user containing the updated fields."}, {"r": "hikari.events.reaction_events", "u": 12, "d": "Events that fire if messages are reacted to."}, {"r": "hikari.events.reaction_events.ReactionEvent", "u": 12, "d": "Event base for any message reaction event. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_REACTIONS - hikari.intents.Intents.DM_MESSAGE_REACTIONS "}, {"r": "hikari.events.reaction_events.ReactionEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.ReactionEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.ReactionEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.ReactionEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.GuildReactionEvent", "u": 12, "d": "Event base for any reaction-bound event in guild messages. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_REACTIONS "}, {"r": "hikari.events.reaction_events.GuildReactionEvent.guild_id", "u": 12, "d": "ID of the guild that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the guild that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.GuildReactionEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.DMReactionEvent", "u": 12, "d": "Event base for any reaction-bound event in private messages. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGE_REACTIONS "}, {"r": "hikari.events.reaction_events.DMReactionEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.DMReactionEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.DMReactionEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.DMReactionEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.ReactionAddEvent", "u": 12, "d": "Event base for any reaction that is added to a message. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_REACTIONS - hikari.intents.Intents.DM_MESSAGE_REACTIONS "}, {"r": "hikari.events.reaction_events.ReactionAddEvent.user_id", "u": 12, "d": "ID of the user that added this reaction. Returns hikari.snowflakes.Snowflake The ID of the user that added this reaction."}, {"r": "hikari.events.reaction_events.ReactionAddEvent.emoji_name", "u": 12, "d": "Name of the emoji which was added if known. ! note This will be builtins.None when the relevant custom emoji's data is not available (e.g. the emoji has been deleted). Returns typing.Union[hikari.emojis.UnicodeEmoji, builtins.str, builtins.None] Either the string name of the custom emoji which was added or the object of the hikari.emojis.UnicodeEmoji which was added."}, {"r": "hikari.events.reaction_events.ReactionAddEvent.emoji_id", "u": 12, "d": "ID of the emoji which was added if it is custom. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the emoji which was added if it was a custom emoji or builtins.None ."}, {"r": "hikari.events.reaction_events.ReactionAddEvent.is_animated", "u": 12, "d": "Whether the emoji which was added is animated. Returns builtins.bool Whether the emoji which was added is animated."}, {"r": "hikari.events.reaction_events.ReactionAddEvent.is_for_emoji", "u": 12, "d": "Get whether the reaction event is for a specific emoji. Parameters emoji : typing.Union[hikari.emojis.Emoji, builtins.str] The emoji to check. Passing builtins.str here indicates a unicode emoji. Returns builtins.bool Whether the emoji is the one which was added.", "f": 1}, {"r": "hikari.events.reaction_events.ReactionAddEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.ReactionAddEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.ReactionAddEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.ReactionAddEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.ReactionDeleteEvent", "u": 12, "d": "Event base for any single reaction that is removed from a message. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_REACTIONS - hikari.intents.Intents.DM_MESSAGE_REACTIONS "}, {"r": "hikari.events.reaction_events.ReactionDeleteEvent.user_id", "u": 12, "d": "User ID for the user that added this reaction initially. Returns hikari.snowflakes.Snowflake The ID of the user that removed this reaction."}, {"r": "hikari.events.reaction_events.ReactionDeleteEvent.emoji_name", "u": 12, "d": "Name of the emoji which was removed. ! note This will be builtins.None when the relevant custom emoji's data is not available (e.g. the emoji has been deleted). Returns typing.Union[hikari.emojis.UnicodeEmoji, builtins.str, builtins.None] Either the string name of the custom emoji which was removed or the object of the hikari.emojis.UnicodeEmoji which was removed."}, {"r": "hikari.events.reaction_events.ReactionDeleteEvent.emoji_id", "u": 12, "d": "ID of the emoji which was removed if it was custom. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the emoji which was removed if it was a custom emoji or builtins.None ."}, {"r": "hikari.events.reaction_events.ReactionDeleteEvent.is_for_emoji", "u": 12, "d": "Get whether the reaction event is for a specific emoji. Parameters emoji : typing.Union[hikari.emojis.Emoji, builtins.str] The emoji to check. Passing builtins.str here indicates a unicode emoji. Returns builtins.bool Whether the emoji is the one which was removed.", "f": 1}, {"r": "hikari.events.reaction_events.ReactionDeleteEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.ReactionDeleteEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.ReactionDeleteEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.ReactionDeleteEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.ReactionDeleteEmojiEvent", "u": 12, "d": "Event base fired when all reactions are removed for one emoji. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_REACTIONS - hikari.intents.Intents.DM_MESSAGE_REACTIONS "}, {"r": "hikari.events.reaction_events.ReactionDeleteEmojiEvent.emoji_name", "u": 12, "d": "Name of the emoji which was removed if known. ! note This will be builtins.None when the relevant custom emoji's data is not available (e.g. the emoji has been deleted). Returns typing.Union[hikari.emojis.UnicodeEmoji, builtins.str, builtins.None] Either the string name of the custom emoji which was removed or the object of the hikari.emojis.UnicodeEmoji which was removed."}, {"r": "hikari.events.reaction_events.ReactionDeleteEmojiEvent.emoji_id", "u": 12, "d": "ID of the emoji which was removed if it was custom. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the emoji which was removed if it was a custom emoji or builtins.None ."}, {"r": "hikari.events.reaction_events.ReactionDeleteEmojiEvent.is_for_emoji", "u": 12, "d": "Get whether the reaction event is for a specific emoji. Parameters emoji : typing.Union[hikari.emojis.Emoji, builtins.str] The emoji to check. Passing builtins.str here indicates a unicode emoji. Returns builtins.bool Whether the emoji is the one which was removed.", "f": 1}, {"r": "hikari.events.reaction_events.ReactionDeleteEmojiEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.ReactionDeleteEmojiEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.ReactionDeleteEmojiEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.ReactionDeleteEmojiEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.ReactionDeleteAllEvent", "u": 12, "d": "Event base fired when all reactions are removed from a message. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_REACTIONS - hikari.intents.Intents.DM_MESSAGE_REACTIONS "}, {"r": "hikari.events.reaction_events.ReactionDeleteAllEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.ReactionDeleteAllEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.ReactionDeleteAllEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.ReactionDeleteAllEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent", "u": 12, "d": "Event fired when a reaction is added to a guild message. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_REACTIONS Method generated by attrs for class GuildReactionAddEvent."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.guild_id", "u": 12, "d": "ID of the guild that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the guild that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.user_id", "u": 12, "d": "ID of the user that added this reaction. Returns hikari.snowflakes.Snowflake The ID of the user that added this reaction."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.emoji_id", "u": 12, "d": "ID of the emoji which was added if it is custom. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the emoji which was added if it was a custom emoji or builtins.None ."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.emoji_name", "u": 12, "d": "Name of the emoji which was added if known. ! note This will be builtins.None when the relevant custom emoji's data is not available (e.g. the emoji has been deleted). Returns typing.Union[hikari.emojis.UnicodeEmoji, builtins.str, builtins.None] Either the string name of the custom emoji which was added or the object of the hikari.emojis.UnicodeEmoji which was added."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.is_animated", "u": 12, "d": "Whether the emoji which was added is animated. Returns builtins.bool Whether the emoji which was added is animated."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.member", "u": 12, "d": "Member that added the reaction. Returns hikari.guilds.Member The member which added this reaction."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.GuildReactionAddEvent.is_for_emoji", "u": 12, "d": "Get whether the reaction event is for a specific emoji. Parameters emoji : typing.Union[hikari.emojis.Emoji, builtins.str] The emoji to check. Passing builtins.str here indicates a unicode emoji. Returns builtins.bool Whether the emoji is the one which was added.", "f": 1}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEvent", "u": 12, "d": "Event fired when a reaction is removed from a guild message. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_REACTIONS Method generated by attrs for class GuildReactionDeleteEvent."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEvent.emoji_id", "u": 12, "d": "ID of the emoji which was removed if it was custom. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the emoji which was removed if it was a custom emoji or builtins.None ."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEvent.emoji_name", "u": 12, "d": "Name of the emoji which was removed. ! note This will be builtins.None when the relevant custom emoji's data is not available (e.g. the emoji has been deleted). Returns typing.Union[hikari.emojis.UnicodeEmoji, builtins.str, builtins.None] Either the string name of the custom emoji which was removed or the object of the hikari.emojis.UnicodeEmoji which was removed."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEvent.guild_id", "u": 12, "d": "ID of the guild that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the guild that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEvent.user_id", "u": 12, "d": "User ID for the user that added this reaction initially. Returns hikari.snowflakes.Snowflake The ID of the user that removed this reaction."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEvent.is_for_emoji", "u": 12, "d": "Get whether the reaction event is for a specific emoji. Parameters emoji : typing.Union[hikari.emojis.Emoji, builtins.str] The emoji to check. Passing builtins.str here indicates a unicode emoji. Returns builtins.bool Whether the emoji is the one which was removed.", "f": 1}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEmojiEvent", "u": 12, "d": "Event fired when an emoji is removed from a guild message's reactions. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_REACTIONS Method generated by attrs for class GuildReactionDeleteEmojiEvent."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.emoji_id", "u": 12, "d": "ID of the emoji which was removed if it was custom. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the emoji which was removed if it was a custom emoji or builtins.None ."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.emoji_name", "u": 12, "d": "Name of the emoji which was removed if known. ! note This will be builtins.None when the relevant custom emoji's data is not available (e.g. the emoji has been deleted). Returns typing.Union[hikari.emojis.UnicodeEmoji, builtins.str, builtins.None] Either the string name of the custom emoji which was removed or the object of the hikari.emojis.UnicodeEmoji which was removed."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.guild_id", "u": 12, "d": "ID of the guild that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the guild that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.is_for_emoji", "u": 12, "d": "Get whether the reaction event is for a specific emoji. Parameters emoji : typing.Union[hikari.emojis.Emoji, builtins.str] The emoji to check. Passing builtins.str here indicates a unicode emoji. Returns builtins.bool Whether the emoji is the one which was removed.", "f": 1}, {"r": "hikari.events.reaction_events.GuildReactionDeleteAllEvent", "u": 12, "d": "Event fired when all of a guild message's reactions are removed. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_REACTIONS Method generated by attrs for class GuildReactionDeleteAllEvent."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteAllEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteAllEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteAllEvent.guild_id", "u": 12, "d": "ID of the guild that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the guild that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteAllEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.GuildReactionDeleteAllEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.DMReactionAddEvent", "u": 12, "d": "Event fired when a reaction is added to a private message. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class DMReactionAddEvent."}, {"r": "hikari.events.reaction_events.DMReactionAddEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.DMReactionAddEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.DMReactionAddEvent.emoji_id", "u": 12, "d": "ID of the emoji which was added if it is custom. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the emoji which was added if it was a custom emoji or builtins.None ."}, {"r": "hikari.events.reaction_events.DMReactionAddEvent.emoji_name", "u": 12, "d": "Name of the emoji which was added if known. ! note This will be builtins.None when the relevant custom emoji's data is not available (e.g. the emoji has been deleted). Returns typing.Union[hikari.emojis.UnicodeEmoji, builtins.str, builtins.None] Either the string name of the custom emoji which was added or the object of the hikari.emojis.UnicodeEmoji which was added."}, {"r": "hikari.events.reaction_events.DMReactionAddEvent.is_animated", "u": 12, "d": "Whether the emoji which was added is animated. Returns builtins.bool Whether the emoji which was added is animated."}, {"r": "hikari.events.reaction_events.DMReactionAddEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.DMReactionAddEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.DMReactionAddEvent.user_id", "u": 12, "d": "ID of the user that added this reaction. Returns hikari.snowflakes.Snowflake The ID of the user that added this reaction."}, {"r": "hikari.events.reaction_events.DMReactionAddEvent.is_for_emoji", "u": 12, "d": "Get whether the reaction event is for a specific emoji. Parameters emoji : typing.Union[hikari.emojis.Emoji, builtins.str] The emoji to check. Passing builtins.str here indicates a unicode emoji. Returns builtins.bool Whether the emoji is the one which was added.", "f": 1}, {"r": "hikari.events.reaction_events.DMReactionDeleteEvent", "u": 12, "d": "Event fired when a reaction is removed from a private message. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class DMReactionDeleteEvent."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEvent.emoji_id", "u": 12, "d": "ID of the emoji which was removed if it was custom. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the emoji which was removed if it was a custom emoji or builtins.None ."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEvent.emoji_name", "u": 12, "d": "Name of the emoji which was removed. ! note This will be builtins.None when the relevant custom emoji's data is not available (e.g. the emoji has been deleted). Returns typing.Union[hikari.emojis.UnicodeEmoji, builtins.str, builtins.None] Either the string name of the custom emoji which was removed or the object of the hikari.emojis.UnicodeEmoji which was removed."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEvent.user_id", "u": 12, "d": "User ID for the user that added this reaction initially. Returns hikari.snowflakes.Snowflake The ID of the user that removed this reaction."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEvent.is_for_emoji", "u": 12, "d": "Get whether the reaction event is for a specific emoji. Parameters emoji : typing.Union[hikari.emojis.Emoji, builtins.str] The emoji to check. Passing builtins.str here indicates a unicode emoji. Returns builtins.bool Whether the emoji is the one which was removed.", "f": 1}, {"r": "hikari.events.reaction_events.DMReactionDeleteEmojiEvent", "u": 12, "d": "Event fired when an emoji is removed from a private message's reactions. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class DMReactionDeleteEmojiEvent."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEmojiEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEmojiEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEmojiEvent.emoji_id", "u": 12, "d": "ID of the emoji which was removed if it was custom. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the emoji which was removed if it was a custom emoji or builtins.None ."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEmojiEvent.emoji_name", "u": 12, "d": "Name of the emoji which was removed if known. ! note This will be builtins.None when the relevant custom emoji's data is not available (e.g. the emoji has been deleted). Returns typing.Union[hikari.emojis.UnicodeEmoji, builtins.str, builtins.None] Either the string name of the custom emoji which was removed or the object of the hikari.emojis.UnicodeEmoji which was removed."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEmojiEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEmojiEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.reaction_events.DMReactionDeleteEmojiEvent.is_for_emoji", "u": 12, "d": "Get whether the reaction event is for a specific emoji. Parameters emoji : typing.Union[hikari.emojis.Emoji, builtins.str] The emoji to check. Passing builtins.str here indicates a unicode emoji. Returns builtins.bool Whether the emoji is the one which was removed.", "f": 1}, {"r": "hikari.events.reaction_events.DMReactionDeleteAllEvent", "u": 12, "d": "Event fired when all of a private message's reactions are removed. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class DMReactionDeleteAllEvent."}, {"r": "hikari.events.reaction_events.DMReactionDeleteAllEvent.app", "u": 12, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.reaction_events.DMReactionDeleteAllEvent.channel_id", "u": 12, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.reaction_events.DMReactionDeleteAllEvent.message_id", "u": 12, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.reaction_events.DMReactionDeleteAllEvent.shard", "u": 12, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.interaction_events", "u": 13, "d": "Events fired for interaction related changes."}, {"r": "hikari.events.interaction_events.InteractionCreateEvent", "u": 13, "d": "Event fired when an interaction is created. Method generated by attrs for class InteractionCreateEvent."}, {"r": "hikari.events.interaction_events.InteractionCreateEvent.app", "u": 13, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.interaction_events.InteractionCreateEvent.interaction", "u": 13, "d": "Interaction that this event is related to. Returns hikari.interactions.base_interactions.PartialInteraction Object of the interaction that this event is related to."}, {"r": "hikari.events.interaction_events.InteractionCreateEvent.shard", "u": 13, "d": "Shard that received this event."}, {"r": "hikari.events.member_events", "u": 14, "d": "Events concerning manipulation of members within guilds."}, {"r": "hikari.events.member_events.MemberEvent", "u": 14, "d": "Event base for any events that concern guild members. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MEMBERS "}, {"r": "hikari.events.member_events.MemberEvent.app", "u": 14, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.member_events.MemberEvent.guild_id", "u": 14, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.member_events.MemberEvent.user", "u": 14, "d": "User object for the member this event concerns. Returns hikari.users.User User object for the member this event concerns."}, {"r": "hikari.events.member_events.MemberEvent.user_id", "u": 14, "d": "ID of the user that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the user that this event relates to."}, {"r": "hikari.events.member_events.MemberEvent.get_guild", "u": 14, "d": "Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else builtins.None .", "f": 1}, {"r": "hikari.events.member_events.MemberEvent.shard", "u": 14, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.member_events.MemberCreateEvent", "u": 14, "d": "Event that is fired when a member joins a guild. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MEMBERS Method generated by attrs for class MemberCreateEvent."}, {"r": "hikari.events.member_events.MemberCreateEvent.guild_id", "u": 14, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.member_events.MemberCreateEvent.user", "u": 14, "d": "User object for the member this event concerns. Returns hikari.users.User User object for the member this event concerns."}, {"r": "hikari.events.member_events.MemberCreateEvent.member", "u": 14, "d": "Member object for the member that joined the guild. Returns hikari.guilds.Member The member object for the member who just joined."}, {"r": "hikari.events.member_events.MemberCreateEvent.shard", "u": 14, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.member_events.MemberCreateEvent.app", "u": 14, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.member_events.MemberCreateEvent.user_id", "u": 14, "d": "ID of the user that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the user that this event relates to."}, {"r": "hikari.events.member_events.MemberCreateEvent.get_guild", "u": 14, "d": "Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else builtins.None .", "f": 1}, {"r": "hikari.events.member_events.MemberUpdateEvent", "u": 14, "d": "Event that is fired when a member is updated in a guild. This may occur if roles are amended, or if the nickname is changed. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MEMBERS Method generated by attrs for class MemberUpdateEvent."}, {"r": "hikari.events.member_events.MemberUpdateEvent.guild_id", "u": 14, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.member_events.MemberUpdateEvent.user", "u": 14, "d": "User object for the member this event concerns. Returns hikari.users.User User object for the member this event concerns."}, {"r": "hikari.events.member_events.MemberUpdateEvent.member", "u": 14, "d": "Member object for the member that was updated. Returns hikari.guilds.Member The member object for the member that was updated."}, {"r": "hikari.events.member_events.MemberUpdateEvent.old_member", "u": 14, "d": "The old member object. This will be builtins.None if the member missing from the cache."}, {"r": "hikari.events.member_events.MemberUpdateEvent.shard", "u": 14, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.member_events.MemberUpdateEvent.app", "u": 14, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.member_events.MemberUpdateEvent.user_id", "u": 14, "d": "ID of the user that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the user that this event relates to."}, {"r": "hikari.events.member_events.MemberUpdateEvent.get_guild", "u": 14, "d": "Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else builtins.None .", "f": 1}, {"r": "hikari.events.member_events.MemberDeleteEvent", "u": 14, "d": "Event fired when a member is kicked from or leaves a guild. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MEMBERS Method generated by attrs for class MemberDeleteEvent."}, {"r": "hikari.events.member_events.MemberDeleteEvent.guild_id", "u": 14, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.member_events.MemberDeleteEvent.old_member", "u": 14, "d": "The old member object. This will be builtins.None if the member was missing from the cache."}, {"r": "hikari.events.member_events.MemberDeleteEvent.shard", "u": 14, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.member_events.MemberDeleteEvent.user", "u": 14, "d": "User object for the member this event concerns. Returns hikari.users.User User object for the member this event concerns."}, {"r": "hikari.events.member_events.MemberDeleteEvent.app", "u": 14, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.member_events.MemberDeleteEvent.user_id", "u": 14, "d": "ID of the user that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the user that this event relates to."}, {"r": "hikari.events.member_events.MemberDeleteEvent.get_guild", "u": 14, "d": "Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else builtins.None .", "f": 1}, {"r": "hikari.events.voice_events", "u": 15, "d": "Events that fire when voice state changes."}, {"r": "hikari.events.voice_events.VoiceEvent", "u": 15, "d": "Base for any voice-related event."}, {"r": "hikari.events.voice_events.VoiceEvent.guild_id", "u": 15, "d": "ID of the guild this event is for. Returns hikari.snowflakes.Snowflake The guild ID of the guild this event relates to."}, {"r": "hikari.events.voice_events.VoiceEvent.shard", "u": 15, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.voice_events.VoiceEvent.app", "u": 15, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.voice_events.VoiceStateUpdateEvent", "u": 15, "d": "Event fired when a user changes their voice state. Sent when a user joins, leaves or moves voice channel(s). This is also fired for the application user, and is used when preparing\nto connect to the voice gateway to stream audio or video content. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_VOICE_STATES Method generated by attrs for class VoiceStateUpdateEvent."}, {"r": "hikari.events.voice_events.VoiceStateUpdateEvent.app", "u": 15, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.voice_events.VoiceStateUpdateEvent.guild_id", "u": 15, "d": "ID of the guild this event is for. Returns hikari.snowflakes.Snowflake The guild ID of the guild this event relates to."}, {"r": "hikari.events.voice_events.VoiceStateUpdateEvent.old_state", "u": 15, "d": "The old voice state. This will be builtins.None if the voice state missing from the cache."}, {"r": "hikari.events.voice_events.VoiceStateUpdateEvent.shard", "u": 15, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.voice_events.VoiceStateUpdateEvent.state", "u": 15, "d": "Voice state that this update contained. Returns hikari.voices.VoiceState The voice state that was updated."}, {"r": "hikari.events.voice_events.VoiceServerUpdateEvent", "u": 15, "d": "Event fired when a voice server is changed. Sent when initially connecting to voice and when the current voice instance\nfalls over to a new server. Method generated by attrs for class VoiceServerUpdateEvent."}, {"r": "hikari.events.voice_events.VoiceServerUpdateEvent.endpoint", "u": 15, "d": "URI for this voice server host, with the correct scheme prepended. If this is builtins.None , it means that the server has been deallocated\nand you have to disconnect. You will later receive a new event specifying\nwhat endpoint to connect to. Returns typing.Optional[builtins.str] If not builtins.None , the URI to use to connect to the voice gateway."}, {"r": "hikari.events.voice_events.VoiceServerUpdateEvent.app", "u": 15, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.voice_events.VoiceServerUpdateEvent.guild_id", "u": 15, "d": "ID of the guild this event is for. Returns hikari.snowflakes.Snowflake The guild ID of the guild this event relates to."}, {"r": "hikari.events.voice_events.VoiceServerUpdateEvent.raw_endpoint", "u": 15, "d": "Raw endpoint URI that Discord sent. If this is builtins.None , it means that the server has been deallocated\nand you have to disconnect. You will later receive a new event specifying\nwhat endpoint to connect to. ! warning This will not contain the scheme to use. Use the endpoint property to get a representation that has this prepended. Returns builtins.str A scheme-less endpoint URI for the endpoint to use for a new voice websocket."}, {"r": "hikari.events.voice_events.VoiceServerUpdateEvent.shard", "u": 15, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.voice_events.VoiceServerUpdateEvent.token", "u": 15, "d": "Token that should be used to authenticate with the voice gateway. Returns builtins.str The token to use to authenticate with the voice gateway."}, {"r": "hikari.events.lifetime_events", "u": 16, "d": "Events that are bound to the lifetime of an application. These are types of hooks that can be invoked on startup or shutdown, which can\nbe used to initialize other resources, fetch information, and perform checks."}, {"r": "hikari.events.lifetime_events.StartingEvent", "u": 16, "d": "Event that is triggered before the application connects to discord. This will only fire once per bot.run / bot.start , so is suitable for\nopening database connections and other resources that need to be\ninitialized within a coroutine function. ! warning The application will not proceed to connect to Discord until all event handlers for this event have completed/terminated. This prevents the risk of race conditions occurring (e.g. allowing message events to try to access a database that has not yet connected fully). If you want to do something _after_ the application has initialized, you\nshould consider using StartedEvent instead. Method generated by attrs for class StartingEvent."}, {"r": "hikari.events.lifetime_events.StartingEvent.app", "u": 16, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.lifetime_events.StartedEvent", "u": 16, "d": "Event that is triggered after the application has started. This will only fire once per bot.run / bot.start , so is suitable for\nopening database connections and other resources that need to be\ninitialized within a coroutine function. If you want to do something _before_ the application connects, you should\nconsider using StartingEvent instead. Method generated by attrs for class StartedEvent."}, {"r": "hikari.events.lifetime_events.StartedEvent.app", "u": 16, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.lifetime_events.StoppingEvent", "u": 16, "d": "Event that is triggered as soon as the application is requested to close. This will fire before the connection is physically disconnected. This will only fire once per bot.close , so is suitable for\nclosing database connections and other resources that need to be\nclosed within a coroutine function. ! warning The application will not proceed to disconnect from Discord until all event handlers for this event have completed/terminated. This prevents the risk of race conditions occurring from code that relies on a connection still being available to complete. If you want to do something _after_ the disconnection has occurred, you\nshould consider using StoppedEvent instead. Method generated by attrs for class StoppingEvent."}, {"r": "hikari.events.lifetime_events.StoppingEvent.app", "u": 16, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.lifetime_events.StoppedEvent", "u": 16, "d": "Event that is triggered once the application has disconnected. This will only fire once per bot.close , so is suitable for\nclosing database connections and other resources that need to be\nclosed within a coroutine function. ! warning The application will not proceed to leave the bot.run call until all event handlers for this event have completed/terminated. This prevents the risk of race conditions occurring where a script may terminate the process before a callback can occur. If you want to do something when the application is preparing to shut down,\nbut _before_ any connection to discord is closed, you should consider using StoppingEvent instead. Method generated by attrs for class StoppedEvent."}, {"r": "hikari.events.lifetime_events.StoppedEvent.app", "u": 16, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events", "u": 17, "d": "Events that fire if messages are sent/updated/deleted."}, {"r": "hikari.events.message_events.MessageEvent", "u": 17, "d": "Any event that concerns manipulation of messages. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGES - hikari.intents.Intents.GUILD_MESSAGES "}, {"r": "hikari.events.message_events.MessageEvent.channel_id", "u": 17, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.message_events.MessageEvent.message_id", "u": 17, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.message_events.MessageEvent.shard", "u": 17, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.message_events.MessageEvent.app", "u": 17, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events.MessageCreateEvent", "u": 17, "d": "Event that is fired when a message is created. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGES - hikari.intents.Intents.GUILD_MESSAGES "}, {"r": "hikari.events.message_events.MessageCreateEvent.app", "u": 17, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events.MessageCreateEvent.author", "u": 17, "d": "User that sent the message. Returns hikari.users.User The user that sent the message."}, {"r": "hikari.events.message_events.MessageCreateEvent.author_id", "u": 17, "d": "ID of the author of the message this event concerns. Returns hikari.snowflakes.Snowflake The ID of the author."}, {"r": "hikari.events.message_events.MessageCreateEvent.channel_id", "u": 17, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.message_events.MessageCreateEvent.content", "u": 17, "d": "Content of the message. Returns typing.Optional[builtins.str] The content of the message, if present. This may be builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent)."}, {"r": "hikari.events.message_events.MessageCreateEvent.embeds", "u": 17, "d": "Sequence of embeds in the message. Returns typing.Sequence[hikari.embeds.Embed] The embeds in the message."}, {"r": "hikari.events.message_events.MessageCreateEvent.is_bot", "u": 17, "d": "Return builtins.True if the message is from a bot. Returns builtins.bool builtins.True if from a bot, or builtins.False otherwise."}, {"r": "hikari.events.message_events.MessageCreateEvent.is_human", "u": 17, "d": "Return builtins.True if the message was created by a human. Returns builtins.bool builtins.True if from a human user, or builtins.False otherwise."}, {"r": "hikari.events.message_events.MessageCreateEvent.is_webhook", "u": 17, "d": "Return builtins.True if the message was created by a webhook. Returns builtins.bool builtins.True if from a webhook, or builtins.False otherwise."}, {"r": "hikari.events.message_events.MessageCreateEvent.message", "u": 17, "d": "Message that was sent in the event. Returns hikari.messages.Message The message object that was sent with this event."}, {"r": "hikari.events.message_events.MessageCreateEvent.message_id", "u": 17, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.message_events.MessageCreateEvent.shard", "u": 17, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.message_events.MessageUpdateEvent", "u": 17, "d": "Event that is fired when a message is updated. ! note Less information will be available here than in the creation event due to Discord limitations. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGES - hikari.intents.Intents.GUILD_MESSAGES "}, {"r": "hikari.events.message_events.MessageUpdateEvent.app", "u": 17, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events.MessageUpdateEvent.author", "u": 17, "d": "User that sent the message. This will be hikari.undefined.UNDEFINED in some cases such as when Discord\nupdates a message with an embed URL preview."}, {"r": "hikari.events.message_events.MessageUpdateEvent.author_id", "u": 17, "d": "ID of the author that triggered this event. This will be hikari.undefined.UNDEFINED in some cases such as when Discord\nupdates a message with an embed URL preview."}, {"r": "hikari.events.message_events.MessageUpdateEvent.channel_id", "u": 17, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.message_events.MessageUpdateEvent.content", "u": 17, "d": "Content of the message. Returns hikari.undefined.UndefinedNoneOr[builtins.str] The content of the message, if present. This may be builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent). If not part of the update, then this will be hikari.undefined.UNDEFINED instead."}, {"r": "hikari.events.message_events.MessageUpdateEvent.embeds", "u": 17, "d": "Sequence of embeds in the message. Returns hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed The embeds in the message. If the embeds were not changed in this event, then this may instead be hikari.undefined.UNDEFINED ."}, {"r": "hikari.events.message_events.MessageUpdateEvent.is_bot", "u": 17, "d": "Return builtins.True if the message is from a bot. Returns typing.Optional[builtins.bool] builtins.True if from a bot, or builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this will return hikari.undefined.UNDEFINED instead."}, {"r": "hikari.events.message_events.MessageUpdateEvent.is_human", "u": 17, "d": "Return builtins.True if the message was created by a human. Returns typing.Optional[builtins.bool] builtins.True if from a human user, or builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this may return hikari.undefined.UNDEFINED instead."}, {"r": "hikari.events.message_events.MessageUpdateEvent.is_webhook", "u": 17, "d": "Return builtins.True if the message was created by a webhook. Returns builtins.bool builtins.True if from a webhook, or builtins.False otherwise."}, {"r": "hikari.events.message_events.MessageUpdateEvent.message", "u": 17, "d": "Partial message that was sent in the event. Returns hikari.messages.PartialMessage The partial message object that was sent with this event."}, {"r": "hikari.events.message_events.MessageUpdateEvent.message_id", "u": 17, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.message_events.MessageUpdateEvent.shard", "u": 17, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.message_events.MessageDeleteEvent", "u": 17, "d": "Special event that is triggered when one or more messages get deleted. ! note Due to Discord limitations, most message information is unavailable during deletion events. You can check if the message was in a singular deletion by checking the is_bulk attribute. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGES - hikari.intents.Intents.DM_MESSAGES "}, {"r": "hikari.events.message_events.MessageDeleteEvent.message_id", "u": 17, "d": "Get the ID of the first deleted message. This is contextually useful if you know this is not a bulk deletion\nevent. For all other purposes, this is the same as running next(iter(event.message_ids  . Returns hikari.snowflakes.Snowflake The first deleted message ID."}, {"r": "hikari.events.message_events.MessageDeleteEvent.message_ids", "u": 17, "d": "Set of message IDs that were bulk deleted. Returns typing.AbstractSet[hikari.snowflakes.Snowflake] A sequence of message IDs that were bulk deleted."}, {"r": "hikari.events.message_events.MessageDeleteEvent.is_bulk", "u": 17, "d": "Flag that determines whether this was a bulk deletion or not. Returns builtins.bool builtins.True if this was a bulk deletion, or builtins.False if it was a regular message deletion."}, {"r": "hikari.events.message_events.MessageDeleteEvent.channel_id", "u": 17, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.message_events.MessageDeleteEvent.shard", "u": 17, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.message_events.MessageDeleteEvent.app", "u": 17, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent", "u": 17, "d": "Event that is fired when a message is created within a guild. This contains the full message in the internal message attribute. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGES Method generated by attrs for class GuildMessageCreateEvent."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.author", "u": 17, "d": "User object of the user that sent the message. Returns hikari.users.User The user object of the user that sent the message."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.member", "u": 17, "d": "Member object of the user that sent the message. Returns typing.Optional[hikari.guilds.Member] The member object of the user that sent the message or builtins.None if sent by a webhook."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.guild_id", "u": 17, "d": "ID of the guild that this event occurred in. Returns hikari.snowflakes.Snowflake The ID of the guild that this event occurred in."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.get_channel", "u": 17, "d": "Channel that the message was sent in, if known. Returns typing.Optional[hikari.channels.TextableGuildChannel] The channel that the message was sent in, if known and cached, otherwise, builtins.None .", "f": 1}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.get_guild", "u": 17, "d": "Get the cached guild that this event occurred in, if known. ! note This will require the GUILDS intent to be specified on start-up in order to be known. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if cached. Otherwise, builtins.None instead.", "f": 1}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.get_member", "u": 17, "d": "Get the member that sent this message from the cache if available. Returns typing.Optional[hikari.guilds.Member] Cached object of the member that sent the message if found.", "f": 1}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.message", "u": 17, "d": "Message that was sent in the event. Returns hikari.messages.Message The message object that was sent with this event."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.shard", "u": 17, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.app", "u": 17, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.author_id", "u": 17, "d": "ID of the author of the message this event concerns. Returns hikari.snowflakes.Snowflake The ID of the author."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.channel_id", "u": 17, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.content", "u": 17, "d": "Content of the message. Returns typing.Optional[builtins.str] The content of the message, if present. This may be builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent)."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.embeds", "u": 17, "d": "Sequence of embeds in the message. Returns typing.Sequence[hikari.embeds.Embed] The embeds in the message."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.is_bot", "u": 17, "d": "Return builtins.True if the message is from a bot. Returns builtins.bool builtins.True if from a bot, or builtins.False otherwise."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.is_human", "u": 17, "d": "Return builtins.True if the message was created by a human. Returns builtins.bool builtins.True if from a human user, or builtins.False otherwise."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.is_webhook", "u": 17, "d": "Return builtins.True if the message was created by a webhook. Returns builtins.bool builtins.True if from a webhook, or builtins.False otherwise."}, {"r": "hikari.events.message_events.GuildMessageCreateEvent.message_id", "u": 17, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent", "u": 17, "d": "Event that is fired when a message is updated in a guild. ! note Less information will be available here than in the creation event due to Discord limitations. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGES Method generated by attrs for class GuildMessageUpdateEvent."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.member", "u": 17, "d": "Member that sent the message if provided by the event. If the message is not in a guild, this will be builtins.None . This will also be hikari.undefined.UNDEFINED in some cases such as when Discord\nupdates a message with an embed URL preview."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.get_member", "u": 17, "d": "Get the member that sent this message from the cache if available. Returns typing.Optional[hikari.guilds.Member] Cached object of the member that sent the message if found.", "f": 1}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.guild_id", "u": 17, "d": "ID of the guild that this event occurred in. Returns hikari.snowflakes.Snowflake The ID of the guild that this event occurred in."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.get_channel", "u": 17, "d": "Channel that the message was sent in, if known. Returns typing.Optional[hikari.channels.TextableGuildChannel] The channel that the message was sent in, if known and cached, otherwise, builtins.None .", "f": 1}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.get_guild", "u": 17, "d": "Get the cached guild that this event occurred in, if known. ! note This will require the GUILDS intent to be specified on start-up in order to be known. Returns typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if cached. Otherwise, builtins.None instead.", "f": 1}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.message", "u": 17, "d": "Partial message that was sent in the event. Returns hikari.messages.PartialMessage The partial message object that was sent with this event."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.old_message", "u": 17, "d": "The old message object. This will be builtins.None if the message missing from the cache."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.shard", "u": 17, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.app", "u": 17, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.author", "u": 17, "d": "User that sent the message. This will be hikari.undefined.UNDEFINED in some cases such as when Discord\nupdates a message with an embed URL preview."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.author_id", "u": 17, "d": "ID of the author that triggered this event. This will be hikari.undefined.UNDEFINED in some cases such as when Discord\nupdates a message with an embed URL preview."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.channel_id", "u": 17, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.content", "u": 17, "d": "Content of the message. Returns hikari.undefined.UndefinedNoneOr[builtins.str] The content of the message, if present. This may be builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent). If not part of the update, then this will be hikari.undefined.UNDEFINED instead."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.embeds", "u": 17, "d": "Sequence of embeds in the message. Returns hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed The embeds in the message. If the embeds were not changed in this event, then this may instead be hikari.undefined.UNDEFINED ."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.is_bot", "u": 17, "d": "Return builtins.True if the message is from a bot. Returns typing.Optional[builtins.bool] builtins.True if from a bot, or builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this will return hikari.undefined.UNDEFINED instead."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.is_human", "u": 17, "d": "Return builtins.True if the message was created by a human. Returns typing.Optional[builtins.bool] builtins.True if from a human user, or builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this may return hikari.undefined.UNDEFINED instead."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.is_webhook", "u": 17, "d": "Return builtins.True if the message was created by a webhook. Returns builtins.bool builtins.True if from a webhook, or builtins.False otherwise."}, {"r": "hikari.events.message_events.GuildMessageUpdateEvent.message_id", "u": 17, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.message_events.GuildMessageDeleteEvent", "u": 17, "d": "Event that is triggered if messages are deleted in a guild. ! note Due to Discord limitations, most message information is unavailable during deletion events. This is triggered for singular message deletion, and bulk message\ndeletion. You can check if the message was in a singular deletion by\nchecking the is_bulk attribute. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGES Method generated by attrs for class GuildMessageDeleteEvent."}, {"r": "hikari.events.message_events.GuildMessageDeleteEvent.get_channel", "u": 17, "d": "Get the cached channel the messages were sent in, if known. Returns typing.Optional[hikari.channels.TextableGuildChannel] The channel the messages were sent in, or builtins.None if not known/cached.", "f": 1}, {"r": "hikari.events.message_events.GuildMessageDeleteEvent.get_guild", "u": 17, "d": "Get the cached guild this event corresponds to, if known. ! note You will need hikari.intents.Intents.GUILDS enabled to receive this information. Returns hikari.guilds.GatewayGuild The gateway guild that this event corresponds to, if known and cached.", "f": 1}, {"r": "hikari.events.message_events.GuildMessageDeleteEvent.app", "u": 17, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events.GuildMessageDeleteEvent.channel_id", "u": 17, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.message_events.GuildMessageDeleteEvent.guild_id", "u": 17, "d": "ID of the guild that this event occurred in. Returns hikari.snowflakes.Snowflake The ID of the guild."}, {"r": "hikari.events.message_events.GuildMessageDeleteEvent.is_bulk", "u": 17, "d": "Flag that determines whether this was a bulk deletion or not. Returns builtins.bool builtins.True if this was a bulk deletion, or builtins.False if it was a regular message deletion."}, {"r": "hikari.events.message_events.GuildMessageDeleteEvent.message_ids", "u": 17, "d": "Set of message IDs that were bulk deleted. Returns typing.AbstractSet[hikari.snowflakes.Snowflake] A sequence of message IDs that were bulk deleted."}, {"r": "hikari.events.message_events.GuildMessageDeleteEvent.shard", "u": 17, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.message_events.GuildMessageDeleteEvent.message_id", "u": 17, "d": "Get the ID of the first deleted message. This is contextually useful if you know this is not a bulk deletion\nevent. For all other purposes, this is the same as running next(iter(event.message_ids  . Returns hikari.snowflakes.Snowflake The first deleted message ID."}, {"r": "hikari.events.message_events.DMMessageCreateEvent", "u": 17, "d": "Event that is fired when a message is created within a DM. This contains the full message in the internal message attribute. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class DMMessageCreateEvent."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.message", "u": 17, "d": "Message that was sent in the event. Returns hikari.messages.Message The message object that was sent with this event."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.shard", "u": 17, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.app", "u": 17, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.author", "u": 17, "d": "User that sent the message. Returns hikari.users.User The user that sent the message."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.author_id", "u": 17, "d": "ID of the author of the message this event concerns. Returns hikari.snowflakes.Snowflake The ID of the author."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.channel_id", "u": 17, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.content", "u": 17, "d": "Content of the message. Returns typing.Optional[builtins.str] The content of the message, if present. This may be builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent)."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.embeds", "u": 17, "d": "Sequence of embeds in the message. Returns typing.Sequence[hikari.embeds.Embed] The embeds in the message."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.is_bot", "u": 17, "d": "Return builtins.True if the message is from a bot. Returns builtins.bool builtins.True if from a bot, or builtins.False otherwise."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.is_human", "u": 17, "d": "Return builtins.True if the message was created by a human. Returns builtins.bool builtins.True if from a human user, or builtins.False otherwise."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.is_webhook", "u": 17, "d": "Return builtins.True if the message was created by a webhook. Returns builtins.bool builtins.True if from a webhook, or builtins.False otherwise."}, {"r": "hikari.events.message_events.DMMessageCreateEvent.message_id", "u": 17, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent", "u": 17, "d": "Event that is fired when a message is updated in a DM. ! note Less information will be available here than in the creation event due to Discord limitations. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class DMMessageUpdateEvent."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.message", "u": 17, "d": "Partial message that was sent in the event. Returns hikari.messages.PartialMessage The partial message object that was sent with this event."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.old_message", "u": 17, "d": "The old message object. This will be builtins.None if the message missing from the cache."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.shard", "u": 17, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.app", "u": 17, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.author", "u": 17, "d": "User that sent the message. This will be hikari.undefined.UNDEFINED in some cases such as when Discord\nupdates a message with an embed URL preview."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.author_id", "u": 17, "d": "ID of the author that triggered this event. This will be hikari.undefined.UNDEFINED in some cases such as when Discord\nupdates a message with an embed URL preview."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.channel_id", "u": 17, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.content", "u": 17, "d": "Content of the message. Returns hikari.undefined.UndefinedNoneOr[builtins.str] The content of the message, if present. This may be builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent). If not part of the update, then this will be hikari.undefined.UNDEFINED instead."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.embeds", "u": 17, "d": "Sequence of embeds in the message. Returns hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed The embeds in the message. If the embeds were not changed in this event, then this may instead be hikari.undefined.UNDEFINED ."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.is_bot", "u": 17, "d": "Return builtins.True if the message is from a bot. Returns typing.Optional[builtins.bool] builtins.True if from a bot, or builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this will return hikari.undefined.UNDEFINED instead."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.is_human", "u": 17, "d": "Return builtins.True if the message was created by a human. Returns typing.Optional[builtins.bool] builtins.True if from a human user, or builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this may return hikari.undefined.UNDEFINED instead."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.is_webhook", "u": 17, "d": "Return builtins.True if the message was created by a webhook. Returns builtins.bool builtins.True if from a webhook, or builtins.False otherwise."}, {"r": "hikari.events.message_events.DMMessageUpdateEvent.message_id", "u": 17, "d": "ID of the message that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the message that this event concerns."}, {"r": "hikari.events.message_events.DMMessageDeleteEvent", "u": 17, "d": "Event that is triggered if messages are deleted in a DM. ! note Due to Discord limitations, most message information is unavailable during deletion events. This is triggered for singular message deletion, and bulk message\ndeletion, although the latter is not expected to occur in DMs. You can check if the message was in a singular deletion by checking the is_bulk attribute. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class DMMessageDeleteEvent."}, {"r": "hikari.events.message_events.DMMessageDeleteEvent.app", "u": 17, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.message_events.DMMessageDeleteEvent.channel_id", "u": 17, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.message_events.DMMessageDeleteEvent.is_bulk", "u": 17, "d": "Flag that determines whether this was a bulk deletion or not. Returns builtins.bool builtins.True if this was a bulk deletion, or builtins.False if it was a regular message deletion."}, {"r": "hikari.events.message_events.DMMessageDeleteEvent.message_ids", "u": 17, "d": "Set of message IDs that were bulk deleted. Returns typing.AbstractSet[hikari.snowflakes.Snowflake] A sequence of message IDs that were bulk deleted."}, {"r": "hikari.events.message_events.DMMessageDeleteEvent.shard", "u": 17, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.message_events.DMMessageDeleteEvent.message_id", "u": 17, "d": "Get the ID of the first deleted message. This is contextually useful if you know this is not a bulk deletion\nevent. For all other purposes, this is the same as running next(iter(event.message_ids  . Returns hikari.snowflakes.Snowflake The first deleted message ID."}, {"r": "hikari.events.channel_events", "u": 18, "d": "Events that fire when channels are modified. This does not include message events, nor reaction events."}, {"r": "hikari.events.channel_events.ChannelEvent", "u": 18, "d": "Event base for any channel-bound event in guilds or private messages. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS - hikari.intents.Intents.DM_MESSAGES "}, {"r": "hikari.events.channel_events.ChannelEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.ChannelEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.PartialChannel A derivative of hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.ChannelEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.ChannelEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.GuildChannelEvent", "u": 18, "d": "Event base for any channel-bound event in guilds. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS "}, {"r": "hikari.events.channel_events.GuildChannelEvent.guild_id", "u": 18, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.channel_events.GuildChannelEvent.get_guild", "u": 18, "d": "Get the cached guild that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return builtins.None .", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelEvent.fetch_guild", "u": 18, "d": "Perform an API call to fetch the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild that this event occurred in. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelEvent.get_channel", "u": 18, "d": "Get the cached channel that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return builtins.None instead.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.GuildChannel A derivative of hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.GuildChannelEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.GuildChannelEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.DMChannelEvent", "u": 18, "d": "Event base for any channel-bound event in private messages."}, {"r": "hikari.events.channel_events.DMChannelEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.PrivateChannel A derivative of hikari.channels.PrivateChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the VIEW_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.DMChannelEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.DMChannelEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.DMChannelEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.ChannelCreateEvent", "u": 18, "d": "Base event for any channel being created. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS - hikari.intents.Intents.DM_MESSAGES "}, {"r": "hikari.events.channel_events.ChannelCreateEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.ChannelCreateEvent.channel", "u": 18, "d": "Channel this event represents. Returns hikari.channels.PartialChannel The channel that was created."}, {"r": "hikari.events.channel_events.ChannelCreateEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.ChannelCreateEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.PartialChannel A derivative of hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.ChannelCreateEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.GuildChannelCreateEvent", "u": 18, "d": "Event fired when a guild channel is created. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class GuildChannelCreateEvent."}, {"r": "hikari.events.channel_events.GuildChannelCreateEvent.guild_id", "u": 18, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.channel_events.GuildChannelCreateEvent.channel", "u": 18, "d": "Guild channel that this event represents. Returns hikari.channels.GuildChannel The guild channel that was created."}, {"r": "hikari.events.channel_events.GuildChannelCreateEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.GuildChannelCreateEvent.get_guild", "u": 18, "d": "Get the cached guild that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return builtins.None .", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelCreateEvent.fetch_guild", "u": 18, "d": "Perform an API call to fetch the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild that this event occurred in. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelCreateEvent.get_channel", "u": 18, "d": "Get the cached channel that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return builtins.None instead.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelCreateEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.GuildChannel A derivative of hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelCreateEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.GuildChannelCreateEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.ChannelUpdateEvent", "u": 18, "d": "Base event for any channel being updated. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS - hikari.intents.Intents.DM_MESSAGES "}, {"r": "hikari.events.channel_events.ChannelUpdateEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.ChannelUpdateEvent.channel", "u": 18, "d": "Channel this event represents. Returns hikari.channels.PartialChannel The channel that was updated."}, {"r": "hikari.events.channel_events.ChannelUpdateEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.ChannelUpdateEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.PartialChannel A derivative of hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.ChannelUpdateEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent", "u": 18, "d": "Event fired when a guild channel is edited. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class GuildChannelUpdateEvent."}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent.guild_id", "u": 18, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent.channel", "u": 18, "d": "Guild channel that this event represents. Returns hikari.channels.GuildChannel The guild channel that was updated."}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent.old_channel", "u": 18, "d": "The old guild channel object. This will be builtins.None if the channel missing from the cache."}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent.get_guild", "u": 18, "d": "Get the cached guild that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return builtins.None .", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent.fetch_guild", "u": 18, "d": "Perform an API call to fetch the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild that this event occurred in. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent.get_channel", "u": 18, "d": "Get the cached channel that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return builtins.None instead.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.GuildChannel A derivative of hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.GuildChannelUpdateEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.ChannelDeleteEvent", "u": 18, "d": "Base event for any channel being deleted. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS - hikari.intents.Intents.DM_MESSAGES "}, {"r": "hikari.events.channel_events.ChannelDeleteEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.ChannelDeleteEvent.channel", "u": 18, "d": "Channel this event represents. Returns hikari.channels.PartialChannel The channel that was deleted."}, {"r": "hikari.events.channel_events.ChannelDeleteEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.ChannelDeleteEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.PartialChannel A derivative of hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.ChannelDeleteEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.GuildChannelDeleteEvent", "u": 18, "d": "Event fired when a guild channel is deleted. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class GuildChannelDeleteEvent."}, {"r": "hikari.events.channel_events.GuildChannelDeleteEvent.guild_id", "u": 18, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.channel_events.GuildChannelDeleteEvent.channel", "u": 18, "d": "Guild channel that this event represents. Returns hikari.channels.GuildChannel The guild channel that was deleted."}, {"r": "hikari.events.channel_events.GuildChannelDeleteEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.GuildChannelDeleteEvent.get_guild", "u": 18, "d": "Get the cached guild that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return builtins.None .", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelDeleteEvent.fetch_guild", "u": 18, "d": "Perform an API call to fetch the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild that this event occurred in. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelDeleteEvent.get_channel", "u": 18, "d": "Get the cached channel that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return builtins.None instead.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelDeleteEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.GuildChannel A derivative of hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.GuildChannelDeleteEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.GuildChannelDeleteEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.PinsUpdateEvent", "u": 18, "d": "Base event fired when a message is pinned/unpinned in a channel. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGES - hikari.intents.Intents.GUILDS "}, {"r": "hikari.events.channel_events.PinsUpdateEvent.last_pin_timestamp", "u": 18, "d": "Datetime of when the most recent message was pinned in the channel. Will be builtins.None if nothing is pinned or the information is\nunavailable. Returns typing.Optional[datetime.datetime] The datetime of the most recent pinned message in the channel, or builtins.None if no pins are available."}, {"r": "hikari.events.channel_events.PinsUpdateEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. Returns hikari.channels.TextableChannel A derivative of hikari.channels.TextableChannel . The actual type will vary depending on the type of channel this event concerns.", "f": 1}, {"r": "hikari.events.channel_events.PinsUpdateEvent.fetch_pins", "u": 18, "d": "Perform an API call to fetch the pinned messages in this channel. Returns typing.Sequence[hikari.messages.Message] The pinned messages in this channel.", "f": 1}, {"r": "hikari.events.channel_events.PinsUpdateEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.PinsUpdateEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.PinsUpdateEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent", "u": 18, "d": "Event fired when a message is pinned/unpinned in a guild channel. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class GuildPinsUpdateEvent."}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent.get_channel", "u": 18, "d": "Get the cached channel that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.channels.TextableGuildChannel] The cached channel this event relates to. If not known, this will return builtins.None instead.", "f": 1}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. Returns hikari.channels.TextableGuildChannel A derivative of hikari.channels.TextableGuildChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the VIEW_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent.guild_id", "u": 18, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent.last_pin_timestamp", "u": 18, "d": "Datetime of when the most recent message was pinned in the channel. Will be builtins.None if nothing is pinned or the information is\nunavailable. Returns typing.Optional[datetime.datetime] The datetime of the most recent pinned message in the channel, or builtins.None if no pins are available."}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent.fetch_pins", "u": 18, "d": "Perform an API call to fetch the pinned messages in this channel. Returns typing.Sequence[hikari.messages.Message] The pinned messages in this channel.", "f": 1}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent.get_guild", "u": 18, "d": "Get the cached guild that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return builtins.None .", "f": 1}, {"r": "hikari.events.channel_events.GuildPinsUpdateEvent.fetch_guild", "u": 18, "d": "Perform an API call to fetch the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild that this event occurred in. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.DMPinsUpdateEvent", "u": 18, "d": "Event fired when a message is pinned/unpinned in a private channel. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class DMPinsUpdateEvent."}, {"r": "hikari.events.channel_events.DMPinsUpdateEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. Returns hikari.channels.DMChannel A derivative of hikari.channels.DMChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.DMPinsUpdateEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.DMPinsUpdateEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.DMPinsUpdateEvent.last_pin_timestamp", "u": 18, "d": "Datetime of when the most recent message was pinned in the channel. Will be builtins.None if nothing is pinned or the information is\nunavailable. Returns typing.Optional[datetime.datetime] The datetime of the most recent pinned message in the channel, or builtins.None if no pins are available."}, {"r": "hikari.events.channel_events.DMPinsUpdateEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.DMPinsUpdateEvent.fetch_pins", "u": 18, "d": "Perform an API call to fetch the pinned messages in this channel. Returns typing.Sequence[hikari.messages.Message] The pinned messages in this channel.", "f": 1}, {"r": "hikari.events.channel_events.InviteCreateEvent", "u": 18, "d": "Event fired when an invite is created in a channel. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_INVITES Method generated by attrs for class InviteCreateEvent."}, {"r": "hikari.events.channel_events.InviteCreateEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.InviteCreateEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.InviteCreateEvent.guild_id", "u": 18, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.channel_events.InviteCreateEvent.code", "u": 18, "d": "Code that is used in the URL for the invite. Returns builtins.str The invite code."}, {"r": "hikari.events.channel_events.InviteCreateEvent.invite", "u": 18, "d": "Invite that was created. Returns hikari.invites.InviteWithMetadata The created invite object."}, {"r": "hikari.events.channel_events.InviteCreateEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.InviteCreateEvent.get_guild", "u": 18, "d": "Get the cached guild that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return builtins.None .", "f": 1}, {"r": "hikari.events.channel_events.InviteCreateEvent.fetch_guild", "u": 18, "d": "Perform an API call to fetch the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild that this event occurred in. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.InviteCreateEvent.get_channel", "u": 18, "d": "Get the cached channel that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return builtins.None instead.", "f": 1}, {"r": "hikari.events.channel_events.InviteCreateEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.GuildChannel A derivative of hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.InviteDeleteEvent", "u": 18, "d": "Event fired when an invite is deleted from a channel. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_INVITES Method generated by attrs for class InviteDeleteEvent."}, {"r": "hikari.events.channel_events.InviteDeleteEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.InviteDeleteEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.InviteDeleteEvent.code", "u": 18, "d": "Code that is used in the URL for the invite. Returns builtins.str The invite code."}, {"r": "hikari.events.channel_events.InviteDeleteEvent.guild_id", "u": 18, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.channel_events.InviteDeleteEvent.old_invite", "u": 18, "d": "Object of the old cached invite. This will be builtins.None if the invite is missing from the cache."}, {"r": "hikari.events.channel_events.InviteDeleteEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.InviteDeleteEvent.get_guild", "u": 18, "d": "Get the cached guild that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return builtins.None .", "f": 1}, {"r": "hikari.events.channel_events.InviteDeleteEvent.fetch_guild", "u": 18, "d": "Perform an API call to fetch the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild that this event occurred in. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.InviteDeleteEvent.get_channel", "u": 18, "d": "Get the cached channel that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return builtins.None instead.", "f": 1}, {"r": "hikari.events.channel_events.InviteDeleteEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.GuildChannel A derivative of hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.WebhookUpdateEvent", "u": 18, "d": "Event fired when a webhook is created/updated/deleted in a channel. Unfortunately, Discord does not provide any information on what webhook\nactually changed, nor specifically whether it was created/updated/deleted,\nso this event is pretty useless unless you keep track of the webhooks in\nthe channel manually beforehand. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_WEBHOOKS Method generated by attrs for class WebhookUpdateEvent."}, {"r": "hikari.events.channel_events.WebhookUpdateEvent.fetch_channel_webhooks", "u": 18, "d": "Perform an API call to fetch the webhooks for this channel. Returns typing.Sequence[hikari.webhooks.PartialWebhook] The webhooks in this channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.WebhookUpdateEvent.fetch_guild_webhooks", "u": 18, "d": "Perform an API call to fetch the webhooks for this guild. Returns typing.Sequence[hikari.webhooks.PartialWebhook] The webhooks in this guild. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.WebhookUpdateEvent.app", "u": 18, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.channel_events.WebhookUpdateEvent.channel_id", "u": 18, "d": "ID of the channel the event relates to. Returns hikari.snowflakes.Snowflake The ID of the channel this event relates to."}, {"r": "hikari.events.channel_events.WebhookUpdateEvent.guild_id", "u": 18, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.channel_events.WebhookUpdateEvent.shard", "u": 18, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.channel_events.WebhookUpdateEvent.get_guild", "u": 18, "d": "Get the cached guild that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return builtins.None .", "f": 1}, {"r": "hikari.events.channel_events.WebhookUpdateEvent.fetch_guild", "u": 18, "d": "Perform an API call to fetch the guild that this event relates to. Returns hikari.guilds.RESTGuild The guild that this event occurred in. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.channel_events.WebhookUpdateEvent.get_channel", "u": 18, "d": "Get the cached channel that this event relates to, if known. If not, return builtins.None . Returns typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return builtins.None instead.", "f": 1}, {"r": "hikari.events.channel_events.WebhookUpdateEvent.fetch_channel", "u": 18, "d": "Perform an API call to fetch the details about this channel. ! note For ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns hikari.channels.GuildChannel A derivative of hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.shard_events", "u": 19, "d": "Events relating to specific shards events."}, {"r": "hikari.events.shard_events.ShardEvent", "u": 19, "d": "Base class for any event that was shard-specific."}, {"r": "hikari.events.shard_events.ShardEvent.shard", "u": 19, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.shard_events.ShardEvent.app", "u": 19, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.shard_events.ShardPayloadEvent", "u": 19, "d": "Event fired for most shard events with their raw payload. ! note This will only be dispatched for real dispatch events received from Discord and not artificial events like the ShardStateEvent events. Method generated by attrs for class ShardPayloadEvent."}, {"r": "hikari.events.shard_events.ShardPayloadEvent.app", "u": 19, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.shard_events.ShardPayloadEvent.name", "u": 19, "d": "Name of the received event."}, {"r": "hikari.events.shard_events.ShardPayloadEvent.payload", "u": 19, "d": "The raw payload for this event."}, {"r": "hikari.events.shard_events.ShardPayloadEvent.shard", "u": 19, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.shard_events.ShardStateEvent", "u": 19, "d": "Base class for any event concerning the state/connectivity of a shard. This currently wraps connection/disconnection/ready/resumed events only."}, {"r": "hikari.events.shard_events.ShardStateEvent.shard", "u": 19, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.shard_events.ShardStateEvent.app", "u": 19, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.shard_events.ShardConnectedEvent", "u": 19, "d": "Event fired when a shard connects. Method generated by attrs for class ShardConnectedEvent."}, {"r": "hikari.events.shard_events.ShardConnectedEvent.app", "u": 19, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.shard_events.ShardConnectedEvent.shard", "u": 19, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.shard_events.ShardDisconnectedEvent", "u": 19, "d": "Event fired when a shard disconnects. Method generated by attrs for class ShardDisconnectedEvent."}, {"r": "hikari.events.shard_events.ShardDisconnectedEvent.app", "u": 19, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.shard_events.ShardDisconnectedEvent.shard", "u": 19, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.shard_events.ShardReadyEvent", "u": 19, "d": "Event fired when a shard declares it is ready. Method generated by attrs for class ShardReadyEvent."}, {"r": "hikari.events.shard_events.ShardReadyEvent.app", "u": 19, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.shard_events.ShardReadyEvent.actual_gateway_version", "u": 19, "d": "Actual gateway version being used. Returns builtins.int The actual gateway version we are actively using for this protocol."}, {"r": "hikari.events.shard_events.ShardReadyEvent.application_flags", "u": 19, "d": "Flags of the application this ready event is for. Returns hikari.applications.ApplicationFlags The current application's flags."}, {"r": "hikari.events.shard_events.ShardReadyEvent.application_id", "u": 19, "d": "ID of the application this ready event is for. Returns hikari.snowflakes.Snowflake The current application's ID."}, {"r": "hikari.events.shard_events.ShardReadyEvent.my_user", "u": 19, "d": "User for the current bot account this connection is authenticated with. Returns hikari.users.OwnUser This bot's user."}, {"r": "hikari.events.shard_events.ShardReadyEvent.session_id", "u": 19, "d": "ID for this session. Returns builtins.str The session ID for this gateway session."}, {"r": "hikari.events.shard_events.ShardReadyEvent.shard", "u": 19, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.shard_events.ShardReadyEvent.unavailable_guilds", "u": 19, "d": "Sequence of the IDs for all guilds this bot is currently in. All guilds will start off \"unavailable\" and should become available after\na few seconds of connecting one-by-one. Returns typing.Sequence[hikari.snowflakes.Snowflake] All guild IDs that the bot is in for this shard."}, {"r": "hikari.events.shard_events.ShardResumedEvent", "u": 19, "d": "Event fired when a shard resumes an existing session. Method generated by attrs for class ShardResumedEvent."}, {"r": "hikari.events.shard_events.ShardResumedEvent.app", "u": 19, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.shard_events.ShardResumedEvent.shard", "u": 19, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.shard_events.MemberChunkEvent", "u": 19, "d": "Event fired when a member chunk payload is received on a gateway shard. Method generated by attrs for class MemberChunkEvent."}, {"r": "hikari.events.shard_events.MemberChunkEvent.app", "u": 19, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.shard_events.MemberChunkEvent.chunk_count", "u": 19, "d": "Total number of expected chunks for the request this is associated with. Returns builtins.int Total number of chunks to be expected."}, {"r": "hikari.events.shard_events.MemberChunkEvent.chunk_index", "u": 19, "d": "Zero-indexed position of this within the queued up chunks for this request. Returns builtins.int The sequence index for this chunk."}, {"r": "hikari.events.shard_events.MemberChunkEvent.guild_id", "u": 19, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.events.shard_events.MemberChunkEvent.members", "u": 19, "d": "Mapping of user IDs to the objects of the members in this chunk. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.guilds.Member] Mapping of user IDs to corresponding member objects."}, {"r": "hikari.events.shard_events.MemberChunkEvent.nonce", "u": 19, "d": "String nonce used to identify the request member chunks are associated with. This is the nonce value passed while requesting member chunks. Returns typing.Optional[builtins.str] The request nonce if set, or builtins.None otherwise."}, {"r": "hikari.events.shard_events.MemberChunkEvent.not_found", "u": 19, "d": "Sequence of the snowflakes that were not found while making this request. This is only applicable when user IDs are specified while making the\nmember request the chunk is associated with. Returns typing.Sequence[hikari.snowflakes.Snowflake] Sequence of user IDs that were not found."}, {"r": "hikari.events.shard_events.MemberChunkEvent.presences", "u": 19, "d": "Mapping of user IDs to found member presence objects. This will be empty if no presences are found or include_presences is not passed as builtins.True while requesting the member chunks. Returns typing.Mapping[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] Mapping of user IDs to corresponding presences."}, {"r": "hikari.events.shard_events.MemberChunkEvent.shard", "u": 19, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.role_events", "u": 20, "d": "Events pertaining to manipulation of roles within guilds."}, {"r": "hikari.events.role_events.RoleEvent", "u": 20, "d": "Event base for any event that involves guild roles. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS "}, {"r": "hikari.events.role_events.RoleEvent.guild_id", "u": 20, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.role_events.RoleEvent.role_id", "u": 20, "d": "ID of the role that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the role that relates to this event."}, {"r": "hikari.events.role_events.RoleEvent.shard", "u": 20, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.role_events.RoleEvent.app", "u": 20, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.role_events.RoleCreateEvent", "u": 20, "d": "Event fired when a role is created. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class RoleCreateEvent."}, {"r": "hikari.events.role_events.RoleCreateEvent.app", "u": 20, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.role_events.RoleCreateEvent.guild_id", "u": 20, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.role_events.RoleCreateEvent.role_id", "u": 20, "d": "ID of the role that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the role that relates to this event."}, {"r": "hikari.events.role_events.RoleCreateEvent.role", "u": 20, "d": "Role that was created. Returns hikari.guilds.Role The created role."}, {"r": "hikari.events.role_events.RoleCreateEvent.shard", "u": 20, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.role_events.RoleUpdateEvent", "u": 20, "d": "Event fired when a role is updated. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class RoleUpdateEvent."}, {"r": "hikari.events.role_events.RoleUpdateEvent.app", "u": 20, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.role_events.RoleUpdateEvent.guild_id", "u": 20, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.role_events.RoleUpdateEvent.role_id", "u": 20, "d": "ID of the role that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the role that relates to this event."}, {"r": "hikari.events.role_events.RoleUpdateEvent.old_role", "u": 20, "d": "The old role object. This will be builtins.None if the role missing from the cache."}, {"r": "hikari.events.role_events.RoleUpdateEvent.role", "u": 20, "d": "Role that was updated. Returns hikari.guilds.Role The created role."}, {"r": "hikari.events.role_events.RoleUpdateEvent.shard", "u": 20, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.role_events.RoleDeleteEvent", "u": 20, "d": "Event fired when a role is deleted. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILDS Method generated by attrs for class RoleDeleteEvent."}, {"r": "hikari.events.role_events.RoleDeleteEvent.app", "u": 20, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.role_events.RoleDeleteEvent.guild_id", "u": 20, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.role_events.RoleDeleteEvent.old_role", "u": 20, "d": "The old role object. This will be builtins.None if the role was missing from the cache."}, {"r": "hikari.events.role_events.RoleDeleteEvent.role_id", "u": 20, "d": "ID of the role that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the role that relates to this event."}, {"r": "hikari.events.role_events.RoleDeleteEvent.shard", "u": 20, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.user_events", "u": 21, "d": "Events fired when the account user is updated."}, {"r": "hikari.events.user_events.OwnUserUpdateEvent", "u": 21, "d": "Event fired when the account user is updated. Method generated by attrs for class OwnUserUpdateEvent."}, {"r": "hikari.events.user_events.OwnUserUpdateEvent.app", "u": 21, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.user_events.OwnUserUpdateEvent.old_user", "u": 21, "d": "The old application user. This will be builtins.None if the user missing from the cache."}, {"r": "hikari.events.user_events.OwnUserUpdateEvent.shard", "u": 21, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.user_events.OwnUserUpdateEvent.user", "u": 21, "d": "This application user. Returns hikari.users.OwnUser This application user."}, {"r": "hikari.events.typing_events", "u": 22, "d": "Events fired when users begin typing in channels."}, {"r": "hikari.events.typing_events.TypingEvent", "u": 22, "d": "Base event fired when a user begins typing in a channel. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_TYPING - hikari.intents.Intents.DM_MESSAGE_TYPING "}, {"r": "hikari.events.typing_events.TypingEvent.channel_id", "u": 22, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.typing_events.TypingEvent.user_id", "u": 22, "d": "ID of the user who triggered this typing event. Returns hikari.snowflakes.Snowflake ID of the user who is typing."}, {"r": "hikari.events.typing_events.TypingEvent.timestamp", "u": 22, "d": "Timestamp of when this typing event started. Returns datetime.datetime UTC timestamp of when the user started typing."}, {"r": "hikari.events.typing_events.TypingEvent.fetch_channel", "u": 22, "d": "Perform an API call to fetch an up-to-date image of this channel. Returns hikari.channels.TextableChannel The channel.", "f": 1}, {"r": "hikari.events.typing_events.TypingEvent.get_user", "u": 22, "d": "Get the cached user that is typing, if known. Returns typing.Optional[hikari.users.User] The user, if known.", "f": 1}, {"r": "hikari.events.typing_events.TypingEvent.fetch_user", "u": 22, "d": "Perform an API call to fetch an up-to-date image of this user. Returns hikari.users.User The user. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.typing_events.TypingEvent.trigger_typing", "u": 22, "d": "Return a typing indicator for this channel that can be awaited. Returns hikari.api.special_endpoints.TypingIndicator A typing indicator context manager and awaitable to trigger typing in a channel with.", "f": 1}, {"r": "hikari.events.typing_events.TypingEvent.shard", "u": 22, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.typing_events.TypingEvent.app", "u": 22, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.typing_events.GuildTypingEvent", "u": 22, "d": "Event fired when a user starts typing in a guild channel. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.GUILD_MESSAGE_TYPING Method generated by attrs for class GuildTypingEvent."}, {"r": "hikari.events.typing_events.GuildTypingEvent.app", "u": 22, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.typing_events.GuildTypingEvent.user_id", "u": 22, "d": "ID of the user who triggered this typing event. Returns hikari.snowflakes.Snowflake ID of the user who is typing."}, {"r": "hikari.events.typing_events.GuildTypingEvent.fetch_channel", "u": 22, "d": "Perform an API call to fetch an up-to-date image of this channel. Returns typing.Union[hikari.channels.TextableGuildChannel] The channel.", "f": 1}, {"r": "hikari.events.typing_events.GuildTypingEvent.fetch_guild", "u": 22, "d": "Perform an API call to fetch an up-to-date image of this guild. Returns hikari.guilds.Guild The guild.", "f": 1}, {"r": "hikari.events.typing_events.GuildTypingEvent.fetch_guild_preview", "u": 22, "d": "Perform an API call to fetch an up-to-date preview of this guild. Returns hikari.guilds.GuildPreview The guild.", "f": 1}, {"r": "hikari.events.typing_events.GuildTypingEvent.fetch_member", "u": 22, "d": "Perform an API call to fetch an up-to-date image of this event's member. Returns hikari.guilds.Member The member.", "f": 1}, {"r": "hikari.events.typing_events.GuildTypingEvent.get_channel", "u": 22, "d": "Get the cached channel object this typing event occurred in. Returns typing.Optional[hikari.channels.TextableGuildChannel] The channel.", "f": 1}, {"r": "hikari.events.typing_events.GuildTypingEvent.get_guild", "u": 22, "d": "Get the cached object of the guild this typing event occurred in. If the guild is not found then this will return builtins.None . Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the gateway guild if found else builtins.None .", "f": 1}, {"r": "hikari.events.typing_events.GuildTypingEvent.channel_id", "u": 22, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.typing_events.GuildTypingEvent.guild_id", "u": 22, "d": "ID of the guild that this event relates to. Returns hikari.snowflakes.Snowflake The ID of the guild that relates to this event."}, {"r": "hikari.events.typing_events.GuildTypingEvent.member", "u": 22, "d": "Object of the member who triggered this typing event. Returns hikari.guilds.Member Object of the member who triggered this typing event."}, {"r": "hikari.events.typing_events.GuildTypingEvent.shard", "u": 22, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.typing_events.GuildTypingEvent.timestamp", "u": 22, "d": "Timestamp of when this typing event started. Returns datetime.datetime UTC timestamp of when the user started typing."}, {"r": "hikari.events.typing_events.GuildTypingEvent.get_user", "u": 22, "d": "Get the cached user that is typing, if known. Returns typing.Optional[hikari.users.User] The user, if known.", "f": 1}, {"r": "hikari.events.typing_events.GuildTypingEvent.fetch_user", "u": 22, "d": "Perform an API call to fetch an up-to-date image of this user. Returns hikari.users.User The user. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.typing_events.GuildTypingEvent.trigger_typing", "u": 22, "d": "Return a typing indicator for this channel that can be awaited. Returns hikari.api.special_endpoints.TypingIndicator A typing indicator context manager and awaitable to trigger typing in a channel with.", "f": 1}, {"r": "hikari.events.typing_events.DMTypingEvent", "u": 22, "d": "Event fired when a user starts typing in a guild channel. This requires one of the following combinations of intents in order to be dispatched: - hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class DMTypingEvent."}, {"r": "hikari.events.typing_events.DMTypingEvent.fetch_channel", "u": 22, "d": "Perform an API call to fetch an up-to-date image of this channel. Returns hikari.channels.DMChannel The channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.typing_events.DMTypingEvent.app", "u": 22, "d": "App instance for this application. Returns hikari.traits.RESTAware The REST-aware app trait."}, {"r": "hikari.events.typing_events.DMTypingEvent.channel_id", "u": 22, "d": "ID of the channel that this event concerns. Returns hikari.snowflakes.Snowflake The ID of the channel that this event concerns."}, {"r": "hikari.events.typing_events.DMTypingEvent.shard", "u": 22, "d": "Shard that received this event. Returns hikari.api.shard.GatewayShard The shard that triggered the event."}, {"r": "hikari.events.typing_events.DMTypingEvent.timestamp", "u": 22, "d": "Timestamp of when this typing event started. Returns datetime.datetime UTC timestamp of when the user started typing."}, {"r": "hikari.events.typing_events.DMTypingEvent.user_id", "u": 22, "d": "ID of the user who triggered this typing event. Returns hikari.snowflakes.Snowflake ID of the user who is typing."}, {"r": "hikari.events.typing_events.DMTypingEvent.get_user", "u": 22, "d": "Get the cached user that is typing, if known. Returns typing.Optional[hikari.users.User] The user, if known.", "f": 1}, {"r": "hikari.events.typing_events.DMTypingEvent.fetch_user", "u": 22, "d": "Perform an API call to fetch an up-to-date image of this user. Returns hikari.users.User The user. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.events.typing_events.DMTypingEvent.trigger_typing", "u": 22, "d": "Return a typing indicator for this channel that can be awaited. Returns hikari.api.special_endpoints.TypingIndicator A typing indicator context manager and awaitable to trigger typing in a channel with.", "f": 1}, {"r": "hikari.api", "u": 23, "d": "Interfaces for components that make up Hikari applications. These are provided to uncouple specific implementation details from each\nimplementation, thus allowing custom solutions to be engineered such as bots\nrelying on a distributed event bus or cache."}, {"r": "hikari.api.cache", "u": 24, "d": "Core interface for a cache implementation."}, {"r": "hikari.api.cache.CacheView", "u": 24, "d": "Interface describing an immutable snapshot view of part of a cache. This can be treated as a normal typing.Mapping but with some special methods."}, {"r": "hikari.api.cache.CacheView.get_item_at", "u": 24, "d": "", "f": 1}, {"r": "hikari.api.cache.CacheView.iterator", "u": 24, "d": "Get a lazy iterator of the entities in the view.", "f": 1}, {"r": "hikari.api.cache.Cache", "u": 24, "d": "Interface describing the operations a cache component should provide. This will be used by the gateway to cache specific types of\nobjects that the application should attempt to remember for later, depending\non how this is implemented. The requirement for this stems from the\nassumption by Discord that bot applications will maintain some form of\n\"memory\" of the events that occur. The implementation may choose to use a simple in-memory collection of\nobjects, or may decide to use a distributed system such as a Redis cache\nfor cross-process bots."}, {"r": "hikari.api.cache.Cache.get_dm_channel_id", "u": 24, "d": "Get the DM channel ID for a user. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get the DM channel ID for. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the DM channel which was found cached for the supplied user or builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_dm_channel_ids_view", "u": 24, "d": "Get a view of the cached DM channel IDs. Returns CacheView[hikari.snowflakes.Snowflake, hikari.snowflakes.Snowflake] Cache view of user IDs to DM channel IDs.", "f": 1}, {"r": "hikari.api.cache.Cache.get_emoji", "u": 24, "d": "Get a known custom emoji from the cache. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] Object or ID of the emoji to get from the cache. Returns typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_emojis_view", "u": 24, "d": "Get a view of the known custom emoji objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the known custom emojis found in the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_emojis_view_for_guild", "u": 24, "d": "Get a view of the known custom emojis cached for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached emoji objects for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of emojis found in the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.Cache.get_guild", "u": 24, "d": "Get a guild from the cache. ! warning This will return a guild regardless of whether it is available or not. To only query available guilds, use get_available_guild instead. Likewise, to only query unavailable guilds, use get_unavailable_guild . Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_available_guild", "u": 24, "d": "Get the object of an available guild from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_unavailable_guild", "u": 24, "d": "Get the object of a unavailable guild from the cache. ! note Unlike Cache.get_available_guild , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_guilds_view", "u": 24, "d": "Get a view of all the guild objects in the cache regardless if availability. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_available_guilds_view", "u": 24, "d": "Get a view of the available guild objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_unavailable_guilds_view", "u": 24, "d": "Get a view of the unavailable guild objects in the cache. ! note Unlike Cache.get_available_guilds_view , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_guild_channel", "u": 24, "d": "Get a guild channel from the cache. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the guild channel to get from the cache. Returns typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_guild_channels_view", "u": 24, "d": "Get a view of the guild channels in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_guild_channels_view_for_guild", "u": 24, "d": "Get a view of the guild channels in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached channels for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.Cache.get_invite", "u": 24, "d": "Get an invite object from the cache. Parameters code : typing.Union[hikari.invites.InviteCode, builtins.str] The object or string code of the invite to get from the cache. Returns typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_invites_view", "u": 24, "d": "Get a view of the invite objects in the cache. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string codes to objects of the invites that were found in the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_invites_view_for_guild", "u": 24, "d": "Get a view of the invite objects in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get invite objects for. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string code to objects of the invites that were found in the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.Cache.get_invites_view_for_channel", "u": 24, "d": "Get a view of the invite objects in the cache for a specified channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get invite objects for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the channel to get invite objects for. Returns CacheView[str, invites.InviteWithMetadata] A view of string codes to objects of the invites there were found in the cache for the specified channel.", "f": 1}, {"r": "hikari.api.cache.Cache.get_me", "u": 24, "d": "Get the own user object from the cache. Returns typing.Optional[hikari.users.OwnUser] The own user object that was found in the cache, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_member", "u": 24, "d": "Get a member object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get a cached member for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get a cached member for. Returns typing.Optional[hikari.guilds.Member] The object of the member found in the cache, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_members_view", "u": 24, "d": "Get a view of all the members objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were found from the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_members_view_for_guild", "u": 24, "d": "Get a view of the members cached for a specific guild. Parameters guild_id : hikari.snowflakes.Snowflakeish The ID of the guild to get the cached member view for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the members cached for the specified guild.", "f": 1}, {"r": "hikari.api.cache.Cache.get_message", "u": 24, "d": "Get a message object from the cache. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] Object or ID of the message to get from the cache. Returns typing.Optional[hikari.messages.Message] The object of the message found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_messages_view", "u": 24, "d": "Get a view of all the message objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.messages.Message] A view of message objects found in the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_presence", "u": 24, "d": "Get a presence object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get a presence for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get a presence for. Returns typing.Optional[hikari.presences.MemberPresence] The object of the presence that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_presences_view", "u": 24, "d": "Get a view of all the presence objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake A view of guild IDs to views of user IDs to objects of the presences found in the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_presences_view_for_guild", "u": 24, "d": "Get a view of the presence objects in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached presence objects for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presence found in the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.Cache.get_role", "u": 24, "d": "Get a role object from the cache. Parameters role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] Object or ID of the role to get from the cache. Returns typing.Optional[hikari.guilds.Role] The object of the role found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_roles_view", "u": 24, "d": "Get a view of all the role objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles found in the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_roles_view_for_guild", "u": 24, "d": "Get a view of the roles in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached roles for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were found in the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.Cache.get_user", "u": 24, "d": "Get a user object from the cache. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get from the cache. Returns typing.Optional[hikari.users.User] The object of the user that was found in the cache, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_users_view", "u": 24, "d": "Get a view of the user objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.users.User] The view of user IDs to the users found in the cache.", "f": 1}, {"r": "hikari.api.cache.Cache.get_voice_state", "u": 24, "d": "Get a voice state object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get a voice state for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get a voice state for. Returns typing.Optional[hikari.voices.VoiceState] The object of the voice state that was found in the cache, or builtins.None .", "f": 1}, {"r": "hikari.api.cache.Cache.get_voice_states_view", "u": 24, "d": "Get a view of all the voice state objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were found in the cache,", "f": 1}, {"r": "hikari.api.cache.Cache.get_voice_states_view_for_channel", "u": 24, "d": "Get a view of the voice states cached for a specific channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached voice states for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the channel to get the cached voice states for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified channel.", "f": 1}, {"r": "hikari.api.cache.Cache.get_voice_states_view_for_guild", "u": 24, "d": "Get a view of the voice states cached for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached voice states for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache", "u": 24, "d": "Cache that exposes read-only operations as well as mutation operations. This is only exposed to internal components. There is no guarantee the\nuser-facing cache will provide these methods or not."}, {"r": "hikari.api.cache.MutableCache.clear", "u": 24, "d": "Clear the full cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_dm_channel_ids", "u": 24, "d": "Remove all the cached DM channel IDs. Returns CacheView[hikari.snowflakes.Snowflake, hikari.snowflakes.Snowflake] Cache view of user IDs to DM channel IDs which were cleared from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_dm_channel_id", "u": 24, "d": "Remove a DM channel ID from the cache. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to remove the cached DM channel ID for. Returns typing.Optional[hikari.snowflakes.Snowflake] The DM channel ID which was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_dm_channel_id", "u": 24, "d": "Add a DM channel ID to the cache. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to add a DM channel ID to the cache for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the DM channel to add to the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_emojis", "u": 24, "d": "Remove all the known custom emoji objects from the cache. ! note This will skip emojis that are being kept alive by a reference on a presence entry. Returns CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A cache view of emoji IDs to objects of the emojis that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_emojis_for_guild", "u": 24, "d": "Remove the known custom emoji objects cached for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove the cached emoji objects for. ! note This will skip emojis that are being kept alive by a reference on a presence entry. Returns CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the emojis that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_emoji", "u": 24, "d": "Remove a known custom emoji from the cache. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] Object or ID of the emoji to remove from the cache. ! note This will not delete emojis that are being kept alive by a reference on a presence entry. Returns typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was removed from the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_emoji", "u": 24, "d": "Add a known custom emoji to the cache. Parameters emoji : hikari.emojis.KnownCustomEmoji The object of the known custom emoji to add to the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.update_emoji", "u": 24, "d": "Update an emoji object in the cache. Parameters emoji : hikari.emojis.KnownCustomEmoji The object of the emoji to update in the cache. Returns typing.Tuple[typing.Optional[hikari.emojis.KnownCustomEmoji], typing.Optional[hikari.emojis.KnownCustomEmoji A tuple of the old cached emoji object if found (else builtins.None ) and the new cached emoji object if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_guilds", "u": 24, "d": "Remove all the guild objects from the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] The cache view of guild IDs to guild objects that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_guild", "u": 24, "d": "Remove a guild object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild that was removed from the cache, will be builtins.None if not found.", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_guild", "u": 24, "d": "Add a guild object to the cache. Parameters guild : hikari.guilds.GatewayGuild The object of the guild to add to the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_guild_availability", "u": 24, "d": "Set whether a cached guild is available or not. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to set the availability for.\nis_available : builtins.bool The availability to set for the guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache.update_guild", "u": 24, "d": "Update a guild in the cache. Parameters guild : hikari.guilds.GatewayGuild The object of the guild to update in the cache. Returns typing.Tuple[typing.Optional[hikari.guilds.GatewayGuild], typing.Optional[hikari.guilds.GatewayGuild A tuple of the old cached guild object if found (else builtins.None ) and the object of the guild that was added to the cache if it could be added (else builtins.None ).", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_guild_channels", "u": 24, "d": "Remove all guild channels from the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_guild_channels_for_guild", "u": 24, "d": "Remove guild channels from the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove cached channels for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_guild_channel", "u": 24, "d": "Remove a guild channel from the cache. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the guild channel to remove from the cache. Returns typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_guild_channel", "u": 24, "d": "Add a guild channel to the cache. Parameters channel : hikari.channels.GuildChannel The guild channel based object to add to the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.update_guild_channel", "u": 24, "d": "Update a guild channel in the cache, Parameters channel : hikari.channels.GuildChannel The object of the channel to update in the cache. Returns typing.Tuple[typing.Optional[hikari.channels.GuildChannel], typing.Optional[hikari.channels.GuildChannel A tuple of the old cached guild channel if found (else builtins.None ) and the new cached guild channel if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_invites", "u": 24, "d": "Remove all the invite objects from the cache. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_invites_for_guild", "u": 24, "d": "Remove the invite objects in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove invite objects for. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_invites_for_channel", "u": 24, "d": "Remove the invite objects in the cache for a specific channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove invite objects for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the channel to remove invite objects for. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache for the specified channel.", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_invite", "u": 24, "d": "Remove an invite object from the cache. Parameters code : typing.Union[hikari.invites.InviteCode, builtins.str] Object or string code of the invite to remove from the cache. Returns typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_invite", "u": 24, "d": "Add an invite object to the cache. Parameters invite : hikari.invites.InviteWithMetadata The object of the invite to add to the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.update_invite", "u": 24, "d": "Update an invite in the cache. Parameters invite : hikari.invites.InviteWithMetadata The object of the invite to update in the cache. Returns typing.Tuple[typing.Optional[hikari.invites.InviteWithMetadata], typing.Optional[hikari.invites.InviteWithMetadata A tuple of the old cached invite object if found (else builtins.None ) and the new cached invite object if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_me", "u": 24, "d": "Remove the own user object from the cache. Returns typing.Optional[hikari.users.OwnUser] The own user object that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_me", "u": 24, "d": "Set the own user object in the cache. Parameters user : hikari.users.OwnUser The own user object to set in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.update_me", "u": 24, "d": "Update the own user entry in the cache. Parameters user : hikari.users.OwnUser The own user object to update in the cache. Returns typing.Tuple[typing.Optional[hikari.users.OwnUser], typing.Optional[hikari.users.OwnUser A tuple of the old cached own user object if found (else builtins.None ) and the new cached own user object if it could be cached, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_members", "u": 24, "d": "Remove all the guild members in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_members_for_guild", "u": 24, "d": "Remove the members for a specific guild from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove cached members for. ! note This will skip members that are being referenced by other entries in the cache; a matching voice state will keep a member entry alive. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the member objects that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_member", "u": 24, "d": "Remove a member object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove a member from the cache for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to remove a member from the cache for. ! note You cannot delete a member entry that's being referenced by other entries in the cache; a matching voice state will keep a member entry alive. Returns typing.Optional[hikari.guilds.Member] The object of the member that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_member", "u": 24, "d": "Add a member object to the cache. Parameters member : hikari.guilds.Member The object of the member to add to the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.update_member", "u": 24, "d": "Update a member in the cache. Parameters member : hikari.guilds.Member The object of the member to update in the cache. Returns typing.Tuple[typing.Optional[hikari.guilds.Member], typing.Optional[hikari.guilds.Member A tuple of the old cached member object if found (else builtins.None ) and the new cached member object if it could be cached (else builtins.None )", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_presences", "u": 24, "d": "Remove all the presences in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence A view of guild IDs to views of user IDs to objects of the presences that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_presences_for_guild", "u": 24, "d": "Remove the presences in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove presences for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presences that were removed from the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_presence", "u": 24, "d": "Remove a presence from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove a presence for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to remove a presence for. Returns typing.Optional[hikari.presences.MemberPresence] The object of the presence that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_presence", "u": 24, "d": "Add a presence object to the cache. Parameters presence : hikari.presences.MemberPresence The object of the presence to add to the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.update_presence", "u": 24, "d": "Update a presence object in the cache. Parameters presence : hikari.presences.MemberPresence The object of the presence to update in the cache. Returns typing.Tuple[typing.Optional[hikari.presences.MemberPresence], typing.Optional[hikari.presences.MemberPresence A tuple of the old cached invite object if found (else builtins.None and the new cached invite object if it could be cached ( else builtins.None ).", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_roles", "u": 24, "d": "Remove all role objects from the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_roles_for_guild", "u": 24, "d": "Remove role objects from the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove roles for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were removed from the cache for the specific guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_role", "u": 24, "d": "Remove a role object form the cache. Parameters role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] Object or ID of the role to remove from the cache. Returns typing.Optional[hikari.guilds.Role] The object of the role that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_role", "u": 24, "d": "Add a role object to the cache. Parameters role : hikari.guilds.Role The object of the role to add to the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.update_role", "u": 24, "d": "Update a role in the cache. Parameters role : hikari.guilds.Role The object of the role to update in the cache. Returns typing.Tuple[typing.Optional[hikari.guilds.Role], typing.Optional[hikari.guilds.Role A tuple of the old cached role object if found (else builtins.None and the new cached role object if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_voice_states", "u": 24, "d": "Remove all voice state objects from the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were removed from the states.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_voice_states_for_guild", "u": 24, "d": "Clear the voice state objects cached for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove cached voice states for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to the voice state objects that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_voice_states_for_channel", "u": 24, "d": "Remove the voice state objects cached for a specific channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove voice states for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the channel to remove voice states for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice state that were removed from the cache for the specified channel.", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_voice_state", "u": 24, "d": "Remove a voice state object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild the voice state to remove is related to.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user who the voice state to remove belongs to. Returns typing.Optional[hikari.voices.VoiceState] The object of the voice state that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_voice_state", "u": 24, "d": "Add a voice state object to the cache. Parameters voice_state : hikari.voices.VoiceState The object of the voice state to add to the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.update_voice_state", "u": 24, "d": "Update a voice state object in the cache. Parameters voice_state : hikari.voices.VoiceState The object of the voice state to update in the cache. Returns typing.Tuple[typing.Optional[hikari.voices.VoiceState], typing.Optional[hikari.voices.VoiceState A tuple of the old cached voice state if found (else builtins.None ) and the new cached voice state object if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.api.cache.MutableCache.clear_messages", "u": 24, "d": "Remove all message objects from the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.messages.Message] A view of message objects that were removed from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.delete_message", "u": 24, "d": "Remove a message object from the cache. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] Object or ID of the messages to remove the cache. Returns typing.Optional[hikari.messages.Message] The object of the message that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.set_message", "u": 24, "d": "Add a message object to the cache. Parameters message : hikari.messages.Message The object of the message to add to the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.update_message", "u": 24, "d": "Update a message in the cache. Parameters message : typing.Union[hikari.messages.PartialMessage, hikari.messages.Message] The object of the message to update in the cache. Returns typing.Tuple[typing.Optional[hikari.messages.Message], typing.Optional[hikari.messages.Message A tuple of the old cached message object if found (else builtins.None ) and the new cached message object if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_dm_channel_id", "u": 24, "d": "Get the DM channel ID for a user. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get the DM channel ID for. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the DM channel which was found cached for the supplied user or builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_dm_channel_ids_view", "u": 24, "d": "Get a view of the cached DM channel IDs. Returns CacheView[hikari.snowflakes.Snowflake, hikari.snowflakes.Snowflake] Cache view of user IDs to DM channel IDs.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_emoji", "u": 24, "d": "Get a known custom emoji from the cache. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] Object or ID of the emoji to get from the cache. Returns typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_emojis_view", "u": 24, "d": "Get a view of the known custom emoji objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the known custom emojis found in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_emojis_view_for_guild", "u": 24, "d": "Get a view of the known custom emojis cached for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached emoji objects for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of emojis found in the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_guild", "u": 24, "d": "Get a guild from the cache. ! warning This will return a guild regardless of whether it is available or not. To only query available guilds, use get_available_guild instead. Likewise, to only query unavailable guilds, use get_unavailable_guild . Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_available_guild", "u": 24, "d": "Get the object of an available guild from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_unavailable_guild", "u": 24, "d": "Get the object of a unavailable guild from the cache. ! note Unlike Cache.get_available_guild , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_guilds_view", "u": 24, "d": "Get a view of all the guild objects in the cache regardless if availability. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_available_guilds_view", "u": 24, "d": "Get a view of the available guild objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_unavailable_guilds_view", "u": 24, "d": "Get a view of the unavailable guild objects in the cache. ! note Unlike Cache.get_available_guilds_view , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_guild_channel", "u": 24, "d": "Get a guild channel from the cache. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the guild channel to get from the cache. Returns typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_guild_channels_view", "u": 24, "d": "Get a view of the guild channels in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_guild_channels_view_for_guild", "u": 24, "d": "Get a view of the guild channels in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached channels for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_invite", "u": 24, "d": "Get an invite object from the cache. Parameters code : typing.Union[hikari.invites.InviteCode, builtins.str] The object or string code of the invite to get from the cache. Returns typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_invites_view", "u": 24, "d": "Get a view of the invite objects in the cache. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string codes to objects of the invites that were found in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_invites_view_for_guild", "u": 24, "d": "Get a view of the invite objects in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get invite objects for. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string code to objects of the invites that were found in the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_invites_view_for_channel", "u": 24, "d": "Get a view of the invite objects in the cache for a specified channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get invite objects for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the channel to get invite objects for. Returns CacheView[str, invites.InviteWithMetadata] A view of string codes to objects of the invites there were found in the cache for the specified channel.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_me", "u": 24, "d": "Get the own user object from the cache. Returns typing.Optional[hikari.users.OwnUser] The own user object that was found in the cache, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_member", "u": 24, "d": "Get a member object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get a cached member for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get a cached member for. Returns typing.Optional[hikari.guilds.Member] The object of the member found in the cache, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_members_view", "u": 24, "d": "Get a view of all the members objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were found from the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_members_view_for_guild", "u": 24, "d": "Get a view of the members cached for a specific guild. Parameters guild_id : hikari.snowflakes.Snowflakeish The ID of the guild to get the cached member view for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the members cached for the specified guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_message", "u": 24, "d": "Get a message object from the cache. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] Object or ID of the message to get from the cache. Returns typing.Optional[hikari.messages.Message] The object of the message found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_messages_view", "u": 24, "d": "Get a view of all the message objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.messages.Message] A view of message objects found in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_presence", "u": 24, "d": "Get a presence object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get a presence for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get a presence for. Returns typing.Optional[hikari.presences.MemberPresence] The object of the presence that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_presences_view", "u": 24, "d": "Get a view of all the presence objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake A view of guild IDs to views of user IDs to objects of the presences found in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_presences_view_for_guild", "u": 24, "d": "Get a view of the presence objects in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached presence objects for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presence found in the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_role", "u": 24, "d": "Get a role object from the cache. Parameters role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] Object or ID of the role to get from the cache. Returns typing.Optional[hikari.guilds.Role] The object of the role found in the cache or builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_roles_view", "u": 24, "d": "Get a view of all the role objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles found in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_roles_view_for_guild", "u": 24, "d": "Get a view of the roles in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached roles for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were found in the cache for the specified guild.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_user", "u": 24, "d": "Get a user object from the cache. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get from the cache. Returns typing.Optional[hikari.users.User] The object of the user that was found in the cache, else builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_users_view", "u": 24, "d": "Get a view of the user objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.users.User] The view of user IDs to the users found in the cache.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_voice_state", "u": 24, "d": "Get a voice state object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get a voice state for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get a voice state for. Returns typing.Optional[hikari.voices.VoiceState] The object of the voice state that was found in the cache, or builtins.None .", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_voice_states_view", "u": 24, "d": "Get a view of all the voice state objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were found in the cache,", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_voice_states_view_for_channel", "u": 24, "d": "Get a view of the voice states cached for a specific channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached voice states for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the channel to get the cached voice states for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified channel.", "f": 1}, {"r": "hikari.api.cache.MutableCache.get_voice_states_view_for_guild", "u": 24, "d": "Get a view of the voice states cached for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached voice states for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified guild.", "f": 1}, {"r": "hikari.api.entity_factory", "u": 25, "d": "Core interface for an object that serializes/deserializes API objects."}, {"r": "hikari.api.entity_factory.EntityFactory", "u": 25, "d": "Interface for components that serialize and deserialize JSON payloads."}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_own_connection", "u": 25, "d": "Parse a raw payload from Discord into an own connection object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.OwnConnection The deserialized \"own connection\" object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_own_guild", "u": 25, "d": "Parse a raw payload from Discord into an own guild object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.OwnGuild The deserialized \"own guild\" object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_application", "u": 25, "d": "Parse a raw payload from Discord into an application object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.Application The deserialized application object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_authorization_information", "u": 25, "d": "Parse a raw payload from Discord into an authorization information object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.AuthorizationInformation The deserialized authorization information object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_partial_token", "u": 25, "d": "Parse a raw payload from Discord into a partial OAuth2 token object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.PartialOAuth2Token The deserialized partial OAuth2 token object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_authorization_token", "u": 25, "d": "Parse a raw payload from Discord into an authorization token object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.OAuth2AuthorizationToken The deserialized OAuth2 authorization token object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_implicit_token", "u": 25, "d": "Parse a query from Discord into an implicit token object. Parameters query : hikari.internal.data_binding.Query The query parameters to deserialize. Returns hikari.applications.OAuth2ImplicitToken The deserialized OAuth2 implicit token object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_audit_log", "u": 25, "d": "Parse a raw payload from Discord into an audit log object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.audit_logs.AuditLog The deserialized audit log object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_channel_follow", "u": 25, "d": "Parse a raw payload from Discord into a channel follow object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.channels.ChannelFollow The deserialized channel follow object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_permission_overwrite", "u": 25, "d": "Parse a raw payload from Discord into a permission overwrite object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.channels.PermissionOverwrite The deserialized permission overwrite object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.serialize_permission_overwrite", "u": 25, "d": "Serialize a permission overwrite object to a json serializable dict. Parameters overwrite : hikari.channels.PermissionOverwrite The permission overwrite object to serialize. Returns hikari.internal.data_binding.JSONObject The serialized representation of the permission overwrite.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_partial_channel", "u": 25, "d": "Parse a raw payload from Discord into a partial channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.channels.PartialChannel The deserialized \"partial channel\" object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_dm", "u": 25, "d": "Parse a raw payload from Discord into a DM channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.channels.DMChannel The deserialized DM channel object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_group_dm", "u": 25, "d": "Parse a raw payload from Discord into a group DM channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.channels.GroupDMChannel The deserialized group DM object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_category", "u": 25, "d": "Parse a raw payload from Discord into a guild category object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is not included in the channel's payload. Returns hikari.channels.GuildCategory The deserialized guild category object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_text_channel", "u": 25, "d": "Parse a raw payload from Discord into a guild text channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is not included in the channel's payload. Returns hikari.channels.GuildTextChannel The deserialized guild text channel object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_news_channel", "u": 25, "d": "Parse a raw payload from Discord into a guild news channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is not included in the channel's payload. Returns hikari.channels.GuildNewsChannel The deserialized guild news channel object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_store_channel", "u": 25, "d": "Parse a raw payload from Discord into a guild store channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is not included in the channel's payload. Returns hikari.channels.GuildStoreChannel The deserialized guild store channel object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_voice_channel", "u": 25, "d": "Parse a raw payload from Discord into a guild voice channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is npt included in the channel's payload. Returns hikari.channels.GuildVoiceChannel The deserialized guild voice channel object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_stage_channel", "u": 25, "d": "Parse a raw payload from Discord into a guild stage channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is npt included in the channel's payload. Returns hikari.channels.GuildStageChannel The deserialized guild stage channel object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_channel", "u": 25, "d": "Parse a raw payload from Discord into a channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. This will be ignored for DM and group DM channels and will be prioritised over \"guild_id\" in the payload when passed. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is not included in the channel's payload. Returns hikari.channels.PartialChannel The deserialized partial channel-derived object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload of a guild channel.\nhikari.errors.UnrecognisedEntityError If the channel type is unknown.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_embed", "u": 25, "d": "Parse a raw payload from Discord into an embed object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.embeds.Embed The deserialized embed object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.serialize_embed", "u": 25, "d": "Serialize an embed object to a json serializable dict. Parameters embed : hikari.embeds.Embed The embed object to serialize. Returns typing.Tuple[hikari.internal.data_binding.JSONObject, typing.List[hikari.files.Resource A tuple with two items in it. The first item will be the serialized embed representation. The second item will be a list of resources to upload with the embed.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_unicode_emoji", "u": 25, "d": "Parse a raw payload from Discord into a unicode emoji object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.emojis.UnicodeEmoji The deserialized unicode emoji object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_custom_emoji", "u": 25, "d": "Parse a raw payload from Discord into a custom emoji object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.emojis.CustomEmoji The deserialized custom emoji object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_known_custom_emoji", "u": 25, "d": "Parse a raw payload from Discord into a known custom emoji object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize.\nguild_id : hikari.snowflakes.Snowflake The ID of the guild this emoji belongs to. This is used to ensure that the guild a known custom emoji belongs to is remembered by allowing for a context based artificial guild_id attribute. Returns hikari.emojis.KnownCustomEmoji The deserialized \"known custom emoji\" object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_emoji", "u": 25, "d": "Parse a raw payload from Discord into an emoji object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.emojis.UnicodeEmoji or hikari.emojis.CustomEmoji The deserialized custom or unicode emoji object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_gateway_bot_info", "u": 25, "d": "Parse a raw payload from Discord into a gateway bot object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.sessions.GatewayBotInfo The deserialized gateway bot information object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_widget", "u": 25, "d": "Parse a raw payload from Discord into a guild widget object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.GuildWidget The deserialized guild widget object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_welcome_screen", "u": 25, "d": "Parse a raw payload from Discord into a guild welcome screen object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.WelcomeScreen The deserialized guild welcome screen object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.serialize_welcome_channel", "u": 25, "d": "Serialize a welcome channel object to a json serializable dict. Parameters welcome_channel : hikari.guilds.WelcomeChannel The guild welcome channel object to serialize. Returns hikari.internal.data_binding.JSONObject The serialized representation of the welcome channel.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_member", "u": 25, "d": "Parse a raw payload from Discord into a member object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters user : hikari.undefined.UndefinedOr[hikari.users.User] The user to attach to this member, should only be passed in situations where \"user\" is not included in the payload.\nguild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this member belongs to. If this is specified then this will be prioritised over \"guild_id\" in the payload. ! note guild_id covers cases such as the GUILD_CREATE gateway event and GET Guild Member where \"guild_id\" is not included in the returned payload. Returns hikari.guilds.Member The deserialized member object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_role", "u": 25, "d": "Parse a raw payload from Discord into a role object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize.\nguild_id : hikari.snowflakes.Snowflake The ID of the guild this role belongs to. This is used to ensure that the guild a role belongs to is remembered by allowing for a context based artificial guild_id attribute. Returns hikari.guilds.Role The deserialized role object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_partial_integration", "u": 25, "d": "Parse a raw payload from Discord into a partial integration object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.PartialIntegration The deserialized partial integration object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_integration", "u": 25, "d": "Parse a raw payload from Discord into an integration object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this integration belongs to. If this is specified then this will be prioritised over \"guild_id\" in the payload. Returns hikari.guilds.Integration The deserialized integration object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload for the payload of the integration.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_member_ban", "u": 25, "d": "Parse a raw payload from Discord into a guild member ban object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.GuildBan The deserialized guild member ban object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_preview", "u": 25, "d": "Parse a raw payload from Discord into a guild preview object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.GuildPreview The deserialized guild preview object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_rest_guild", "u": 25, "d": "Parse a raw payload from Discord into a guild object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.RESTGuild The deserialized guild object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_gateway_guild", "u": 25, "d": "Parse a raw payload from Discord into a guild object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns GatewayGuildDefinition The deserialized guild object and the internal collections as maps of hikari.snowflakes.Snowflake mapping to hikari.channels.GuildChannel , hikari.guilds.Member , hikari.presences.MemberPresence , hikari.guilds.Role , and hikari.emojis.KnownCustomEmoji . This is provided in several components to allow separate caching and linking between entities in various relational cache implementations internally.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_command", "u": 25, "d": "Parse a raw payload from Discord into a command object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.Snowflake] The ID of the guild this command belongs to. If this is specified then this will be prioritised over \"guild_id\" in the payload. Returns hikari.commands.Command The deserialized command object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload for the payload of the integration.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_command_permissions", "u": 25, "d": "Parse a raw payload from Discord into guild command permissions object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.commands.GuildCommandPermissions The deserialized guild command permissions object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.serialize_command_permission", "u": 25, "d": "Serialize a command permission object to a json serializable dict. Parameters permission: hikari.commands.CommandPermission The command permission object to serialize. Returns hikari.internal.data_binding.JSONObject The serialized representation of the command permission.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_partial_interaction", "u": 25, "d": "Parse a raw payload from Discord into a partial interaction object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.interactions.base_interactions.PartialInteraction The deserialized partial interaction object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_command_interaction", "u": 25, "d": "Parse a raw payload from Discord into a command interaction object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.interactions.command_interactions.CommandInteraction The deserialized command interaction object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_interaction", "u": 25, "d": "Parse a raw payload from Discord into a interaction object. ! note This isn't required to implement logic for deserializing PING interactions and if you want to unmarshal those EntityFactory.deserialize_partial_interaction should be compatible. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.interactions.base_interactions.PartialInteraction The deserialized interaction object. Raises hikari.errors.UnrecognisedEntityError If the integration type is unknown.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.serialize_command_option", "u": 25, "d": "Serialize a command option object to a json serializable dict. Parameters option: hikari.commands.CommandOption The command option object to serialize. Returns hikari.internal.data_binding.JSONObject The serialized representation of the command option.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_component_interaction", "u": 25, "d": "Parser a raw payload from Discord into a component interaction object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.interactions.component_interactions.ComponentInteraction The deserialized component interaction.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_vanity_url", "u": 25, "d": "Parse a raw payload from Discord into a vanity url object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.invites.VanityURL The deserialized vanity url object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_invite", "u": 25, "d": "Parse a raw payload from Discord into an invite object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.invites.Invite The deserialized invite object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_invite_with_metadata", "u": 25, "d": "Parse a raw payload from Discord into a invite with metadata object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.invites.InviteWithMetadata The deserialized invite with metadata object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_sticker_pack", "u": 25, "d": "Parse a raw payload from Discord into a sticker pack object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.stickers.StickerPack The deserialized sticker pack object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_partial_sticker", "u": 25, "d": "Parse a raw payload from Discord into a partial sticker object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.stickers.PartialSticker The deserialized partial sticker object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_standard_sticker", "u": 25, "d": "Parse a raw payload from Discord into a standard sticker object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.stickers.StandardSticker The deserialized standard sticker object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_guild_sticker", "u": 25, "d": "Parse a raw payload from Discord into a guild sticker object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.stickers.GuildSticker The deserialized guild sticker object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_action_row", "u": 25, "d": "Parse a raw payload from Discord into an action row component object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.ActionRowComponent The deserialized action row component.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_button", "u": 25, "d": "Parse a raw payload from Discord into a button component object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.ButtonComponent The deserialized button component.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_select_menu", "u": 25, "d": "Parse a raw payload from Discord into a select menu component object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.SelectMenuComponent The deserialized button component.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_component", "u": 25, "d": "Parse a raw payload from Discord into a message component object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.PartialComponent The deserialized message component.\nhikari.errors.UnrecognisedEntityError If the message component type isn't recognised.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_partial_message", "u": 25, "d": "Parse a raw payload from Discord into a partial message object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.PartialMessage The deserialized partial message object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_message", "u": 25, "d": "Parse a raw payload from Discord into a message object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.Message The deserialized message object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_member_presence", "u": 25, "d": "Parse a raw payload from Discord into a member presence object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild the presence belongs to. If this is specified then it is prioritised over guild_id in the payload. ! note At the time of writing, the only place where guild_id will be mandatory is when parsing presences sent in a GUILD_CREATE event from Discord, since the guild_id attribute in the payload will have been omitted for redundancy. Returns hikari.presences.MemberPresence The deserialized member presence object. Raises builtins.KeyError If guild_id is not an attribute of the payload dict, and no guild ID was passed for the guild_id parameter. If this is raised, no guild ID info was provided anywhere.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_template", "u": 25, "d": "Parse a raw payload from Discord into a template object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.templates.Template The deserialized template object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_user", "u": 25, "d": "Parse a raw payload from Discord into a user object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.users.User The deserialized user object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_my_user", "u": 25, "d": "Parse a raw payload from Discord into a user object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.users.OwnUser The deserialized user object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_voice_state", "u": 25, "d": "Parse a raw payload from Discord into a voice state object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this voice state belongs to. If this is specified then this will be prioritised over \"guild_id\" in the payload.\nmember : hikari.undefined.UndefinedOr[hikari.guilds.Member] The object of the member this voice state belongs to. If this is specified then this will be prioritised over \"member\" in the payload. ! note At the time of writing, GUILD_CREATE events are the only known place where neither guild_id nor member will be keys on the payload. In this case, you will need to provide the former parameters explicitly. Returns hikari.voices.VoiceState The deserialized voice state object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload for the payload of the voice state. This will also be raised if no member data was passed in any acceptable place.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_voice_region", "u": 25, "d": "Parse a raw payload from Discord into a voice region object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.voices.VoiceRegion The deserialized voice region object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_incoming_webhook", "u": 25, "d": "Parse a raw payload from Discord into a incoming webhook object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.webhooks.IncomingWebhook The parsed incoming webhook object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_channel_follower_webhook", "u": 25, "d": "Parse a raw payload from Discord into a channel follower webhook object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.webhooks.ChannelFollowerWebhook The parsed channel follower webhook object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_application_webhook", "u": 25, "d": "Parse a raw payload from Discord into an application webhook object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.webhooks.ApplicationWebhook The parsed application webhook object.", "f": 1}, {"r": "hikari.api.entity_factory.EntityFactory.deserialize_webhook", "u": 25, "d": "Parse a raw payload from Discord into a webhook object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.webhooks.PartialWebhook The deserialized webhook object.", "f": 1}, {"r": "hikari.api.entity_factory.GatewayGuildDefinition", "u": 25, "d": "A structure for handling entities within guild create and update events. Method generated by attrs for class GatewayGuildDefinition."}, {"r": "hikari.api.entity_factory.GatewayGuildDefinition.channels", "u": 25, "d": "Mapping of channel IDs to the channels that belong to the guild. Will be builtins.None when returned by guild update gateway events rather\nthan create."}, {"r": "hikari.api.entity_factory.GatewayGuildDefinition.emojis", "u": 25, "d": "Mapping of emoji IDs to the emojis that belong to the guild."}, {"r": "hikari.api.entity_factory.GatewayGuildDefinition.guild", "u": 25, "d": "Object of the guild the definition is for."}, {"r": "hikari.api.entity_factory.GatewayGuildDefinition.members", "u": 25, "d": "Mapping of user IDs to the members that belong to the guild. Will be builtins.None when returned by guild update gateway events rather\nthan create. ! note This may be a partial mapping of members in the guild."}, {"r": "hikari.api.entity_factory.GatewayGuildDefinition.presences", "u": 25, "d": "Mapping of user IDs to the presences that are active in the guild. Will be builtins.None when returned by guild update gateway events rather\nthan create. ! note This may be a partial mapping of presences active in the guild."}, {"r": "hikari.api.entity_factory.GatewayGuildDefinition.roles", "u": 25, "d": "Mapping of role IDs to the roles that belong to the guild."}, {"r": "hikari.api.entity_factory.GatewayGuildDefinition.voice_states", "u": 25, "d": "Mapping of user IDs to the voice states that are active in the guild. ! note This may be a partial mapping of voice states active in the guild."}, {"r": "hikari.api.special_endpoints", "u": 26, "d": "Special additional endpoints used by the REST API."}, {"r": "hikari.api.special_endpoints.ActionRowBuilder", "u": 26, "d": "Builder class for action row components."}, {"r": "hikari.api.special_endpoints.ActionRowBuilder.components", "u": 26, "d": "Sequence of the component builders registered within this action row. Returns typing.Sequence[ComponentBuilder] Sequence of the component builders registered within this action row."}, {"r": "hikari.api.special_endpoints.ActionRowBuilder.add_button", "u": 26, "d": "Add a button component to this action row builder. Parameters style : typing.Union[builtins.int, hikari.messages.ButtonStyle] The button's style.\nurl_or_custom_id : builtins.str For interactive button styles this is a developer-defined custom identifier used to identify which button triggered component interactions. For Link button styles this is the URL the link button should redirect to. Returns ButtonBuilder[Self] Button builder object. ButtonBuilder.add_to_container should be called to finalise the button.", "f": 1}, {"r": "hikari.api.special_endpoints.ActionRowBuilder.add_select_menu", "u": 26, "d": "Add a select menu component to this action row builder. Parameters custom_id : builtins.str A developer-defined custom identifier used to identify which menu triggered component interactions. Returns SelectMenuBuilder[Self] Select menu builder object. SelectMenuBuilder.add_to_container should be called to finalise the button.", "f": 1}, {"r": "hikari.api.special_endpoints.ActionRowBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.ButtonBuilder", "u": 26, "d": "Builder class for a message button component."}, {"r": "hikari.api.special_endpoints.ButtonBuilder.style", "u": 26, "d": "Button's style. Returns typing.Union[builtins.int, hikari.messages.ButtonStyle] The button's style."}, {"r": "hikari.api.special_endpoints.ButtonBuilder.emoji", "u": 26, "d": "Emoji which should appear on this button. Returns typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object or ID or raw string of the emoji which should be displayed on this button if set."}, {"r": "hikari.api.special_endpoints.ButtonBuilder.label", "u": 26, "d": "Text label which should appear on this button. ! note The text label to that should appear on this button. This may be up to 80 characters long. Returns hikari.undefined.UndefinedOr[builtins.str] Text label which should appear on this button."}, {"r": "hikari.api.special_endpoints.ButtonBuilder.is_disabled", "u": 26, "d": "Whether the button should be marked as disabled. ! note Defaults to builtins.False . Returns builtins.bool Whether the button should be marked as disabled."}, {"r": "hikari.api.special_endpoints.ButtonBuilder.set_emoji", "u": 26, "d": "Set the emoji to display on this button. Parameters emoji : typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object, ID or raw string of the emoji which should be displayed on this button. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.ButtonBuilder.set_label", "u": 26, "d": "Set the text label which should be displayed on this button. Parameters label : hikari.undefined.UndefinedOr[builtins.str] The text label to show on this button. This may be up to 80 characters long. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.ButtonBuilder.set_is_disabled", "u": 26, "d": "Set whether this button should be disabled. Parameters state : bool Whether this button should be disabled. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.ButtonBuilder.add_to_container", "u": 26, "d": "Add this button to the container component it belongs to. This is used as the finalising call during chained calls. Returns _ContainerT The container component that owns this button.", "f": 1}, {"r": "hikari.api.special_endpoints.ButtonBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.CommandBuilder", "u": 26, "d": "Interface of a command builder used when bulk creating commands over REST."}, {"r": "hikari.api.special_endpoints.CommandBuilder.name", "u": 26, "d": "Name to set for this command. ! warning This should match the regex ^[a-z0-9_-]{1,32}$ . Returns builtins.str The name to set for this command."}, {"r": "hikari.api.special_endpoints.CommandBuilder.description", "u": 26, "d": "Return the description to set for this command. ! warning This should be inclusively between 1-100 characters in length. Returns builtins.str The description to set for this command."}, {"r": "hikari.api.special_endpoints.CommandBuilder.options", "u": 26, "d": "Sequence of up to 25 of the options set for this command. Returns typing.Sequence[hikari.commands.CommandOption] A sequence of up to 25 of the options set for this command."}, {"r": "hikari.api.special_endpoints.CommandBuilder.id", "u": 26, "d": "ID of this command. Returns hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of this command if set."}, {"r": "hikari.api.special_endpoints.CommandBuilder.default_permission", "u": 26, "d": "Whether the command should be enabled by default (without any permissions). Defaults to builtins.bool . Returns undefined.UndefinedOr[builtins.bool] Whether the command should be enabled by default (without any permissions)."}, {"r": "hikari.api.special_endpoints.CommandBuilder.set_id", "u": 26, "d": "Set the ID of this command. Parameters id_ : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID to set for this command. Returns CommandBuilder Object of this command builder.", "f": 1}, {"r": "hikari.api.special_endpoints.CommandBuilder.set_default_permission", "u": 26, "d": "Whether this command should be enabled by default (without any permissions). Parameters state : hikari.undefined.UndefinedOr[builtins.bool] Whether this command should be enabled by default. Returns CommandBuilder Object of this command builder for chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.CommandBuilder.add_option", "u": 26, "d": "Add an option to this command. ! note A command can have up to 25 options. Parameters option : hikari.commands.CommandOption The option to add to this command. Returns CommandBuilder Object of this command builder.", "f": 1}, {"r": "hikari.api.special_endpoints.CommandBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Parameters entity_factory : hikari.api.entity_factory.EntityFactory The entity factory to use to serialize entities within this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.ComponentBuilder", "u": 26, "d": "Base class for all component builder classes."}, {"r": "hikari.api.special_endpoints.ComponentBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.TypingIndicator", "u": 26, "d": "Result type of hikari.api.rest.RESTClient.trigger_typing . This is an object that can either be awaited like a coroutine to trigger\nthe typing indicator once, or an async context manager to keep triggering\nthe typing indicator repeatedly until the context finishes. ! note This is a helper class that is used by hikari.api.rest.RESTClient . You should only ever need to use instances of this class that are produced by that API."}, {"r": "hikari.api.special_endpoints.GuildBuilder", "u": 26, "d": "Result type of hikari.api.rest.RESTClient.guild_builder . This is used to create a guild in a tidy way using the HTTP API, since\nthe logic behind creating a guild on an API level is somewhat confusing\nand detailed. ! note This is a helper class that is used by hikari.api.rest.RESTClient . You should only ever need to use instances of this class that are produced by that API, thus, any details about the constructor are omitted from the following examples for brevity. Examples Creating an empty guild. py\nguild = await rest.guild_builder(\"My Server!\").create() Creating a guild with an icon py\nfrom hikari.files import WebResourceStream guild_builder = rest.guild_builder(\"My Server!\")\nguild_builder.icon = WebResourceStream(\"cat.png\", \"http:  .\")\nguild = await guild_builder.create() Adding roles to your guild. py\nfrom hikari.permissions import Permissions guild_builder = rest.guild_builder(\"My Server!\") everyone_role_id = guild_builder.add_role(\"@everyone\")\nadmin_role_id = guild_builder.add_role(\"Admins\", permissions=Permissions.ADMINISTRATOR) await guild_builder.create()  ! warning The first role must always be the @everyone role. ! note If you call add_role , the default roles provided by discord will be created. This also applies to the add_ functions for text channels/voice channels/categories. ! note Functions that return a hikari.snowflakes.Snowflake do not provide the final ID that the object will have once the API call is made. The returned IDs are only able to be used to re-reference particular objects while building the guild format. This is provided to allow creation of channels within categories, and to provide permission overwrites. Adding a text channel to your guild. py\nguild_builder = rest.guild_builder(\"My Server!\") category_id = guild_builder.add_category(\"My safe place\")\nchannel_id = guild_builder.add_text_channel(\"general\", parent_id=category_id) await guild_builder.create() "}, {"r": "hikari.api.special_endpoints.GuildBuilder.name", "u": 26, "d": "Name of the guild to create. Returns builtins.str The guild name."}, {"r": "hikari.api.special_endpoints.GuildBuilder.default_message_notifications", "u": 26, "d": "Default message notification level that can be overwritten. If not overridden, this will use the Discord default level. Returns hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] The default message notification level, if overwritten."}, {"r": "hikari.api.special_endpoints.GuildBuilder.explicit_content_filter_level", "u": 26, "d": "Explicit content filter level that can be overwritten. If not overridden, this will use the Discord default level. Returns hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] The explicit content filter level, if overwritten."}, {"r": "hikari.api.special_endpoints.GuildBuilder.icon", "u": 26, "d": "Guild icon to use that can be overwritten. If not overridden, the guild will not have an icon. Returns hikari.undefined.UndefinedOr[hikari.files.Resourceish] The guild icon to use, if overwritten."}, {"r": "hikari.api.special_endpoints.GuildBuilder.verification_level", "u": 26, "d": "Verification level required to join the guild that can be overwritten. If not overridden, the guild will use the default verification level for Returns hikari.undefined.UndefinedOr[typing.Union[hikari.guilds.GuildVerificationLevel, builtins.int The verification level required to join the guild, if overwritten."}, {"r": "hikari.api.special_endpoints.GuildBuilder.create", "u": 26, "d": "Send the request to Discord to create the guild. The application user will be added to this guild as soon as it is\ncreated. All IDs that were provided when building this guild will\nbecome invalid and will be replaced with real IDs. Returns hikari.guilds.RESTGuild The created guild. Raises hikari.errors.BadRequestError If any values set in the guild builder are invalid.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are already in 10 guilds.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.special_endpoints.GuildBuilder.add_role", "u": 26, "d": "Create a role. ! warning The first role you create must always be the @everyone role. Parameters name : builtins.str The role's name. Other Parameters permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the permissions for the role.\ncolor : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the role's color.\ncolour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for color .\nhoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role.\nmentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.snowflakes.Snowflake The dummy ID for this role that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID. Raises builtins.ValueError If you are defining the first role, but did not name it @everyone .\nbuiltins.TypeError If you specify both color and colour together or if you try to specify color , colour , hoisted , mentionable or position for the @everyone role.", "f": 1}, {"r": "hikari.api.special_endpoints.GuildBuilder.add_category", "u": 26, "d": "Create a category channel. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category. Returns hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.", "f": 1}, {"r": "hikari.api.special_endpoints.GuildBuilder.add_text_channel", "u": 26, "d": "Create a text channel. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[builtins.int] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. Returns hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.", "f": 1}, {"r": "hikari.api.special_endpoints.GuildBuilder.add_voice_channel", "u": 26, "d": "Create a voice channel. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. Returns hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.", "f": 1}, {"r": "hikari.api.special_endpoints.GuildBuilder.add_stage_channel", "u": 26, "d": "Create a stage channel. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. Returns hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionDeferredBuilder", "u": 26, "d": "Interface of a deferred message interaction response builder."}, {"r": "hikari.api.special_endpoints.InteractionDeferredBuilder.type", "u": 26, "d": "Return the type of this response. Returns hikari.interactions.base_interactions.DeferredResponseTypesT The type of response this is."}, {"r": "hikari.api.special_endpoints.InteractionDeferredBuilder.flags", "u": 26, "d": "Message flags this response should have. ! note As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . Returns typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The message flags this response should have if set else hikari.undefined.UNDEFINED ."}, {"r": "hikari.api.special_endpoints.InteractionDeferredBuilder.set_flags", "u": 26, "d": "Set message flags for this response. ! note As of writing, the only message flag which can be set is EPHEMERAL. Parameters flags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The message flags to set for this response. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionDeferredBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Parameters entity_factory : hikari.api.entity_factory.EntityFactory The entity factory to use to serialize entities within this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionResponseBuilder", "u": 26, "d": "Base class for all interaction response builders used in the interaction server."}, {"r": "hikari.api.special_endpoints.InteractionResponseBuilder.type", "u": 26, "d": "Return the type of this response. Returns typing.Union[builtins.int, hikari.interactions.base_interactions.ResponseType] The type of response this is."}, {"r": "hikari.api.special_endpoints.InteractionResponseBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Parameters entity_factory : hikari.api.entity_factory.EntityFactory The entity factory to use to serialize entities within this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder", "u": 26, "d": "Interface of an interaction message response builder used within REST servers. This can be returned by the listener registered to hikari.api.interaction_server.InteractionServer as a response to the interaction\ncreate."}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.type", "u": 26, "d": "Return the type of this response. Returns hikari.interactions.base_interactions.MessageResponseTypesT The type of response this is."}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.embeds", "u": 26, "d": "Sequence of up to 10 of the embeds included in this response. Returns typing.Sequence[hikari.embeds.Embed] A sequence of up to 10 of the embeds included in this response."}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.content", "u": 26, "d": "Response's message content. Returns hikari.undefined.UndefinedOr[builtins.str] The response's message content, if set."}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.flags", "u": 26, "d": "Message flags this response should have. ! note As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . Returns typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The message flags this response should have if set else hikari.undefined.UNDEFINED ."}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.is_tts", "u": 26, "d": "Whether this response's content should be treated as text-to-speech. Returns builtins.bool Whether this response's content should be treated as text-to-speech. If left as hikari.undefined.UNDEFINED then this will be disabled."}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.mentions_everyone", "u": 26, "d": "Whether @everyone and @here mentions should be enabled for this response. Returns hikari.undefined.UndefinedOr[builtins.bool] Whether @everyone mentions should be enabled for this response. If left as hikari.undefined.UNDEFINED then they will be disabled."}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.role_mentions", "u": 26, "d": "Whether and what role mentions should be enabled for this response. Returns hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Either a sequence of object/IDs of the roles mentions should be enabled for, builtins.False or hikari.undefined.UNDEFINED to disallow any role mentions or True to allow all role mentions."}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.user_mentions", "u": 26, "d": "Whether and what user mentions should be enabled for this response. Returns hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Either a sequence of object/IDs of the users mentions should be enabled for, builtins.False or hikari.undefined.UNDEFINED to disallow any user mentions or True to allow all user mentions."}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.add_embed", "u": 26, "d": "Add an embed to this response. Parameters embed : hikari.embeds.Embed Object of the embed to add to this response. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.set_content", "u": 26, "d": "Set the response's message content. Parameters content : hikari.undefined.UndefinedOr[builtins.str] The message content to set for this response. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.set_flags", "u": 26, "d": "Set message flags for this response. ! note As of writing, the only message flag which can be set is EPHEMERAL. Parameters flags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The message flags to set for this response. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.set_tts", "u": 26, "d": "Set whether this response should trigger text-to-speech processing. Parameters tts : Whether this response should trigger text-to-speech processing. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.set_mentions_everyone", "u": 26, "d": "Set whether this response should be able to mention @everyone/@here. Parameters mentions : hikari.undefined.UndefinedOr[builtins.bool] Whether this response should be able to mention @everyone/@here. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.set_role_mentions", "u": 26, "d": "Set whether and what role mentions should be possible for this response. Parameters mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Either a sequence of object/IDs of the roles mentions should be enabled for, builtins.False or hikari.undefined.UNDEFINED to disallow any role mentions or True to allow all role mentions. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.set_user_mentions", "u": 26, "d": "Set whether and what user mentions should be possible for this response. Parameters mentions: hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Either a sequence of object/IDs of the users mentions should be enabled for, builtins.False or hikari.undefined.UNDEFINED to disallow any user mentions or True to allow all user mentions. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractionMessageBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Parameters entity_factory : hikari.api.entity_factory.EntityFactory The entity factory to use to serialize entities within this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder", "u": 26, "d": "Builder interface for interactive buttons."}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder.custom_id", "u": 26, "d": "Developer set custom ID used for identifying interactions with this button. Returns builtins.str Developer set custom ID used for identifying interactions with this button."}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder.style", "u": 26, "d": "Button's style. Returns typing.Union[builtins.int, hikari.messages.ButtonStyle] The button's style."}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder.emoji", "u": 26, "d": "Emoji which should appear on this button. Returns typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object or ID or raw string of the emoji which should be displayed on this button if set."}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder.label", "u": 26, "d": "Text label which should appear on this button. ! note The text label to that should appear on this button. This may be up to 80 characters long. Returns hikari.undefined.UndefinedOr[builtins.str] Text label which should appear on this button."}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder.is_disabled", "u": 26, "d": "Whether the button should be marked as disabled. ! note Defaults to builtins.False . Returns builtins.bool Whether the button should be marked as disabled."}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder.set_emoji", "u": 26, "d": "Set the emoji to display on this button. Parameters emoji : typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object, ID or raw string of the emoji which should be displayed on this button. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder.set_label", "u": 26, "d": "Set the text label which should be displayed on this button. Parameters label : hikari.undefined.UndefinedOr[builtins.str] The text label to show on this button. This may be up to 80 characters long. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder.set_is_disabled", "u": 26, "d": "Set whether this button should be disabled. Parameters state : bool Whether this button should be disabled. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder.add_to_container", "u": 26, "d": "Add this button to the container component it belongs to. This is used as the finalising call during chained calls. Returns _ContainerT The container component that owns this button.", "f": 1}, {"r": "hikari.api.special_endpoints.InteractiveButtonBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder", "u": 26, "d": "Builder interface for link buttons."}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder.url", "u": 26, "d": "Url this button should link to when pressed. Returns builtins.str Url this button should link to when pressed."}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder.style", "u": 26, "d": "Button's style. Returns typing.Union[builtins.int, hikari.messages.ButtonStyle] The button's style."}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder.emoji", "u": 26, "d": "Emoji which should appear on this button. Returns typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object or ID or raw string of the emoji which should be displayed on this button if set."}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder.label", "u": 26, "d": "Text label which should appear on this button. ! note The text label to that should appear on this button. This may be up to 80 characters long. Returns hikari.undefined.UndefinedOr[builtins.str] Text label which should appear on this button."}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder.is_disabled", "u": 26, "d": "Whether the button should be marked as disabled. ! note Defaults to builtins.False . Returns builtins.bool Whether the button should be marked as disabled."}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder.set_emoji", "u": 26, "d": "Set the emoji to display on this button. Parameters emoji : typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object, ID or raw string of the emoji which should be displayed on this button. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder.set_label", "u": 26, "d": "Set the text label which should be displayed on this button. Parameters label : hikari.undefined.UndefinedOr[builtins.str] The text label to show on this button. This may be up to 80 characters long. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder.set_is_disabled", "u": 26, "d": "Set whether this button should be disabled. Parameters state : bool Whether this button should be disabled. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder.add_to_container", "u": 26, "d": "Add this button to the container component it belongs to. This is used as the finalising call during chained calls. Returns _ContainerT The container component that owns this button.", "f": 1}, {"r": "hikari.api.special_endpoints.LinkButtonBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder", "u": 26, "d": "Builder class for select menu options."}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.custom_id", "u": 26, "d": "Developer set custom ID used for identifying interactions with this menu. Returns builtins.str Developer set custom ID used for identifying interactions with this menu."}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.is_disabled", "u": 26, "d": "Whether the select menu should be marked as disabled. ! note Defaults to builtins.False . Returns builtins.bool Whether the select menu should be marked as disabled."}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.options", "u": 26, "d": "Sequence of the options set for this select menu. Returns typing.Sequence[SelectOptionBuilder[Self Sequence of the options set for this select menu."}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.placeholder", "u": 26, "d": "Return the placeholder text to display when no options are selected. Returns hikari.undefined.UndefinedOr[builtins.str] Placeholder text to display when no options are selected, if defined."}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.min_values", "u": 26, "d": "Minimum number of options which must be chosen. Defaults to 1.\nMust be greater than or equal to SelectMenuBuilder.min_values and less\nthan or equal to 25. Returns builtins.str Minimum number of options which must be chosen."}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.max_values", "u": 26, "d": "Maximum number of options which must be chosen. Defaults to 1.\nMust be greater than or equal to SelectMenuBuilder.max_values and\ngreater than or equal to 0. Returns builtins.str Maximum number of options which must be chosen."}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.add_option", "u": 26, "d": "Add an option to this menu. Parameters label : builtins.str The user-facing name of this option, max 100 characters.\nvalue : builtins.str The developer defined value of this option, max 100 characters. Returns SelectOptionBuilder[Self] Option builder object. This should be finalised by calling SelectOptionBuilder.add_to_menu .", "f": 1}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.set_is_disabled", "u": 26, "d": "Set whether this option is disabled. Defaults to builtins.False . Parameters state : builtins.bool Whether this option is disabled. Returns SelectMenuBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.set_placeholder", "u": 26, "d": "Set place-holder text to be shown when no option is selected. Parameters value : hikari.undefined.UndefinedOr[builtins.str] Place-holder text to be displayed when no option is selected. Max 100 characters. Returns SelectMenuBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.set_min_values", "u": 26, "d": "Set the minimum amount of options which need to be selected for this menu. ! note This defaults to 1 if not set and can be greater than or equal to 0 and less than or equal to SelectMenuBuilder.max_values . Parameters value : builtins.int The minimum amount of options which need to be selected for this menu. Returns SelectMenuBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.set_max_values", "u": 26, "d": "Set the maximum amount of options which need to be selected for this menu. ! note This defaults to 1 if not set and can be less than or equal to 25 and greater than or equal to SelectMenuBuilder.min_values . Parameters value : builtins.int The maximum amount of options which need to be selected for this menu. Returns SelectMenuBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.add_to_container", "u": 26, "d": "Finalise this builder by adding it to its parent container component. Returns _ContainerT The parent container component builder.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectMenuBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder", "u": 26, "d": "Builder class for select menu options."}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder.label", "u": 26, "d": "User-facing name of the option, max 100 characters. Returns builtins.str User-facing name of the option."}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder.value", "u": 26, "d": "Developer-defined value of the option, max 100 characters. Returns builtins.str Developer-defined value of the option."}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder.description", "u": 26, "d": "Return the description of the option, max 100 characters. Returns hikari.undefined.UndefinedOr[builtins.str] Description of the option, if set."}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder.emoji", "u": 26, "d": "Emoji which should appear on this option. Returns typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object or ID or raw string of the emoji which should be displayed on this option if set."}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder.is_default", "u": 26, "d": "Whether this option should be marked as selected by default. Defaults to builtins.False . Returns builtins.bool Whether this option should be marked as selected by default."}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder.set_description", "u": 26, "d": "Set the option's description. Parameters value : hikari.undefined.UndefinedOr[builtins.str] Description to set for this option. This can be up to 100 characters long. Returns SelectOptionBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder.set_emoji", "u": 26, "d": "Set the emoji to display on this option. Parameters emoji : typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object, ID or raw string of the emoji which should be displayed on this option. Returns SelectOptionBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder.set_is_default", "u": 26, "d": "Set whether this option should be selected by default. Parameters state : builtins.bool Whether this option should be selected by default. Returns SelectOptionBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder.add_to_menu", "u": 26, "d": "Add this option to the menu component it belongs to. This is used as the finalising call during chained calls. Returns _SelectMenuBuilderT The menu component that owns this button.", "f": 1}, {"r": "hikari.api.special_endpoints.SelectOptionBuilder.build", "u": 26, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.api.event_manager", "u": 27, "d": "Core interface for components that manage events in the library."}, {"r": "hikari.api.event_manager.EventManager", "u": 27, "d": "Base interface for event manager implementations. This is a listener of a hikari.events.base_events.Event object and\nconsumer of raw event payloads, and is expected to invoke one or more\ncorresponding event listeners where appropriate."}, {"r": "hikari.api.event_manager.EventManager.consume_raw_event", "u": 27, "d": "Consume a raw event. Parameters event_name : str The case-insensitive name of the event being triggered.\nshard : hikari.api.shard.GatewayShard Object of the shard that received this event.\npayload : hikari.internal.data_binding.JSONObject Payload of the event being triggered. Raises builtins.LookupError If there is no consumer for the event.", "f": 1}, {"r": "hikari.api.event_manager.EventManager.dispatch", "u": 27, "d": "Dispatch an event. Parameters event : hikari.events.base_events.Event The event to dispatch. Example We can dispatch custom events by first defining a class that\nderives from hikari.events.base_events.Event . py\nimport attr from hikari.traits import RESTAware\nfrom hikari.events.base_events import Event\nfrom hikari.users import User\nfrom hikari.snowflakes import Snowflake @attr.define()\nclass EveryoneMentionedEvent(Event): app: RESTAware = attr.field() author: User = attr.field() 'The user who mentioned everyone. ' content: str = attr.field() 'The message that was sent. ' message_id: Snowflake = attr.field() 'The message ID. ' channel_id: Snowflake = attr.field() 'The channel ID. ' We can then dispatch our event as we see fit. py\nfrom hikari.events.messages import MessageCreateEvent @bot.listen(MessageCreateEvent)\nasync def on_message(event): if \"@everyone\" in event.content or \"@here\" in event.content: event = EveryoneMentionedEvent( author=event.author, content=event.content, message_id=event.id, channel_id=event.channel_id, ) bot.dispatch(event) This event can be listened to elsewhere by subscribing to it with EventManager.subscribe . py\n@bot.listen(EveryoneMentionedEvent)\nasync def on_everyone_mentioned(event): print(event.user, \"just pinged everyone in\", event.channel_id) Returns asyncio.Future[typing.Any] A future that can be optionally awaited. If awaited, the future will complete once all corresponding event listeners have been invoked. If not awaited, this will schedule the dispatch of the events in the background for later. See Also Subscribe: hikari.api.event_manager.EventManager.subscribe Stream: hikari.api.event_manager.EventManager.stream Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.api.event_manager.EventManager.subscribe", "u": 27, "d": "Subscribe a given callback to a given event type. Parameters event_type : typing.Type[T] The event type to listen for. This will also listen for any subclasses of the given type. T must be a subclass of hikari.events.base_events.Event .\ncallback Must be a coroutine function to invoke. This should consume an instance of the given event, or an instance of a valid subclass if one exists. Any result is discarded. Example The following demonstrates subscribing a callback to message creation\nevents. py\nfrom hikari.events.messages import MessageCreateEvent async def on_message(event): . bot.subscribe(MessageCreateEvent, on_message) See Also Listen: hikari.api.event_manager.EventManager.listen Stream: hikari.api.event_manager.EventManager.stream Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.api.event_manager.EventManager.unsubscribe", "u": 27, "d": "Unsubscribe a given callback from a given event type, if present. Parameters event_type : typing.Type[T] The event type to unsubscribe from. This must be the same exact type as was originally subscribed with to be removed correctly. T must derive from hikari.events.base_events.Event .\ncallback The callback to unsubscribe. Example The following demonstrates unsubscribing a callback from a message\ncreation event. py\nfrom hikari.events.messages import MessageCreateEvent async def on_message(event): . bot.unsubscribe(MessageCreateEvent, on_message) ", "f": 1}, {"r": "hikari.api.event_manager.EventManager.get_listeners", "u": 27, "d": "Get the listeners for a given event type, if there are any. Parameters event_type : typing.Type[T] The event type to look for. T must be a subclass of hikari.events.base_events.Event .\npolymorphic : builtins.bool If builtins.True , this will also return the listeners of the subclasses of the given event type. If builtins.False , then only listeners for this class specifically are returned. The default is builtins.True . Returns typing.Collection[typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None A copy of the collection of listeners for the event. Will return an empty collection if nothing is registered. T must be a subclass of hikari.events.base_events.Event . See Also Has listener: hikari.api.event_manager.EventManager.has_listener ", "f": 1}, {"r": "hikari.api.event_manager.EventManager.listen", "u": 27, "d": "Generate a decorator to subscribe a callback to an event type. This is a second-order decorator. Parameters event_type : typing.Optional[typing.Type[T The event type to subscribe to. The implementation may allow this to be undefined. If this is the case, the event type will be inferred instead from the type hints on the function signature. T must be a subclass of hikari.events.base_events.Event . Returns typing.Callable T], T] A decorator for a coroutine function that passes it to EventManager.subscribe before returning the function reference. See Also Dispatch: hikari.api.event_manager.EventManager.dispatch Stream: hikari.api.event_manager.EventManager.stream Subscribe: hikari.api.event_manager.EventManager.subscribe Unsubscribe: hikari.api.event_manager.EventManager.unsubscribe Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.api.event_manager.EventManager.stream", "u": 27, "d": "Return a stream iterator for the given event and sub-events. Parameters event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally.\ntimeout : typing.Optional[builtins.int, builtins.float] How long this streamer should wait for the next event before ending the iteration. If builtins.None then this will continue until explicitly broken from.\nlimit : typing.Optional[builtins.int] The limit for how many events this should queue at one time before dropping extra incoming events, leave this as builtins.None for the cache size to be unlimited. Returns EventStream[hikari.events.base_events.Event] The async iterator to handle streamed events. This must be started with async with stream: or await stream.open() before asynchronously iterating over it. ! warning If you use await stream.open() to start the stream then you must also close it with await stream.close() otherwise it may queue events in memory indefinitely. Examples  \nasync with bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id as stream: async for user_id in stream.map(\"user_id\").limit(50): . or using await open() and await close()  \nstream = bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id await stream.open() async for user_id in stream.map(\"user_id\").limit(50) . await stream.close() See Also Dispatch: hikari.api.event_manager.EventManager.dispatch Listen: hikari.api.event_manager.EventManager.listen Subscribe: hikari.api.event_manager.EventManager.subscribe Unsubscribe: hikari.api.event_manager.EventManager.unsubscribe Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.api.event_manager.EventManager.wait_for", "u": 27, "d": "Wait for a given event to occur once, then return the event. Parameters event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally.\npredicate A function taking the event as the single parameter. This should return builtins.True if the event is one you want to return, or builtins.False if the event should not be returned. If left as None (the default), then the first matching event type that the bot receives (or any subtype) will be the one returned. ! warning Async predicates are not supported.\ntimeout : typing.Union[builtins.float, builtins.int, builtins.None] The amount of time to wait before raising an asyncio.TimeoutError and giving up instead. This is measured in seconds. If builtins.None , then no timeout will be waited for (no timeout can result in \"leaking\" of coroutines that never complete if called in an uncontrolled way, so is not recommended). Returns hikari.events.base_events.Event The event that was provided. Raises asyncio.TimeoutError If the timeout is not builtins.None and is reached before an event is received that the predicate returns builtins.True for. See Also Listen: hikari.api.event_manager.EventManager.listen Stream: hikari.api.event_manager.EventManager.stream Subscribe: hikari.api.event_manager.EventManager.subscribe Dispatch: hikari.api.event_manager.EventManager.dispatch ", "f": 1}, {"r": "hikari.api.event_manager.EventStream", "u": 27, "d": "A base abstract class for all event streamers. Unlike hikari.iterators.LazyIterator (which this extends), an event\nstreamer must be started and closed. Examples A streamer may either be started and closed using async with syntax\nwhere EventStream.open and EventStream.close are implicitly called based on\ncontext. py\nasync with EventStream(app, EventType, timeout=50) as stream: async for entry in stream: . A streamer may also be directly started and closed using the EventStream.close and EventStream.open . Note that if you don't call EventStream.close after\nopening a streamer when you're finished with it then it may queue events\nevents in memory indefinitely. py\nstream = EventStream(app, EventType, timeout=50)\nawait stream.open()\nasync for event in stream: . await stream.close() See Also LazyIterator: hikari.iterators.LazyIterator "}, {"r": "hikari.api.event_manager.EventStream.close", "u": 27, "d": "Mark this streamer as closed to stop it from queueing and receiving events. If called on an already closed streamer then this will do nothing. ! note async with streamer may be used as a short-cut for opening and closing a streamer.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.open", "u": 27, "d": "Mark this streamer as opened to let it start receiving and queueing events. If called on an already started streamer then this will do nothing. ! note async with streamer may be used as a short-cut for opening and closing a stream.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.chunk", "u": 27, "d": "Return results in chunks of up to chunk_size amount of entries. Parameters chunk_size : int The limit for how many results should be returned in each chunk. Returns LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.map", "u": 27, "d": "Map the values to a different value. Parameters transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the . operator. Returns LazyIterator[AnotherValueT] LazyIterator that maps each value to another value.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.for_each", "u": 27, "d": "Pass each value to a given consumer immediately.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.filter", "u": 27, "d": "Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item\nthat this iterator would return when it is requested. All conditions must evaluate to builtins.True for the item to be\nreturned. If this is not met, then the item is discarded and ignored,\nthe next matching item will be returned instead, if there is one. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.filter \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values where all conditions are matched.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.take_while", "u": 27, "d": "Return each item until any conditions fail or the end is reached. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.take_while \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.take_until", "u": 27, "d": "Return each item until any conditions pass or the end is reached. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.take_until \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.skip_while", "u": 27, "d": "Discard items while all conditions are True. Items after this will be yielded as normal. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.skip_while \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.skip_until", "u": 27, "d": "Discard items while all conditions are False. Items after this will be yielded as normal. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.skip_until \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.enumerate", "u": 27, "d": "Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of builtins.enumerate which uses much less memory than collecting all the results first and\ncalling builtins.enumerate across them. Parameters start : builtins.int Optional int to start at. If omitted, this is 0 . Examples >>> async for i, item in paginated_results.enumerate(): . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9): . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3): . print(i, item) (9, foo) (10, bar) (11, baz) Returns LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.limit", "u": 27, "d": "Limit the number of items you receive from this async iterator. Parameters limit : builtins.int The number of items to get. This must be greater than zero. Examples >>> async for item in paginated_results.limit(3): . print(item) Returns LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.skip", "u": 27, "d": "Drop the given number of items, then yield anything after. Parameters number : builtins.int The max number of items to drop before any items are yielded. Returns LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.next", "u": 27, "d": "Return the next element of this iterator only. Returns ValueT The next result. Raises builtins.LookupError If no more results exist.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.last", "u": 27, "d": "Return the last element of this iterator only. Returns ValueT The last result. ! note This method will consume the whole iterator if run. Raises builtins.LookupError If no result exists.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.reversed", "u": 27, "d": "Return a lazy iterator of the remainder of this iterator's values reversed. Returns LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.sort", "u": 27, "d": "Collect all results, then sort the collection before returning it.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.collect", "u": 27, "d": "Collect the results into a given type and return it. Parameters collector A function that consumes a sequence of values and returns a collection.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.count", "u": 27, "d": "Count the number of results. Returns builtins.int Number of results found.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.flat_map", "u": 27, "d": "Perform a flat mapping operation. This will pass each item in the iterator to the given function parameter, expecting a new typing.Iterable or typing.AsyncIterator to be returned as the result. This means you can map to a new LazyIterator , typing.AsyncIterator , typing.Iterable ,\nasync generator, or generator. Remember that typing.Iterator implicitly provides typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement\nreactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded\nlazily. Parameters flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example The following example generates a distinct collection of all mentioned\nusers in the given channel from the past 500 messages. py\ndef iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\"<@!?(\\d+)>\", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct()\n) Returns LazyIterator[AnotherValueT] The new lazy iterator to return.", "f": 1}, {"r": "hikari.api.event_manager.EventStream.awaiting", "u": 27, "d": "Await each item concurrently in a fixed size window. Parameters window_size : int The window size of how many tasks to await at once. You can set this to 0 to await everything at once, but see the below warning. Returns LazyIterator[ValueT] The new lazy iterator to return. ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the fetch_user endpoint seems to be notorious for doing this). ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.", "f": 1}, {"r": "hikari.api.voice", "u": 28, "d": "Interfaces used to describe voice client implementations."}, {"r": "hikari.api.voice.VoiceComponent", "u": 28, "d": "Interface for a voice system implementation."}, {"r": "hikari.api.voice.VoiceComponent.is_alive", "u": 28, "d": "Whether this component is alive."}, {"r": "hikari.api.voice.VoiceComponent.connections", "u": 28, "d": "Return a mapping of guild-id to active voice connection."}, {"r": "hikari.api.voice.VoiceComponent.close", "u": 28, "d": "Shut down all connections, waiting for them to terminate. Once this is done, unsubscribe from any events. If you simply wish to disconnect every connection, use disconnect instead.", "f": 1}, {"r": "hikari.api.voice.VoiceComponent.disconnect", "u": 28, "d": "Disconnect from a given guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.Guild] The guild to disconnect from.", "f": 1}, {"r": "hikari.api.voice.VoiceComponent.disconnect_all", "u": 28, "d": "Disconnect all the active voice connections.", "f": 1}, {"r": "hikari.api.voice.VoiceComponent.connect_to", "u": 28, "d": "Connect to a given voice channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.Guild] The guild to connect to.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel] The channel or channel ID to connect to.\nvoice_connection_type : typing.Type[VoiceConnection] The type of voice connection to use. This should be initialized internally using the VoiceConnection.initialize  builtins.classmethod .\ndeaf : builtins.bool Defaulting to builtins.False , if builtins.True , the client will enter the voice channel deafened (thus unable to hear other users).\nmute : builtins.bool Defaulting to builtins.False , if builtins.True , the client will enter the voice channel muted (thus unable to send audio). kwargs : typing.Any Any arguments to provide to the VoiceConnection.initialize method. Returns VoiceConnection A voice connection implementation of some sort.", "f": 1}, {"r": "hikari.api.voice.VoiceConnection", "u": 28, "d": "An abstract interface for defining how bots can interact with voice. Since voice will generally be run in a subprocess to prevent interfering\nwith the bot when performing CPU-bound encoding/encryption, any\nimplementation of this is expected to implement the appropriate mechanisms\nfor communicating with a voice subprocess and controlling it, however, this\nis left to the discretion of each implementation. Control is left to the implementation to define how to perform it. The\nidea is to allow various decoders to be implemented to allow this to direct\ninterface with other types of system outside this library, such as LavaLink,\nfor example."}, {"r": "hikari.api.voice.VoiceConnection.initialize", "u": 28, "d": "Initialize and connect the voice connection. Parameters channel_id : hikari.snowflakes.Snowflake The channel ID that the voice connection is actively connected to.\nendpoint : str The voice websocket endpoint to connect to. Will contain the protocol at the start (i.e. wss:  ), and end with the correct port (the port and protocol are sanitized since Discord still provide the wrong information four years later).\nguild_id : hikari.snowflakes.Snowflake The guild ID that the websocket should connect to.\non_close : typing.Callable T], typing.Awaitable[None A shutdown hook to invoke when closing a connection to ensure the connection is unregistered from the voice component safely.\nowner : VoiceComponent The component that made this connection object.\nsession_id : builtins.str The voice session ID to use.\nshard_id : builtins.int The associated shard ID that the voice connection was generated from.\ntoken : builtins.str The voice token to use.\nuser_id : hikari.snowflakes.Snowflake The user ID of the account that just joined the voice channel. kwargs : typing.Any Any implementation-specific arguments to provide to the voice connection that is being initialized. Returns VoiceConnection The type of this connection object.", "f": 1}, {"r": "hikari.api.voice.VoiceConnection.channel_id", "u": 28, "d": "Return the ID of the voice channel this voice connection is in."}, {"r": "hikari.api.voice.VoiceConnection.guild_id", "u": 28, "d": "Return the ID of the guild this voice connection is in."}, {"r": "hikari.api.voice.VoiceConnection.is_alive", "u": 28, "d": "Return builtins.True if the connection is alive."}, {"r": "hikari.api.voice.VoiceConnection.shard_id", "u": 28, "d": "Return the ID of the shard that requested the connection."}, {"r": "hikari.api.voice.VoiceConnection.owner", "u": 28, "d": "Return the component that is managing this connection."}, {"r": "hikari.api.voice.VoiceConnection.disconnect", "u": 28, "d": "Signal the process to shut down.", "f": 1}, {"r": "hikari.api.voice.VoiceConnection.join", "u": 28, "d": "Wait for the process to halt before continuing.", "f": 1}, {"r": "hikari.api.voice.VoiceConnection.notify", "u": 28, "d": "Submit an event to the voice connection to be processed.", "f": 1}, {"r": "hikari.api.rest", "u": 29, "d": "Provides an interface for REST API implementations to follow."}, {"r": "hikari.api.rest.RESTClient", "u": 29, "d": "Interface for functionality that a REST API implementation provides."}, {"r": "hikari.api.rest.RESTClient.is_alive", "u": 29, "d": "Whether this component is alive."}, {"r": "hikari.api.rest.RESTClient.token_type", "u": 29, "d": "Type of token this client is using for most requests. Returns typing.Union[builtins.str, hikari.applications.TokenType, builtins.None] The type of token this client is using for most requests. If this is builtins.None then this client will likely only work for some endpoints such as public and webhook ones."}, {"r": "hikari.api.rest.RESTClient.close", "u": 29, "d": "Close the client session.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_channel", "u": 29, "d": "Fetch a channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The channel to fetch. This may be the object or the ID of an existing channel. Returns hikari.channels.PartialChannel The channel. This will be a _derivative_ of hikari.channels.PartialChannel , depending on the type of channel you request for. This means that you may get one of hikari.channels.DMChannel , hikari.channels.GroupDMChannel , hikari.channels.GuildTextChannel , hikari.channels.GuildVoiceChannel , hikari.channels.GuildStoreChannel , hikari.channels.GuildNewsChannel . Likewise, the hikari.channels.GuildChannel can be used to determine if a channel is guild-bound, and hikari.channels.TextableChannel can be used to determine if the channel provides textual functionality to the application. You can check for these using the builtins.isinstance builtin function. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_channel", "u": 29, "d": "Edit a channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to edit. This may be the object or the ID of an existing channel. Other Parameters name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel.\nposition : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel.\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[builtins.str, hikari.voices.VoiceRegion If provided, the voice region to set for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel.\nparent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.PartialChannel The edited channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing permissions to edit the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.follow_channel", "u": 29, "d": "Follow a news channel to send messages to a target channel. Parameters news_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel] The object or ID of the news channel to follow.\ntarget_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The object or ID of the channel to target. Returns hikari.channels.ChannelFollow Information about the new relationship that was made. Raises hikari.errors.BadRequestError If you try to follow a channel that's not a news channel or if the target channel has reached it's webhook limit, which is 10 at the time of writing.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission in the target channel or are missing the VIEW_CHANNEL permission in the origin channel.\nhikari.errors.NotFoundError If the origin or target channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_channel", "u": 29, "d": "Delete a channel in a guild, or close a DM. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The channel to delete. This may be the object or the ID of an existing channel. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_my_voice_state", "u": 29, "d": "Edit the current user's voice state in a stage channel. ! note The current user has to have already joined the target stage channel before any calls can be made to this endpoint. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or Id of the guild to edit a voice state in.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildStageChannel] Object or Id of the channel to edit a voice state in. Other Parameters suppress : hikari.undefined.UndefinedOr[builtins.bool] If specified, whether the user should be allowed to become a speaker in the target stage channel with builtin.True suppressing them from becoming one.\nrequest_to_speak : typing.Union[hikari.undefined.UndefinedType, builtins.bool, datetime.datetime] Whether to request to speak. This may be one of the following:  True to indicate that the bot wants to speak.  False to remove any previously set request to speak.  datetime.datetime to specify when they want their request to speak timestamp to be set to. ! note If a datetime from the past is passed then Discord will use the current time instead. Raises hikari.errors.BadRequestError If you try to target a non-staging channel.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MUTE_MEMBERS permission in the channel.\nhikari.errors.NotFoundError If the channel, message or voice state is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_voice_state", "u": 29, "d": "Edit an existing voice state in a stage channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or Id of the guild to edit a voice state in.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildStageChannel] Object or Id of the channel to edit a voice state in.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or Id of the user to to edit the voice state of. Other Parameters suppress : hikari.undefined.UndefinedOr[builtins.bool] If defined, whether the user should be allowed to become a speaker in the target stage channel. ! note The target user must already be present in the stage channel before any calls are made to this endpoint. Raises hikari.errors.BadRequestError If you try to target a non-staging channel.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MUTE_MEMBERS permission in the channel.\nhikari.errors.NotFoundError If the channel, message or voice state is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_permission_overwrites", "u": 29, "d": "Edit permissions for a specific entity in the given guild channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to edit a permission overwrite in. This may be the object, or the ID of an existing channel.\ntarget : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int If provided, the type of the target to update. If unset, will attempt to get the type from target .\nallow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions.\ndeny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises builtins.TypeError If target_type is unset and we were unable to determine the type from target .\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_permission_overwrite", "u": 29, "d": "Delete a custom permission for an entity in a given guild channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to delete a permission overwrite in. This may be the object, or the ID of an existing channel.\ntarget : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_channel_invites", "u": 29, "d": "Fetch all invites pointing to the given guild channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to fetch the invites from. This may be a channel object, or the ID of an existing channel. Returns typing.Sequence[hikari.invites.InviteWithMetadata] The invites pointing to the given guild channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found in any guilds you are a member of.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_invite", "u": 29, "d": "Create an invite to the given guild channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to create a invite for. This may be the object or the ID of an existing channel. Other Parameters max_age : hikari.undefined.UndefinedOr[typing.Union[datetime.timedelta, builtins.float, builtins.int If provided, the duration of the invite before expiry.\nmax_uses : hikari.undefined.UndefinedOr[builtins.int] If provided, the max uses the invite can have.\ntemporary : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the invite only grants temporary membership.\nunique : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the invite should be unique.\ntarget_type : hikari.undefined.UndefinedOr[hikari.invites.TargetType] If provided, the target type of this invite.\ntarget_user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser If provided, the target user id for this invite. This may be the object or the ID of an existing user. ! note This is required if target_type is STREAM and the targeted user must be streaming into the channel.\ntarget_application : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication If provided, the target application id for this invite. This may be the object or the ID of an existing application. ! note This is required if target_type is EMBEDDED_APPLICATION and the targeted application must have the EMBEDDED flag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.invites.InviteWithMetadata The invite to the given guild channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNELS permission.\nhikari.errors.NotFoundError If the channel is not found, or if the target user does not exist, if provided.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.trigger_typing", "u": 29, "d": "Trigger typing in a text channel. The result of this call can be awaited to trigger typing once, or\ncan be used as an async context manager to continually type until the\ncontext manager is left. Examples   Trigger typing just once.\nawait rest.trigger_typing(channel) Trigger typing repeatedly for 1 minute.\nasync with rest.trigger_typing(channel): await asyncio.sleep(60)  ! warning Sending a message to the channel will cause the typing indicator to disappear until it is re-triggered. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to trigger typing in. This may be the object or the ID of an existing channel. Returns hikari.api.special_endpoints.TypingIndicator A typing indicator to use. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise any of the above types.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_pins", "u": 29, "d": "Fetch the pinned messages in this text channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to fetch pins from. This may be the object or the ID of an existing channel. Returns typing.Sequence[hikari.messages.Message] The pinned messages in this text channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.pin_message", "u": 29, "d": "Pin an existing message in the given text channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to pin a message in. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to pin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found, or if the message does not exist in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.unpin_message", "u": 29, "d": "Unpin a given message from a given text channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to unpin a message in. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to unpin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.NotFoundError If the channel is not found or the message is not a pinned message in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_messages", "u": 29, "d": "Browse the message history for a given text channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to fetch messages in. This may be the object or the ID of an existing channel. Other Parameters before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\nafter : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\naround : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns hikari.iterators.LazyIterator[hikari.messages.Message] An iterator to fetch the messages. ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See hikari.iterators for the full API for this iterator type. Raises builtins.TypeError If you specify more than one of before , after , about .\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint (other than builtins.TypeError ) will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything (other than builtins.TypeError ).", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_message", "u": 29, "d": "Fetch a specific message in the given text channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to fetch messages in. This may be the object or the ID of an existing message.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel.\nhikari.errors.NotFoundError If the channel is not found or the message is not found in the given text channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_message", "u": 29, "d": "Create a message in the given channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to create the message in.\ncontent : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nnonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions or if both attachment and attachments , component and components or embed and embeds are specified.\nbuiltins.TypeError If attachments , components or embeds is passed but is not a sequence.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; if reply is not found or not in the same channel as channel ; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.crosspost_message", "u": 29, "d": "Broadcast an announcement message. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel] The object or ID of the news channel to crosspost a message in.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The object or ID of the message to crosspost. Returns hikari.messages.Message The message object that was crossposted. Raises hikari.errors.BadRequestError If you tried to crosspost a message that has already been broadcast.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you try to crosspost a message by the current user without the SEND_MESSAGES permission for the target news channel or try to crosspost a message by another user without both the SEND_MESSAGES and MANAGE_MESSAGES permissions for the target channel.\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_message", "u": 29, "d": "Edit an existing message in a given channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to create the message in. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to edit. This may be the object or the ID of an existing message.\ncontent : hikari.undefined.UndefinedOr[typing.Any] If provided, the message content to update with. If hikari.undefined.UNDEFINED , then the content will not be changed. If builtins.None , then the content will be removed. Any other value will be cast to a builtins.str before sending. If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if message is not a reply message.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, sanitation for user mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , all valid user mentions will behave as mentions. If builtins.False , all valid user mentions will not behave as mentions. You may alternatively pass a collection of hikari.snowflakes.Snowflake user IDs, or hikari.users.PartialUser -derived objects.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, sanitation for role mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , all valid role mentions will behave as mentions. If builtins.False , all valid role mentions will not behave as mentions. You may alternatively pass a collection of hikari.snowflakes.Snowflake role IDs, or hikari.guilds.PartialRole -derived objects.\nflags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag] If provided, optional flags to set on the message. If hikari.undefined.UNDEFINED , then nothing is changed. Note that some flags may not be able to be set. Currently the only flags that can be set are NONE and SUPPRESS_EMBEDS . If you have MANAGE_MESSAGES permissions, you can use this call to suppress embeds on another user's message. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all four of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all four of them each time. ! warning If the message was not sent by your user, the only parameter you may provide to this call is the flags parameter. Anything else will result in a hikari.errors.ForbiddenError being raised. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If both attachment and attachments , component and components or embed and embeds are specified.\nbuiltins.TypeError If attachments , components or embeds is passed but is not a sequence.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel; if you try to change the contents of another user's message; or if you try to edit the flags on another user's message without the MANAGE_MESSAGES permission.\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_message", "u": 29, "d": "Delete a given message in a given channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to delete the message in. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES , and the message is not sent by you.\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_messages", "u": 29, "d": "Bulk-delete messages from the channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to bulk delete the messages in. This may be the object or the ID of an existing channel.\nmessages : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], hikari.snowflakes.SnowflakeishIterable[hikari.messages.PartialMessage Either the object/ID of an existing message to delete or an iterable of the objects and/or IDs of existing messages to delete. Other Parameters  other_messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The objects and/or IDs of other existing messages to delete. ! note This API endpoint will only be able to delete 100 messages at a time. For anything more than this, multiple requests will be executed one-after-the-other, since the rate limits for this endpoint do not favour more than one request per bucket. If one message is left over from chunking per 100 messages, or only one message is passed to this coroutine function, then the logic is expected to defer to delete_message . The implication of this is that the delete_message endpoint is ratelimited by a different bucket with different usage rates. ! warning This endpoint is not atomic. If an error occurs midway through a bulk delete, you will not be able to revert any changes made up to this point. ! warning Specifying any messages more than 14 days old will cause the call to fail, potentially with partial completion. Raises hikari.errors.BulkDeleteError An error containing the messages successfully deleted, and the messages that were not removed. The builtins.BaseException.__cause__ of the exception will be the original error that terminated this process.", "f": 1}, {"r": "hikari.api.rest.RESTClient.add_reaction", "u": 29, "d": "Add a reaction emoji to a message in a given channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to add the reaction to is. This may be a hikari.channels.TextableChannel or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to add a reaction to. This may be the object or the ID of an existing message.\nemoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to react with. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to react with. This should only be provided when a custom emoji's name is passed for emoji . Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the ADD_REACTIONS (this is only necessary if you are the first person to add the reaction).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_my_reaction", "u": 29, "d": "Delete a reaction that your application user created. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to delete the reaction from is. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reaction from. This may be the object or the ID of an existing message.\nemoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to remove your reaction for. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to remove your reaction for. This should only be provided when a custom emoji's name is passed for emoji . Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_all_reactions_for_emoji", "u": 29, "d": "Delete all reactions for a single emoji on a given message. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to delete the reactions from is. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reactions from. This may be the object or the ID of an existing message.\nemoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to remove all the reactions for. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to remove all the reactions for. This should only be provided when a custom emoji's name is passed for emoji . Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_reaction", "u": 29, "d": "Delete a reaction from a message. If you are looking to delete your own applications reaction, use delete_my_reaction . Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to delete the reaction from is. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reaction from. This may be the object or the ID of an existing message.\nuser: hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to remove the reaction of.\nemoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to react with. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to react with. This should only be provided when a custom emoji's name is passed for emoji . Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_all_reactions", "u": 29, "d": "Delete all reactions from a message. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to delete all reactions from is. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete all reaction from. This may be the object or the ID of an existing message. Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_reactions_for_emoji", "u": 29, "d": "Fetch reactions for an emoji from a message. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to delete all reactions from is. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete all reaction from. This may be the object or the ID of an existing message.\nemoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to get the reactions for. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to get the reactions for. This should only be provided when a custom emoji's name is passed for emoji . Returns hikari.iterators.LazyIterator[hikari.users.User] An iterator to fetch the users. ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See hikari.iterators for the full API for this iterator type. Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_webhook", "u": 29, "d": "Create webhook in a channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT] The channel where the webhook will be created. This may be the object or the ID of an existing channel.\nname : str The name for the webhook. This cannot be clyde . Other Parameters avatar : typing.Optional[hikari.files.Resourceish] If provided, the avatar for the webhook.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.webhooks.IncomingWebhook The created webhook. Raises hikari.errors.BadRequestError If name doesn't follow the restrictions enforced by discord.\nhikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_webhook", "u": 29, "d": "Fetch an existing webhook. Parameters webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook] The webhook to fetch. This may be the object or the ID of an existing webhook. Other Parameters token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to fetch the webhook instead of the token the client was initialized with. Returns hikari.webhooks.PartialWebhook The requested webhook. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission when not using a token.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_channel_webhooks", "u": 29, "d": "Fetch all channel webhooks. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT] The channel to fetch the webhooks for. This may be an instance of any of the classes which are valid for hikari.channels.WebhookChannelT or the ID of an existing channel. Returns typing.Sequence[hikari.webhooks.PartialWebhook] The fetched webhooks. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_guild_webhooks", "u": 29, "d": "Fetch all guild webhooks. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the webhooks for. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.webhooks.PartialWebhook] The fetched webhooks. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_webhook", "u": 29, "d": "Edit a webhook. Parameters webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook] The webhook to edit. This may be the object or the ID of an existing webhook. Other Parameters token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to edit the webhook instead of the token the client was initialized with.\nname : hikari.undefined.UndefinedOr[builtins.str] If provided, the new webhook name.\navatar : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new webhook avatar. If builtins.None , will remove the webhook avatar.\nchannel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT If provided, the text channel to move the webhook to.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.webhooks.PartialWebhook The edited webhook. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission when not using a token.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_webhook", "u": 29, "d": "Delete a webhook. Parameters webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook] The webhook to delete. This may be the object or the ID of an existing webhook. Other Parameters token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to delete the webhook instead of the token the client was initialized with. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission when not using a token.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhoook is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.execute_webhook", "u": 29, "d": "Execute a webhook. Parameters webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook] The webhook to execute. This may be the object or the ID of an existing webhook.\ntoken: builtins.str The webhook token.\ncontent : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor no embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters username : hikari.undefined.UndefinedOr[builtins.str] If provided, the username to override the webhook's username for this request.\navatar_url : hikari.undefined.UndefinedOr[builtins.str] If provided, the url of an image to override the webhook's avatar with for this request.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nnonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.\nflags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The flags to set for this webhook message. ! warning As of writing this can only be set for interaction webhooks and the only settable flag is EPHEMERAL; this field is just ignored for non-interaction webhooks. ! warning As of writing, username and avatar_url are ignored for interaction webhooks. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions or if both attachment and attachments or embed and embeds are specified.\nbuiltins.TypeError If attachments , or embeds is passed but is not a sequence.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_webhook_message", "u": 29, "d": "Fetch an old message sent by the webhook. Parameters webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook] The webhook to execute. This may be the object or the ID of an existing webhook.\ntoken: builtins.str The webhook token.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found or the webhook's message wasn't found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_webhook_message", "u": 29, "d": "Edit a message sent by a webhook. Parameters webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook] The webhook to execute. This may be the object or the ID of an existing webhook.\ntoken: builtins.str The webhook token.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message.\ncontent : hikari.undefined.UndefinedOr[typing.Any] If provided, the message content to update with. If hikari.undefined.UNDEFINED , then the content will not be changed. If builtins.None , then the content will be removed. Any other value will be cast to a builtins.str before sending. If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all three of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If both attachment and attachments , component and components or embed and embeds are specified.\nbuiltins.TypeError If attachments , components or embeds is passed but is not a sequence.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_webhook_message", "u": 29, "d": "Delete a given message in a given channel. Parameters webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook] The webhook to execute. This may be the object or the ID of an existing webhook.\ntoken: builtins.str The webhook token.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_gateway_url", "u": 29, "d": "Fetch the gateway url. ! note This endpoint does not require any valid authorization. Raises hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_gateway_bot_info", "u": 29, "d": "Fetch the gateway gateway info for the bot. Returns hikari.sessions.GatewayBotInfo The gateway bot information. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_invite", "u": 29, "d": "Fetch an existing invite. Parameters invite : typing.Union[hikari.invites.InviteCode, builtins.str] The invite to fetch. This may be an invite object or the code of an existing invite. Returns hikari.invites.Invite The requested invite. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the invite is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_invite", "u": 29, "d": "Delete an existing invite. Parameters invite : typing.Union[hikari.invites.InviteCode, builtins.str] The invite to delete. This may be an invite object or the code of an existing invite. Returns hikari.invites.Invite Object of the invite that was deleted. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission in the guild the invite is from or if you are missing the MANAGE_CHANNELS permission in the channel the invite is from.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the invite is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_my_user", "u": 29, "d": "Fetch the token's associated user. Returns hikari.users.OwnUser The token's associated user. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_my_user", "u": 29, "d": "Edit the token's associated user. Other Parameters username : undefined.UndefinedOr[builtins.str] If provided, the new username.\navatar : undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new avatar. If builtins.None , the avatar will be removed. Returns hikari.users.OwnUser The edited token's associated user. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Discord also returns this on a ratelimit: https: github.com/discord/discord-api-docs/issues/1462\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_my_connections", "u": 29, "d": "Fetch the token's associated connections. Returns hikari.applications.OwnConnection The token's associated connections. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_my_guilds", "u": 29, "d": "Fetch the token's associated guilds. Other Parameters newest_first : builtins.bool Whether to fetch the newest first or the olders first. Defaults to builtins.False .\nstart_at : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.guilds.PartialGuild If provided, will start at this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may also be a guild object. In this case, the date the object was first created will be used. Returns hikari.iterators.LazyIterator[hikari.applications.OwnGuild] The token's associated guilds. ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See hikari.iterators for the full API for this iterator type. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.", "f": 1}, {"r": "hikari.api.rest.RESTClient.leave_guild", "u": 29, "d": "Leave a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to leave. This may be the object or the ID of an existing guild. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found or you own the guild.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_dm_channel", "u": 29, "d": "Create a DM channel with a user. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to create the DM channel with. This may be the object or the ID of an existing user. Returns hikari.channels.DMChannel The created DM channel. Raises hikari.errors.BadRequestError If the user is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_application", "u": 29, "d": "Fetch the token's associated application. ! warning This endpoint can only be used with a Bot token. Using this with a Bearer token will result in a hikari.errors.UnauthorizedError . Returns hikari.applications.Application The token's associated application. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_authorization", "u": 29, "d": "Fetch the token's authorization information. ! warning This endpoint can only be used with a Bearer token. Using this with a Bot token will result in a hikari.errors.UnauthorizedError . Returns hikari.applications.AuthorizationInformation The token's authorization information. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.authorize_client_credentials_token", "u": 29, "d": "Authorize a client credentials token for an application. Parameters client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to authorize as.\nclient_secret : builtins.str Secret of the application to authorize as.\nscopes : typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, builtins.str The scopes to authorize for. Returns hikari.applications.PartialOAuth2Token Object of the authorized partial OAuth2 token. Raises hikari.errors.BadRequestError If invalid any invalid or malformed scopes are passed.\nhikari.errors.UnauthorizedError When an client or client secret is passed.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.authorize_access_token", "u": 29, "d": "Authorize an OAuth2 token using the authorize code grant type. Parameters client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to authorize with.\nclient_secret : builtins.str Secret of the application to authorize with.\ncode : builtins.str The authorization code to exchange for an OAuth2 access token.\nredirect_uri : builtins.str The redirect uri that was included in the authorization request. Returns hikari.applications.OAuth2AuthorizationToken Object of the authorized OAuth2 token. Raises hikari.errors.BadRequestError If an invalid redirect uri or code is passed.\nhikari.errors.UnauthorizedError When an client or client secret is passed.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.refresh_access_token", "u": 29, "d": "Refresh an access token. ! warning As of writing this Discord currently ignores any passed scopes, therefore you should use hikari.applications.OAuth2AuthorizationToken.scopes to validate that the expected scopes were actually authorized here. Parameters client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to authorize with.\nclient_secret : builtins.str Secret of the application to authorize with.\nrefresh_token : builtins.str The refresh token to use. Other Parameters scopes : typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, builtins.str The scope of the access request. Returns hikari.applications.OAuth2AuthorizationToken Object of the authorized OAuth2 token. Raises hikari.errors.BadRequestError If an invalid redirect uri or refresh_token is passed.\nhikari.errors.UnauthorizedError When an client or client secret is passed.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.revoke_access_token", "u": 29, "d": "Revoke an OAuth2 token. Parameters client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to authorize with.\nclient_secret : builtins.str Secret of the application to authorize with.\ntoken : typing.Union[builtins.str, hikari.applications.PartialOAuth2Token] Object or string of the access token to revoke. Raises hikari.errors.UnauthorizedError When an client or client secret is passed.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.add_user_to_guild", "u": 29, "d": "Add a user to a guild. ! note This requires the access_token to have the hikari.applications.OAuth2Scope.GUILDS_JOIN scope enabled along with the authorization of a Bot which has MANAGE_INVITES permission within the target guild. Parameters access_token : typing.Union[builtins.str, hikari.applications.PartialOAuth2Token] Object or string of the access token to use for this request.\nguild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to add the user to. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to add to the guild. This may be the object or the ID of an existing user. Other Parameters nick : hikari.undefined.UndefinedOr[builtins.str] If provided, the nick to add to the user when he joins the guild. Requires the MANAGE_NICKNAMES permission on the guild.\nroles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, the roles to add to the user when he joins the guild. This may be a collection objects or IDs of existing roles. Requires the MANAGE_ROLES permission on the guild.\nmute : hikari.undefined.UndefinedOr[builtins.bool] If provided, the mute state to add the user when he joins the guild. Requires the MUTE_MEMBERS permission on the guild.\ndeaf : hikari.undefined.UndefinedOr[builtins.bool] If provided, the deaf state to add the user when he joins the guild. Requires the DEAFEN_MEMBERS permission on the guild. Returns typing.Optional[hikari.guilds.Member] builtins.None if the user was already part of the guild, else hikari.guilds.Member . Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are not part of the guild you want to add the user to, if you are missing permissions to do one of the things you specified, if you are using an access token for another user, if the token is bound to another bot or if the access token doesn't have the hikari.applications.OAuth2Scope.GUILDS_JOIN scope enabled.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If you own the guild or the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_voice_regions", "u": 29, "d": "Fetch available voice regions. ! note This endpoint doesn't return VIP voice regions. Returns typing.Sequence[hikari.voices.VoiceRegion] The available voice regions. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_user", "u": 29, "d": "Fetch a user. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to fetch. This can be the object or the ID of an existing user. Returns hikari.users.User The requested user Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_audit_log", "u": 29, "d": "Fetch the guild's audit log. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the audit logs from. This can be a guild object or the ID of an existing guild. Other Parameters before : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, filter to only actions after this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\nuser : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser If provided, the user to filter for.\nevent_type : hikari.undefined.UndefinedOr[typing.Union[hikari.audit_logs.AuditLogEventType, builtins.int If provided, the event type to filter for. Returns hikari.iterators.LazyIterator[hikari.audit_logs.AuditLog] The guild's audit log. ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See hikari.iterators for the full API for this iterator type. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the VIEW_AUDIT_LOG permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_emoji", "u": 29, "d": "Fetch a guild emoji. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the emoji from. This can be a guild object or the ID of an existing guild.\nemoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns hikari.emojis.KnownCustomEmoji The requested emoji. Raises hikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_guild_emojis", "u": 29, "d": "Fetch the emojis of a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the emojis from. This can be a guild object or the ID of an existing guild. Returns typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_emoji", "u": 29, "d": "Create an emoji in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the emoji on. This can be a guild object or the ID of an existing guild.\nname : builtins.str The name for the emoji.\nimage : hikari.files.Resourceish The 128x128 image for the emoji. Maximum upload size is 256kb. This can be a still or an animated image. Other Parameters roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, a collection of the roles that will be able to use this emoji. This can be a hikari.guilds.PartialRole or the ID of an existing role.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.emojis.KnownCustomEmoji The created emoji. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the type of emoji in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_emoji", "u": 29, "d": "Edit an emoji in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the emoji on. This can be a guild object or the ID of an existing guild.\nemoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to edit. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the emoji.\nroles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, the new collection of roles that will be able to use this emoji. This can be a hikari.guilds.PartialRole or the ID of an existing role.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.emojis.KnownCustomEmoji The edited emoji. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_emoji", "u": 29, "d": "Delete an emoji in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete the emoji on. This can be a guild object or the ID of an existing guild.\nemoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to delete. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_available_sticker_packs", "u": 29, "d": "Fetch the available sticker packs. Returns typing.Sequence[hikari.stickers.StickerPack] The available sticker packs. Raises hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_sticker", "u": 29, "d": "Fetch a sticker. Parameters sticker : snowflakes.SnowflakeishOr[stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns typing.Union[hikari.stickers.GuildSticker, hikari.stickers.StandardSticker] The requested sticker. Raises hikari.errors.NotFoundError If the sticker is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_guild_stickers", "u": 29, "d": "Fetch a standard sticker. Parameters guild : snowflakes.SnowflakeishOr[stickers.PartialGuild] The guild to request stickers for. This can be a guild object or the ID of an existing guild. Returns typing.Sequence[hikari.stickers.GuildSticker] The requested stickers. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_guild_sticker", "u": 29, "d": "Fetch a guild sticker. Parameters guild : snowflakes.SnowflakeishOr[stickers.PartialGuild] The guild the sticker is in. This can be a guild object or the ID of an existing guild.\nsticker : snowflakes.SnowflakeishOr[stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns hikari.stickers.GuildSticker The requested sticker. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_sticker", "u": 29, "d": "Create a sticker in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the sticker on. This can be a guild object or the ID of an existing guild.\nname : builtins.str The name for the sticker.\ntag : builtins.str The tag for the sticker.\nimage : hikari.files.Resourceish The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie. ! note Lottie support is only available for verified and partnered servers. Other Parameters description: hikari.undefined.UndefinedOr[builtins.str] If provided, the description of the sticker.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The created sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_sticker", "u": 29, "d": "Edit a sticker in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the sticker on. This can be a guild object or the ID of an existing guild.\nsticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to edit. This can be a sticker object or the ID of an existing sticker. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the sticker.\ndescription : hikari.undefined.UndefinedOr[builtins.str] If provided, the new description for the sticker.\ntag : hikari.undefined.UndefinedOr[builtins.str] If provided, the new sticker tag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The edited sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_sticker", "u": 29, "d": "Delete a sticker in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete the sticker on. This can be a guild object or the ID of an existing guild.\nsticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to delete. This can be a sticker object or the ID of an existing sticker. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.guild_builder", "u": 29, "d": "Make a guild builder to create a guild with. Parameters name : builtins.str The new guilds name. Returns hikari.api.special_endpoints.GuildBuilder The guild builder to use. This will allow to create a guild later with hikari.api.special_endpoints.GuildBuilder.create . ! note This endpoint can only be used by bots in less than 10 guilds. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if you call this as a bot that's in more than 10 guilds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once hikari.api.special_endpoints.GuildBuilder.create is called. Invoking this function itself will not raise any of the above types. See Also Guild builder: hikari.api.special_endpoints.GuildBuilder ", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_guild", "u": 29, "d": "Fetch a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch. This can be the object or the ID of an existing guild. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_guild_preview", "u": 29, "d": "Fetch a guild preview. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the preview of. This can be a guild object or the ID of an existing guild. Returns hikari.guilds.GuildPreview The requested guild preview. ! note This will only work for guilds you are a part of or are public. Raises hikari.errors.NotFoundError If the guild is not found or you are not part of the guild.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_guild", "u": 29, "d": "Edit a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild.\nverification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level.\ndefault_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level.\nexplicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level.\nafk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires afk_timeout to be set to work.\nafk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout.\nicon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature.\nowner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner. ! warning You need to be the owner of the server to use this.\nsplash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the INVITE_SPLASH feature.\nbanner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the BANNER feature.\nsystem_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel.\nrules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel.\npublic_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel.\npreferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.RESTGuild The edited guild. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission or if you tried to pass ownership without being the server owner.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_guild", "u": 29, "d": "Delete a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete. This may be the object or the ID of an existing guild. Raises hikari.errors.ForbiddenError If you are not the owner of the guild.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If you own the guild or if you are not in it.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_guild_channels", "u": 29, "d": "Fetch the channels in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the channels from. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.channels.GuildChannel] The requested channels. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_guild_text_channel", "u": 29, "d": "Create a text channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildTextChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_guild_news_channel", "u": 29, "d": "Create a news channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildNewsChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_guild_voice_channel", "u": 29, "d": "Create a voice channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildVoiceChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_guild_stage_channel", "u": 29, "d": "Create a stage channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channel's name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildStageChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_guild_category", "u": 29, "d": "Create a category in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildCategory The created category. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.reposition_channels", "u": 29, "d": "Reposition the channels in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to reposition the channels in. This may be the object or the ID of an existing guild.\npositions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel A mapping of of the object or the ID of an existing channel to the new position, relative to their parent category, if any. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_member", "u": 29, "d": "Fetch a guild member. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to get the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to get the member for. This may be the object or the ID of an existing user. Returns hikari.guilds.Member The requested member. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or the user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_members", "u": 29, "d": "Fetch the members from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the members of. This may be the object or the ID of an existing guild. Returns hikari.iterators.LazyIterator[hikari.guilds.Member] An iterator to fetch the members. ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See hikari.iterators for the full API for this iterator type. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything. ! warning This endpoint requires the GUILD_MEMBERS intent to be enabled in the dashboard, not necessarily authenticated with it if using the gateway. If you don't have the intents you can use search_members which doesn't require any intents.", "f": 1}, {"r": "hikari.api.rest.RESTClient.search_members", "u": 29, "d": "Search the members in a guild by nickname and username. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The object or ID of the guild to search members in.\nname : str The query to match username(s) and nickname(s) against. Returns typing.Sequence[hikari.guilds.Member] A sequence of the members who matched the provided name . Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note Unlike RESTClient.fetch_members this endpoint isn't paginated and therefore will return all the members in one go rather than needing to be asynchronously iterated over.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_member", "u": 29, "d": "Edit a guild member. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. Other Parameters nick : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new nick for the member. If builtins.None , will remove the members nick. Requires the MANAGE_NICKNAMES permission.\nroles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, the new roles for the member. Requires the MANAGE_ROLES permission.\nmute : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server mute state for the member. Requires the MUTE_MEMBERS permission.\ndeaf : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server deaf state for the member. Requires the DEAFEN_MEMBERS permission.\nvoice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel ] If provided, builtins.None or the object or the ID of an existing voice channel to move the member to. If builtins.None , will disconnect the member from voice. Requires the MOVE_MEMBERS permission and the CONNECT permission in the original voice channel and the target voice channel. ! note If the member is not in a voice channel, this will take no effect.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.Member Object of the member that was updated. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing a permission to do an action.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or the user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_my_nick", "u": 29, "d": "Edit the associated token's member nick. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild.\nnick : typing.Optional[builtins.str] The new nick. If builtins.None , will remove the nick. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the CHANGE_NICKNAME permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.add_role_to_member", "u": 29, "d": "Add a role to a member. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild where the member is in. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to add the role to. This may be the object or the ID of an existing user.\nrole : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to add. This may be the object or the ID of an existing role. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild, user or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.remove_role_from_member", "u": 29, "d": "Remove a role from a member. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild where the member is in. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to remove the role from. This may be the object or the ID of an existing user.\nrole : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to remove. This may be the object or the ID of an existing role. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild, user or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.kick_user", "u": 29, "d": "Kick a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to kick the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.kick_member", "u": 29, "d": "Kick a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to kick the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.ban_user", "u": 29, "d": "Ban a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to ban the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.ban_member", "u": 29, "d": "Ban a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to ban the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.unban_user", "u": 29, "d": "Unban a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to unban the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to unban. This may be the object or the ID of an existing user. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.unban_member", "u": 29, "d": "Unban a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to unban the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to unban. This may be the object or the ID of an existing user. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_ban", "u": 29, "d": "Fetch the guild's ban info for a user. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the ban from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to fetch the ban of. This may be the object or the ID of an existing user. Returns hikari.guilds.GuildBan The requested ban info. Raises hikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found or if the user is not banned.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_bans", "u": 29, "d": "Fetch the bans of a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the bans from. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.guilds.GuildBan] The requested bans. Raises hikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_roles", "u": 29, "d": "Fetch the roles of a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the roles from. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.guilds.Role] The requested roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_role", "u": 29, "d": "Create a role. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the role in. This may be the object or the ID of an existing guild. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the name for the role.\npermissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] The permissions to give the role. This will default to setting NO roles if left to the default value. This is in contrast to default behaviour on Discord where some random permissions will be set by default.\ncolor : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the role's color.\ncolour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for color .\nhoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role.\nmentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.Role The created role. Raises builtins.TypeError If both color and colour are specified.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.reposition_roles", "u": 29, "d": "Reposition the roles in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to reposition the roles in. This may be the object or the ID of an existing guild.\npositions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole A mapping of the position to the role. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_role", "u": 29, "d": "Edit a role. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the role in. This may be the object or the ID of an existing guild.\nrole : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to edit. This may be the object or the ID of an existing role. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the role.\npermissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new permissions for the role.\ncolor : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the new color for the role.\ncolour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for color .\nhoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role.\nmentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.Role The edited role. Raises builtins.TypeError If both color and colour are specified.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_role", "u": 29, "d": "Delete a role. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete the role in. This may be the object or the ID of an existing guild.\nrole : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to delete. This may be the object or the ID of an existing role. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.estimate_guild_prune_count", "u": 29, "d": "Estimate the guild prune count. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to estimate the guild prune count for. This may be the object or the ID of an existing guild. Other Parameters days : hikari.undefined.UndefinedOr[builtins.int] If provided, number of days to count prune for.\ninclude_roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole ] If provided, the role(s) to include. By default, this endpoint will not count users with roles. Providing roles using this attribute will make members with the specified roles also get included into the count. Returns builtins.int The estimated guild prune count. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.begin_guild_prune", "u": 29, "d": "Begin the guild prune. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to begin the guild prune in. This may be the object or the ID of an existing guild. Other Parameters days : hikari.undefined.UndefinedOr[builtins.int] If provided, number of days to count prune for.\ncompute_prune_count: hikari.snowflakes.SnowflakeishOr[builtins.bool] If provided, whether to return the prune count. This is discouraged for large guilds.\ninclude_roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, the role(s) to include. By default, this endpoint will not count users with roles. Providing roles using this attribute will make members with the specified roles also get included into the count.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns typing.Optional[builtins.int] If compute_prune_count is not provided or builtins.True , the number of members pruned. Else builtins.None . Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_guild_voice_regions", "u": 29, "d": "Fetch the available voice regions for a guild. ! note Unlike RESTClient.fetch_voice_regions , this will return the VIP regions if the guild has access to them. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the voice regions for. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.voices.VoiceRegion] The available voice regions for the guild. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_guild_invites", "u": 29, "d": "Fetch the guild's invites. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the invites for. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.invites.InviteWithMetadata] The invites for the guild. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_integrations", "u": 29, "d": "Fetch the guild's integrations. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the integrations for. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.guilds.Integration] The integrations for the guild. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_widget", "u": 29, "d": "Fetch a guilds's widget. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the widget from. This can be the object or the ID of an existing guild. Returns hikari.guilds.GuildWidget The requested guild widget. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_widget", "u": 29, "d": "Fetch a guilds's widget. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the widget in. This can be the object or the ID of an existing guild. Other Parameters channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel If provided, the channel to set the widget to. If builtins.None , will not set to any.\nenabled : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to enable the widget.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.GuildWidget The edited guild widget. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_welcome_screen", "u": 29, "d": "Fetch a guild's welcome screen. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to fetch the welcome screen for. Returns hikari.guilds.WelcomeScreen The requested welcome screen. Raises hikari.errors.NotFoundError If the guild is not found or the welcome screen has never been set for this guild (if the welcome screen has been set for a guild before and then disabled you should still be able to fetch it).\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_welcome_screen", "u": 29, "d": "Edit the welcome screen of a community guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] ID or object of the guild to edit the welcome screen for. Other Parameters description : undefined.UndefinedNoneOr[builtins.str] If provided, the description to set for the guild's welcome screen. This may be builtins.None to unset the description.\nenabled : undefined.UndefinedOr[builtins.bool] If provided, Whether the guild's welcome screen should be enabled.\nchannels : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.guilds.WelcomeChannel If provided, a sequence of up to 5 public channels to set in this guild's welcome screen. This may be passed as builtins.None to remove all welcome channels ! note Custom emojis may only be included in a guild's welcome channels if it's boost status is tier 2 or above. Returns hikari.guilds.WelcomeScreen The edited guild welcome screen. Raises hikari.errors.BadRequestError If more than 5 welcome channels are provided or if a custom emoji is included on a welcome channel in a guild that doesn't have tier 2 of above boost status or if a private channel is included as a welcome channel.\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission, are not part of the guild or the guild doesn't have access to the community welcome screen feature.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_vanity_url", "u": 29, "d": "Fetch a guild's vanity url. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the vanity url from. This can be the object or the ID of an existing guild. Returns hikari.invites.VanityURL The requested invite. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_template", "u": 29, "d": "Create a guild template. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create a template from.\nname : str The name to use for the created template. Other Parameters description : hikari.undefined.UndefinedNoneOr[builtins.str] The description to set for the template. Returns hikari.templates.Template The object of the created template. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found or you are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_guild_from_template", "u": 29, "d": "Make a guild from a template. Parameters template : typing.Union[builtins.str, hikari.templates.Template] The object or string code of the template to create a guild based on.\nname : builtins.str The new guilds name. Other Parameters icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the guild icon to set. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature. Returns hikari.guilds.RESTGuild Object of the created guild. ! note This endpoint can only be used by bots in less than 10 guilds. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if you call this as a bot that's in more than 10 guilds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_template", "u": 29, "d": "Delete a guild template. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete a template in.\ntemplate : typing.Union[str, hikari.templates.Template] Object or string code of the template to delete. Returns hikari.templates.Template The deleted template's object. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found or you are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_template", "u": 29, "d": "Modify a guild template. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit a template in.\ntemplate : typing.Union[builtins.str, hikari.templates.Template] Object or string code of the template to modify. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] The name to set for this template.\ndescription : hikari.undefined.UndefinedNoneOr[builtins.str] The description to set for the template. Returns hikari.templates.Template The object of the edited template. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found or you are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_template", "u": 29, "d": "Fetch a guild template. Parameters template : typing.Union[builtins.str, hikari.templates.Template] The object or string code of the template to fetch. Returns hikari.templates.Template The object of the found template. Raises hikari.errors.NotFoundError If the template was not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_guild_templates", "u": 29, "d": "Fetch the templates for a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The object or ID of the guild to get the templates for. Returns typing.Sequence[hikari.templates.Template] A sequence of the found template objects. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found or are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.sync_guild_template", "u": 29, "d": "Create a guild template. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to sync a template in.\ntemplate : typing.Union[builtins.str, hikari.templates.Template] Object or code of the template to sync. Returns hikari.templates.Template The object of the synced template. Raises hikari.errors.ForbiddenError If you are not part of the guild or are missing the MANAGE_GUILD permission.\nhikari.errors.NotFoundError If the guild or template is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.command_builder", "u": 29, "d": "Create a command builder for use in RESTClient.set_application_commands . Parameters name : builtins.str The command's name. This should match the regex ^[a-z0-9_-]{1,32}$ .\ndescription : builtins.str The description to set for the command. This should be inclusively between 1-100 characters in length. Returns hikari.api.special_endpoints.CommandBuilder The created command builder object.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_application_command", "u": 29, "d": "Fetch a command set for an application. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to fetch a command for.\ncommand: hikari.snowflakes.SnowflakeishOr[hikari.commands.Command] Object or ID of the command to fetch. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to fetch the command for. If left as hikari.undefined.UNDEFINED then this will return a global command, otherwise this will return a command made for the specified guild. Returns hikari.commands.Command Object of the fetched command. Raises hikari.errors.ForbiddenError If you cannot access the target command.\nhikari.errors.NotFoundError If the command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_application_commands", "u": 29, "d": "Fetch the commands set for an application. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to fetch the commands for. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to fetch the commands for. If left as hikari.undefined.UNDEFINED then this will only return the global commands, otherwise this will only return the commands set exclusively for the specific guild. Returns typing.Sequence[hikari.commands.Command] A sequence of the commands declared for the provided application. This will exclusively either contain the commands set for a specific guild if guild is provided or the global commands if not. Raises hikari.errors.ForbiddenError If you cannot access the target guild.\nhikari.errors.NotFoundError If the provided application isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_application_command", "u": 29, "d": "Create an application command. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to create a command for.\nname : builtins.str The command's name. This should match the regex ^[a-z0-9_-]{1,32}$ .\ndescription : builtins.str The description to set for the command. This should be inclusively between 1-100 characters in length. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the specific guild this should be made for. If left as hikari.undefined.UNDEFINED then this call will create a global command rather than a guild specific one.\noptions : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption A sequence of up to 10 options for this command.\ndefault_permission : hikari.undefined.UndefinedOr[builtins.bool] Whether this command should be enabled by default (without any permissions) when added to a guild. Defaults to builtins.True . Returns hikari.commands.Command Object of the created command. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands.\nhikari.errors.NotFoundError If the provided application isn't found.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.set_application_commands", "u": 29, "d": "Set the commands for an application. ! warning Any existing commands not included in the provided commands array will be deleted. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to create a command for.\ncommands: typing.Sequence[hikari.api.special_endpoints.CommandBuilder] A sequence of up to 100 initialised command builder objects of the commands to set for this the application. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the specific guild to set the commands for. If left as hikari.undefined.UNDEFINED then this set the global commands rather than guild specific commands. Returns typing.Sequence[hikari.commands.Command] A sequence of the set command objects. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands.\nhikari.errors.NotFoundError If the provided application isn't found.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_application_command", "u": 29, "d": "Edit a registered application command. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to edit a command for.\ncommand : hikari.snowflakes.SnowflakeishOr[hikari.commands.Command] Object or ID of the command to modify. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to edit a command for if this is a guild specific command. Leave this as hikari.undefined.UNDEFINED to delete a global command.\nname : hikari.undefined.UndefinedOr[builtins.str] The name to set for the command. Leave as hikari.undefined.UNDEFINED to not change.\ndescription : hikari.undefined.UndefinedOr[builtins.str] The description to set for the command. Leave as hikari.undefined.UNDEFINED to not change.\noptions : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption A sequence of up to 10 options to set for this command. Leave this as hikari.undefined.UNDEFINED to not change. Returns hikari.commands.Command The edited command object. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_application_command", "u": 29, "d": "Delete a registered application command. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to delete a command for.\ncommand : hikari.snowflakes.SnowflakeishOr[hikari.commands.Command] Object or ID of the command to delete. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to delete a command for if this is a guild specific command. Leave this as hikari.undefined.UNDEFINED to delete a global command. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_application_guild_commands_permissions", "u": 29, "d": "Fetch the command permissions registered in a guild. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to fetch the command permissions for.\nguild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to fetch the command permissions for. Returns typing.Sequence[hikari.commands.GuildCommandPermissions] Sequence of the guild command permissions set for the specified guild. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands or guild.\nhikari.errors.NotFoundError If the provided application isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_application_command_permissions", "u": 29, "d": "Fetch the permissions registered for a specific command in a guild. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to fetch the command permissions for.\nguild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to fetch the command permissions for.\ncommand: hikari.snowflakes.SnowflakeishOr[hikari.commands.Command] Objecr or ID of the command to fetch the command permissions for. Returns hikari.commands.GuildCommandPermissions Object of the command permissions set for the specified command. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands or guild.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.set_application_guild_commands_permissions", "u": 29, "d": "Set permissions in a guild for multiple commands. ! note This overwrites any previously set permissions for the specified commands. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to set the command permissions for.\nguild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to set the command permissions for.\npermissions : typing.Mapping[hikari.snowflakes.SnowflakeishOr[hikari.commands.Command], typing.Sequence[hikari.commands.CommandPermission Mapping of objects and/or IDs of commands to sequences of the commands to set for the specified guild. ! warning Only a maximum of up to 10 permissions can be set per command. Returns typing.Sequence[hikari.commands.GuildCommandPermissions] Sequence of the set guild command permissions. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands or guild.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.set_application_command_permissions", "u": 29, "d": "Set permissions for a specific command. ! note This overwrites any previously set permissions. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to set the command permissions for.\nguild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to set the command permissions for.\ncommand : hikari.snowflakes.SnowflakeishOr[hikari.commands.Command] Object or ID of the command to set the permissions for.\npermissions : typing.Sequence[hikari.commands.CommandPermission] Sequence of up to 10 of the permission objects to set. Returns hikari.commands.GuildCommandPermissions Object of the set permissions. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands or guild.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.interaction_deferred_builder", "u": 29, "d": "Create a builder for a deferred message interaction response. Parameters type: typing.Union[hikari.interactions.base_interactions.ResponseType, builtins.int] The type of deferred message response this builder is for. Returns hikari.api.special_endpoints.InteractionDeferredBuilder The deferred message interaction response builder object.", "f": 1}, {"r": "hikari.api.rest.RESTClient.interaction_message_builder", "u": 29, "d": "Create a builder for a message interaction response. Parameters type : typing.Union[hikari.interactions.base_interactions.ResponseType, builtins.int] The type of message response this builder is for. Returns hikari.api.special_endpoints.InteractionMessageBuilder The interaction message response builder object.", "f": 1}, {"r": "hikari.api.rest.RESTClient.fetch_interaction_response", "u": 29, "d": "Fetch the initial response for an interaction. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to fetch a command for.\ntoken: builtins.str Token of the interaction to get the initial response for. Returns hikari.messages.Message Message object of the initial response. Raises hikari.errors.ForbiddenError If you cannot access the target interaction.\nhikari.errors.NotFoundError If the initial response isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.create_interaction_response", "u": 29, "d": "Create the initial response for a interaction. ! warning Calling this with an interaction which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request. Parameters interaction : hikari.snowflakes.SnowflakeishOr[hikari.interactions.base_interactions.PartialInteraction] Object or ID of the interaction this response is for.\ntoken : builtins.str The command interaction's token.\nresponse_type : typing.Union[builtins.int, hikari.interactions.base_interactions.ResponseType] The type of interaction response this is. Other Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor no embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nflags : typing.Union[builtins.int, hikari.messages.MessageFlag, hikari.undefined.UndefinedType] If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL .\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits invalid image URLs in embeds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction is not found or if the interaction's initial response has already been created.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.edit_interaction_response", "u": 29, "d": "Edit the initial response to a command interaction. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to edit a command response for.\ntoken : builtins.str The interaction's token. Other Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message content to update with. If hikari.undefined.UNDEFINED , then the content will not be changed. If builtins.None , then the content will be removed. Any other value will be cast to a builtins.str before sending. If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify one of mentions_everyone , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If both attachment and attachments , component and components or embed and embeds are specified.\nbuiltins.TypeError If attachments , components or embeds is passed but is not a sequence.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.delete_interaction_response", "u": 29, "d": "Delete the initial response of an interaction. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to delete a command response for.\ntoken : builtins.str The interaction's token. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction or response is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.api.rest.RESTClient.build_action_row", "u": 29, "d": "Build an action row message component for use in message create and REST calls. Returns hikari.api.special_endpoints.ActionRowBuilder The initialised action row builder.", "f": 1}, {"r": "hikari.api.rest.RESTClient.http_settings", "u": 29, "d": "Return the HTTP settings in use by this component. Returns hikari.config.HTTPSettings The HTTP settings in use."}, {"r": "hikari.api.rest.RESTClient.proxy_settings", "u": 29, "d": "Return the proxy settings in use by this component. Returns hikari.config.ProxySettings The proxy settings in use."}, {"r": "hikari.api.rest.TokenStrategy", "u": 29, "d": "Interface of an object used for managing OAuth2 access."}, {"r": "hikari.api.rest.TokenStrategy.token_type", "u": 29, "d": "Type of token this strategy returns. Returns typing.Union[hikari.applications.TokenType, builtins.str] The type of token this strategy returns."}, {"r": "hikari.api.rest.TokenStrategy.acquire", "u": 29, "d": "Acquire an authorization token (including the prefix). Returns builtins.str The current authorization token to use for this client and it's prefix.", "f": 1}, {"r": "hikari.api.rest.TokenStrategy.invalidate", "u": 29, "d": "Invalidate the cached token in this handler. ! note token may be provided in-order to avoid newly generated tokens from being invalidated due to multiple calls being made by separate subroutines which are handling the same token. Parameters token : typing.Optional[builtins.str] The token to specifically invalidate. If provided then this will only invalidate the cached token if it matches this, otherwise it'll be invalidated regardless.", "f": 1}, {"r": "hikari.api.interaction_server", "u": 30, "d": "Provides an interface for Interaction REST server API implementations to follow."}, {"r": "hikari.api.interaction_server.ListenerT", "u": 30, "d": "Type hint of a Interaction server's listener callback. This should be an async callback which takes in one positional argument which\nsubclases hikari.interactions.base_interactions.PartialInteraction and may return an\ninstance of the relevant hikari.api.special_endpoints.InteractionResponseBuilder subclass for the provided interaction type which will instruct the server on how\nto respond. ! note For the standard implementations of hikari.api.special_endpoints.InteractionResponseBuilder see hikari.impl.special_endpoints ."}, {"r": "hikari.api.interaction_server.Response", "u": 30, "d": "Protocol of the data returned by InteractionServer.on_interaction . This is used to instruct lower-level REST server logic on how it should\nrespond."}, {"r": "hikari.api.interaction_server.Response.headers", "u": 30, "d": "Headers that should be added to the response if applicable. Returns typing.Optional[typing.Mapping[builtins.str, builtins.str A mapping of string header names to string header values that should be included in the response if applicable else builtins.None ."}, {"r": "hikari.api.interaction_server.Response.payload", "u": 30, "d": "Payload to provide in the response. ! note If this is not builtins.None then an appropriate \"Content-Type\" header should be declared in Response.headers Returns typing.Optional[builtins.bytes] The bytes payload to respond with if applicable else builtins.None ."}, {"r": "hikari.api.interaction_server.Response.status_code", "u": 30, "d": "Status code that should be used to respond. Returns builtins.int The response code to use for the response. This should be a valid HTTP status code, for more information see https: developer.mozilla.org/en-US/docs/Web/HTTP/Status."}, {"r": "hikari.api.interaction_server.InteractionServer", "u": 30, "d": "Interface for an implementation of a Interactions compatible REST server."}, {"r": "hikari.api.interaction_server.InteractionServer.on_interaction", "u": 30, "d": "Handle an interaction received from Discord as a REST server. Parameters body : builtins.bytes The interaction payload.\nsignature : builtins.bytes Value of the \"X-Signature-Ed25519\" header used to verify the body.\ntimestamp : builtins.bytes Value of the \"X-Signature-Timestamp\" header used to verify the body. Returns Response Instructions on how the REST server calling this should respond to the interaction request.", "f": 1}, {"r": "hikari.api.interaction_server.InteractionServer.get_listener", "u": 30, "d": "Get the listener registered for an interaction. Parameters interaction_type : typing.Type[hikari.interactions.base_interactions.PartialInteraction] Type of the interaction to get the registered listener for. Returns typing.Optional[ListenersT[hikari.interactions.base_interactions.PartialInteraction, hikari.api.special_endpoints.InteractionResponseBuilder] The callback registered for the provided interaction type if found, else builtins.None .", "f": 1}, {"r": "hikari.api.interaction_server.InteractionServer.set_listener", "u": 30, "d": "Set the listener callback for this interaction server. Parameters interaction_type : typing.Type[hikari.interactions.base_interactions.PartialInteraction] The type of interaction this listener should be registered for.\nlistener : typing.Optional[ListenerT[hikari.interactions.base_interactions.PartialInteraction, hikari.api.special_endpoints.InteractionResponseBuilder The asynchronous listener callback to set or builtins.None to unset the previous listener. Other Parameters replace : builtins.bool Whether this call should replace the previously set listener or not. This call will raise a builtins.ValueError if set to builtins.False when a listener is already set. Raises builtins.TypeError If replace is builtins.False when a listener is already set.", "f": 1}, {"r": "hikari.api.shard", "u": 31, "d": "Provides an interface for gateway shard implementations to conform to."}, {"r": "hikari.api.shard.GatewayDataFormat", "u": 31, "d": "Format of inbound gateway payloads."}, {"r": "hikari.api.shard.GatewayDataFormat.name", "u": 31, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.api.shard.GatewayDataFormat.value", "u": 31, "d": "Return the value of the enum member."}, {"r": "hikari.api.shard.GatewayDataFormat.JSON", "u": 31, "d": "Javascript serialized object notation."}, {"r": "hikari.api.shard.GatewayDataFormat.ETF", "u": 31, "d": "Erlang transmission format."}, {"r": "hikari.api.shard.GatewayCompression", "u": 31, "d": "Types of gateway compression that may be supported."}, {"r": "hikari.api.shard.GatewayCompression.name", "u": 31, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.api.shard.GatewayCompression.value", "u": 31, "d": "Return the value of the enum member."}, {"r": "hikari.api.shard.GatewayCompression.TRANSPORT_ZLIB_STREAM", "u": 31, "d": "Transport compression using ZLIB."}, {"r": "hikari.api.shard.GatewayCompression.PAYLOAD_ZLIB_STREAM", "u": 31, "d": "Payload compression using ZLIB."}, {"r": "hikari.api.shard.GatewayShard", "u": 31, "d": "Interface for a definition of a V8 compatible websocket gateway. Each instance should represent a single shard."}, {"r": "hikari.api.shard.GatewayShard.heartbeat_latency", "u": 31, "d": "Return the shard's most recent heartbeat latency. Returns builtins.float Heartbeat latency measured in seconds. If the information is not yet available, then this will be float('nan') instead."}, {"r": "hikari.api.shard.GatewayShard.id", "u": 31, "d": "Return the shard ID for this shard. Returns builtins.int The integer 0-based shard ID."}, {"r": "hikari.api.shard.GatewayShard.intents", "u": 31, "d": "Return the intents set on this shard. Returns hikari.intents.Intents The intents being used on this shard."}, {"r": "hikari.api.shard.GatewayShard.is_alive", "u": 31, "d": "Return builtins.True if the shard is alive and connected. Returns builtins.bool builtins.True if connected, or builtins.False if not."}, {"r": "hikari.api.shard.GatewayShard.shard_count", "u": 31, "d": "Return the total number of shards expected in the entire application. Returns builtins.int A number of shards greater than or equal to 1."}, {"r": "hikari.api.shard.GatewayShard.get_user_id", "u": 31, "d": "Return the user ID. If the shard has not connected fully yet, this should wait until the ID\nis set before returning. Returns hikari.snowflakes.Snowflake The user ID for the application user.", "f": 1}, {"r": "hikari.api.shard.GatewayShard.close", "u": 31, "d": "Close the websocket if it is connected, otherwise do nothing.", "f": 1}, {"r": "hikari.api.shard.GatewayShard.join", "u": 31, "d": "Wait indefinitely until the websocket closes permanently. This can be placed in a task and cancelled without affecting the\nwebsocket runtime itself.", "f": 1}, {"r": "hikari.api.shard.GatewayShard.start", "u": 31, "d": "Start the shard, wait for it to become ready.", "f": 1}, {"r": "hikari.api.shard.GatewayShard.update_presence", "u": 31, "d": "Update the presence of the shard user. If the shard is not alive, no physical data will be sent, however,\nthe new presence settings will be remembered for when the shard\ndoes connect. Other Parameters idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed.\nafk : hikari.undefined.UndefinedOr[builtins.bool] If builtins.True , the user is marked as AFK. If builtins.False , the user is marked as being active. If undefined, this will not be changed.\nactivity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed.\nstatus : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed.", "f": 1}, {"r": "hikari.api.shard.GatewayShard.update_voice_state", "u": 31, "d": "Update the voice state for this shard in a given guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild or guild ID to update the voice state for.\nchannel : typing.Optional[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel The channel or channel ID to update the voice state for. If builtins.None then the bot will leave the voice channel that it is in for the given guild.\nself_mute : builtins.bool If specified and builtins.True , the bot will mute itself in that voice channel. If builtins.False , then it will unmute itself.\nself_deaf : builtins.bool If specified and builtins.True , the bot will deafen itself in that voice channel. If builtins.False , then it will undeafen itself.", "f": 1}, {"r": "hikari.api.shard.GatewayShard.request_guild_members", "u": 31, "d": "Request for a guild chunk. Parameters guild: hikari.guilds.Guild The guild to request chunk for. Other Parameters include_presences: hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences.\nquery: builtins.str If not   , request the members which username starts with the string.\nlimit: builtins.int Maximum number of members to send matching the query.\nusers: hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.users.User If provided, the users to request for.\nnonce: hikari.undefined.UndefinedOr[builtins.str] If provided, the nonce to be sent with guild chunks. ! note To request the full list of members, set query to   (empty string) and limit to 0 . Raises ValueError When trying to specify users with query / limit , if limit is not between 0 and 100, both inclusive or if users length is over 100.\nhikari.errors.MissingIntentError When trying to request presences without the GUILD_MEMBERS or when trying to request the full list of members without GUILD_PRESENCES .", "f": 1}, {"r": "hikari.api.event_factory", "u": 32, "d": "Component that provides the ability to generate event models."}, {"r": "hikari.api.event_factory.EventFactory", "u": 32, "d": "Interface for components that deserialize JSON events."}, {"r": "hikari.api.event_factory.EventFactory.deserialize_channel_create_event", "u": 32, "d": "Parse a raw payload from Discord into a channel create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.channel_events.ChannelCreateEvent The parsed channel create event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_channel_update_event", "u": 32, "d": "Parse a raw payload from Discord into a channel update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_channel : typing.Optional[hikari.channels.GuildChannel] The guild channel object or builtins.None . Returns hikari.events.channel_events.ChannelUpdateEvent The parsed event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_channel_delete_event", "u": 32, "d": "Parse a raw payload from Discord into a channel delete event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.channel_events.ChannelDeleteEvent The parsed channel delete event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_channel_pins_update_event", "u": 32, "d": "Parse a raw payload from Discord into a channel pins update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.channel_events.PinsUpdateEvent The parsed channel pins update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_webhook_update_event", "u": 32, "d": "Parse a raw payload from Discord into a webhook update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.channel_events.WebhookUpdateEvent The parsed webhook update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_invite_create_event", "u": 32, "d": "Parse a raw payload from Discord into an invite create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.channel_events.InviteCreateEvent The parsed invite create event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_invite_delete_event", "u": 32, "d": "Parse a raw payload from Discord into an invite delete event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_invite: typing.Optional[hikari.invites.InviteWithMetadata] The invite object or builtins.None . Returns hikari.events.channel_events.InviteDeleteEvent The parsed invite delete event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_typing_start_event", "u": 32, "d": "Parse a raw payload from Discord into a typing start event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.typing_events.TypingEvent The parsed typing start event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_create_event", "u": 32, "d": "Parse a raw payload from Discord into a guild create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.GuildAvailableEvent The parsed guild create event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_update_event", "u": 32, "d": "Parse a raw payload from Discord into a guild update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_guild : typing.Optional[hikari.guilds.Guild] The guild object or builtins.None . Returns hikari.events.guild_events.GuildUpdateEvent The parsed guild update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_leave_event", "u": 32, "d": "Parse a raw payload from Discord into a guild leave event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.GuildLeaveEvent The parsed guild leave event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_unavailable_event", "u": 32, "d": "Parse a raw payload from Discord into a guild unavailable event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.GuildUnavailableEvent The parsed guild unavailable event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_ban_add_event", "u": 32, "d": "Parse a raw payload from Discord into a guild ban add event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.BanCreateEvent The parsed guild ban add event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_ban_remove_event", "u": 32, "d": "Parse a raw payload from Discord into a guild ban remove event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.BanDeleteEvent The parsed guild ban remove event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_emojis_update_event", "u": 32, "d": "Parse a raw payload from Discord into a guild emojis update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_emojis : typing.Optional[typing.Sequence[hikari.emojis.KnownCustomEmoji The sequence of emojis or builtins.None . Returns hikari.events.guild_events.EmojisUpdateEvent The parsed guild emojis update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_integration_create_event", "u": 32, "d": "Parse a raw payload from Discord into an integration create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.IntegrationCreateEvent The parsed integration create event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_integration_delete_event", "u": 32, "d": "Parse a raw payload from Discord into an integration delete event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.IntegrationDeleteEvent The parsed integration delete event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_integration_update_event", "u": 32, "d": "Parse a raw payload from Discord into an integration update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.IntegrationUpdateEvent The parsed integration update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_presence_update_event", "u": 32, "d": "Parse a raw payload from Discord into a presence update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_presence: typing.Optional[hikari.presences.MemberPresence] The presence object or builtins.None . Returns hikari.events.guild_events.PresenceUpdateEvent The parsed presence update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_interaction_create_event", "u": 32, "d": "Parse a raw payload from Discord into a interaction create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.interaction_events.InteractionCreateEvent The parsed interaction create event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_member_add_event", "u": 32, "d": "Parse a raw payload from Discord into a guild member add event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.member_events.MemberCreateEvent The parsed guild member add event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_member_update_event", "u": 32, "d": "Parse a raw payload from Discord into a guild member update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_member: typing.Optional[hikari.guilds.Member] The member object or builtins.None . Returns hikari.events.member_events.MemberUpdateEvent The parsed guild member update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_member_remove_event", "u": 32, "d": "Parse a raw payload from Discord into a guild member remove event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_member: typing.Optional[hikari.guilds.Member] The member object or builtins.None . Returns hikari.events.member_events.MemberDeleteEvent The parsed guild member remove event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_role_create_event", "u": 32, "d": "Parse a raw payload from Discord into a guild role create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.role_events.RoleCreateEvent The parsed guild role create event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_role_update_event", "u": 32, "d": "Parse a raw payload from Discord into a guild role update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_role: typing.Optional[hikari.guilds.Role] The role object or builtins.None . Returns hikari.events.role_events.RoleUpdateEvent The parsed guild role update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_role_delete_event", "u": 32, "d": "Parse a raw payload from Discord into a guild role delete event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_role: typing.Optional[hikari.guilds.Role] The role object or builtins.None . Returns hikari.events.role_events.RoleDeleteEvent The parsed guild role delete event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_starting_event", "u": 32, "d": "Build a starting event object. Returns hikari.events.lifetime_events.StartingEvent The built starting event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_started_event", "u": 32, "d": "Build a started event object. Returns hikari.events.lifetime_events.StartingEvent The built started event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_stopping_event", "u": 32, "d": "Build a starting event object. Returns hikari.events.lifetime_events.StartingEvent The built starting event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_stopped_event", "u": 32, "d": "Build a stopped event object. Returns hikari.events.lifetime_events.StartingEvent The built starting event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_message_create_event", "u": 32, "d": "Parse a raw payload from Discord into a message create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.message_events.MessageCreateEvent The parsed message create event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_message_update_event", "u": 32, "d": "Parse a raw payload from Discord into a message update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_message: typing.Optional[hikari.messages.PartialMessage] The message object or builtins.None . Returns hikari.events.message_events.MessageUpdateEvent The parsed message update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_message_delete_event", "u": 32, "d": "Parse a raw payload from Discord into a message delete event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.message_events.MessageDeleteEvent The parsed message delete event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_message_delete_bulk_event", "u": 32, "d": "Parse a raw payload from Discord into a message delete bulk event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.message_events.MessageDeleteEvent The parsed message delete bulk event object. Raises builtins.NotImplementedError If a bulk delete occurs in a DM channel.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_message_reaction_add_event", "u": 32, "d": "Parse a raw payload from Discord into a message reaction add event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.reaction_events.ReactionAddEvent The parsed message reaction add event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_message_reaction_remove_event", "u": 32, "d": "Parse a raw payload from Discord into a message reaction remove event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.reaction_events.ReactionDeleteEvent The parsed message reaction remove event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_message_reaction_remove_all_event", "u": 32, "d": "Parse a raw payload from Discord into a message reaction remove all event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.reaction_events.ReactionDeleteAllEvent The parsed message reaction remove all event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_message_reaction_remove_emoji_event", "u": 32, "d": "Parse a raw payload from Discord into a message reaction remove emoji event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.reaction_events.ReactionDeleteEmojiEvent The parsed message reaction remove emoji event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_shard_payload_event", "u": 32, "d": "Parse a raw payload from Discord into a shard payload event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nname : builtins.str Name of the event. Returns hikari.events.shard_events.ShardPayloadEvent The parsed shard payload event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_ready_event", "u": 32, "d": "Parse a raw payload from Discord into a ready event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.shard_events.ShardReadyEvent The parsed ready event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_connected_event", "u": 32, "d": "Build a shard connected event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event. Returns hikari.events.shard_events.ShardReadyEvent The built shard connected event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_disconnected_event", "u": 32, "d": "Build a shard disconnected event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event. Returns hikari.events.shard_events.ShardReadyEvent The built shard disconnected event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_resumed_event", "u": 32, "d": "Build a shard resumed event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event. Returns hikari.events.shard_events.ShardReadyEvent The built shard resumed event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_guild_member_chunk_event", "u": 32, "d": "Parse a raw payload from Discord into a member chunk event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.shard_events.MemberChunkEvent The parsed member chunk object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_own_user_update_event", "u": 32, "d": "Parse a raw payload from Discord into a own user update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_user: typing.Optional[hikari.users.OwnUser] The OwnUser object or builtins.None . Returns hikari.events.user_events.OwnUserUpdateEvent The parsed own user update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_voice_state_update_event", "u": 32, "d": "Parse a raw payload from Discord into a voice state update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_state: typing.Optional[hikari.voices.VoiceState] The VoiceState object or builtins.None . Returns hikari.events.voice_events.VoiceStateUpdateEvent The parsed voice state update event object.", "f": 1}, {"r": "hikari.api.event_factory.EventFactory.deserialize_voice_server_update_event", "u": 32, "d": "Parse a raw payload from Discord into a voice server update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.voice_events.VoiceServerUpdateEvent The parsed voice server update event object.", "f": 1}, {"r": "hikari.channels", "u": 33, "d": "Application and entities that are used to describe both DMs and guild channels on Discord."}, {"r": "hikari.channels.ChannelType", "u": 33, "d": "The known channel types that are exposed to us by the API."}, {"r": "hikari.channels.ChannelType.name", "u": 33, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.channels.ChannelType.value", "u": 33, "d": "Return the value of the enum member."}, {"r": "hikari.channels.ChannelType.GUILD_TEXT", "u": 33, "d": "A text channel in a guild."}, {"r": "hikari.channels.ChannelType.DM", "u": 33, "d": "A direct channel between two users."}, {"r": "hikari.channels.ChannelType.GUILD_VOICE", "u": 33, "d": "A voice channel in a guild."}, {"r": "hikari.channels.ChannelType.GROUP_DM", "u": 33, "d": "A direct channel between multiple users."}, {"r": "hikari.channels.ChannelType.GUILD_CATEGORY", "u": 33, "d": "An category used for organizing channels in a guild."}, {"r": "hikari.channels.ChannelType.GUILD_NEWS", "u": 33, "d": "A channel that can be followed and can crosspost."}, {"r": "hikari.channels.ChannelType.GUILD_STORE", "u": 33, "d": "A channel that show's a game's store page."}, {"r": "hikari.channels.ChannelType.GUILD_STAGE", "u": 33, "d": "A few to many voice channel for hosting events."}, {"r": "hikari.channels.VideoQualityMode", "u": 33, "d": "The camera quality of the voice chat."}, {"r": "hikari.channels.VideoQualityMode.name", "u": 33, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.channels.VideoQualityMode.value", "u": 33, "d": "Return the value of the enum member."}, {"r": "hikari.channels.VideoQualityMode.AUTO", "u": 33, "d": "Video quality will be set for optimal performance."}, {"r": "hikari.channels.VideoQualityMode.FULL", "u": 33, "d": "Video quality will be set to 720p."}, {"r": "hikari.channels.ChannelFollow", "u": 33, "d": "Relationship between a news channel and a subscriber channel. The subscriber channel will receive crosspost messages that correspond\nto any \"broadcast\" announcements that the news channel creates. Method generated by attrs for class ChannelFollow."}, {"r": "hikari.channels.ChannelFollow.fetch_channel", "u": 33, "d": "Fetch the object of the guild channel being followed. Returns typing.Union[hikari.channels.GuildNewsChannel, hikari.channels.GuildTextChannel] The channel being followed. While this will usually be GuildNewsChannel , if the channel's news status has been removed then this will be a GuildTextChannel Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.ChannelFollow.fetch_webhook", "u": 33, "d": "Fetch the webhook attached to this follow. Returns hikari.webhooks.ChannelFollowerWebhook The webhook attached to this follow. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission in the guild or channel this follow is targeting.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.ChannelFollow.get_channel", "u": 33, "d": "Get the channel being followed from the cache. ! warning This will always be builtins.None if you are not in the guild that this channel exists in. Returns typing.Union[hikari.channels.GuildNewsChannel, hikari.channels.GuildTextChannel, builtins.None] The object of the guild channel that was found in the cache or builtins.None . While this will usually be GuildNewsChannel or builtins.None , if the channel referenced has since lost it's news status then this will return a GuildTextChannel .", "f": 1}, {"r": "hikari.channels.ChannelFollow.app", "u": 33, "d": "Return the client application that models may use for procedures. Returns hikari.traits.RESTAware The REST-aware application object."}, {"r": "hikari.channels.ChannelFollow.channel_id", "u": 33, "d": "Return the channel ID of the channel being followed. Returns hikari.snowflakes.Snowflake The channel ID for the channel being followed."}, {"r": "hikari.channels.ChannelFollow.webhook_id", "u": 33, "d": "Return the ID of the webhook for this follow. Returns hikari.snowflakes.Snowflake The ID of the webhook that was created for this follow."}, {"r": "hikari.channels.PermissionOverwrite", "u": 33, "d": "Represents permission overwrites for a channel or role in a channel. You may sometimes need to make instances of this object to add/edit\npermission overwrites on channels. Example Creating a permission overwrite. py\noverwrite = PermissionOverwrite( type=PermissionOverwriteType.MEMBER, allow=( Permissions.VIEW_CHANNEL | Permissions.READ_MESSAGE_HISTORY | Permissions.SEND_MESSAGES ), deny=( Permissions.MANAGE_MESSAGES | Permissions.SPEAK ),\n) Method generated by attrs for class PermissionOverwrite."}, {"r": "hikari.channels.PermissionOverwrite.unset", "u": 33, "d": "Bitfield of all permissions not explicitly allowed or denied by this overwrite."}, {"r": "hikari.channels.PermissionOverwrite.allow", "u": 33, "d": "The permissions this overwrite allows."}, {"r": "hikari.channels.PermissionOverwrite.deny", "u": 33, "d": "The permissions this overwrite denies."}, {"r": "hikari.channels.PermissionOverwrite.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.PermissionOverwrite.type", "u": 33, "d": "The type of entity this overwrite targets."}, {"r": "hikari.channels.PermissionOverwrite.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.PermissionOverwriteType", "u": 33, "d": "The type of entity a Permission Overwrite targets."}, {"r": "hikari.channels.PermissionOverwriteType.name", "u": 33, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.channels.PermissionOverwriteType.value", "u": 33, "d": "Return the value of the enum member."}, {"r": "hikari.channels.PermissionOverwriteType.ROLE", "u": 33, "d": "A permission overwrite that targets all the members with a specific role."}, {"r": "hikari.channels.PermissionOverwriteType.MEMBER", "u": 33, "d": "A permission overwrite that targets a specific guild member."}, {"r": "hikari.channels.PartialChannel", "u": 33, "d": "Channel representation for cases where further detail is not provided. This is commonly received in HTTP API responses where full information is\nnot available from Discord. Method generated by attrs for class PartialChannel."}, {"r": "hikari.channels.PartialChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.PartialChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.PartialChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.PartialChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.PartialChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.PartialChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.TextableChannel", "u": 33, "d": "Mixin class for a channel which can have text messages in it. Method generated by attrs for class PartialChannel."}, {"r": "hikari.channels.TextableChannel.fetch_history", "u": 33, "d": "Browse the message history for a given text channel. Other Parameters before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\nafter : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\naround : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises builtins.TypeError If you specify more than one of before , after , about .\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to read message history in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint (other than builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than builtins.TypeError ).", "f": 1}, {"r": "hikari.channels.TextableChannel.fetch_message", "u": 33, "d": "Fetch a specific message in the given text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel.\nhikari.errors.NotFoundError If the channel is not found or the message is not found in the given text channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableChannel.send", "u": 33, "d": "Create a message in this channel. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech).\nnonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to send messages in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.\nbuiltins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.channels.TextableChannel.trigger_typing", "u": 33, "d": "Trigger typing in a given channel. This returns an object that can either be await ed to trigger typing\nonce, or used as an async context manager to keep typing until the\nblock completes. py\nawait channel.trigger_typing() type for 10s async with channel.trigger_typing(): await asyncio.sleep(35) keep typing until this finishes  ! note Sending a message to this channel will stop the typing indicator. If using an async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns hikari.api.special_endpoints.TypingIndicator The typing indicator object.", "f": 1}, {"r": "hikari.channels.TextableChannel.fetch_pins", "u": 33, "d": "Fetch the pinned messages in this text channel. Returns typing.Sequence[hikari.messages.Message] The pinned messages in this text channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableChannel.pin_message", "u": 33, "d": "Pin an existing message in the text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to pin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found, or if the message does not exist in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableChannel.unpin_message", "u": 33, "d": "Unpin a given message from the text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to unpin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.NotFoundError If the channel is not found or the message is not a pinned message in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableChannel.delete_messages", "u": 33, "d": "Bulk-delete messages from the channel. Parameters messages : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], hikari.snowflakes.SnowflakeishIterable[hikari.messages.PartialMessage Either the object/ID of an existing message to delete or an iterable of the objects and/or IDs of existing messages to delete. Other Parameters  other_messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The objects and/or IDs of other existing messages to delete. ! note This API endpoint will only be able to delete 100 messages at a time. For anything more than this, multiple requests will be executed one-after-the-other, since the rate limits for this endpoint do not favour more than one request per bucket. If one message is left over from chunking per 100 messages, or only one message is passed to this coroutine function, then the logic is expected to defer to delete_message . The implication of this is that the delete_message endpoint is ratelimited by a different bucket with different usage rates. ! warning This endpoint is not atomic. If an error occurs midway through a bulk delete, you will not be able to revert any changes made up to this point. ! warning Specifying any messages more than 14 days old will cause the call to fail, potentially with partial completion. Raises hikari.errors.BulkDeleteError An error containing the messages successfully deleted, and the messages that were not removed. The builtins.BaseException.__cause__ of the exception will be the original error that terminated this process.", "f": 1}, {"r": "hikari.channels.TextableChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.TextableChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.TextableChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.TextableChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.TextableChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.TextableChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.TextableGuildChannel", "u": 33, "d": "Mixin class for any guild channel which can have text messages in it. Method generated by attrs for class GuildChannel."}, {"r": "hikari.channels.TextableGuildChannel.mention", "u": 33, "d": "Return a raw mention string for the guild channel. ! note As of writing, GuildCategory channels are a special case for this and mentions of them will not resolve as clickable. Returns builtins.str The mention string to use."}, {"r": "hikari.channels.TextableGuildChannel.shard_id", "u": 33, "d": "Return the shard ID for the shard. This may be builtins.None if the shard count is not known."}, {"r": "hikari.channels.TextableGuildChannel.fetch_guild", "u": 33, "d": "Fetch the guild linked to this channel. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.edit_overwrite", "u": 33, "d": "Edit permissions for a specific entity in the given guild channel. This creates new overwrite for the channel, if there no other overwrites present. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int If provided, the type of the target to update. If unset, will attempt to get the type from target .\nallow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions.\ndeny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises builtins.TypeError If target_type is unset and we were unable to determine the type from target .\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.remove_overwrite", "u": 33, "d": "Delete a custom permission for an entity in a given guild channel. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.edit", "u": 33, "d": "Edit the text channel. Other Parameters name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel.\nposition : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel.\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to set for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel.\nparent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.PartialChannel The edited channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing permissions to edit the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.guild_id", "u": 33, "d": "The ID of the guild the channel belongs to."}, {"r": "hikari.channels.TextableGuildChannel.is_nsfw", "u": 33, "d": "Whether the channel is marked as NSFW. ! warning This will be builtins.None when received over the gateway in certain events (e.g Guild Create)."}, {"r": "hikari.channels.TextableGuildChannel.parent_id", "u": 33, "d": "The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be builtins.None ."}, {"r": "hikari.channels.TextableGuildChannel.permission_overwrites", "u": 33, "d": "The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."}, {"r": "hikari.channels.TextableGuildChannel.position", "u": 33, "d": "The sorting position of the channel. Higher numbers appear further down the channel list."}, {"r": "hikari.channels.TextableGuildChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.TextableGuildChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.TextableGuildChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.TextableGuildChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.TextableGuildChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.TextableGuildChannel.fetch_history", "u": 33, "d": "Browse the message history for a given text channel. Other Parameters before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\nafter : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\naround : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises builtins.TypeError If you specify more than one of before , after , about .\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to read message history in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint (other than builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than builtins.TypeError ).", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.fetch_message", "u": 33, "d": "Fetch a specific message in the given text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel.\nhikari.errors.NotFoundError If the channel is not found or the message is not found in the given text channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.send", "u": 33, "d": "Create a message in this channel. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech).\nnonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to send messages in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.\nbuiltins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.trigger_typing", "u": 33, "d": "Trigger typing in a given channel. This returns an object that can either be await ed to trigger typing\nonce, or used as an async context manager to keep typing until the\nblock completes. py\nawait channel.trigger_typing() type for 10s async with channel.trigger_typing(): await asyncio.sleep(35) keep typing until this finishes  ! note Sending a message to this channel will stop the typing indicator. If using an async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns hikari.api.special_endpoints.TypingIndicator The typing indicator object.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.fetch_pins", "u": 33, "d": "Fetch the pinned messages in this text channel. Returns typing.Sequence[hikari.messages.Message] The pinned messages in this text channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.pin_message", "u": 33, "d": "Pin an existing message in the text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to pin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found, or if the message does not exist in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.unpin_message", "u": 33, "d": "Unpin a given message from the text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to unpin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.NotFoundError If the channel is not found or the message is not a pinned message in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.TextableGuildChannel.delete_messages", "u": 33, "d": "Bulk-delete messages from the channel. Parameters messages : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], hikari.snowflakes.SnowflakeishIterable[hikari.messages.PartialMessage Either the object/ID of an existing message to delete or an iterable of the objects and/or IDs of existing messages to delete. Other Parameters  other_messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The objects and/or IDs of other existing messages to delete. ! note This API endpoint will only be able to delete 100 messages at a time. For anything more than this, multiple requests will be executed one-after-the-other, since the rate limits for this endpoint do not favour more than one request per bucket. If one message is left over from chunking per 100 messages, or only one message is passed to this coroutine function, then the logic is expected to defer to delete_message . The implication of this is that the delete_message endpoint is ratelimited by a different bucket with different usage rates. ! warning This endpoint is not atomic. If an error occurs midway through a bulk delete, you will not be able to revert any changes made up to this point. ! warning Specifying any messages more than 14 days old will cause the call to fail, potentially with partial completion. Raises hikari.errors.BulkDeleteError An error containing the messages successfully deleted, and the messages that were not removed. The builtins.BaseException.__cause__ of the exception will be the original error that terminated this process.", "f": 1}, {"r": "hikari.channels.PrivateChannel", "u": 33, "d": "The base for anything that is a private (non-guild bound) channel. Method generated by attrs for class PrivateChannel."}, {"r": "hikari.channels.PrivateChannel.last_message_id", "u": 33, "d": "The ID of the last message sent in this channel. ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."}, {"r": "hikari.channels.PrivateChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.PrivateChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.PrivateChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.PrivateChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.PrivateChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.PrivateChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.DMChannel", "u": 33, "d": "Represents a direct message text channel that is between you and another user. Method generated by attrs for class DMChannel."}, {"r": "hikari.channels.DMChannel.shard_id", "u": 33, "d": "Return the shard ID for the shard."}, {"r": "hikari.channels.DMChannel.recipient", "u": 33, "d": "The user recipient of this DM."}, {"r": "hikari.channels.DMChannel.last_message_id", "u": 33, "d": "The ID of the last message sent in this channel. ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."}, {"r": "hikari.channels.DMChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.DMChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.DMChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.DMChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.DMChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.DMChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.DMChannel.fetch_history", "u": 33, "d": "Browse the message history for a given text channel. Other Parameters before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\nafter : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\naround : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises builtins.TypeError If you specify more than one of before , after , about .\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to read message history in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint (other than builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than builtins.TypeError ).", "f": 1}, {"r": "hikari.channels.DMChannel.fetch_message", "u": 33, "d": "Fetch a specific message in the given text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel.\nhikari.errors.NotFoundError If the channel is not found or the message is not found in the given text channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.DMChannel.send", "u": 33, "d": "Create a message in this channel. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech).\nnonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to send messages in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.\nbuiltins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.channels.DMChannel.trigger_typing", "u": 33, "d": "Trigger typing in a given channel. This returns an object that can either be await ed to trigger typing\nonce, or used as an async context manager to keep typing until the\nblock completes. py\nawait channel.trigger_typing() type for 10s async with channel.trigger_typing(): await asyncio.sleep(35) keep typing until this finishes  ! note Sending a message to this channel will stop the typing indicator. If using an async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns hikari.api.special_endpoints.TypingIndicator The typing indicator object.", "f": 1}, {"r": "hikari.channels.DMChannel.fetch_pins", "u": 33, "d": "Fetch the pinned messages in this text channel. Returns typing.Sequence[hikari.messages.Message] The pinned messages in this text channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.DMChannel.pin_message", "u": 33, "d": "Pin an existing message in the text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to pin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found, or if the message does not exist in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.DMChannel.unpin_message", "u": 33, "d": "Unpin a given message from the text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to unpin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.NotFoundError If the channel is not found or the message is not a pinned message in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.DMChannel.delete_messages", "u": 33, "d": "Bulk-delete messages from the channel. Parameters messages : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], hikari.snowflakes.SnowflakeishIterable[hikari.messages.PartialMessage Either the object/ID of an existing message to delete or an iterable of the objects and/or IDs of existing messages to delete. Other Parameters  other_messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The objects and/or IDs of other existing messages to delete. ! note This API endpoint will only be able to delete 100 messages at a time. For anything more than this, multiple requests will be executed one-after-the-other, since the rate limits for this endpoint do not favour more than one request per bucket. If one message is left over from chunking per 100 messages, or only one message is passed to this coroutine function, then the logic is expected to defer to delete_message . The implication of this is that the delete_message endpoint is ratelimited by a different bucket with different usage rates. ! warning This endpoint is not atomic. If an error occurs midway through a bulk delete, you will not be able to revert any changes made up to this point. ! warning Specifying any messages more than 14 days old will cause the call to fail, potentially with partial completion. Raises hikari.errors.BulkDeleteError An error containing the messages successfully deleted, and the messages that were not removed. The builtins.BaseException.__cause__ of the exception will be the original error that terminated this process.", "f": 1}, {"r": "hikari.channels.GroupDMChannel", "u": 33, "d": "Represents a group direct message channel. ! note This doesn't have the methods found on TextableChannel as bots cannot interact with a group DM that they own by sending or seeing messages in it. Method generated by attrs for class GroupDMChannel."}, {"r": "hikari.channels.GroupDMChannel.icon_url", "u": 33, "d": "Icon for this group DM, if set."}, {"r": "hikari.channels.GroupDMChannel.make_icon_url", "u": 33, "d": "Generate the icon for this group, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL, or builtins.None if no icon is present. Raises builtins.ValueError If size is not a power of two between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.channels.GroupDMChannel.application_id", "u": 33, "d": "The ID of the application that created the group DM. If the group DM was not created by a bot, this will be builtins.None ."}, {"r": "hikari.channels.GroupDMChannel.icon_hash", "u": 33, "d": "The CDN hash of the icon of the group, if an icon is set."}, {"r": "hikari.channels.GroupDMChannel.nicknames", "u": 33, "d": "A mapping of set nicknames within this group DMs to user IDs."}, {"r": "hikari.channels.GroupDMChannel.owner_id", "u": 33, "d": "The ID of the owner of the group."}, {"r": "hikari.channels.GroupDMChannel.recipients", "u": 33, "d": "The recipients of the group DM."}, {"r": "hikari.channels.GroupDMChannel.last_message_id", "u": 33, "d": "The ID of the last message sent in this channel. ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."}, {"r": "hikari.channels.GroupDMChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.GroupDMChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.GroupDMChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.GroupDMChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.GroupDMChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.GroupDMChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.GuildCategory", "u": 33, "d": "Represents a guild category channel. These can contain other channels inside, and act as a method for\norganisation. Method generated by attrs for class GuildCategory."}, {"r": "hikari.channels.GuildCategory.guild_id", "u": 33, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.channels.GuildCategory.position", "u": 33, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.channels.GuildCategory.permission_overwrites", "u": 33, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.channels.GuildCategory.is_nsfw", "u": 33, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.channels.GuildCategory.parent_id", "u": 33, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.channels.GuildCategory.mention", "u": 33, "d": "Return a raw mention string for the guild channel. ! note As of writing, GuildCategory channels are a special case for this and mentions of them will not resolve as clickable. Returns builtins.str The mention string to use."}, {"r": "hikari.channels.GuildCategory.shard_id", "u": 33, "d": "Return the shard ID for the shard. This may be builtins.None if the shard count is not known."}, {"r": "hikari.channels.GuildCategory.fetch_guild", "u": 33, "d": "Fetch the guild linked to this channel. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildCategory.edit_overwrite", "u": 33, "d": "Edit permissions for a specific entity in the given guild channel. This creates new overwrite for the channel, if there no other overwrites present. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int If provided, the type of the target to update. If unset, will attempt to get the type from target .\nallow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions.\ndeny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises builtins.TypeError If target_type is unset and we were unable to determine the type from target .\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildCategory.remove_overwrite", "u": 33, "d": "Delete a custom permission for an entity in a given guild channel. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildCategory.edit", "u": 33, "d": "Edit the text channel. Other Parameters name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel.\nposition : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel.\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to set for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel.\nparent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.PartialChannel The edited channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing permissions to edit the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildCategory.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.GuildCategory.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.GuildCategory.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.GuildCategory.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.GuildCategory.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.GuildCategory.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.GuildChannel", "u": 33, "d": "The base for anything that is a guild channel. Method generated by attrs for class GuildChannel."}, {"r": "hikari.channels.GuildChannel.mention", "u": 33, "d": "Return a raw mention string for the guild channel. ! note As of writing, GuildCategory channels are a special case for this and mentions of them will not resolve as clickable. Returns builtins.str The mention string to use."}, {"r": "hikari.channels.GuildChannel.shard_id", "u": 33, "d": "Return the shard ID for the shard. This may be builtins.None if the shard count is not known."}, {"r": "hikari.channels.GuildChannel.fetch_guild", "u": 33, "d": "Fetch the guild linked to this channel. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildChannel.edit_overwrite", "u": 33, "d": "Edit permissions for a specific entity in the given guild channel. This creates new overwrite for the channel, if there no other overwrites present. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int If provided, the type of the target to update. If unset, will attempt to get the type from target .\nallow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions.\ndeny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises builtins.TypeError If target_type is unset and we were unable to determine the type from target .\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildChannel.remove_overwrite", "u": 33, "d": "Delete a custom permission for an entity in a given guild channel. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildChannel.edit", "u": 33, "d": "Edit the text channel. Other Parameters name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel.\nposition : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel.\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to set for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel.\nparent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.PartialChannel The edited channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing permissions to edit the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildChannel.guild_id", "u": 33, "d": "The ID of the guild the channel belongs to."}, {"r": "hikari.channels.GuildChannel.is_nsfw", "u": 33, "d": "Whether the channel is marked as NSFW. ! warning This will be builtins.None when received over the gateway in certain events (e.g Guild Create)."}, {"r": "hikari.channels.GuildChannel.parent_id", "u": 33, "d": "The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be builtins.None ."}, {"r": "hikari.channels.GuildChannel.permission_overwrites", "u": 33, "d": "The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."}, {"r": "hikari.channels.GuildChannel.position", "u": 33, "d": "The sorting position of the channel. Higher numbers appear further down the channel list."}, {"r": "hikari.channels.GuildChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.GuildChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.GuildChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.GuildChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.GuildChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.GuildChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.GuildTextChannel", "u": 33, "d": "Represents a guild text channel. Method generated by attrs for class GuildTextChannel."}, {"r": "hikari.channels.GuildTextChannel.last_message_id", "u": 33, "d": "The ID of the last message sent in this channel. ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."}, {"r": "hikari.channels.GuildTextChannel.last_pin_timestamp", "u": 33, "d": "The timestamp of the last-pinned message. ! note This may be builtins.None in several cases; Discord does not document what these cases are. Trust no one!"}, {"r": "hikari.channels.GuildTextChannel.rate_limit_per_user", "u": 33, "d": "The delay (in seconds) between a user can send a message to this channel. If there is no rate limit, this will be 0 seconds. ! note Any user that has permissions allowing MANAGE_MESSAGES , MANAGE_CHANNEL , ADMINISTRATOR will not be limited. Likewise, bots will not be affected by this rate limit."}, {"r": "hikari.channels.GuildTextChannel.topic", "u": 33, "d": "The topic of the channel."}, {"r": "hikari.channels.GuildTextChannel.mention", "u": 33, "d": "Return a raw mention string for the guild channel. ! note As of writing, GuildCategory channels are a special case for this and mentions of them will not resolve as clickable. Returns builtins.str The mention string to use."}, {"r": "hikari.channels.GuildTextChannel.shard_id", "u": 33, "d": "Return the shard ID for the shard. This may be builtins.None if the shard count is not known."}, {"r": "hikari.channels.GuildTextChannel.fetch_guild", "u": 33, "d": "Fetch the guild linked to this channel. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.edit_overwrite", "u": 33, "d": "Edit permissions for a specific entity in the given guild channel. This creates new overwrite for the channel, if there no other overwrites present. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int If provided, the type of the target to update. If unset, will attempt to get the type from target .\nallow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions.\ndeny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises builtins.TypeError If target_type is unset and we were unable to determine the type from target .\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.remove_overwrite", "u": 33, "d": "Delete a custom permission for an entity in a given guild channel. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.edit", "u": 33, "d": "Edit the text channel. Other Parameters name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel.\nposition : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel.\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to set for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel.\nparent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.PartialChannel The edited channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing permissions to edit the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.guild_id", "u": 33, "d": "The ID of the guild the channel belongs to."}, {"r": "hikari.channels.GuildTextChannel.is_nsfw", "u": 33, "d": "Whether the channel is marked as NSFW. ! warning This will be builtins.None when received over the gateway in certain events (e.g Guild Create)."}, {"r": "hikari.channels.GuildTextChannel.parent_id", "u": 33, "d": "The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be builtins.None ."}, {"r": "hikari.channels.GuildTextChannel.permission_overwrites", "u": 33, "d": "The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."}, {"r": "hikari.channels.GuildTextChannel.position", "u": 33, "d": "The sorting position of the channel. Higher numbers appear further down the channel list."}, {"r": "hikari.channels.GuildTextChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.GuildTextChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.GuildTextChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.GuildTextChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.GuildTextChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.GuildTextChannel.fetch_history", "u": 33, "d": "Browse the message history for a given text channel. Other Parameters before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\nafter : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\naround : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises builtins.TypeError If you specify more than one of before , after , about .\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to read message history in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint (other than builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than builtins.TypeError ).", "f": 1}, {"r": "hikari.channels.GuildTextChannel.fetch_message", "u": 33, "d": "Fetch a specific message in the given text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel.\nhikari.errors.NotFoundError If the channel is not found or the message is not found in the given text channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.send", "u": 33, "d": "Create a message in this channel. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech).\nnonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to send messages in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.\nbuiltins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.trigger_typing", "u": 33, "d": "Trigger typing in a given channel. This returns an object that can either be await ed to trigger typing\nonce, or used as an async context manager to keep typing until the\nblock completes. py\nawait channel.trigger_typing() type for 10s async with channel.trigger_typing(): await asyncio.sleep(35) keep typing until this finishes  ! note Sending a message to this channel will stop the typing indicator. If using an async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns hikari.api.special_endpoints.TypingIndicator The typing indicator object.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.fetch_pins", "u": 33, "d": "Fetch the pinned messages in this text channel. Returns typing.Sequence[hikari.messages.Message] The pinned messages in this text channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.pin_message", "u": 33, "d": "Pin an existing message in the text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to pin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found, or if the message does not exist in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.unpin_message", "u": 33, "d": "Unpin a given message from the text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to unpin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.NotFoundError If the channel is not found or the message is not a pinned message in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildTextChannel.delete_messages", "u": 33, "d": "Bulk-delete messages from the channel. Parameters messages : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], hikari.snowflakes.SnowflakeishIterable[hikari.messages.PartialMessage Either the object/ID of an existing message to delete or an iterable of the objects and/or IDs of existing messages to delete. Other Parameters  other_messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The objects and/or IDs of other existing messages to delete. ! note This API endpoint will only be able to delete 100 messages at a time. For anything more than this, multiple requests will be executed one-after-the-other, since the rate limits for this endpoint do not favour more than one request per bucket. If one message is left over from chunking per 100 messages, or only one message is passed to this coroutine function, then the logic is expected to defer to delete_message . The implication of this is that the delete_message endpoint is ratelimited by a different bucket with different usage rates. ! warning This endpoint is not atomic. If an error occurs midway through a bulk delete, you will not be able to revert any changes made up to this point. ! warning Specifying any messages more than 14 days old will cause the call to fail, potentially with partial completion. Raises hikari.errors.BulkDeleteError An error containing the messages successfully deleted, and the messages that were not removed. The builtins.BaseException.__cause__ of the exception will be the original error that terminated this process.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel", "u": 33, "d": "Represents an news channel. Method generated by attrs for class GuildNewsChannel."}, {"r": "hikari.channels.GuildNewsChannel.last_message_id", "u": 33, "d": "The ID of the last message sent in this channel. ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."}, {"r": "hikari.channels.GuildNewsChannel.last_pin_timestamp", "u": 33, "d": "The timestamp of the last-pinned message. ! note This may be builtins.None in several cases; Discord does not document what these cases are. Trust no one!"}, {"r": "hikari.channels.GuildNewsChannel.topic", "u": 33, "d": "The topic of the channel."}, {"r": "hikari.channels.GuildNewsChannel.mention", "u": 33, "d": "Return a raw mention string for the guild channel. ! note As of writing, GuildCategory channels are a special case for this and mentions of them will not resolve as clickable. Returns builtins.str The mention string to use."}, {"r": "hikari.channels.GuildNewsChannel.shard_id", "u": 33, "d": "Return the shard ID for the shard. This may be builtins.None if the shard count is not known."}, {"r": "hikari.channels.GuildNewsChannel.fetch_guild", "u": 33, "d": "Fetch the guild linked to this channel. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.edit_overwrite", "u": 33, "d": "Edit permissions for a specific entity in the given guild channel. This creates new overwrite for the channel, if there no other overwrites present. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int If provided, the type of the target to update. If unset, will attempt to get the type from target .\nallow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions.\ndeny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises builtins.TypeError If target_type is unset and we were unable to determine the type from target .\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.remove_overwrite", "u": 33, "d": "Delete a custom permission for an entity in a given guild channel. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.edit", "u": 33, "d": "Edit the text channel. Other Parameters name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel.\nposition : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel.\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to set for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel.\nparent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.PartialChannel The edited channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing permissions to edit the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.guild_id", "u": 33, "d": "The ID of the guild the channel belongs to."}, {"r": "hikari.channels.GuildNewsChannel.is_nsfw", "u": 33, "d": "Whether the channel is marked as NSFW. ! warning This will be builtins.None when received over the gateway in certain events (e.g Guild Create)."}, {"r": "hikari.channels.GuildNewsChannel.parent_id", "u": 33, "d": "The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be builtins.None ."}, {"r": "hikari.channels.GuildNewsChannel.permission_overwrites", "u": 33, "d": "The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."}, {"r": "hikari.channels.GuildNewsChannel.position", "u": 33, "d": "The sorting position of the channel. Higher numbers appear further down the channel list."}, {"r": "hikari.channels.GuildNewsChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.GuildNewsChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.GuildNewsChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.GuildNewsChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.GuildNewsChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.GuildNewsChannel.fetch_history", "u": 33, "d": "Browse the message history for a given text channel. Other Parameters before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\nafter : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\naround : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises builtins.TypeError If you specify more than one of before , after , about .\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to read message history in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint (other than builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than builtins.TypeError ).", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.fetch_message", "u": 33, "d": "Fetch a specific message in the given text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel.\nhikari.errors.NotFoundError If the channel is not found or the message is not found in the given text channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.send", "u": 33, "d": "Create a message in this channel. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech).\nnonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you lack permissions to send messages in the given channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.\nbuiltins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.trigger_typing", "u": 33, "d": "Trigger typing in a given channel. This returns an object that can either be await ed to trigger typing\nonce, or used as an async context manager to keep typing until the\nblock completes. py\nawait channel.trigger_typing() type for 10s async with channel.trigger_typing(): await asyncio.sleep(35) keep typing until this finishes  ! note Sending a message to this channel will stop the typing indicator. If using an async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns hikari.api.special_endpoints.TypingIndicator The typing indicator object.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.fetch_pins", "u": 33, "d": "Fetch the pinned messages in this text channel. Returns typing.Sequence[hikari.messages.Message] The pinned messages in this text channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.pin_message", "u": 33, "d": "Pin an existing message in the text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to pin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found, or if the message does not exist in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.unpin_message", "u": 33, "d": "Unpin a given message from the text channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to unpin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.NotFoundError If the channel is not found or the message is not a pinned message in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildNewsChannel.delete_messages", "u": 33, "d": "Bulk-delete messages from the channel. Parameters messages : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], hikari.snowflakes.SnowflakeishIterable[hikari.messages.PartialMessage Either the object/ID of an existing message to delete or an iterable of the objects and/or IDs of existing messages to delete. Other Parameters  other_messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The objects and/or IDs of other existing messages to delete. ! note This API endpoint will only be able to delete 100 messages at a time. For anything more than this, multiple requests will be executed one-after-the-other, since the rate limits for this endpoint do not favour more than one request per bucket. If one message is left over from chunking per 100 messages, or only one message is passed to this coroutine function, then the logic is expected to defer to delete_message . The implication of this is that the delete_message endpoint is ratelimited by a different bucket with different usage rates. ! warning This endpoint is not atomic. If an error occurs midway through a bulk delete, you will not be able to revert any changes made up to this point. ! warning Specifying any messages more than 14 days old will cause the call to fail, potentially with partial completion. Raises hikari.errors.BulkDeleteError An error containing the messages successfully deleted, and the messages that were not removed. The builtins.BaseException.__cause__ of the exception will be the original error that terminated this process.", "f": 1}, {"r": "hikari.channels.GuildStoreChannel", "u": 33, "d": "Represents a store channel. These were originally used to sell games when Discord had a game store. This\nwas scrapped at the end of 2019, so these may disappear from the platform\neventually. Method generated by attrs for class GuildStoreChannel."}, {"r": "hikari.channels.GuildStoreChannel.guild_id", "u": 33, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.channels.GuildStoreChannel.position", "u": 33, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.channels.GuildStoreChannel.permission_overwrites", "u": 33, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.channels.GuildStoreChannel.is_nsfw", "u": 33, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.channels.GuildStoreChannel.parent_id", "u": 33, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.channels.GuildStoreChannel.mention", "u": 33, "d": "Return a raw mention string for the guild channel. ! note As of writing, GuildCategory channels are a special case for this and mentions of them will not resolve as clickable. Returns builtins.str The mention string to use."}, {"r": "hikari.channels.GuildStoreChannel.shard_id", "u": 33, "d": "Return the shard ID for the shard. This may be builtins.None if the shard count is not known."}, {"r": "hikari.channels.GuildStoreChannel.fetch_guild", "u": 33, "d": "Fetch the guild linked to this channel. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildStoreChannel.edit_overwrite", "u": 33, "d": "Edit permissions for a specific entity in the given guild channel. This creates new overwrite for the channel, if there no other overwrites present. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int If provided, the type of the target to update. If unset, will attempt to get the type from target .\nallow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions.\ndeny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises builtins.TypeError If target_type is unset and we were unable to determine the type from target .\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildStoreChannel.remove_overwrite", "u": 33, "d": "Delete a custom permission for an entity in a given guild channel. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildStoreChannel.edit", "u": 33, "d": "Edit the text channel. Other Parameters name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel.\nposition : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel.\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to set for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel.\nparent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.PartialChannel The edited channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing permissions to edit the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildStoreChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.GuildStoreChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.GuildStoreChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.GuildStoreChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.GuildStoreChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.GuildStoreChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.GuildVoiceChannel", "u": 33, "d": "Represents a voice channel. Method generated by attrs for class GuildVoiceChannel."}, {"r": "hikari.channels.GuildVoiceChannel.bitrate", "u": 33, "d": "The bitrate for the voice channel (in bits per second)."}, {"r": "hikari.channels.GuildVoiceChannel.region", "u": 33, "d": "ID of the voice region for this voice channel. If set to builtins.None then this is set to \"auto\" mode where the used\nregion will be decided based on the first person who connects to it when\nit's empty."}, {"r": "hikari.channels.GuildVoiceChannel.user_limit", "u": 33, "d": "The user limit for the voice channel. If this is 0 , then assume no limit."}, {"r": "hikari.channels.GuildVoiceChannel.video_quality_mode", "u": 33, "d": "The video quality mode for the voice channel."}, {"r": "hikari.channels.GuildVoiceChannel.mention", "u": 33, "d": "Return a raw mention string for the guild channel. ! note As of writing, GuildCategory channels are a special case for this and mentions of them will not resolve as clickable. Returns builtins.str The mention string to use."}, {"r": "hikari.channels.GuildVoiceChannel.shard_id", "u": 33, "d": "Return the shard ID for the shard. This may be builtins.None if the shard count is not known."}, {"r": "hikari.channels.GuildVoiceChannel.fetch_guild", "u": 33, "d": "Fetch the guild linked to this channel. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildVoiceChannel.edit_overwrite", "u": 33, "d": "Edit permissions for a specific entity in the given guild channel. This creates new overwrite for the channel, if there no other overwrites present. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int If provided, the type of the target to update. If unset, will attempt to get the type from target .\nallow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions.\ndeny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises builtins.TypeError If target_type is unset and we were unable to determine the type from target .\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildVoiceChannel.remove_overwrite", "u": 33, "d": "Delete a custom permission for an entity in a given guild channel. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildVoiceChannel.edit", "u": 33, "d": "Edit the text channel. Other Parameters name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel.\nposition : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel.\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to set for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel.\nparent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.PartialChannel The edited channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing permissions to edit the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildVoiceChannel.guild_id", "u": 33, "d": "The ID of the guild the channel belongs to."}, {"r": "hikari.channels.GuildVoiceChannel.is_nsfw", "u": 33, "d": "Whether the channel is marked as NSFW. ! warning This will be builtins.None when received over the gateway in certain events (e.g Guild Create)."}, {"r": "hikari.channels.GuildVoiceChannel.parent_id", "u": 33, "d": "The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be builtins.None ."}, {"r": "hikari.channels.GuildVoiceChannel.permission_overwrites", "u": 33, "d": "The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."}, {"r": "hikari.channels.GuildVoiceChannel.position", "u": 33, "d": "The sorting position of the channel. Higher numbers appear further down the channel list."}, {"r": "hikari.channels.GuildVoiceChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.GuildVoiceChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.GuildVoiceChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.GuildVoiceChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.GuildVoiceChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.GuildVoiceChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.GuildStageChannel", "u": 33, "d": "Represents a stage channel. Method generated by attrs for class GuildStageChannel."}, {"r": "hikari.channels.GuildStageChannel.bitrate", "u": 33, "d": "The bitrate for the stage channel (in bits per second)."}, {"r": "hikari.channels.GuildStageChannel.region", "u": 33, "d": "ID of the voice region for this stage channel. If set to builtins.None then this is set to \"auto\" mode where the used\nregion will be decided based on the first person who connects to it when\nit's empty."}, {"r": "hikari.channels.GuildStageChannel.user_limit", "u": 33, "d": "The user limit for the stage channel. If this is 0 , then assume no limit."}, {"r": "hikari.channels.GuildStageChannel.mention", "u": 33, "d": "Return a raw mention string for the guild channel. ! note As of writing, GuildCategory channels are a special case for this and mentions of them will not resolve as clickable. Returns builtins.str The mention string to use."}, {"r": "hikari.channels.GuildStageChannel.shard_id", "u": 33, "d": "Return the shard ID for the shard. This may be builtins.None if the shard count is not known."}, {"r": "hikari.channels.GuildStageChannel.fetch_guild", "u": 33, "d": "Fetch the guild linked to this channel. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildStageChannel.edit_overwrite", "u": 33, "d": "Edit permissions for a specific entity in the given guild channel. This creates new overwrite for the channel, if there no other overwrites present. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int If provided, the type of the target to update. If unset, will attempt to get the type from target .\nallow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions.\ndeny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises builtins.TypeError If target_type is unset and we were unable to determine the type from target .\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildStageChannel.remove_overwrite", "u": 33, "d": "Delete a custom permission for an entity in a given guild channel. Parameters target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildStageChannel.edit", "u": 33, "d": "Edit the text channel. Other Parameters name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel.\nposition : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel.\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to set for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel.\nparent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.PartialChannel The edited channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing permissions to edit the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.channels.GuildStageChannel.guild_id", "u": 33, "d": "The ID of the guild the channel belongs to."}, {"r": "hikari.channels.GuildStageChannel.is_nsfw", "u": 33, "d": "Whether the channel is marked as NSFW. ! warning This will be builtins.None when received over the gateway in certain events (e.g Guild Create)."}, {"r": "hikari.channels.GuildStageChannel.parent_id", "u": 33, "d": "The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be builtins.None ."}, {"r": "hikari.channels.GuildStageChannel.permission_overwrites", "u": 33, "d": "The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."}, {"r": "hikari.channels.GuildStageChannel.position", "u": 33, "d": "The sorting position of the channel. Higher numbers appear further down the channel list."}, {"r": "hikari.channels.GuildStageChannel.delete", "u": 33, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.channels.GuildStageChannel.app", "u": 33, "d": "The client application that models may use for procedures."}, {"r": "hikari.channels.GuildStageChannel.id", "u": 33, "d": "The ID of this entity."}, {"r": "hikari.channels.GuildStageChannel.name", "u": 33, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.channels.GuildStageChannel.type", "u": 33, "d": "The channel's type."}, {"r": "hikari.channels.GuildStageChannel.created_at", "u": 33, "d": "When the object was created."}, {"r": "hikari.channels.WebhookChannelT", "u": 33, "d": "Union of the channel types which incoming and follower webhooks can be attached to. The following types are in this:  GuildTextChannel   GuildNewsChannel "}, {"r": "hikari.channels.WebhookChannelTypes", "u": 33, "d": "Tuple of the channel types which are valid for WebhookChannelT . This includes:  GuildTextChannel   GuildNewsChannel "}, {"r": "hikari.interactions", "u": 34, "d": "Models and enums related to Discord's interactions system."}, {"r": "hikari.interactions.component_interactions", "u": 35, "d": "Models and enums used for Discord's Components interaction flow."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction", "u": 35, "d": "Represents a component interaction on Discord. Method generated by attrs for class ComponentInteraction."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.build_response", "u": 35, "d": "Get a message response builder for use in the REST server flow. ! note For interactions received over the gateway ComponentInteraction.create_initial_response should be used to set the interaction response message. Parameters type_ : typing.Union[builtins.int, hikari.interactions.base_interactions.ResponseType] The type of immediate response this should be. This may be one of the following:  hikari.interactions.base_interactions.ResponseType.MESSAGE_CREATE   hikari.interactions.base_interactions.ResponseType.MESSAGE_UPDATE Examples  \nasync def handle_component_interaction(interaction: ComponentInteraction) -> InteractionMessageBuilder: return ( interaction .build_response(ResponseType.MESSAGE_UPDATE) .add_embed(Embed(description=\"Hi there\" .set_content(\"Konnichiwa\") ) Returns hikari.api.special_endpoints.InteractionMessageBuilder Interaction message response builder object.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.build_deferred_response", "u": 35, "d": "Get a deferred message response builder for use in the REST server flow. ! note For interactions received over the gateway ComponentInteraction.create_initial_response should be used to set the interaction response message. ! note Unlike hikari.api.special_endpoints.InteractionMessageBuilder , the result of this call can be returned as is without any modifications being made to it. Parameters type_ : typing.Union[builtins.int, hikari.interactions.base_interactions.ResponseType] The type of deferred response this should be. This may be one of the following:  hikari.interactions.base_interactions.ResponseType.DEFERRED_MESSAGE_CREATE   hikari.interactions.base_interactions.ResponseType.DEFERRED_MESSAGE_UPDATE Returns hikari.api.special_endpoints.InteractionDeferredBuilder Deferred interaction message response builder object.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.fetch_channel", "u": 35, "d": "Fetch the channel this interaction occurred in. Returns hikari.channels.TextableChannel The channel. This will be a _derivative_ of hikari.channels.TextableChannel . Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.get_channel", "u": 35, "d": "Get the guild channel this interaction occurred in. ! note This will always return builtins.None for interactions triggered in a DM channel. Returns typing.Union[hikari.channels.GuildTextChannel, hikari.channels.GuildNewsChannel, builtins.None] The object of the guild channel that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.fetch_guild", "u": 35, "d": "Fetch the guild this interaction happened in. Returns typing.Optional[hikari.guilds.RESTGuild] Object of the guild this interaction happened in or builtins.None if this occurred within a DM channel. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.get_guild", "u": 35, "d": "Get the object of this interaction's guild guild from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.fetch_parent_message", "u": 35, "d": "Fetch the message which this interaction was triggered on. Returns hikari.messages.Message The requested message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found or the webhook's message wasn't found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.get_parent_message", "u": 35, "d": "Get the message which this interaction was triggered on from the cache. Returns typing.Optional[hikari.messages.Message] The object of the message found in the cache or builtins.None .", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.channel_id", "u": 35, "d": "ID of the channel this interaction was triggered in."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.component_type", "u": 35, "d": "The type of component which triggers this interaction. ! note This will never be ButtonStyle.LINK as link buttons don't trigger interactions."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.custom_id", "u": 35, "d": "Developer defined ID of the component which triggered this interaction."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.guild_id", "u": 35, "d": "ID of the guild this interaction was triggered in. This will be builtins.None for command interactions triggered in DMs."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.member", "u": 35, "d": "The member who triggered this interaction. This will be builtins.None for interactions triggered in DMs. ! note This member object comes with the extra field permissions which contains the member's permissions in the current channel."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.message", "u": 35, "d": "Object of the message the components for this interaction are attached to."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.user", "u": 35, "d": "The user who triggered this interaction."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.values", "u": 35, "d": "Sequence of the values which were selected for a select menu component."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.fetch_initial_response", "u": 35, "d": "Fetch the initial response of this interaction. Returns hikari.messages.Message Message object of the initial response. Raises hikari.errors.ForbiddenError If you cannot access the target interaction.\nhikari.errors.NotFoundError If the initial response isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.create_initial_response", "u": 35, "d": "Create the initial response for this interaction. ! warning Calling this on an interaction which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request. Parameters response_type : typing.Union[builtins.int, CommandResponseTypesT] The type of interaction response this is. Other Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nflags : typing.Union[builtins.int, hikari.messages.MessageFlag, hikari.undefined.UndefinedType] If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL .\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction is not found or if the interaction's initial response has already been created.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.edit_initial_response", "u": 35, "d": "Edit the initial response of this command interaction. Other Parameters content : hikari.undefined.UndefinedNoneOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify one of mentions_everyone , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.delete_initial_response", "u": 35, "d": "Delete the initial response of this interaction. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction or response is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.webhook_id", "u": 35, "d": "ID used to execute this entity as a webhook. Returns hikari.snowflakes.Snowflake The ID used to execute this entity as a webhook."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.app", "u": 35, "d": "The client application that models may use for procedures."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.application_id", "u": 35, "d": "ID of the application this interaction belongs to."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.id", "u": 35, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.token", "u": 35, "d": "The interaction's token."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.type", "u": 35, "d": "The type of interaction this is."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.version", "u": 35, "d": "Version of the interaction system this interaction is under."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.created_at", "u": 35, "d": "When the object was created."}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.execute", "u": 35, "d": "Execute the webhook to create a message. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters username : hikari.undefined.UndefinedOr[builtins.str] If provided, the username to override the webhook's username for this request.\navatar_url : hikari.undefined.UndefinedOr[builtins.str] If provided, the url of an image to override the webhook's avatar with for this request.\ntts : hikari.undefined.UndefinedOr[bool] If provided, whether the message will be sent as a TTS message.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.\nflags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The flags to set for this webhook message. ! warning As of writing this can only be set for interaction webhooks and the only settable flag is EPHEMERAL; this field is just ignored for non-interaction webhooks. ! warning As of writing, username and avatar_url are ignored for interaction webhooks. Returns hikari.messages.Message The created message object. Raises hikari.errors.NotFoundError If the current webhook is not found.\nhikari.errors.BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook.\nbuiltins.ValueError If either ExecutableWebhook.token is builtins.None or more than 100 unique objects/entities are passed for role_mentions or user_mentions or if token is not available.\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.fetch_message", "u": 35, "d": "Fetch an old message sent by the webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found or the webhook's message wasn't found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.edit_message", "u": 35, "d": "Edit a message sent by a webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message.\ncontent : hikari.undefined.UndefinedNoneOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor no embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all three of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions or token is not available.\nbuiltins.TypeError If both attachment and attachments are specified or if both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.component_interactions.ComponentInteraction.delete_message", "u": 35, "d": "Delete a given message in a given channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.component_interactions.COMPONENT_RESPONSE_TYPES", "u": 35, "d": "Set of the response types which are valid for a component interaction. This includes:  hikari.interactions.base_interactions.ResponseType.MESSAGE_CREATE   hikari.interactions.base_interactions.ResponseType.DEFERRED_MESSAGE_CREATE   hikari.interactions.base_interactions.ResponseType.DEFERRED_MESSAGE_UPDATE   hikari.interactions.base_interactions.ResponseType.MESSAGE_UPDATE "}, {"r": "hikari.interactions.component_interactions.ComponentResponseTypesT", "u": 35, "d": "Type-hint of the response types which are valid for a component interaction. The following types are valid for this:  hikari.interactions.base_interactions.ResponseType.MESSAGE_CREATE / 4   hikari.interactions.base_interactions.ResponseType.DEFERRED_MESSAGE_CREATE / 5   hikari.interactions.base_interactions.ResponseType.DEFERRED_MESSAGE_UPDATE / 6   hikari.interactions.base_interactions.ResponseType.MESSAGE_UPDATE / 7 "}, {"r": "hikari.interactions.base_interactions", "u": 36, "d": "Base classes and enums inherited and used throughout the interactions flow."}, {"r": "hikari.interactions.base_interactions.DEFERRED_RESPONSE_TYPES", "u": 36, "d": "Set of the response types which are valid for deferred messages responses. This includes the following:  ResponseType.DEFERRED_MESSAGE_CREATE   ResponseType.DEFERRED_MESSAGE_UPDATE "}, {"r": "hikari.interactions.base_interactions.DeferredResponseTypesT", "u": 36, "d": "Type-hint of the response types which are valid for deferred messages responses. The following are valid for this:  ResponseType.DEFERRED_MESSAGE_CREATE / 5   ResponseType.DEFERRED_MESSAGE_UPDATE / 6 "}, {"r": "hikari.interactions.base_interactions.InteractionMember", "u": 36, "d": "Model of the member who triggered an interaction. Unlike hikari.guilds.Member , this object comes with an extra InteractionMember.permissions field. Method generated by attrs for class InteractionMember."}, {"r": "hikari.interactions.base_interactions.InteractionMember.permissions", "u": 36, "d": "Permissions the member has in the current channel."}, {"r": "hikari.interactions.base_interactions.InteractionMember.app", "u": 36, "d": "Return the app that is bound to the user object."}, {"r": "hikari.interactions.base_interactions.InteractionMember.avatar_hash", "u": 36, "d": "Avatar hash for the user, if they have one, otherwise builtins.None ."}, {"r": "hikari.interactions.base_interactions.InteractionMember.avatar_url", "u": 36, "d": "Avatar URL for the user, if they have one set. May be builtins.None if no custom avatar is set. In this case, you\nshould use default_avatar_url instead."}, {"r": "hikari.interactions.base_interactions.InteractionMember.default_avatar_url", "u": 36, "d": "Default avatar URL for this user."}, {"r": "hikari.interactions.base_interactions.InteractionMember.discriminator", "u": 36, "d": "Discriminator for the user."}, {"r": "hikari.interactions.base_interactions.InteractionMember.display_name", "u": 36, "d": "Return the member's display name. If the member has a nickname, this will return that nickname.\nOtherwise, it will return the username instead. Returns builtins.str The member display name. See Also Nickname: Member.nickname Username: Member.username "}, {"r": "hikari.interactions.base_interactions.InteractionMember.flags", "u": 36, "d": "Flag bits that are set for the user."}, {"r": "hikari.interactions.base_interactions.InteractionMember.id", "u": 36, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.interactions.base_interactions.InteractionMember.is_bot", "u": 36, "d": " builtins.True if this user is a bot account, builtins.False otherwise."}, {"r": "hikari.interactions.base_interactions.InteractionMember.is_system", "u": 36, "d": " builtins.True if this user is a system account, builtins.False otherwise."}, {"r": "hikari.interactions.base_interactions.InteractionMember.mention", "u": 36, "d": "Return a raw mention string for the given member. If the member has a known nickname, we always return\na bang (\" ! \") before the ID part of the mention string. This\nmimics the behaviour Discord clients tend to provide. Example  \n>>> some_member_without_nickname.mention\n'<@123456789123456789>'\n>>> some_member_with_nickname.mention\n'<@!123456789123456789>' Returns builtins.str The mention string to use."}, {"r": "hikari.interactions.base_interactions.InteractionMember.get_presence", "u": 36, "d": "Get the cached presence for this member, if known. Presence info includes user status and activities. This requires the GUILD_PRESENCES intent to be enabled. Returns typing.Optional[hikari.presences.MemberPresence] The member presence, or builtins.None if not known.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.get_roles", "u": 36, "d": "Return the roles the user has. This will be empty if the roles are missing from the cache. Returns typing.Sequence[hikari.guilds.Role] The roles the users has.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.get_top_role", "u": 36, "d": "Return the highest role the member has. Returns typing.Optional[hikari.guilds.Role] builtins.None if the cache is missing the roles information or the highest role the user has.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.username", "u": 36, "d": "Username for the user."}, {"r": "hikari.interactions.base_interactions.InteractionMember.make_avatar_url", "u": 36, "d": "Generate the avatar URL for this user, if set. If no custom avatar is set, this returns builtins.None . You can then\nuse the default_avatar_url attribute instead to fetch the displayed\nURL. Parameters ext : typing.Optional[builtins.str] The ext to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). Will be ignored for default avatars which can only be png . If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns typing.Optional[hikari.files.URL] The URL to the avatar, or builtins.None if not present. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.fetch_self", "u": 36, "d": "Fetch an up-to-date view of this member from the API. Returns hikari.guilds.Member An up-to-date view of this member. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the member is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.fetch_dm_channel", "u": 36, "d": "Fetch the DM channel for this user. Returns hikari.channels.DMChannel The requested channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.fetch_roles", "u": 36, "d": "Fetch an up-to-date view of this member's roles from the API. Returns typing.Sequence[hikari.guilds.Role] An up-to-date view of this member's roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the member is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.ban", "u": 36, "d": "Ban this member from this guild. Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.unban", "u": 36, "d": "Unban this member from the guild. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.kick", "u": 36, "d": "Kick this member from this guild. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.add_role", "u": 36, "d": "Add a role to the member. Parameters role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to add. This may be the object or the ID of an existing role. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild, user or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.remove_role", "u": 36, "d": "Remove a role from the member. Parameters role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to remove. This may be the object or the ID of an existing role. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild, user or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.edit", "u": 36, "d": "Edit the member. Other Parameters nick : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new nick for the member. If builtins.None , will remove the members nick. Requires the MANAGE_NICKNAMES permission.\nroles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, the new roles for the member. Requires the MANAGE_ROLES permission.\nmute : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server mute state for the member. Requires the MUTE_MEMBERS permission.\ndeaf : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server deaf state for the member. Requires the DEAFEN_MEMBERS permission.\nvoice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel ] If provided, builtins.None or the object or the ID of an existing voice channel to move the member to. If builtins.None , will disconnect the member from voice. Requires the MOVE_MEMBERS permission and the CONNECT permission in the original voice channel and the target voice channel. ! note If the member is not in a voice channel, this will take no effect.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.Member Object of the member that was updated. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing a permission to do an action.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or the user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.guild_id", "u": 36, "d": "The ID of the guild this member belongs to."}, {"r": "hikari.interactions.base_interactions.InteractionMember.is_deaf", "u": 36, "d": " builtins.True if this member is deafened in the current voice channel. This will be hikari.undefined.UNDEFINED if it's state is\nunknown."}, {"r": "hikari.interactions.base_interactions.InteractionMember.is_mute", "u": 36, "d": " builtins.True if this member is muted in the current voice channel. This will be hikari.undefined.UNDEFINED if it's state is unknown."}, {"r": "hikari.interactions.base_interactions.InteractionMember.is_pending", "u": 36, "d": "Whether the user has passed the guild's membership screening requirements. This will be hikari.undefined.UNDEFINED if it's state is unknown."}, {"r": "hikari.interactions.base_interactions.InteractionMember.joined_at", "u": 36, "d": "The datetime of when this member joined the guild they belong to."}, {"r": "hikari.interactions.base_interactions.InteractionMember.nickname", "u": 36, "d": "This member's nickname. This will be builtins.None if not set."}, {"r": "hikari.interactions.base_interactions.InteractionMember.premium_since", "u": 36, "d": "The datetime of when this member started \"boosting\" this guild. Will be builtins.None if the member is not a premium user."}, {"r": "hikari.interactions.base_interactions.InteractionMember.role_ids", "u": 36, "d": "A sequence of the IDs of the member's current roles."}, {"r": "hikari.interactions.base_interactions.InteractionMember.user", "u": 36, "d": "This member's corresponding user object."}, {"r": "hikari.interactions.base_interactions.InteractionMember.send", "u": 36, "d": "Send a message to this user in DM's. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nnonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both attachment and attachments are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; reply not found or not in the same channel; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled.\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.InteractionMember.created_at", "u": 36, "d": "When the object was created."}, {"r": "hikari.interactions.base_interactions.InteractionType", "u": 36, "d": "The type of an interaction."}, {"r": "hikari.interactions.base_interactions.InteractionType.name", "u": 36, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.interactions.base_interactions.InteractionType.value", "u": 36, "d": "Return the value of the enum member."}, {"r": "hikari.interactions.base_interactions.InteractionType.APPLICATION_COMMAND", "u": 36, "d": "An interaction triggered by a user calling an application command."}, {"r": "hikari.interactions.base_interactions.InteractionType.MESSAGE_COMPONENT", "u": 36, "d": "An interaction triggered by a user calling a message component."}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin", "u": 36, "d": "Mixin' class for all interaction types which can be responded to with a message. Method generated by attrs for class PartialInteraction."}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.fetch_initial_response", "u": 36, "d": "Fetch the initial response of this interaction. Returns hikari.messages.Message Message object of the initial response. Raises hikari.errors.ForbiddenError If you cannot access the target interaction.\nhikari.errors.NotFoundError If the initial response isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.create_initial_response", "u": 36, "d": "Create the initial response for this interaction. ! warning Calling this on an interaction which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request. Parameters response_type : typing.Union[builtins.int, CommandResponseTypesT] The type of interaction response this is. Other Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nflags : typing.Union[builtins.int, hikari.messages.MessageFlag, hikari.undefined.UndefinedType] If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL .\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction is not found or if the interaction's initial response has already been created.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.edit_initial_response", "u": 36, "d": "Edit the initial response of this command interaction. Other Parameters content : hikari.undefined.UndefinedNoneOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify one of mentions_everyone , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.delete_initial_response", "u": 36, "d": "Delete the initial response of this interaction. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction or response is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.webhook_id", "u": 36, "d": "ID used to execute this entity as a webhook. Returns hikari.snowflakes.Snowflake The ID used to execute this entity as a webhook."}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.app", "u": 36, "d": "The client application that models may use for procedures."}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.application_id", "u": 36, "d": "ID of the application this interaction belongs to."}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.id", "u": 36, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.token", "u": 36, "d": "The interaction's token."}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.type", "u": 36, "d": "The type of interaction this is."}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.version", "u": 36, "d": "Version of the interaction system this interaction is under."}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.created_at", "u": 36, "d": "When the object was created."}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.execute", "u": 36, "d": "Execute the webhook to create a message. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters username : hikari.undefined.UndefinedOr[builtins.str] If provided, the username to override the webhook's username for this request.\navatar_url : hikari.undefined.UndefinedOr[builtins.str] If provided, the url of an image to override the webhook's avatar with for this request.\ntts : hikari.undefined.UndefinedOr[bool] If provided, whether the message will be sent as a TTS message.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.\nflags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The flags to set for this webhook message. ! warning As of writing this can only be set for interaction webhooks and the only settable flag is EPHEMERAL; this field is just ignored for non-interaction webhooks. ! warning As of writing, username and avatar_url are ignored for interaction webhooks. Returns hikari.messages.Message The created message object. Raises hikari.errors.NotFoundError If the current webhook is not found.\nhikari.errors.BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook.\nbuiltins.ValueError If either ExecutableWebhook.token is builtins.None or more than 100 unique objects/entities are passed for role_mentions or user_mentions or if token is not available.\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.fetch_message", "u": 36, "d": "Fetch an old message sent by the webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found or the webhook's message wasn't found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.edit_message", "u": 36, "d": "Edit a message sent by a webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message.\ncontent : hikari.undefined.UndefinedNoneOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor no embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all three of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions or token is not available.\nbuiltins.TypeError If both attachment and attachments are specified or if both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.MessageResponseMixin.delete_message", "u": 36, "d": "Delete a given message in a given channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.MESSAGE_RESPONSE_TYPES", "u": 36, "d": "Set of the response types which are valid for message responses. This includes the following:  ResponseType.MESSAGE_CREATE   ResponseType.MESSAGE_UPDATE "}, {"r": "hikari.interactions.base_interactions.MessageResponseTypesT", "u": 36, "d": "Type-hint of the response types which are valid for message responses. The following are valid for this:  ResponseType.MESSAGE_CREATE / 4   ResponseType.MESSAGE_UPDATE / 7 "}, {"r": "hikari.interactions.base_interactions.PartialInteraction", "u": 36, "d": "The base model for all interaction models. Method generated by attrs for class PartialInteraction."}, {"r": "hikari.interactions.base_interactions.PartialInteraction.webhook_id", "u": 36, "d": "ID used to execute this entity as a webhook. Returns hikari.snowflakes.Snowflake The ID used to execute this entity as a webhook."}, {"r": "hikari.interactions.base_interactions.PartialInteraction.app", "u": 36, "d": "The client application that models may use for procedures."}, {"r": "hikari.interactions.base_interactions.PartialInteraction.application_id", "u": 36, "d": "ID of the application this interaction belongs to."}, {"r": "hikari.interactions.base_interactions.PartialInteraction.id", "u": 36, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.interactions.base_interactions.PartialInteraction.token", "u": 36, "d": "The interaction's token."}, {"r": "hikari.interactions.base_interactions.PartialInteraction.type", "u": 36, "d": "The type of interaction this is."}, {"r": "hikari.interactions.base_interactions.PartialInteraction.version", "u": 36, "d": "Version of the interaction system this interaction is under."}, {"r": "hikari.interactions.base_interactions.PartialInteraction.created_at", "u": 36, "d": "When the object was created."}, {"r": "hikari.interactions.base_interactions.PartialInteraction.execute", "u": 36, "d": "Execute the webhook to create a message. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters username : hikari.undefined.UndefinedOr[builtins.str] If provided, the username to override the webhook's username for this request.\navatar_url : hikari.undefined.UndefinedOr[builtins.str] If provided, the url of an image to override the webhook's avatar with for this request.\ntts : hikari.undefined.UndefinedOr[bool] If provided, whether the message will be sent as a TTS message.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.\nflags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The flags to set for this webhook message. ! warning As of writing this can only be set for interaction webhooks and the only settable flag is EPHEMERAL; this field is just ignored for non-interaction webhooks. ! warning As of writing, username and avatar_url are ignored for interaction webhooks. Returns hikari.messages.Message The created message object. Raises hikari.errors.NotFoundError If the current webhook is not found.\nhikari.errors.BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook.\nbuiltins.ValueError If either ExecutableWebhook.token is builtins.None or more than 100 unique objects/entities are passed for role_mentions or user_mentions or if token is not available.\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.interactions.base_interactions.PartialInteraction.fetch_message", "u": 36, "d": "Fetch an old message sent by the webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found or the webhook's message wasn't found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.PartialInteraction.edit_message", "u": 36, "d": "Edit a message sent by a webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message.\ncontent : hikari.undefined.UndefinedNoneOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor no embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all three of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions or token is not available.\nbuiltins.TypeError If both attachment and attachments are specified or if both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.PartialInteraction.delete_message", "u": 36, "d": "Delete a given message in a given channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.base_interactions.ResponseType", "u": 36, "d": "The type of an interaction response."}, {"r": "hikari.interactions.base_interactions.ResponseType.name", "u": 36, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.interactions.base_interactions.ResponseType.value", "u": 36, "d": "Return the value of the enum member."}, {"r": "hikari.interactions.base_interactions.ResponseType.MESSAGE_CREATE", "u": 36, "d": "An immediate message response to an interaction.  InteractionType.APPLICATION_COMMAND   InteractionType.MESSAGE_COMPONENT "}, {"r": "hikari.interactions.base_interactions.ResponseType.DEFERRED_MESSAGE_CREATE", "u": 36, "d": "Acknowledge an interaction with the intention to edit in a message response later. The user will see a loading state when this type is used until this\ninteraction expires or a message response is edited in over REST. This is valid for the following interaction types:  InteractionType.APPLICATION_COMMAND   InteractionType.MESSAGE_COMPONENT "}, {"r": "hikari.interactions.base_interactions.ResponseType.DEFERRED_MESSAGE_UPDATE", "u": 36, "d": "Acknowledge an interaction with the intention to edit its message later. This is valid for the following interaction types:  InteractionType.MESSAGE_COMPONENT "}, {"r": "hikari.interactions.base_interactions.ResponseType.MESSAGE_UPDATE", "u": 36, "d": "An immediate interaction response with instructions on how to update its message. This is valid for the following interaction types:  InteractionType.MESSAGE_COMPONENT "}, {"r": "hikari.interactions.command_interactions", "u": 37, "d": "Models and enums used for Discord's Slash Commands interaction flow."}, {"r": "hikari.interactions.command_interactions.CommandInteractionOption", "u": 37, "d": "Represents the options passed for a command interaction. Method generated by attrs for class CommandInteractionOption."}, {"r": "hikari.interactions.command_interactions.CommandInteractionOption.name", "u": 37, "d": "Name of this option."}, {"r": "hikari.interactions.command_interactions.CommandInteractionOption.options", "u": 37, "d": "Options provided for this option. Either CommandInteractionOption.value or CommandInteractionOption.options will be provided with value being provided when an option is provided as a\nparameter with a value and options being provided when an option donates a\nsubcommand or group."}, {"r": "hikari.interactions.command_interactions.CommandInteractionOption.type", "u": 37, "d": "Type of this option."}, {"r": "hikari.interactions.command_interactions.CommandInteractionOption.value", "u": 37, "d": "Value provided for this option. Either CommandInteractionOption.value or CommandInteractionOption.options will be provided with value being provided when an option is provided as a\nparameter with a value and options being provided when an option donates a\nsubcommand or group."}, {"r": "hikari.interactions.command_interactions.CommandInteraction", "u": 37, "d": "Represents a command interaction on Discord. Method generated by attrs for class CommandInteraction."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.build_response", "u": 37, "d": "Get a message response builder for use in the REST server flow. ! note For interactions received over the gateway CommandInteraction.create_initial_response should be used to set the interaction response message. Examples  \nasync def handle_command_interaction(interaction: CommandInteraction) -> InteractionMessageBuilder: return ( interaction .build_response() .add_embed(Embed(description=\"Hi there\" .set_content(\"Konnichiwa\") ) Returns hikari.api.special_endpoints.InteractionMessageBuilder Interaction message response builder object.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.build_deferred_response", "u": 37, "d": "Get a deferred message response builder for use in the REST server flow. ! note For interactions received over the gateway CommandInteraction.create_initial_response should be used to set the interaction response message. ! note Unlike hikari.api.special_endpoints.InteractionMessageBuilder , the result of this call can be returned as is without any modifications being made to it. Returns hikari.api.special_endpoints.InteractionMessageBuilder Deferred interaction message response builder object.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.fetch_channel", "u": 37, "d": "Fetch the guild channel this was triggered in. Returns hikari.channels.TextableChannel The requested partial channel derived object of the channel this was triggered in. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.get_channel", "u": 37, "d": "Get the guild channel this was triggered in from the cache. ! note This will always return builtins.None for interactions triggered in a DM channel. Returns typing.Optional[hikari.channels.TextableGuildChannel] The object of the guild channel that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.fetch_command", "u": 37, "d": "Fetch the command which triggered this interaction. Returns hikari.commands.Command Object of this interaction's command. Raises hikari.errors.ForbiddenError If you cannot access the target command.\nhikari.errors.NotFoundError If the command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.fetch_guild", "u": 37, "d": "Fetch the guild this interaction happened in. Returns typing.Optional[hikari.guilds.RESTGuild] Object of the guild this interaction happened in or builtins.None if this occurred within a DM channel. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.get_guild", "u": 37, "d": "Get the object of this interaction's guild guild from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.channel_id", "u": 37, "d": "ID of the channel this command interaction event was triggered in."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.command_id", "u": 37, "d": "ID of the command being invoked."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.command_name", "u": 37, "d": "Name of the command being invoked."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.guild_id", "u": 37, "d": "ID of the guild this command interaction event was triggered in. This will be builtins.None for command interactions triggered in DMs."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.member", "u": 37, "d": "The member who triggered this command interaction. This will be builtins.None for command interactions triggered in DMs. ! note This member object comes with the extra field permissions which contains the member's permissions in the current channel."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.options", "u": 37, "d": "Parameter values provided by the user invoking this command."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.resolved", "u": 37, "d": "Mappings of the objects resolved for the provided command options."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.user", "u": 37, "d": "The user who triggered this command interaction."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.fetch_initial_response", "u": 37, "d": "Fetch the initial response of this interaction. Returns hikari.messages.Message Message object of the initial response. Raises hikari.errors.ForbiddenError If you cannot access the target interaction.\nhikari.errors.NotFoundError If the initial response isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.create_initial_response", "u": 37, "d": "Create the initial response for this interaction. ! warning Calling this on an interaction which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request. Parameters response_type : typing.Union[builtins.int, CommandResponseTypesT] The type of interaction response this is. Other Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nflags : typing.Union[builtins.int, hikari.messages.MessageFlag, hikari.undefined.UndefinedType] If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL .\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction is not found or if the interaction's initial response has already been created.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.edit_initial_response", "u": 37, "d": "Edit the initial response of this command interaction. Other Parameters content : hikari.undefined.UndefinedNoneOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify one of mentions_everyone , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.delete_initial_response", "u": 37, "d": "Delete the initial response of this interaction. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction or response is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.webhook_id", "u": 37, "d": "ID used to execute this entity as a webhook. Returns hikari.snowflakes.Snowflake The ID used to execute this entity as a webhook."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.app", "u": 37, "d": "The client application that models may use for procedures."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.application_id", "u": 37, "d": "ID of the application this interaction belongs to."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.id", "u": 37, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.token", "u": 37, "d": "The interaction's token."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.type", "u": 37, "d": "The type of interaction this is."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.version", "u": 37, "d": "Version of the interaction system this interaction is under."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.created_at", "u": 37, "d": "When the object was created."}, {"r": "hikari.interactions.command_interactions.CommandInteraction.execute", "u": 37, "d": "Execute the webhook to create a message. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters username : hikari.undefined.UndefinedOr[builtins.str] If provided, the username to override the webhook's username for this request.\navatar_url : hikari.undefined.UndefinedOr[builtins.str] If provided, the url of an image to override the webhook's avatar with for this request.\ntts : hikari.undefined.UndefinedOr[bool] If provided, whether the message will be sent as a TTS message.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.\nflags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The flags to set for this webhook message. ! warning As of writing this can only be set for interaction webhooks and the only settable flag is EPHEMERAL; this field is just ignored for non-interaction webhooks. ! warning As of writing, username and avatar_url are ignored for interaction webhooks. Returns hikari.messages.Message The created message object. Raises hikari.errors.NotFoundError If the current webhook is not found.\nhikari.errors.BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook.\nbuiltins.ValueError If either ExecutableWebhook.token is builtins.None or more than 100 unique objects/entities are passed for role_mentions or user_mentions or if token is not available.\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.fetch_message", "u": 37, "d": "Fetch an old message sent by the webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found or the webhook's message wasn't found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.edit_message", "u": 37, "d": "Edit a message sent by a webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message.\ncontent : hikari.undefined.UndefinedNoneOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor no embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all three of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions or token is not available.\nbuiltins.TypeError If both attachment and attachments are specified or if both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.command_interactions.CommandInteraction.delete_message", "u": 37, "d": "Delete a given message in a given channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.interactions.command_interactions.COMMAND_RESPONSE_TYPES", "u": 37, "d": "Set of the response types which are valid for a command interaction. This includes:  hikari.interactions.base_interactions.ResponseType.MESSAGE_CREATE   hikari.interactions.base_interactions.ResponseType.DEFERRED_MESSAGE_CREATE "}, {"r": "hikari.interactions.command_interactions.CommandResponseTypesT", "u": 37, "d": "Type-hint of the response types which are valid for a command interaction. The following types are valid for this:  hikari.interactions.base_interactions.ResponseType.MESSAGE_CREATE / 4   hikari.interactions.base_interactions.ResponseType.DEFERRED_MESSAGE_CREATE / 5 "}, {"r": "hikari.interactions.command_interactions.InteractionChannel", "u": 37, "d": "Represents partial channels returned as resolved entities on interactions. Method generated by attrs for class InteractionChannel."}, {"r": "hikari.interactions.command_interactions.InteractionChannel.permissions", "u": 37, "d": "Permissions the command's executor has in this channel."}, {"r": "hikari.interactions.command_interactions.InteractionChannel.delete", "u": 37, "d": "Delete a channel in a guild, or close a DM. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.interactions.command_interactions.InteractionChannel.app", "u": 37, "d": "The client application that models may use for procedures."}, {"r": "hikari.interactions.command_interactions.InteractionChannel.id", "u": 37, "d": "The ID of this entity."}, {"r": "hikari.interactions.command_interactions.InteractionChannel.name", "u": 37, "d": "The channel's name. This will be missing for DM channels."}, {"r": "hikari.interactions.command_interactions.InteractionChannel.type", "u": 37, "d": "The channel's type."}, {"r": "hikari.interactions.command_interactions.InteractionChannel.created_at", "u": 37, "d": "When the object was created."}, {"r": "hikari.interactions.command_interactions.ResolvedOptionData", "u": 37, "d": "Represents the resolved objects of entities referenced in a command's options. Method generated by attrs for class ResolvedOptionData."}, {"r": "hikari.interactions.command_interactions.ResolvedOptionData.channels", "u": 37, "d": "Mapping of snowflake iDs to the resolved option partial channel objects."}, {"r": "hikari.interactions.command_interactions.ResolvedOptionData.members", "u": 37, "d": "Mapping of snowflake IDs to the resolved option member objects."}, {"r": "hikari.interactions.command_interactions.ResolvedOptionData.roles", "u": 37, "d": "Mapping of snowflake IDs to the resolved option role objects."}, {"r": "hikari.interactions.command_interactions.ResolvedOptionData.users", "u": 37, "d": "Mapping of snowflake IDs to the resolved option user objects."}, {"r": "hikari.voices", "u": 38, "d": "Application and entities that are used to describe voice state on Discord."}, {"r": "hikari.voices.VoiceRegion", "u": 38, "d": "Represents a voice region server. Method generated by attrs for class VoiceRegion."}, {"r": "hikari.voices.VoiceRegion.id", "u": 38, "d": "The string ID of this region. ! note Unlike most parts of this API, this ID will always be a string type. This is intentional."}, {"r": "hikari.voices.VoiceRegion.is_custom", "u": 38, "d": "Whether this region is custom (e.g. used for events)."}, {"r": "hikari.voices.VoiceRegion.is_deprecated", "u": 38, "d": "Whether this region is deprecated."}, {"r": "hikari.voices.VoiceRegion.is_optimal_location", "u": 38, "d": "Whether this region's server is closest to the current user's client."}, {"r": "hikari.voices.VoiceRegion.is_vip", "u": 38, "d": "Whether this region is vip-only."}, {"r": "hikari.voices.VoiceRegion.name", "u": 38, "d": "The name of this region."}, {"r": "hikari.voices.VoiceState", "u": 38, "d": "Represents a user's voice connection status. Method generated by attrs for class VoiceState."}, {"r": "hikari.voices.VoiceState.app", "u": 38, "d": "The client application that models may use for procedures."}, {"r": "hikari.voices.VoiceState.channel_id", "u": 38, "d": "The ID of the channel this user is connected to. This will be builtins.None if they are leaving voice."}, {"r": "hikari.voices.VoiceState.guild_id", "u": 38, "d": "The ID of the guild this voice state is in."}, {"r": "hikari.voices.VoiceState.is_guild_deafened", "u": 38, "d": "Whether this user is deafened by the guild."}, {"r": "hikari.voices.VoiceState.is_guild_muted", "u": 38, "d": "Whether this user is muted by the guild."}, {"r": "hikari.voices.VoiceState.is_self_deafened", "u": 38, "d": "Whether this user is deafened by their client."}, {"r": "hikari.voices.VoiceState.is_self_muted", "u": 38, "d": "Whether this user is muted by their client."}, {"r": "hikari.voices.VoiceState.is_streaming", "u": 38, "d": "Whether this user is streaming using \"Go Live\"."}, {"r": "hikari.voices.VoiceState.is_suppressed", "u": 38, "d": "Whether this user is considered to be \"suppressed\" in a voice context. In the context of a voice channel this may mean that the user is muted by\nthe current user and in the context of a stage channel this means that the\nuser is not a speaker."}, {"r": "hikari.voices.VoiceState.is_video_enabled", "u": 38, "d": "Whether this user's camera is enabled."}, {"r": "hikari.voices.VoiceState.member", "u": 38, "d": "The guild member this voice state is for."}, {"r": "hikari.voices.VoiceState.requested_to_speak_at", "u": 38, "d": "When the user requested to speak in a stage channel. Will be builtins.None if they have not requested to speak."}, {"r": "hikari.voices.VoiceState.session_id", "u": 38, "d": "The string ID of this voice state's session."}, {"r": "hikari.voices.VoiceState.user_id", "u": 38, "d": "The ID of the user this voice state is for."}, {"r": "hikari.emojis", "u": 39, "d": "Application and entities that are used to describe emojis on Discord."}, {"r": "hikari.emojis.Emoji", "u": 39, "d": "Base class for all emojis. Any emoji implementation supports being used as a hikari.files.Resource when uploading an attachment to the API.\nThis is achieved in the same way as using a hikari.files.WebResource would achieve this."}, {"r": "hikari.emojis.Emoji.name", "u": 39, "d": "Return the generic name/representation for this emoji."}, {"r": "hikari.emojis.Emoji.url", "u": 39, "d": "URL of the emoji image to display in clients."}, {"r": "hikari.emojis.Emoji.url_name", "u": 39, "d": "Name of the part of the emoji to use in requests."}, {"r": "hikari.emojis.Emoji.mention", "u": 39, "d": "Mention string to use to mention the emoji with."}, {"r": "hikari.emojis.Emoji.parse", "u": 39, "d": "Parse a given string into an emoji object. Parameters string : builtins.str The emoji object to parse. Returns Emoji The parsed emoji object. This will be a CustomEmoji if a custom emoji mention, or a UnicodeEmoji otherwise. Raises builtins.ValueError If a mention is given that has an invalid format.", "f": 1}, {"r": "hikari.emojis.Emoji.stream", "u": 39, "d": "Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource,\nor just to view any metadata that may be provided. Parameters executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples Downloading an entire resource at once into memory: py\nasync with obj.stream() as stream: data = await stream.read() Checking the metadata: py\nasync with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None: .\nelif mimetype not in whitelisted_mimetypes: .\nelse: . Fetching the data-uri of a resource: py\nasync with obj.stream() as stream: data_uri = await stream.data_uri() Returns AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises hikari.errors.BadRequestError If a 400 is returned.\nhikari.errors.UnauthorizedError If a 401 is returned.\nhikari.errors.ForbiddenError If a 403 is returned.\nhikari.errors.NotFoundError If a 404 is returned.\nhikari.errors.ClientHTTPResponseError If any other 4xx is returned.\nhikari.errors.InternalServerError If any other 5xx is returned.\nhikari.errors.HTTPResponseError If any other unexpected response code is returned.", "f": 1}, {"r": "hikari.emojis.Emoji.filename", "u": 39, "d": "Filename of the resource."}, {"r": "hikari.emojis.Emoji.extension", "u": 39, "d": "File extension, if there is one."}, {"r": "hikari.emojis.Emoji.read", "u": 39, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.emojis.UnicodeEmoji", "u": 39, "d": "Represents a unicode emoji. ! warning A word of warning if you try to upload this emoji as a file attachment. While this emoji type can be used to upload the Twemoji representations of this emoji as a PNG, this is NOT foolproof. The mapping between Discord's implementation and official Twemoji bindings is very flaky. Responsible implementations relying on this behaviour will be implemented to expect this behaviour in the form of hikari.errors.NotFoundError exceptions being raised when a mismatch may occur. It is also likely that this will change in the future without notice, so you will likely be relying on flaky behaviour. If this is proven to be too unstable, this functionality will be removed in a future release after a deprecation period."}, {"r": "hikari.emojis.UnicodeEmoji.name", "u": 39, "d": "Return the code points which form the emoji."}, {"r": "hikari.emojis.UnicodeEmoji.url_name", "u": 39, "d": "Name of the part of the emoji to use in requests."}, {"r": "hikari.emojis.UnicodeEmoji.mention", "u": 39, "d": "Mention string to use to mention the emoji with."}, {"r": "hikari.emojis.UnicodeEmoji.codepoints", "u": 39, "d": "Integer codepoints that make up this emoji, as UTF-8."}, {"r": "hikari.emojis.UnicodeEmoji.filename", "u": 39, "d": "Filename to use if re-uploading this emoji's PNG."}, {"r": "hikari.emojis.UnicodeEmoji.url", "u": 39, "d": "Get the URL of the PNG rendition of this emoji. This will use the official Twitter \"twemoji\" repository to fetch\nthis information, as Discord only stores this in a hashed format\nthat uses SVG files, which is not usually of any use. Since this uses \"twemoji\" directly, the emojis may not directly\nmatch what is on Discord if Discord have failed to keep their emoji\npacks up-to-date with this repository. Example https: github.com/twitter/twemoji/raw/master/assets/72x72/1f004.png"}, {"r": "hikari.emojis.UnicodeEmoji.unicode_escape", "u": 39, "d": "Get the unicode escape string for this emoji."}, {"r": "hikari.emojis.UnicodeEmoji.parse_codepoints", "u": 39, "d": "Create a unicode emoji from one or more UTF-32 codepoints.", "f": 1}, {"r": "hikari.emojis.UnicodeEmoji.parse_unicode_escape", "u": 39, "d": "Create a unicode emoji from a unicode escape string.", "f": 1}, {"r": "hikari.emojis.UnicodeEmoji.parse", "u": 39, "d": "Parse a given string into a unicode emoji object. Parameters string : builtins.str The emoji object to parse. Returns UnicodeEmoji The parsed UnicodeEmoji object.", "f": 1}, {"r": "hikari.emojis.UnicodeEmoji.stream", "u": 39, "d": "Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource,\nor just to view any metadata that may be provided. Parameters executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples Downloading an entire resource at once into memory: py\nasync with obj.stream() as stream: data = await stream.read() Checking the metadata: py\nasync with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None: .\nelif mimetype not in whitelisted_mimetypes: .\nelse: . Fetching the data-uri of a resource: py\nasync with obj.stream() as stream: data_uri = await stream.data_uri() Returns AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises hikari.errors.BadRequestError If a 400 is returned.\nhikari.errors.UnauthorizedError If a 401 is returned.\nhikari.errors.ForbiddenError If a 403 is returned.\nhikari.errors.NotFoundError If a 404 is returned.\nhikari.errors.ClientHTTPResponseError If any other 4xx is returned.\nhikari.errors.InternalServerError If any other 5xx is returned.\nhikari.errors.HTTPResponseError If any other unexpected response code is returned.", "f": 1}, {"r": "hikari.emojis.UnicodeEmoji.extension", "u": 39, "d": "File extension, if there is one."}, {"r": "hikari.emojis.UnicodeEmoji.read", "u": 39, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.emojis.CustomEmoji", "u": 39, "d": "Represents a custom emoji. This is a custom emoji that is from a guild you might not be part of. All CustomEmoji objects and their derivatives act as valid hikari.files.Resource objects. This means you can use them as a\nfile when sending a message. >>> emojis = await bot.rest.fetch_guild_emojis(12345) >>> picks = random.choices(emojis, 5) >>> await event.respond(files=picks) ! warning Discord will not provide information on whether these emojis are animated or not when a reaction is removed and an event is fired. This is problematic if you need to try and determine the emoji that was removed. The side effect of this means that mentions for animated emojis will not be correct. This will not be changed as stated here: https: github.com/discord/discord-api-docs/issues/1614 issuecomment-628548913 Method generated by attrs for class CustomEmoji."}, {"r": "hikari.emojis.CustomEmoji.filename", "u": 39, "d": "Filename of the resource."}, {"r": "hikari.emojis.CustomEmoji.url_name", "u": 39, "d": "Name of the part of the emoji to use in requests."}, {"r": "hikari.emojis.CustomEmoji.mention", "u": 39, "d": "Mention string to use to mention the emoji with."}, {"r": "hikari.emojis.CustomEmoji.url", "u": 39, "d": "URL of the emoji image to display in clients."}, {"r": "hikari.emojis.CustomEmoji.parse", "u": 39, "d": "Parse a given emoji mention string into a custom emoji object. Parameters string : builtins.str The emoji mention to parse. Returns CustomEmoji The parsed emoji object. Raises builtins.ValueError If a mention is given that has an invalid format.", "f": 1}, {"r": "hikari.emojis.CustomEmoji.id", "u": 39, "d": "The ID of this entity."}, {"r": "hikari.emojis.CustomEmoji.is_animated", "u": 39, "d": "Whether the emoji is animated."}, {"r": "hikari.emojis.CustomEmoji.name", "u": 39, "d": "The name of the emoji."}, {"r": "hikari.emojis.CustomEmoji.created_at", "u": 39, "d": "When the object was created."}, {"r": "hikari.emojis.CustomEmoji.stream", "u": 39, "d": "Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource,\nor just to view any metadata that may be provided. Parameters executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples Downloading an entire resource at once into memory: py\nasync with obj.stream() as stream: data = await stream.read() Checking the metadata: py\nasync with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None: .\nelif mimetype not in whitelisted_mimetypes: .\nelse: . Fetching the data-uri of a resource: py\nasync with obj.stream() as stream: data_uri = await stream.data_uri() Returns AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises hikari.errors.BadRequestError If a 400 is returned.\nhikari.errors.UnauthorizedError If a 401 is returned.\nhikari.errors.ForbiddenError If a 403 is returned.\nhikari.errors.NotFoundError If a 404 is returned.\nhikari.errors.ClientHTTPResponseError If any other 4xx is returned.\nhikari.errors.InternalServerError If any other 5xx is returned.\nhikari.errors.HTTPResponseError If any other unexpected response code is returned.", "f": 1}, {"r": "hikari.emojis.CustomEmoji.extension", "u": 39, "d": "File extension, if there is one."}, {"r": "hikari.emojis.CustomEmoji.read", "u": 39, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.emojis.KnownCustomEmoji", "u": 39, "d": "Represents an emoji that is known from a guild the bot is in. This is a specialization of CustomEmoji that is from a guild that you\n_are_ part of. As a result, it contains a lot more information with it. Method generated by attrs for class KnownCustomEmoji."}, {"r": "hikari.emojis.KnownCustomEmoji.app", "u": 39, "d": "The client application that models may use for procedures."}, {"r": "hikari.emojis.KnownCustomEmoji.guild_id", "u": 39, "d": "The ID of the guild this emoji belongs to."}, {"r": "hikari.emojis.KnownCustomEmoji.is_available", "u": 39, "d": "Whether this emoji can currently be used. May be builtins.False due to a loss of Sever Boosts on the emoji's guild."}, {"r": "hikari.emojis.KnownCustomEmoji.is_colons_required", "u": 39, "d": "Whether this emoji must be wrapped in colons."}, {"r": "hikari.emojis.KnownCustomEmoji.is_managed", "u": 39, "d": "Whether the emoji is managed by an integration."}, {"r": "hikari.emojis.KnownCustomEmoji.role_ids", "u": 39, "d": "The IDs of the roles that are whitelisted to use this emoji. If this is empty then any user can use this emoji regardless of their roles."}, {"r": "hikari.emojis.KnownCustomEmoji.user", "u": 39, "d": "The user that created the emoji. ! note This will be builtins.None if you are missing the MANAGE_EMOJIS_AND_STICKERS permission in the server the emoji is from."}, {"r": "hikari.emojis.KnownCustomEmoji.filename", "u": 39, "d": "Filename of the resource."}, {"r": "hikari.emojis.KnownCustomEmoji.url_name", "u": 39, "d": "Name of the part of the emoji to use in requests."}, {"r": "hikari.emojis.KnownCustomEmoji.mention", "u": 39, "d": "Mention string to use to mention the emoji with."}, {"r": "hikari.emojis.KnownCustomEmoji.url", "u": 39, "d": "URL of the emoji image to display in clients."}, {"r": "hikari.emojis.KnownCustomEmoji.parse", "u": 39, "d": "Parse a given emoji mention string into a custom emoji object. Parameters string : builtins.str The emoji mention to parse. Returns CustomEmoji The parsed emoji object. Raises builtins.ValueError If a mention is given that has an invalid format.", "f": 1}, {"r": "hikari.emojis.KnownCustomEmoji.id", "u": 39, "d": "The ID of this entity."}, {"r": "hikari.emojis.KnownCustomEmoji.is_animated", "u": 39, "d": "Whether the emoji is animated."}, {"r": "hikari.emojis.KnownCustomEmoji.name", "u": 39, "d": "The name of the emoji."}, {"r": "hikari.emojis.KnownCustomEmoji.created_at", "u": 39, "d": "When the object was created."}, {"r": "hikari.emojis.KnownCustomEmoji.stream", "u": 39, "d": "Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource,\nor just to view any metadata that may be provided. Parameters executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples Downloading an entire resource at once into memory: py\nasync with obj.stream() as stream: data = await stream.read() Checking the metadata: py\nasync with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None: .\nelif mimetype not in whitelisted_mimetypes: .\nelse: . Fetching the data-uri of a resource: py\nasync with obj.stream() as stream: data_uri = await stream.data_uri() Returns AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises hikari.errors.BadRequestError If a 400 is returned.\nhikari.errors.UnauthorizedError If a 401 is returned.\nhikari.errors.ForbiddenError If a 403 is returned.\nhikari.errors.NotFoundError If a 404 is returned.\nhikari.errors.ClientHTTPResponseError If any other 4xx is returned.\nhikari.errors.InternalServerError If any other 5xx is returned.\nhikari.errors.HTTPResponseError If any other unexpected response code is returned.", "f": 1}, {"r": "hikari.emojis.KnownCustomEmoji.extension", "u": 39, "d": "File extension, if there is one."}, {"r": "hikari.emojis.KnownCustomEmoji.read", "u": 39, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.iterators", "u": 40, "d": "Lazy iterators for data that requires repeated API calls to retrieve. For consumers of this API, the only class you need to worry about is LazyIterator . Everything else is internal detail only exposed for people who\nwish to extend this API further!"}, {"r": "hikari.iterators.LazyIterator", "u": 40, "d": "A set of results that are fetched asynchronously from the API as needed. This is a typing.AsyncIterable and typing.AsyncIterator with several\nadditional helpful methods provided for convenience. Examples You can use this in multiple ways. As an async iterable: py\n>>> async for item in paginated_results: . process(item) As an eagerly retrieved set of results (performs all API calls at once,\nwhich may be slow for large sets of data): py\n>>> results = await paginated_results\n>>>  . which is equivalent to this .\n>>> results = [item async for item in paginated_results] As an async iterator (not recommended): py\n>>> try: . while True: . process(await paginated_results.__anext__(  . except StopAsyncIteration: . pass Additionally, you can make use of some of the provided helper methods\non this class to perform basic operations easily. Iterating across the items with indexes (like builtins.enumerate for normal\niterables): py\n>>> async for i, item in paginated_results.enumerate(): . print(i, item)\n(0, foo)\n(1, bar)\n(2, baz) Limiting the number of results you iterate across: py\n>>> async for item in paginated_results.limit(3): . process(item) "}, {"r": "hikari.iterators.LazyIterator.chunk", "u": 40, "d": "Return results in chunks of up to chunk_size amount of entries. Parameters chunk_size : int The limit for how many results should be returned in each chunk. Returns LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.", "f": 1}, {"r": "hikari.iterators.LazyIterator.map", "u": 40, "d": "Map the values to a different value. Parameters transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the . operator. Returns LazyIterator[AnotherValueT] LazyIterator that maps each value to another value.", "f": 1}, {"r": "hikari.iterators.LazyIterator.for_each", "u": 40, "d": "Pass each value to a given consumer immediately.", "f": 1}, {"r": "hikari.iterators.LazyIterator.filter", "u": 40, "d": "Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item\nthat this iterator would return when it is requested. All conditions must evaluate to builtins.True for the item to be\nreturned. If this is not met, then the item is discarded and ignored,\nthe next matching item will be returned instead, if there is one. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.filter \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values where all conditions are matched.", "f": 1}, {"r": "hikari.iterators.LazyIterator.take_while", "u": 40, "d": "Return each item until any conditions fail or the end is reached. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.take_while \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.", "f": 1}, {"r": "hikari.iterators.LazyIterator.take_until", "u": 40, "d": "Return each item until any conditions pass or the end is reached. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.take_until \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.", "f": 1}, {"r": "hikari.iterators.LazyIterator.skip_while", "u": 40, "d": "Discard items while all conditions are True. Items after this will be yielded as normal. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.skip_while \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.", "f": 1}, {"r": "hikari.iterators.LazyIterator.skip_until", "u": 40, "d": "Discard items while all conditions are False. Items after this will be yielded as normal. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.skip_until \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.", "f": 1}, {"r": "hikari.iterators.LazyIterator.enumerate", "u": 40, "d": "Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of builtins.enumerate which uses much less memory than collecting all the results first and\ncalling builtins.enumerate across them. Parameters start : builtins.int Optional int to start at. If omitted, this is 0 . Examples >>> async for i, item in paginated_results.enumerate(): . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9): . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3): . print(i, item) (9, foo) (10, bar) (11, baz) Returns LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.", "f": 1}, {"r": "hikari.iterators.LazyIterator.limit", "u": 40, "d": "Limit the number of items you receive from this async iterator. Parameters limit : builtins.int The number of items to get. This must be greater than zero. Examples >>> async for item in paginated_results.limit(3): . print(item) Returns LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.", "f": 1}, {"r": "hikari.iterators.LazyIterator.skip", "u": 40, "d": "Drop the given number of items, then yield anything after. Parameters number : builtins.int The max number of items to drop before any items are yielded. Returns LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.", "f": 1}, {"r": "hikari.iterators.LazyIterator.next", "u": 40, "d": "Return the next element of this iterator only. Returns ValueT The next result. Raises builtins.LookupError If no more results exist.", "f": 1}, {"r": "hikari.iterators.LazyIterator.last", "u": 40, "d": "Return the last element of this iterator only. Returns ValueT The last result. ! note This method will consume the whole iterator if run. Raises builtins.LookupError If no result exists.", "f": 1}, {"r": "hikari.iterators.LazyIterator.reversed", "u": 40, "d": "Return a lazy iterator of the remainder of this iterator's values reversed. Returns LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.", "f": 1}, {"r": "hikari.iterators.LazyIterator.sort", "u": 40, "d": "Collect all results, then sort the collection before returning it.", "f": 1}, {"r": "hikari.iterators.LazyIterator.collect", "u": 40, "d": "Collect the results into a given type and return it. Parameters collector A function that consumes a sequence of values and returns a collection.", "f": 1}, {"r": "hikari.iterators.LazyIterator.count", "u": 40, "d": "Count the number of results. Returns builtins.int Number of results found.", "f": 1}, {"r": "hikari.iterators.LazyIterator.flat_map", "u": 40, "d": "Perform a flat mapping operation. This will pass each item in the iterator to the given function parameter, expecting a new typing.Iterable or typing.AsyncIterator to be returned as the result. This means you can map to a new LazyIterator , typing.AsyncIterator , typing.Iterable ,\nasync generator, or generator. Remember that typing.Iterator implicitly provides typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement\nreactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded\nlazily. Parameters flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example The following example generates a distinct collection of all mentioned\nusers in the given channel from the past 500 messages. py\ndef iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\"<@!?(\\d+)>\", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct()\n) Returns LazyIterator[AnotherValueT] The new lazy iterator to return.", "f": 1}, {"r": "hikari.iterators.LazyIterator.awaiting", "u": 40, "d": "Await each item concurrently in a fixed size window. Parameters window_size : int The window size of how many tasks to await at once. You can set this to 0 to await everything at once, but see the below warning. Returns LazyIterator[ValueT] The new lazy iterator to return. ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the fetch_user endpoint seems to be notorious for doing this). ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator", "u": 40, "d": "A lazy iterator that has all items in-memory and ready. This can be iterated across as a normal iterator, or as an async iterator."}, {"r": "hikari.iterators.FlatLazyIterator.chunk", "u": 40, "d": "Return results in chunks of up to chunk_size amount of entries. Parameters chunk_size : int The limit for how many results should be returned in each chunk. Returns LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.map", "u": 40, "d": "Map the values to a different value. Parameters transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the . operator. Returns LazyIterator[AnotherValueT] LazyIterator that maps each value to another value.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.for_each", "u": 40, "d": "Pass each value to a given consumer immediately.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.filter", "u": 40, "d": "Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item\nthat this iterator would return when it is requested. All conditions must evaluate to builtins.True for the item to be\nreturned. If this is not met, then the item is discarded and ignored,\nthe next matching item will be returned instead, if there is one. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.filter \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values where all conditions are matched.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.take_while", "u": 40, "d": "Return each item until any conditions fail or the end is reached. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.take_while \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.take_until", "u": 40, "d": "Return each item until any conditions pass or the end is reached. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.take_until \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.skip_while", "u": 40, "d": "Discard items while all conditions are True. Items after this will be yielded as normal. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.skip_while \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.skip_until", "u": 40, "d": "Discard items while all conditions are False. Items after this will be yielded as normal. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.skip_until \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.enumerate", "u": 40, "d": "Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of builtins.enumerate which uses much less memory than collecting all the results first and\ncalling builtins.enumerate across them. Parameters start : builtins.int Optional int to start at. If omitted, this is 0 . Examples >>> async for i, item in paginated_results.enumerate(): . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9): . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3): . print(i, item) (9, foo) (10, bar) (11, baz) Returns LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.limit", "u": 40, "d": "Limit the number of items you receive from this async iterator. Parameters limit : builtins.int The number of items to get. This must be greater than zero. Examples >>> async for item in paginated_results.limit(3): . print(item) Returns LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.skip", "u": 40, "d": "Drop the given number of items, then yield anything after. Parameters number : builtins.int The max number of items to drop before any items are yielded. Returns LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.next", "u": 40, "d": "Return the next element of this iterator only. Returns ValueT The next result. Raises builtins.LookupError If no more results exist.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.last", "u": 40, "d": "Return the last element of this iterator only. Returns ValueT The last result. ! note This method will consume the whole iterator if run. Raises builtins.LookupError If no result exists.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.reversed", "u": 40, "d": "Return a lazy iterator of the remainder of this iterator's values reversed. Returns LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.sort", "u": 40, "d": "Collect all results, then sort the collection before returning it.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.collect", "u": 40, "d": "Collect the results into a given type and return it. Parameters collector A function that consumes a sequence of values and returns a collection.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.count", "u": 40, "d": "Count the number of results. Returns builtins.int Number of results found.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.flat_map", "u": 40, "d": "Perform a flat mapping operation. This will pass each item in the iterator to the given function parameter, expecting a new typing.Iterable or typing.AsyncIterator to be returned as the result. This means you can map to a new LazyIterator , typing.AsyncIterator , typing.Iterable ,\nasync generator, or generator. Remember that typing.Iterator implicitly provides typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement\nreactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded\nlazily. Parameters flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example The following example generates a distinct collection of all mentioned\nusers in the given channel from the past 500 messages. py\ndef iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\"<@!?(\\d+)>\", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct()\n) Returns LazyIterator[AnotherValueT] The new lazy iterator to return.", "f": 1}, {"r": "hikari.iterators.FlatLazyIterator.awaiting", "u": 40, "d": "Await each item concurrently in a fixed size window. Parameters window_size : int The window size of how many tasks to await at once. You can set this to 0 to await everything at once, but see the below warning. Returns LazyIterator[ValueT] The new lazy iterator to return. ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the fetch_user endpoint seems to be notorious for doing this). ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.", "f": 1}, {"r": "hikari.iterators.All", "u": 40, "d": "Helper that wraps predicates and invokes them together. Calling this object will pass the input item to each item, returning builtins.True only when all wrapped predicates return True when called\nwith the given item. For example . py\nif w(foo) and x(foo) andy(foo) and z(foo): . is equivalent to py\ncondition = All([w, x, y, z]) if condition(foo): . This behaves like a lazy wrapper implementation of the builtins.all builtin. ! note Like the rest of the standard library, this is a short-circuiting operation. This means that if a predicate returns builtins.False , no predicates after this are invoked, as the result is already known. In this sense, they are invoked in-order. ! warning You should not generally need to use this outside of extending the iterators API in this library! Operators   this(value : ValueT) -> bool : Return builtins.True if all conditions return builtins.True when invoked with the given value.  ~this : Return a condition that, when invoked with the value, returns builtins.False if all conditions were builtins.True in this object. Parameters  conditions : typing.Callable ValueT], builtins.bool] The predicates to wrap."}, {"r": "hikari.iterators.All.conditions", "u": 40, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.iterators.AttrComparator", "u": 40, "d": "A comparator that compares the result of a call with something else. This uses the spel module internally. Parameters attr_name : builtins.str The attribute name. Can be prepended with a . optionally. If the attribute name ends with a () , then the call is invoked rather than treated as a property (useful for methods like str.isupper , for example).\nexpected_value : typing.Any The expected value.\ncast : typing.Optional[typing.Callable ValueT], typing.Any Optional cast to perform on the input value when being called before comparing it to the expected value but after accessing the attribute."}, {"r": "hikari.iterators.AttrComparator.attr_getter", "u": 40, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.iterators.AttrComparator.cast", "u": 40, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.iterators.AttrComparator.expected_value", "u": 40, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.iterators.BufferedLazyIterator", "u": 40, "d": "A special kind of lazy iterator that is used by internal components. The purpose of this is to provide an interface to lazily deserialize\ncollections of payloads received from paginated API endpoints such as GET /channels/{channel_id}/messages , which will return a certain number\nof messages at a time on a low level. This class provides the base interface\nfor handling lazily decoding each item in those responses and returning them\nin the expected format when iterating across this object. Implementations are expected to provide a _next_chunk private method\nwhich when awaited returns a lazy generator of each deserialized object\nto later yield. This will be iterated across lazily by this implementation,\nthus reducing the amount of work needed if only a few objects out of, say,\n100, need to be deserialized. This _next_chunk should return builtins.None once the end of all items\nhas been reached. An example would look like the following: py\nasync def some_http_call(i): . class SomeEndpointLazyIterator(BufferedLazyIterator[SomeObject]): def __init__(self): super().__init__() self._i = 0 def _next_chunk(self) -> typing.Optional[typing.Generator[ValueT, None, None : raw_items = await some_http_call(self._i) self._i += 1 if not raw_items: return None generator = (SomeObject(raw_item) for raw_item in raw_items) return generator "}, {"r": "hikari.iterators.BufferedLazyIterator.chunk", "u": 40, "d": "Return results in chunks of up to chunk_size amount of entries. Parameters chunk_size : int The limit for how many results should be returned in each chunk. Returns LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.map", "u": 40, "d": "Map the values to a different value. Parameters transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the . operator. Returns LazyIterator[AnotherValueT] LazyIterator that maps each value to another value.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.for_each", "u": 40, "d": "Pass each value to a given consumer immediately.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.filter", "u": 40, "d": "Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item\nthat this iterator would return when it is requested. All conditions must evaluate to builtins.True for the item to be\nreturned. If this is not met, then the item is discarded and ignored,\nthe next matching item will be returned instead, if there is one. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.filter \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values where all conditions are matched.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.take_while", "u": 40, "d": "Return each item until any conditions fail or the end is reached. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.take_while \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.take_until", "u": 40, "d": "Return each item until any conditions pass or the end is reached. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.take_until \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.skip_while", "u": 40, "d": "Discard items while all conditions are True. Items after this will be yielded as normal. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.skip_while \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.skip_until", "u": 40, "d": "Discard items while all conditions are False. Items after this will be yielded as normal. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.skip_until \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.enumerate", "u": 40, "d": "Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of builtins.enumerate which uses much less memory than collecting all the results first and\ncalling builtins.enumerate across them. Parameters start : builtins.int Optional int to start at. If omitted, this is 0 . Examples >>> async for i, item in paginated_results.enumerate(): . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9): . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3): . print(i, item) (9, foo) (10, bar) (11, baz) Returns LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.limit", "u": 40, "d": "Limit the number of items you receive from this async iterator. Parameters limit : builtins.int The number of items to get. This must be greater than zero. Examples >>> async for item in paginated_results.limit(3): . print(item) Returns LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.skip", "u": 40, "d": "Drop the given number of items, then yield anything after. Parameters number : builtins.int The max number of items to drop before any items are yielded. Returns LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.next", "u": 40, "d": "Return the next element of this iterator only. Returns ValueT The next result. Raises builtins.LookupError If no more results exist.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.last", "u": 40, "d": "Return the last element of this iterator only. Returns ValueT The last result. ! note This method will consume the whole iterator if run. Raises builtins.LookupError If no result exists.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.reversed", "u": 40, "d": "Return a lazy iterator of the remainder of this iterator's values reversed. Returns LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.sort", "u": 40, "d": "Collect all results, then sort the collection before returning it.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.collect", "u": 40, "d": "Collect the results into a given type and return it. Parameters collector A function that consumes a sequence of values and returns a collection.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.count", "u": 40, "d": "Count the number of results. Returns builtins.int Number of results found.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.flat_map", "u": 40, "d": "Perform a flat mapping operation. This will pass each item in the iterator to the given function parameter, expecting a new typing.Iterable or typing.AsyncIterator to be returned as the result. This means you can map to a new LazyIterator , typing.AsyncIterator , typing.Iterable ,\nasync generator, or generator. Remember that typing.Iterator implicitly provides typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement\nreactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded\nlazily. Parameters flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example The following example generates a distinct collection of all mentioned\nusers in the given channel from the past 500 messages. py\ndef iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\"<@!?(\\d+)>\", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct()\n) Returns LazyIterator[AnotherValueT] The new lazy iterator to return.", "f": 1}, {"r": "hikari.iterators.BufferedLazyIterator.awaiting", "u": 40, "d": "Await each item concurrently in a fixed size window. Parameters window_size : int The window size of how many tasks to await at once. You can set this to 0 to await everything at once, but see the below warning. Returns LazyIterator[ValueT] The new lazy iterator to return. ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the fetch_user endpoint seems to be notorious for doing this). ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.", "f": 1}, {"r": "hikari.iterators.ValueT", "u": 40, "d": "Type-hint of the type of the value returned by a lazy iterator."}, {"r": "hikari.iterators.AnotherValueT", "u": 40, "d": "Type-hint of the type of a value by a mapped lazy iterator."}, {"r": "hikari.invites", "u": 41, "d": "Application and entities that are used to describe invites on Discord."}, {"r": "hikari.invites.TargetType", "u": 41, "d": "The target of the invite."}, {"r": "hikari.invites.TargetType.name", "u": 41, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.invites.TargetType.value", "u": 41, "d": "Return the value of the enum member."}, {"r": "hikari.invites.TargetType.STREAM", "u": 41, "d": "This invite is targeting a \"Go Live\" stream."}, {"r": "hikari.invites.TargetType.EMBEDDED_APPLICATION", "u": 41, "d": "This invite is targeting an embedded application."}, {"r": "hikari.invites.VanityURL", "u": 41, "d": "A special case invite object, that represents a guild's vanity url. Method generated by attrs for class VanityURL."}, {"r": "hikari.invites.VanityURL.app", "u": 41, "d": "The client application that models may use for procedures."}, {"r": "hikari.invites.VanityURL.code", "u": 41, "d": "The code for this invite."}, {"r": "hikari.invites.VanityURL.uses", "u": 41, "d": "The amount of times this invite has been used."}, {"r": "hikari.invites.InviteGuild", "u": 41, "d": "Represents the partial data of a guild that is attached to invites. Method generated by attrs for class InviteGuild."}, {"r": "hikari.invites.InviteGuild.splash_url", "u": 41, "d": "Splash URL for the guild, if set."}, {"r": "hikari.invites.InviteGuild.make_splash_url", "u": 41, "d": "Generate the guild's splash image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the splash, or builtins.None if not set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.invites.InviteGuild.banner_url", "u": 41, "d": "Banner URL for the guild, if set."}, {"r": "hikari.invites.InviteGuild.make_banner_url", "u": 41, "d": "Generate the guild's banner image URL, if set. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL of the banner, or builtins.None if no banner is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.invites.InviteGuild.banner_hash", "u": 41, "d": "The hash for the guild's banner. This is only present if hikari.guilds.GuildFeature.BANNER is in the features for this guild. For all other purposes, it is builtins.None ."}, {"r": "hikari.invites.InviteGuild.description", "u": 41, "d": "The guild's description. This is only present if certain features are set in this guild.\nOtherwise, this will always be builtins.None . For all other purposes, it is builtins.None ."}, {"r": "hikari.invites.InviteGuild.features", "u": 41, "d": "A list of the features in this guild."}, {"r": "hikari.invites.InviteGuild.nsfw_level", "u": 41, "d": "The NSFW level of the guild."}, {"r": "hikari.invites.InviteGuild.splash_hash", "u": 41, "d": "The hash of the splash for the guild, if there is one."}, {"r": "hikari.invites.InviteGuild.vanity_url_code", "u": 41, "d": "The vanity URL code for the guild's vanity URL. This is only present if hikari.guilds.GuildFeature.VANITY_URL is in the features for this guild. If not, this will always be builtins.None ."}, {"r": "hikari.invites.InviteGuild.verification_level", "u": 41, "d": "The verification level required for a user to participate in this guild."}, {"r": "hikari.invites.InviteGuild.welcome_screen", "u": 41, "d": "The welcome screen of a community guild shown to new members, if set."}, {"r": "hikari.invites.InviteGuild.icon_url", "u": 41, "d": "Icon URL for the guild, if set; otherwise builtins.None ."}, {"r": "hikari.invites.InviteGuild.shard_id", "u": 41, "d": "Return the ID of the shard this guild is served by. This may return None if the application does not have a gateway\nconnection."}, {"r": "hikari.invites.InviteGuild.make_icon_url", "u": 41, "d": "Generate the guild's icon URL, if set. Parameters ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the resource, or builtins.None if no icon is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.invites.InviteGuild.ban", "u": 41, "d": "Ban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to ban from the guild Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.unban", "u": 41, "d": "Unban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to unban from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.kick", "u": 41, "d": "Kicks the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to kick from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.edit", "u": 41, "d": "Edits the guild. Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild.\nverification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level.\ndefault_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level.\nexplicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level.\nafk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires afk_timeout to be set to work.\nafk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout.\nicon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature.\nowner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner. ! warning You need to be the owner of the server to use this.\nsplash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the INVITE_SPLASH feature.\nbanner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the BANNER feature.\nsystem_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel.\nrules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel.\npublic_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel.\npreferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.RESTGuild The edited guild. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission or if you tried to pass ownership without being the server owner.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.fetch_emojis", "u": 41, "d": "Fetch the emojis of the guild. Returns typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.fetch_emoji", "u": 41, "d": "Fetch an emoji from the guild. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns hikari.emojis.KnownCustomEmoji The requested emoji. Raises hikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.fetch_stickers", "u": 41, "d": "Fetch the stickers of the guild. Returns typing.Sequence[hikari.stickers.GuildSticker] The requested stickers. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.fetch_sticker", "u": 41, "d": "Fetch a sticker from the guild. Parameters sticker : snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns hikari.stickers.GuildSticker The requested sticker. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.create_sticker", "u": 41, "d": "Create a sticker in a guild. Parameters name : builtins.str The name for the sticker.\ntag : builtins.str The tag for the sticker.\nimage : hikari.files.Resourceish The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie. ! note Lottie support is only available for verified and partnered servers. Other Parameters description: hikari.undefined.UndefinedOr[builtins.str] If provided, the description of the sticker.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The created sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.edit_sticker", "u": 41, "d": "Edit a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to edit. This can be a sticker object or the ID of an existing sticker. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the sticker.\ndescription : hikari.undefined.UndefinedOr[builtins.str] If provided, the new description for the sticker.\ntag : hikari.undefined.UndefinedOr[builtins.str] If provided, the new sticker tag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The edited sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.delete_sticker", "u": 41, "d": "Delete a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to delete. This can be a sticker object or the ID of an existing sticker. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.create_category", "u": 41, "d": "Create a category in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildCategory The created category. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.create_text_channel", "u": 41, "d": "Create a text channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildTextChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.create_news_channel", "u": 41, "d": "Create a news channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildNewsChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.create_voice_channel", "u": 41, "d": "Create a voice channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildVoiceChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the gui ld is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.create_stage_channel", "u": 41, "d": "Create a stage channel in the guild. Parameters name : builtins.str The channel's name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildStageChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.delete_channel", "u": 41, "d": "Delete a channel in the guild. ! note This method can also be used for deleting guild categories as well. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel or category to delete. This may be the object or the ID of an existing channel. Returns hikari.channels.GuildChannel Object of the channel or category that was deleted. Raises hikari.errors.UnauthorizedError, or close a DM. If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.invites.InviteGuild.fetch_self", "u": 41, "d": "Fetch the guild. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.fetch_roles", "u": 41, "d": "Fetch the roles of the guild. Returns typing.Sequence[hikari.guilds.Role] The requested roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.invites.InviteGuild.app", "u": 41, "d": "The client application that models may use for procedures."}, {"r": "hikari.invites.InviteGuild.icon_hash", "u": 41, "d": "The hash for the guild icon, if there is one."}, {"r": "hikari.invites.InviteGuild.id", "u": 41, "d": "The ID of this entity."}, {"r": "hikari.invites.InviteGuild.name", "u": 41, "d": "The name of the guild."}, {"r": "hikari.invites.InviteGuild.created_at", "u": 41, "d": "When the object was created."}, {"r": "hikari.invites.InviteCode", "u": 41, "d": "A representation of a guild/channel invite."}, {"r": "hikari.invites.InviteCode.code", "u": 41, "d": "Return the code for this invite. Returns builtins.str The invite code that can be appended to a URL."}, {"r": "hikari.invites.Invite", "u": 41, "d": "Represents an invite that's used to add users to a guild or group dm. Method generated by attrs for class Invite."}, {"r": "hikari.invites.Invite.app", "u": 41, "d": "The client application that models may use for procedures."}, {"r": "hikari.invites.Invite.approximate_active_member_count", "u": 41, "d": "The approximate amount of presences in this invite's guild. This is only returned by the GET REST Invites endpoint."}, {"r": "hikari.invites.Invite.approximate_member_count", "u": 41, "d": "The approximate amount of members in this invite's guild. This is only returned by the GET Invites REST endpoint."}, {"r": "hikari.invites.Invite.channel", "u": 41, "d": "The partial object of the channel this invite targets. Will be builtins.None for invite objects that are attached to gateway events,\nin which case you should refer to Invite.channel_id ."}, {"r": "hikari.invites.Invite.channel_id", "u": 41, "d": "The ID of the channel this invite targets."}, {"r": "hikari.invites.Invite.code", "u": 41, "d": "The code for this invite."}, {"r": "hikari.invites.Invite.expires_at", "u": 41, "d": "When this invite will expire. This field is only returned by the GET Invite REST endpoint and will be\nreturned as builtins.None by said endpoint if the invite doesn't have a set\nexpiry date. Other places will always return this as builtins.None ."}, {"r": "hikari.invites.Invite.guild", "u": 41, "d": "The partial object of the guild this invite belongs to. Will be builtins.None for group DM invites and when attached to a gateway event;\nfor invites received over the gateway you should refer to Invite.guild_id ."}, {"r": "hikari.invites.Invite.guild_id", "u": 41, "d": "The ID of the guild this invite belongs to. Will be builtins.None for group DM invites."}, {"r": "hikari.invites.Invite.inviter", "u": 41, "d": "The object of the user who created this invite."}, {"r": "hikari.invites.Invite.target_application", "u": 41, "d": "The embedded application this invite targets, if applicable."}, {"r": "hikari.invites.Invite.target_type", "u": 41, "d": "The type of the target of this invite, if applicable."}, {"r": "hikari.invites.Invite.target_user", "u": 41, "d": "The object of the user who this invite targets, if set."}, {"r": "hikari.invites.InviteWithMetadata", "u": 41, "d": "Extends the base Invite object with metadata. The metadata is only returned when getting an invite with\nguild permissions, rather than it's code. Method generated by attrs for class InviteWithMetadata."}, {"r": "hikari.invites.InviteWithMetadata.uses_left", "u": 41, "d": "Return the number of uses left for this invite. Returns typing.Optional[builtins.int] The number of uses left for this invite. This will be builtins.None if the invite has unlimited uses."}, {"r": "hikari.invites.InviteWithMetadata.expires_at", "u": 41, "d": "When this invite will expire. If this invite doesn't have a set expiry then this will be builtins.None ."}, {"r": "hikari.invites.InviteWithMetadata.created_at", "u": 41, "d": "When this invite was created."}, {"r": "hikari.invites.InviteWithMetadata.is_temporary", "u": 41, "d": "Whether this invite grants temporary membership."}, {"r": "hikari.invites.InviteWithMetadata.max_age", "u": 41, "d": "The timedelta of how long this invite will be valid for. If set to builtins.None then this is unlimited."}, {"r": "hikari.invites.InviteWithMetadata.max_uses", "u": 41, "d": "The limit for how many times this invite can be used before it expires. If set to builtins.None then this is unlimited."}, {"r": "hikari.invites.InviteWithMetadata.uses", "u": 41, "d": "The amount of times this invite has been used."}, {"r": "hikari.invites.InviteWithMetadata.app", "u": 41, "d": "The client application that models may use for procedures."}, {"r": "hikari.invites.InviteWithMetadata.approximate_active_member_count", "u": 41, "d": "The approximate amount of presences in this invite's guild. This is only returned by the GET REST Invites endpoint."}, {"r": "hikari.invites.InviteWithMetadata.approximate_member_count", "u": 41, "d": "The approximate amount of members in this invite's guild. This is only returned by the GET Invites REST endpoint."}, {"r": "hikari.invites.InviteWithMetadata.channel", "u": 41, "d": "The partial object of the channel this invite targets. Will be builtins.None for invite objects that are attached to gateway events,\nin which case you should refer to Invite.channel_id ."}, {"r": "hikari.invites.InviteWithMetadata.channel_id", "u": 41, "d": "The ID of the channel this invite targets."}, {"r": "hikari.invites.InviteWithMetadata.code", "u": 41, "d": "The code for this invite."}, {"r": "hikari.invites.InviteWithMetadata.guild", "u": 41, "d": "The partial object of the guild this invite belongs to. Will be builtins.None for group DM invites and when attached to a gateway event;\nfor invites received over the gateway you should refer to Invite.guild_id ."}, {"r": "hikari.invites.InviteWithMetadata.guild_id", "u": 41, "d": "The ID of the guild this invite belongs to. Will be builtins.None for group DM invites."}, {"r": "hikari.invites.InviteWithMetadata.inviter", "u": 41, "d": "The object of the user who created this invite."}, {"r": "hikari.invites.InviteWithMetadata.target_application", "u": 41, "d": "The embedded application this invite targets, if applicable."}, {"r": "hikari.invites.InviteWithMetadata.target_type", "u": 41, "d": "The type of the target of this invite, if applicable."}, {"r": "hikari.invites.InviteWithMetadata.target_user", "u": 41, "d": "The object of the user who this invite targets, if set."}, {"r": "hikari.impl", "u": 42, "d": "Basic implementations of application components. These components implement the interfaces in hikari.api to provide the\nbaseline functionality. For most applications that do not have bespoke\nperformance or structural requirements, you will want to use these\nimplementations."}, {"r": "hikari.impl.cache", "u": 43, "d": "Basic implementation of a cache for general bots and gateway apps."}, {"r": "hikari.impl.cache.CacheImpl", "u": 43, "d": "In-memory cache implementation. Parameters app : hikari.traits.RESTAware The object of the REST aware app this is bound to.\nsettings : hikari.config.CacheSettings The cache settings to use."}, {"r": "hikari.impl.cache.CacheImpl.settings", "u": 43, "d": ""}, {"r": "hikari.impl.cache.CacheImpl.clear", "u": 43, "d": "Clear the full cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_dm_channel_ids", "u": 43, "d": "Remove all the cached DM channel IDs. Returns CacheView[hikari.snowflakes.Snowflake, hikari.snowflakes.Snowflake] Cache view of user IDs to DM channel IDs which were cleared from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_dm_channel_id", "u": 43, "d": "Remove a DM channel ID from the cache. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to remove the cached DM channel ID for. Returns typing.Optional[hikari.snowflakes.Snowflake] The DM channel ID which was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_dm_channel_id", "u": 43, "d": "Get the DM channel ID for a user. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get the DM channel ID for. Returns typing.Optional[hikari.snowflakes.Snowflake] ID of the DM channel which was found cached for the supplied user or builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_dm_channel_ids_view", "u": 43, "d": "Get a view of the cached DM channel IDs. Returns CacheView[hikari.snowflakes.Snowflake, hikari.snowflakes.Snowflake] Cache view of user IDs to DM channel IDs.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_dm_channel_id", "u": 43, "d": "Add a DM channel ID to the cache. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to add a DM channel ID to the cache for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the DM channel to add to the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_emojis", "u": 43, "d": "Remove all the known custom emoji objects from the cache. ! note This will skip emojis that are being kept alive by a reference on a presence entry. Returns CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A cache view of emoji IDs to objects of the emojis that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_emojis_for_guild", "u": 43, "d": "Remove the known custom emoji objects cached for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove the cached emoji objects for. ! note This will skip emojis that are being kept alive by a reference on a presence entry. Returns CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the emojis that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_emoji", "u": 43, "d": "Remove a known custom emoji from the cache. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] Object or ID of the emoji to remove from the cache. ! note This will not delete emojis that are being kept alive by a reference on a presence entry. Returns typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was removed from the cache or builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_emoji", "u": 43, "d": "Get a known custom emoji from the cache. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] Object or ID of the emoji to get from the cache. Returns typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_emojis_view", "u": 43, "d": "Get a view of the known custom emoji objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the known custom emojis found in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_emojis_view_for_guild", "u": 43, "d": "Get a view of the known custom emojis cached for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached emoji objects for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of emojis found in the cache for the specified guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_emoji", "u": 43, "d": "Add a known custom emoji to the cache. Parameters emoji : hikari.emojis.KnownCustomEmoji The object of the known custom emoji to add to the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.update_emoji", "u": 43, "d": "Update an emoji object in the cache. Parameters emoji : hikari.emojis.KnownCustomEmoji The object of the emoji to update in the cache. Returns typing.Tuple[typing.Optional[hikari.emojis.KnownCustomEmoji], typing.Optional[hikari.emojis.KnownCustomEmoji A tuple of the old cached emoji object if found (else builtins.None ) and the new cached emoji object if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_guilds", "u": 43, "d": "Remove all the guild objects from the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] The cache view of guild IDs to guild objects that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_guild", "u": 43, "d": "Remove a guild object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild that was removed from the cache, will be builtins.None if not found.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_guild", "u": 43, "d": "Get a guild from the cache. ! warning This will return a guild regardless of whether it is available or not. To only query available guilds, use get_available_guild instead. Likewise, to only query unavailable guilds, use get_unavailable_guild . Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_available_guild", "u": 43, "d": "Get the object of an available guild from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_unavailable_guild", "u": 43, "d": "Get the object of a unavailable guild from the cache. ! note Unlike Cache.get_available_guild , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get from the cache. Returns typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_guilds_view", "u": 43, "d": "Get a view of all the guild objects in the cache regardless if availability. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_available_guilds_view", "u": 43, "d": "Get a view of the available guild objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_unavailable_guilds_view", "u": 43, "d": "Get a view of the unavailable guild objects in the cache. ! note Unlike Cache.get_available_guilds_view , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_guild", "u": 43, "d": "Add a guild object to the cache. Parameters guild : hikari.guilds.GatewayGuild The object of the guild to add to the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_guild_availability", "u": 43, "d": "Set whether a cached guild is available or not. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to set the availability for.\nis_available : builtins.bool The availability to set for the guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.update_guild", "u": 43, "d": "Update a guild in the cache. Parameters guild : hikari.guilds.GatewayGuild The object of the guild to update in the cache. Returns typing.Tuple[typing.Optional[hikari.guilds.GatewayGuild], typing.Optional[hikari.guilds.GatewayGuild A tuple of the old cached guild object if found (else builtins.None ) and the object of the guild that was added to the cache if it could be added (else builtins.None ).", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_guild_channels", "u": 43, "d": "Remove all guild channels from the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_guild_channels_for_guild", "u": 43, "d": "Remove guild channels from the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove cached channels for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_guild_channel", "u": 43, "d": "Remove a guild channel from the cache. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the guild channel to remove from the cache. Returns typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_guild_channel", "u": 43, "d": "Get a guild channel from the cache. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the guild channel to get from the cache. Returns typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_guild_channels_view", "u": 43, "d": "Get a view of the guild channels in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_guild_channels_view_for_guild", "u": 43, "d": "Get a view of the guild channels in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached channels for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache for the specified guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_guild_channel", "u": 43, "d": "Add a guild channel to the cache. Parameters channel : hikari.channels.GuildChannel The guild channel based object to add to the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.update_guild_channel", "u": 43, "d": "Update a guild channel in the cache, Parameters channel : hikari.channels.GuildChannel The object of the channel to update in the cache. Returns typing.Tuple[typing.Optional[hikari.channels.GuildChannel], typing.Optional[hikari.channels.GuildChannel A tuple of the old cached guild channel if found (else builtins.None ) and the new cached guild channel if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_invites", "u": 43, "d": "Remove all the invite objects from the cache. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_invites_for_guild", "u": 43, "d": "Remove the invite objects in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove invite objects for. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache for the specified guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_invites_for_channel", "u": 43, "d": "Remove the invite objects in the cache for a specific channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove invite objects for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the channel to remove invite objects for. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache for the specified channel.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_invite", "u": 43, "d": "Remove an invite object from the cache. Parameters code : typing.Union[hikari.invites.InviteCode, builtins.str] Object or string code of the invite to remove from the cache. Returns typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_invite", "u": 43, "d": "Get an invite object from the cache. Parameters code : typing.Union[hikari.invites.InviteCode, builtins.str] The object or string code of the invite to get from the cache. Returns typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_invites_view", "u": 43, "d": "Get a view of the invite objects in the cache. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string codes to objects of the invites that were found in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_invites_view_for_guild", "u": 43, "d": "Get a view of the invite objects in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get invite objects for. Returns CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string code to objects of the invites that were found in the cache for the specified guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_invites_view_for_channel", "u": 43, "d": "Get a view of the invite objects in the cache for a specified channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get invite objects for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the channel to get invite objects for. Returns CacheView[str, invites.InviteWithMetadata] A view of string codes to objects of the invites there were found in the cache for the specified channel.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_invite", "u": 43, "d": "Add an invite object to the cache. Parameters invite : hikari.invites.InviteWithMetadata The object of the invite to add to the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.update_invite", "u": 43, "d": "Update an invite in the cache. Parameters invite : hikari.invites.InviteWithMetadata The object of the invite to update in the cache. Returns typing.Tuple[typing.Optional[hikari.invites.InviteWithMetadata], typing.Optional[hikari.invites.InviteWithMetadata A tuple of the old cached invite object if found (else builtins.None ) and the new cached invite object if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_me", "u": 43, "d": "Remove the own user object from the cache. Returns typing.Optional[hikari.users.OwnUser] The own user object that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_me", "u": 43, "d": "Get the own user object from the cache. Returns typing.Optional[hikari.users.OwnUser] The own user object that was found in the cache, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_me", "u": 43, "d": "Set the own user object in the cache. Parameters user : hikari.users.OwnUser The own user object to set in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.update_me", "u": 43, "d": "Update the own user entry in the cache. Parameters user : hikari.users.OwnUser The own user object to update in the cache. Returns typing.Tuple[typing.Optional[hikari.users.OwnUser], typing.Optional[hikari.users.OwnUser A tuple of the old cached own user object if found (else builtins.None ) and the new cached own user object if it could be cached, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_members", "u": 43, "d": "Remove all the guild members in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_members_for_guild", "u": 43, "d": "Remove the members for a specific guild from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove cached members for. ! note This will skip members that are being referenced by other entries in the cache; a matching voice state will keep a member entry alive. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the member objects that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_member", "u": 43, "d": "Remove a member object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove a member from the cache for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to remove a member from the cache for. ! note You cannot delete a member entry that's being referenced by other entries in the cache; a matching voice state will keep a member entry alive. Returns typing.Optional[hikari.guilds.Member] The object of the member that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_member", "u": 43, "d": "Get a member object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get a cached member for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get a cached member for. Returns typing.Optional[hikari.guilds.Member] The object of the member found in the cache, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_members_view", "u": 43, "d": "Get a view of all the members objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were found from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_members_view_for_guild", "u": 43, "d": "Get a view of the members cached for a specific guild. Parameters guild_id : hikari.snowflakes.Snowflakeish The ID of the guild to get the cached member view for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the members cached for the specified guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_member", "u": 43, "d": "Add a member object to the cache. Parameters member : hikari.guilds.Member The object of the member to add to the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.update_member", "u": 43, "d": "Update a member in the cache. Parameters member : hikari.guilds.Member The object of the member to update in the cache. Returns typing.Tuple[typing.Optional[hikari.guilds.Member], typing.Optional[hikari.guilds.Member A tuple of the old cached member object if found (else builtins.None ) and the new cached member object if it could be cached (else builtins.None )", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_presences", "u": 43, "d": "Remove all the presences in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence A view of guild IDs to views of user IDs to objects of the presences that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_presences_for_guild", "u": 43, "d": "Remove the presences in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove presences for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presences that were removed from the cache for the specified guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_presence", "u": 43, "d": "Remove a presence from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove a presence for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to remove a presence for. Returns typing.Optional[hikari.presences.MemberPresence] The object of the presence that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_presence", "u": 43, "d": "Get a presence object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get a presence for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get a presence for. Returns typing.Optional[hikari.presences.MemberPresence] The object of the presence that was found in the cache or builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_presences_view", "u": 43, "d": "Get a view of all the presence objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake A view of guild IDs to views of user IDs to objects of the presences found in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_presences_view_for_guild", "u": 43, "d": "Get a view of the presence objects in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached presence objects for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presence found in the cache for the specified guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_presence", "u": 43, "d": "Add a presence object to the cache. Parameters presence : hikari.presences.MemberPresence The object of the presence to add to the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.update_presence", "u": 43, "d": "Update a presence object in the cache. Parameters presence : hikari.presences.MemberPresence The object of the presence to update in the cache. Returns typing.Tuple[typing.Optional[hikari.presences.MemberPresence], typing.Optional[hikari.presences.MemberPresence A tuple of the old cached invite object if found (else builtins.None and the new cached invite object if it could be cached ( else builtins.None ).", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_roles", "u": 43, "d": "Remove all role objects from the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_roles_for_guild", "u": 43, "d": "Remove role objects from the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove roles for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were removed from the cache for the specific guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_role", "u": 43, "d": "Remove a role object form the cache. Parameters role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] Object or ID of the role to remove from the cache. Returns typing.Optional[hikari.guilds.Role] The object of the role that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_role", "u": 43, "d": "Get a role object from the cache. Parameters role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] Object or ID of the role to get from the cache. Returns typing.Optional[hikari.guilds.Role] The object of the role found in the cache or builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_roles_view", "u": 43, "d": "Get a view of all the role objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles found in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_roles_view_for_guild", "u": 43, "d": "Get a view of the roles in the cache for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached roles for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were found in the cache for the specified guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_role", "u": 43, "d": "Add a role object to the cache. Parameters role : hikari.guilds.Role The object of the role to add to the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.update_role", "u": 43, "d": "Update a role in the cache. Parameters role : hikari.guilds.Role The object of the role to update in the cache. Returns typing.Tuple[typing.Optional[hikari.guilds.Role], typing.Optional[hikari.guilds.Role A tuple of the old cached role object if found (else builtins.None and the new cached role object if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_user", "u": 43, "d": "Get a user object from the cache. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get from the cache. Returns typing.Optional[hikari.users.User] The object of the user that was found in the cache, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_users_view", "u": 43, "d": "Get a view of the user objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.users.User] The view of user IDs to the users found in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_voice_states", "u": 43, "d": "Remove all voice state objects from the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were removed from the states.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_voice_states_for_channel", "u": 43, "d": "Remove the voice state objects cached for a specific channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove voice states for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the channel to remove voice states for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice state that were removed from the cache for the specified channel.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_voice_states_for_guild", "u": 43, "d": "Clear the voice state objects cached for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to remove cached voice states for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to the voice state objects that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_voice_state", "u": 43, "d": "Remove a voice state object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild the voice state to remove is related to.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user who the voice state to remove belongs to. Returns typing.Optional[hikari.voices.VoiceState] The object of the voice state that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_voice_state", "u": 43, "d": "Get a voice state object from the cache. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get a voice state for.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to get a voice state for. Returns typing.Optional[hikari.voices.VoiceState] The object of the voice state that was found in the cache, or builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_voice_states_view", "u": 43, "d": "Get a view of all the voice state objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were found in the cache,", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_voice_states_view_for_channel", "u": 43, "d": "Get a view of the voice states cached for a specific channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached voice states for.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] Object or ID of the channel to get the cached voice states for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified channel.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_voice_states_view_for_guild", "u": 43, "d": "Get a view of the voice states cached for a specific guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to get the cached voice states for. Returns CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified guild.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_voice_state", "u": 43, "d": "Add a voice state object to the cache. Parameters voice_state : hikari.voices.VoiceState The object of the voice state to add to the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.update_voice_state", "u": 43, "d": "Update a voice state object in the cache. Parameters voice_state : hikari.voices.VoiceState The object of the voice state to update in the cache. Returns typing.Tuple[typing.Optional[hikari.voices.VoiceState], typing.Optional[hikari.voices.VoiceState A tuple of the old cached voice state if found (else builtins.None ) and the new cached voice state object if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.clear_messages", "u": 43, "d": "Remove all message objects from the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.messages.Message] A view of message objects that were removed from the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.delete_message", "u": 43, "d": "Remove a message object from the cache. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] Object or ID of the messages to remove the cache. Returns typing.Optional[hikari.messages.Message] The object of the message that was removed from the cache if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_message", "u": 43, "d": "Get a message object from the cache. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] Object or ID of the message to get from the cache. Returns typing.Optional[hikari.messages.Message] The object of the message found in the cache or builtins.None .", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.get_messages_view", "u": 43, "d": "Get a view of all the message objects in the cache. Returns CacheView[hikari.snowflakes.Snowflake, hikari.messages.Message] A view of message objects found in the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.set_message", "u": 43, "d": "Add a message object to the cache. Parameters message : hikari.messages.Message The object of the message to add to the cache.", "f": 1}, {"r": "hikari.impl.cache.CacheImpl.update_message", "u": 43, "d": "Update a message in the cache. Parameters message : typing.Union[hikari.messages.PartialMessage, hikari.messages.Message] The object of the message to update in the cache. Returns typing.Tuple[typing.Optional[hikari.messages.Message], typing.Optional[hikari.messages.Message A tuple of the old cached message object if found (else builtins.None ) and the new cached message object if it could be cached (else builtins.None ).", "f": 1}, {"r": "hikari.impl.entity_factory", "u": 44, "d": "Basic implementation of an entity factory for general bots and HTTP apps."}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl", "u": 44, "d": "Standard implementation for a serializer/deserializer. This will convert objects to/from JSON compatible representations."}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_own_connection", "u": 44, "d": "Parse a raw payload from Discord into an own connection object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.OwnConnection The deserialized \"own connection\" object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_own_guild", "u": 44, "d": "Parse a raw payload from Discord into an own guild object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.OwnGuild The deserialized \"own guild\" object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_application", "u": 44, "d": "Parse a raw payload from Discord into an application object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.Application The deserialized application object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_authorization_information", "u": 44, "d": "Parse a raw payload from Discord into an authorization information object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.AuthorizationInformation The deserialized authorization information object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_partial_token", "u": 44, "d": "Parse a raw payload from Discord into a partial OAuth2 token object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.PartialOAuth2Token The deserialized partial OAuth2 token object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_authorization_token", "u": 44, "d": "Parse a raw payload from Discord into an authorization token object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.applications.OAuth2AuthorizationToken The deserialized OAuth2 authorization token object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_implicit_token", "u": 44, "d": "Parse a query from Discord into an implicit token object. Parameters query : hikari.internal.data_binding.Query The query parameters to deserialize. Returns hikari.applications.OAuth2ImplicitToken The deserialized OAuth2 implicit token object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_audit_log", "u": 44, "d": "Parse a raw payload from Discord into an audit log object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.audit_logs.AuditLog The deserialized audit log object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_channel_follow", "u": 44, "d": "Parse a raw payload from Discord into a channel follow object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.channels.ChannelFollow The deserialized channel follow object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_permission_overwrite", "u": 44, "d": "Parse a raw payload from Discord into a permission overwrite object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.channels.PermissionOverwrite The deserialized permission overwrite object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.serialize_permission_overwrite", "u": 44, "d": "Serialize a permission overwrite object to a json serializable dict. Parameters overwrite : hikari.channels.PermissionOverwrite The permission overwrite object to serialize. Returns hikari.internal.data_binding.JSONObject The serialized representation of the permission overwrite.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_partial_channel", "u": 44, "d": "Parse a raw payload from Discord into a partial channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.channels.PartialChannel The deserialized \"partial channel\" object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_dm", "u": 44, "d": "Parse a raw payload from Discord into a DM channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.channels.DMChannel The deserialized DM channel object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_group_dm", "u": 44, "d": "Parse a raw payload from Discord into a group DM channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.channels.GroupDMChannel The deserialized group DM object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_category", "u": 44, "d": "Parse a raw payload from Discord into a guild category object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is not included in the channel's payload. Returns hikari.channels.GuildCategory The deserialized guild category object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_text_channel", "u": 44, "d": "Parse a raw payload from Discord into a guild text channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is not included in the channel's payload. Returns hikari.channels.GuildTextChannel The deserialized guild text channel object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_news_channel", "u": 44, "d": "Parse a raw payload from Discord into a guild news channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is not included in the channel's payload. Returns hikari.channels.GuildNewsChannel The deserialized guild news channel object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_store_channel", "u": 44, "d": "Parse a raw payload from Discord into a guild store channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is not included in the channel's payload. Returns hikari.channels.GuildStoreChannel The deserialized guild store channel object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_voice_channel", "u": 44, "d": "Parse a raw payload from Discord into a guild voice channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is npt included in the channel's payload. Returns hikari.channels.GuildVoiceChannel The deserialized guild voice channel object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_stage_channel", "u": 44, "d": "Parse a raw payload from Discord into a guild stage channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over \"guild_id\" in the payload. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is npt included in the channel's payload. Returns hikari.channels.GuildStageChannel The deserialized guild stage channel object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_channel", "u": 44, "d": "Parse a raw payload from Discord into a channel object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. This will be ignored for DM and group DM channels and will be prioritised over \"guild_id\" in the payload when passed. ! note guild_id currently only covers the gateway GUILD_CREATE event where \"guild_id\" is not included in the channel's payload. Returns hikari.channels.PartialChannel The deserialized partial channel-derived object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload of a guild channel.\nhikari.errors.UnrecognisedEntityError If the channel type is unknown.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_embed", "u": 44, "d": "Parse a raw payload from Discord into an embed object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.embeds.Embed The deserialized embed object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.serialize_embed", "u": 44, "d": "Serialize an embed object to a json serializable dict. Parameters embed : hikari.embeds.Embed The embed object to serialize. Returns typing.Tuple[hikari.internal.data_binding.JSONObject, typing.List[hikari.files.Resource A tuple with two items in it. The first item will be the serialized embed representation. The second item will be a list of resources to upload with the embed.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_unicode_emoji", "u": 44, "d": "Parse a raw payload from Discord into a unicode emoji object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.emojis.UnicodeEmoji The deserialized unicode emoji object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_custom_emoji", "u": 44, "d": "Parse a raw payload from Discord into a custom emoji object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.emojis.CustomEmoji The deserialized custom emoji object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_known_custom_emoji", "u": 44, "d": "Parse a raw payload from Discord into a known custom emoji object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize.\nguild_id : hikari.snowflakes.Snowflake The ID of the guild this emoji belongs to. This is used to ensure that the guild a known custom emoji belongs to is remembered by allowing for a context based artificial guild_id attribute. Returns hikari.emojis.KnownCustomEmoji The deserialized \"known custom emoji\" object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_emoji", "u": 44, "d": "Parse a raw payload from Discord into an emoji object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.emojis.UnicodeEmoji or hikari.emojis.CustomEmoji The deserialized custom or unicode emoji object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_gateway_bot_info", "u": 44, "d": "Parse a raw payload from Discord into a gateway bot object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.sessions.GatewayBotInfo The deserialized gateway bot information object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_widget", "u": 44, "d": "Parse a raw payload from Discord into a guild widget object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.GuildWidget The deserialized guild widget object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_welcome_screen", "u": 44, "d": "Parse a raw payload from Discord into a guild welcome screen object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.WelcomeScreen The deserialized guild welcome screen object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.serialize_welcome_channel", "u": 44, "d": "Serialize a welcome channel object to a json serializable dict. Parameters welcome_channel : hikari.guilds.WelcomeChannel The guild welcome channel object to serialize. Returns hikari.internal.data_binding.JSONObject The serialized representation of the welcome channel.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_member", "u": 44, "d": "Parse a raw payload from Discord into a member object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters user : hikari.undefined.UndefinedOr[hikari.users.User] The user to attach to this member, should only be passed in situations where \"user\" is not included in the payload.\nguild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this member belongs to. If this is specified then this will be prioritised over \"guild_id\" in the payload. ! note guild_id covers cases such as the GUILD_CREATE gateway event and GET Guild Member where \"guild_id\" is not included in the returned payload. Returns hikari.guilds.Member The deserialized member object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_role", "u": 44, "d": "Parse a raw payload from Discord into a role object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize.\nguild_id : hikari.snowflakes.Snowflake The ID of the guild this role belongs to. This is used to ensure that the guild a role belongs to is remembered by allowing for a context based artificial guild_id attribute. Returns hikari.guilds.Role The deserialized role object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_partial_integration", "u": 44, "d": "Parse a raw payload from Discord into a partial integration object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.PartialIntegration The deserialized partial integration object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_integration", "u": 44, "d": "Parse a raw payload from Discord into an integration object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this integration belongs to. If this is specified then this will be prioritised over \"guild_id\" in the payload. Returns hikari.guilds.Integration The deserialized integration object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload for the payload of the integration.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_member_ban", "u": 44, "d": "Parse a raw payload from Discord into a guild member ban object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.GuildBan The deserialized guild member ban object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_preview", "u": 44, "d": "Parse a raw payload from Discord into a guild preview object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.GuildPreview The deserialized guild preview object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_rest_guild", "u": 44, "d": "Parse a raw payload from Discord into a guild object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.guilds.RESTGuild The deserialized guild object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_gateway_guild", "u": 44, "d": "Parse a raw payload from Discord into a guild object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns GatewayGuildDefinition The deserialized guild object and the internal collections as maps of hikari.snowflakes.Snowflake mapping to hikari.channels.GuildChannel , hikari.guilds.Member , hikari.presences.MemberPresence , hikari.guilds.Role , and hikari.emojis.KnownCustomEmoji . This is provided in several components to allow separate caching and linking between entities in various relational cache implementations internally.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_vanity_url", "u": 44, "d": "Parse a raw payload from Discord into a vanity url object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.invites.VanityURL The deserialized vanity url object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_invite", "u": 44, "d": "Parse a raw payload from Discord into an invite object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.invites.Invite The deserialized invite object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_invite_with_metadata", "u": 44, "d": "Parse a raw payload from Discord into a invite with metadata object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.invites.InviteWithMetadata The deserialized invite with metadata object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_command", "u": 44, "d": "Parse a raw payload from Discord into a command object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.Snowflake] The ID of the guild this command belongs to. If this is specified then this will be prioritised over \"guild_id\" in the payload. Returns hikari.commands.Command The deserialized command object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload for the payload of the integration.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_command_permissions", "u": 44, "d": "Parse a raw payload from Discord into guild command permissions object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.commands.GuildCommandPermissions The deserialized guild command permissions object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.serialize_command_permission", "u": 44, "d": "Serialize a command permission object to a json serializable dict. Parameters permission: hikari.commands.CommandPermission The command permission object to serialize. Returns hikari.internal.data_binding.JSONObject The serialized representation of the command permission.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_partial_interaction", "u": 44, "d": "Parse a raw payload from Discord into a partial interaction object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.interactions.base_interactions.PartialInteraction The deserialized partial interaction object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_command_interaction", "u": 44, "d": "Parse a raw payload from Discord into a command interaction object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.interactions.command_interactions.CommandInteraction The deserialized command interaction object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_interaction", "u": 44, "d": "Parse a raw payload from Discord into a interaction object. ! note This isn't required to implement logic for deserializing PING interactions and if you want to unmarshal those EntityFactory.deserialize_partial_interaction should be compatible. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.interactions.base_interactions.PartialInteraction The deserialized interaction object. Raises hikari.errors.UnrecognisedEntityError If the integration type is unknown.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.serialize_command_option", "u": 44, "d": "Serialize a command option object to a json serializable dict. Parameters option: hikari.commands.CommandOption The command option object to serialize. Returns hikari.internal.data_binding.JSONObject The serialized representation of the command option.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_component_interaction", "u": 44, "d": "Parser a raw payload from Discord into a component interaction object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.interactions.component_interactions.ComponentInteraction The deserialized component interaction.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_sticker_pack", "u": 44, "d": "Parse a raw payload from Discord into a sticker pack object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.stickers.StickerPack The deserialized sticker pack object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_partial_sticker", "u": 44, "d": "Parse a raw payload from Discord into a partial sticker object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.stickers.PartialSticker The deserialized partial sticker object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_standard_sticker", "u": 44, "d": "Parse a raw payload from Discord into a standard sticker object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.stickers.StandardSticker The deserialized standard sticker object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_sticker", "u": 44, "d": "Parse a raw payload from Discord into a guild sticker object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.stickers.GuildSticker The deserialized guild sticker object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_action_row", "u": 44, "d": "Parse a raw payload from Discord into an action row component object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.ActionRowComponent The deserialized action row component.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_button", "u": 44, "d": "Parse a raw payload from Discord into a button component object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.ButtonComponent The deserialized button component.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_select_menu", "u": 44, "d": "Parse a raw payload from Discord into a select menu component object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.SelectMenuComponent The deserialized button component.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_component", "u": 44, "d": "Parse a raw payload from Discord into a message component object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.PartialComponent The deserialized message component.\nhikari.errors.UnrecognisedEntityError If the message component type isn't recognised.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_partial_message", "u": 44, "d": "Parse a raw payload from Discord into a partial message object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.PartialMessage The deserialized partial message object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_message", "u": 44, "d": "Parse a raw payload from Discord into a message object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.messages.Message The deserialized message object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_member_presence", "u": 44, "d": "Parse a raw payload from Discord into a member presence object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild the presence belongs to. If this is specified then it is prioritised over guild_id in the payload. ! note At the time of writing, the only place where guild_id will be mandatory is when parsing presences sent in a GUILD_CREATE event from Discord, since the guild_id attribute in the payload will have been omitted for redundancy. Returns hikari.presences.MemberPresence The deserialized member presence object. Raises builtins.KeyError If guild_id is not an attribute of the payload dict, and no guild ID was passed for the guild_id parameter. If this is raised, no guild ID info was provided anywhere.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_template", "u": 44, "d": "Parse a raw payload from Discord into a template object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.templates.Template The deserialized template object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_user", "u": 44, "d": "Parse a raw payload from Discord into a user object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.users.User The deserialized user object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_my_user", "u": 44, "d": "Parse a raw payload from Discord into a user object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.users.OwnUser The deserialized user object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_voice_state", "u": 44, "d": "Parse a raw payload from Discord into a voice state object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this voice state belongs to. If this is specified then this will be prioritised over \"guild_id\" in the payload.\nmember : hikari.undefined.UndefinedOr[hikari.guilds.Member] The object of the member this voice state belongs to. If this is specified then this will be prioritised over \"member\" in the payload. ! note At the time of writing, GUILD_CREATE events are the only known place where neither guild_id nor member will be keys on the payload. In this case, you will need to provide the former parameters explicitly. Returns hikari.voices.VoiceState The deserialized voice state object. Raises builtins.KeyError If guild_id is left as hikari.undefined.UNDEFINED when \"guild_id\" is not present in the passed payload for the payload of the voice state. This will also be raised if no member data was passed in any acceptable place.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_voice_region", "u": 44, "d": "Parse a raw payload from Discord into a voice region object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.voices.VoiceRegion The deserialized voice region object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_incoming_webhook", "u": 44, "d": "Parse a raw payload from Discord into a incoming webhook object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.webhooks.IncomingWebhook The parsed incoming webhook object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_channel_follower_webhook", "u": 44, "d": "Parse a raw payload from Discord into a channel follower webhook object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.webhooks.ChannelFollowerWebhook The parsed channel follower webhook object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_application_webhook", "u": 44, "d": "Parse a raw payload from Discord into an application webhook object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.webhooks.ApplicationWebhook The parsed application webhook object.", "f": 1}, {"r": "hikari.impl.entity_factory.EntityFactoryImpl.deserialize_webhook", "u": 44, "d": "Parse a raw payload from Discord into a webhook object. Parameters payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns hikari.webhooks.PartialWebhook The deserialized webhook object.", "f": 1}, {"r": "hikari.impl.rate_limits", "u": 45, "d": "Basic lazy ratelimit systems for asyncio. See hikari.impl.buckets for HTTP-specific rate-limiting logic."}, {"r": "hikari.impl.rate_limits.BaseRateLimiter", "u": 45, "d": "Base for any asyncio-based rate limiter being used."}, {"r": "hikari.impl.rate_limits.BaseRateLimiter.acquire", "u": 45, "d": "Acquire permission to perform a task that needs to have rate limit management enforced. Calling this function will cause it to block until you are not longer\nbeing rate limited.", "f": 1}, {"r": "hikari.impl.rate_limits.BaseRateLimiter.close", "u": 45, "d": "Close the rate limiter, cancelling any internal tasks that are executing.", "f": 1}, {"r": "hikari.impl.rate_limits.BurstRateLimiter", "u": 45, "d": "Base implementation for a burst-based rate limiter. This provides an internal queue and throttling placeholder, as well as\ncomplete logic for safely aborting any pending tasks when being shut down."}, {"r": "hikari.impl.rate_limits.BurstRateLimiter.acquire", "u": 45, "d": "Acquire time on this rate limiter. Calling this function will cause it to block until you are not longer\nbeing rate limited.", "f": 1}, {"r": "hikari.impl.rate_limits.BurstRateLimiter.close", "u": 45, "d": "Close the rate limiter, and shut down any pending tasks. Once this is invoked, you should not reuse this object.", "f": 1}, {"r": "hikari.impl.rate_limits.BurstRateLimiter.is_empty", "u": 45, "d": "Return builtins.True if no futures are on the queue being rate limited."}, {"r": "hikari.impl.rate_limits.BurstRateLimiter.name", "u": 45, "d": "The name of the rate limiter."}, {"r": "hikari.impl.rate_limits.BurstRateLimiter.queue", "u": 45, "d": "The queue of any futures under a rate limit."}, {"r": "hikari.impl.rate_limits.BurstRateLimiter.throttle_task", "u": 45, "d": "The throttling task, or builtins.None if it is not running."}, {"r": "hikari.impl.rate_limits.ManualRateLimiter", "u": 45, "d": "Rate limit handler for the global HTTP rate limit. This is a non-preemptive rate limiting algorithm that will always return\ncompleted futures until ManualRateLimiter.throttle is invoked. Once this\nis invoked, any subsequent calls to ManualRateLimiter.acquire will return\nincomplete futures that will be enqueued to an internal queue. A task will\nbe spun up to wait for a period of time given to the ManualRateLimiter.throttle . Once that has passed, the lock will begin to\nre-consume incomplete futures on the queue, completing them. Triggering a throttle when it is already set will cancel the current\nthrottle task that is sleeping and replace it. This is used to enforce the global HTTP rate limit that will occur\n\"randomly\" during HTTP API interaction. Expect random occurrences."}, {"r": "hikari.impl.rate_limits.ManualRateLimiter.acquire", "u": 45, "d": "Acquire time on this rate limiter. Calling this function will cause it to block until you are not longer\nbeing rate limited.", "f": 1}, {"r": "hikari.impl.rate_limits.ManualRateLimiter.throttle", "u": 45, "d": "Perform the throttling rate limiter logic. Iterates repeatedly while the queue is not empty, adhering to any\nrate limits that occur in the mean time. Parameters retry_after : builtins.float How long to sleep for before unlocking and releasing any futures in the queue. ! note This will invoke ManualRateLimiter.unlock_later as a scheduled task in the future (it will not await it to finish). When the ManualRateLimiter.unlock_later coroutine function completes, it should be expected to set the throttle_task to builtins.None . This means you can check if throttling is occurring by checking if throttle_task is not builtins.None . If this is invoked while another throttle is in progress, that one is cancelled and a new one is started. This enables new rate limits to override existing ones.", "f": 1}, {"r": "hikari.impl.rate_limits.ManualRateLimiter.unlock_later", "u": 45, "d": "Sleeps for a while, then removes the lock. Parameters retry_after : builtins.float How long to sleep for before unlocking and releasing any futures in the queue. ! note You should not need to invoke this directly. Call ManualRateLimiter.throttle instead. When the ManualRateLimiter.unlock_later coroutine function completes, it should be expected to set the throttle_task to builtins.None . This means you can check if throttling is occurring by checking if throttle_task is not builtins.None .", "f": 1}, {"r": "hikari.impl.rate_limits.ManualRateLimiter.close", "u": 45, "d": "Close the rate limiter, and shut down any pending tasks. Once this is invoked, you should not reuse this object.", "f": 1}, {"r": "hikari.impl.rate_limits.ManualRateLimiter.is_empty", "u": 45, "d": "Return builtins.True if no futures are on the queue being rate limited."}, {"r": "hikari.impl.rate_limits.ManualRateLimiter.name", "u": 45, "d": "The name of the rate limiter."}, {"r": "hikari.impl.rate_limits.ManualRateLimiter.queue", "u": 45, "d": "The queue of any futures under a rate limit."}, {"r": "hikari.impl.rate_limits.ManualRateLimiter.throttle_task", "u": 45, "d": "The throttling task, or builtins.None if it is not running."}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter", "u": 45, "d": "Windowed burst rate limiter. Rate limiter for rate limits that last fixed periods of time with a\nfixed number of times it can be used in that time frame. To use this, you should call WindowedBurstRateLimiter.aquire and await the\nresult immediately before performing your rate-limited task. If the rate limit has been hit, acquiring time will return an incomplete\nfuture that is placed on the internal queue. A throttle task is then spun up\nif not already running that will be expected to provide some implementation\nof backing off and sleeping for a given period of time until the limit has\npassed, and then proceed to consume futures from the queue while adhering\nto those rate limits. If the throttle task is already running, the acquired future will always be\nincomplete and enqueued regardless of whether the rate limit is actively\nreached or not. Acquiring a future from this limiter when no throttling task is running and\nwhen the rate limit is not reached will always result in the task invoking\na drip and a completed future being returned. Dripping is left to the implementation of this class, but will be expected\nto provide some mechanism for updating the internal statistics to represent\nthat a unit has been placed into the bucket."}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.acquire", "u": 45, "d": "Acquire time on this rate limiter. Calling this function will cause it to block until you are not longer\nbeing rate limited.", "f": 1}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.get_time_until_reset", "u": 45, "d": "Determine how long until the current rate limit is reset. Parameters now : builtins.float The monotonic time.monotonic_timestamp timestamp. ! warning Invoking this method will update the internal state if we were previously rate limited, but at the given time are no longer under that limit. This makes it imperative that you only pass the current timestamp to this function, and not past or future timestamps. The effects of doing the latter are undefined behaviour. Returns builtins.float The time left to sleep before the rate limit is reset. If no rate limit is in effect, then this will return 0.0 instead.", "f": 1}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.is_rate_limited", "u": 45, "d": "Determine if we are under a rate limit at the given time. Parameters now : builtins.float The monotonic time.monotonic_timestamp timestamp. Returns builtins.bool builtins.True if we are being rate limited, or builtins.False if we are not. ! warning Invoking this method will update the internal state if we were previously rate limited, but at the given time are no longer under that limit. This makes it imperative that you only pass the current timestamp to this function, and not past or future timestamps. The effects of doing the latter are undefined behaviour.", "f": 1}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.drip", "u": 45, "d": "Decrements the remaining counter.", "f": 1}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.throttle", "u": 45, "d": "Perform the throttling rate limiter logic. Iterates repeatedly while the queue is not empty, adhering to any\nrate limits that occur in the mean time. ! note You should usually not need to invoke this directly, but if you do, ensure to call it using asyncio.create_task , and store the task immediately in throttle_task . When this coroutine function completes, it will set the throttle_task to builtins.None . This means you can check if throttling is occurring by checking if throttle_task is not builtins.None .", "f": 1}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.limit", "u": 45, "d": "The maximum number of WindowedBurstRateLimiter.acquire 's allowed in\nthis time window."}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.period", "u": 45, "d": "How long the window lasts for from the start in seconds."}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.remaining", "u": 45, "d": "The number of WindowedBurstRateLimiter.acquire 's left in this window\nbefore you will get rate limited."}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.reset_at", "u": 45, "d": "The time.monotonic_timestamp that the limit window ends at."}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.close", "u": 45, "d": "Close the rate limiter, and shut down any pending tasks. Once this is invoked, you should not reuse this object.", "f": 1}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.is_empty", "u": 45, "d": "Return builtins.True if no futures are on the queue being rate limited."}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.name", "u": 45, "d": "The name of the rate limiter."}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.queue", "u": 45, "d": "The queue of any futures under a rate limit."}, {"r": "hikari.impl.rate_limits.WindowedBurstRateLimiter.throttle_task", "u": 45, "d": "The throttling task, or builtins.None if it is not running."}, {"r": "hikari.impl.rate_limits.ExponentialBackOff", "u": 45, "d": "Implementation of an asyncio-compatible exponential back-off algorithm with random jitter. math t_{backoff} = b^{i} + m \\cdot \\mathrm{rand}() Such that \\(t_{backoff}\\) is the backoff time, \\(b\\) is the base,\n\\(i\\) is the increment that increases by 1 for each invocation, and\n\\(m\\) is the jitter multiplier. \\(\\mathrm{rand}()\\) returns a value in\nthe range \\([0,1]\\). Parameters base : builtins.float The base to use. Defaults to 2.0 .\nmaximum : builtins.float The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter.\njitter_multiplier : builtins.float The multiplier for the random jitter. Defaults to 1.0 . Set to 0 to disable jitter.\ninitial_increment : builtins.int The initial increment to start at. Defaults to 0 . Raises ValueError If an builtins.int that's too big to be represented as a builtins.float or a non-finite value is passed in place of a field that's annotated as builtins.float ."}, {"r": "hikari.impl.rate_limits.ExponentialBackOff.reset", "u": 45, "d": "Reset the exponential back-off.", "f": 1}, {"r": "hikari.impl.rate_limits.ExponentialBackOff.base", "u": 45, "d": "The base to use. Defaults to 2.0."}, {"r": "hikari.impl.rate_limits.ExponentialBackOff.increment", "u": 45, "d": "The current increment."}, {"r": "hikari.impl.rate_limits.ExponentialBackOff.jitter_multiplier", "u": 45, "d": "The multiplier for the random jitter. This defaults to 1.0 . Set to 0.0 to disable jitter."}, {"r": "hikari.impl.rate_limits.ExponentialBackOff.maximum", "u": 45, "d": "This is the max value the backoff can be in a single iteration before an asyncio.TimeoutError is raised."}, {"r": "hikari.impl.special_endpoints", "u": 46, "d": "Special endpoint implementations. You should never need to make any of these objects manually."}, {"r": "hikari.impl.special_endpoints.ActionRowBuilder", "u": 46, "d": "Standard implementation of hikari.api.special_endpoints.ActionRowBuilder . Method generated by attrs for class ActionRowBuilder."}, {"r": "hikari.impl.special_endpoints.ActionRowBuilder.components", "u": 46, "d": "Sequence of the component builders registered within this action row. Returns typing.Sequence[ComponentBuilder] Sequence of the component builders registered within this action row."}, {"r": "hikari.impl.special_endpoints.ActionRowBuilder.add_component", "u": 46, "d": "", "f": 1}, {"r": "hikari.impl.special_endpoints.ActionRowBuilder.add_button", "u": 46, "d": "Add a button component to this action row builder. Parameters style : typing.Union[builtins.int, hikari.messages.ButtonStyle] The button's style.\nurl_or_custom_id : builtins.str For interactive button styles this is a developer-defined custom identifier used to identify which button triggered component interactions. For Link button styles this is the URL the link button should redirect to. Returns ButtonBuilder[Self] Button builder object. ButtonBuilder.add_to_container should be called to finalise the button.", "f": 1}, {"r": "hikari.impl.special_endpoints.ActionRowBuilder.add_select_menu", "u": 46, "d": "Add a select menu component to this action row builder. Parameters custom_id : builtins.str A developer-defined custom identifier used to identify which menu triggered component interactions. Returns SelectMenuBuilder[Self] Select menu builder object. SelectMenuBuilder.add_to_container should be called to finalise the button.", "f": 1}, {"r": "hikari.impl.special_endpoints.ActionRowBuilder.build", "u": 46, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.CommandBuilder", "u": 46, "d": "Standard implementation of hikari.api.special_endpoints.CommandBuilder . Method generated by attrs for class CommandBuilder."}, {"r": "hikari.impl.special_endpoints.CommandBuilder.description", "u": 46, "d": "Return the description to set for this command. ! warning This should be inclusively between 1-100 characters in length. Returns builtins.str The description to set for this command."}, {"r": "hikari.impl.special_endpoints.CommandBuilder.id", "u": 46, "d": "ID of this command. Returns hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of this command if set."}, {"r": "hikari.impl.special_endpoints.CommandBuilder.default_permission", "u": 46, "d": "Whether the command should be enabled by default (without any permissions). Defaults to builtins.bool . Returns undefined.UndefinedOr[builtins.bool] Whether the command should be enabled by default (without any permissions)."}, {"r": "hikari.impl.special_endpoints.CommandBuilder.options", "u": 46, "d": "Sequence of up to 25 of the options set for this command. Returns typing.Sequence[hikari.commands.CommandOption] A sequence of up to 25 of the options set for this command."}, {"r": "hikari.impl.special_endpoints.CommandBuilder.name", "u": 46, "d": "Name to set for this command. ! warning This should match the regex ^[a-z0-9_-]{1,32}$ . Returns builtins.str The name to set for this command."}, {"r": "hikari.impl.special_endpoints.CommandBuilder.add_option", "u": 46, "d": "Add an option to this command. ! note A command can have up to 25 options. Parameters option : hikari.commands.CommandOption The option to add to this command. Returns CommandBuilder Object of this command builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.CommandBuilder.set_id", "u": 46, "d": "Set the ID of this command. Parameters id_ : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID to set for this command. Returns CommandBuilder Object of this command builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.CommandBuilder.set_default_permission", "u": 46, "d": "Whether this command should be enabled by default (without any permissions). Parameters state : hikari.undefined.UndefinedOr[builtins.bool] Whether this command should be enabled by default. Returns CommandBuilder Object of this command builder for chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.CommandBuilder.build", "u": 46, "d": "Build a JSON object from this builder. Parameters entity_factory : hikari.api.entity_factory.EntityFactory The entity factory to use to serialize entities within this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.TypingIndicator", "u": 46, "d": "Result type of hikari.api.rest.RESTClient.trigger_typing . This is an object that can either be awaited like a coroutine to trigger\nthe typing indicator once, or an async context manager to keep triggering\nthe typing indicator repeatedly until the context finishes. ! note This is a helper class that is used by hikari.api.rest.RESTClient . You should only ever need to use instances of this class that are produced by that API."}, {"r": "hikari.impl.special_endpoints.GuildBuilder", "u": 46, "d": "Result type of hikari.api.rest.RESTClient.guild_builder . This is used to create a guild in a tidy way using the HTTP API, since\nthe logic behind creating a guild on an API level is somewhat confusing\nand detailed. ! note This is a helper class that is used by hikari.api.rest.RESTClient . You should only ever need to use instances of this class that are produced by that API, thus, any details about the constructor are omitted from the following examples for brevity. Examples Creating an empty guild. py\nguild = await rest.guild_builder(\"My Server!\").create() Creating a guild with an icon py\nfrom hikari.files import WebResourceStream guild_builder = rest.guild_builder(\"My Server!\")\nguild_builder.icon = WebResourceStream(\"cat.png\", \"http:  .\")\nguild = await guild_builder.create() Adding roles to your guild. py\nfrom hikari.permissions import Permissions guild_builder = rest.guild_builder(\"My Server!\") everyone_role_id = guild_builder.add_role(\"@everyone\")\nadmin_role_id = guild_builder.add_role(\"Admins\", permissions=Permissions.ADMINISTRATOR) await guild_builder.create()  ! warning The first role must always be the @everyone role. ! note If you call add_role , the default roles provided by discord will be created. This also applies to the add_ functions for text channels/voice channels/categories. ! note Functions that return a hikari.snowflakes.Snowflake do not provide the final ID that the object will have once the API call is made. The returned IDs are only able to be used to re-reference particular objects while building the guild format. This is provided to allow creation of channels within categories, and to provide permission overwrites. Adding a text channel to your guild. py\nguild_builder = rest.guild_builder(\"My Server!\") category_id = guild_builder.add_category(\"My safe place\")\nchannel_id = guild_builder.add_text_channel(\"general\", parent_id=category_id) await guild_builder.create() Method generated by attrs for class GuildBuilder."}, {"r": "hikari.impl.special_endpoints.GuildBuilder.name", "u": 46, "d": "Name of the guild to create. Returns builtins.str The guild name."}, {"r": "hikari.impl.special_endpoints.GuildBuilder.create", "u": 46, "d": "Send the request to Discord to create the guild. The application user will be added to this guild as soon as it is\ncreated. All IDs that were provided when building this guild will\nbecome invalid and will be replaced with real IDs. Returns hikari.guilds.RESTGuild The created guild. Raises hikari.errors.BadRequestError If any values set in the guild builder are invalid.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are already in 10 guilds.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.special_endpoints.GuildBuilder.add_role", "u": 46, "d": "Create a role. ! warning The first role you create must always be the @everyone role. Parameters name : builtins.str The role's name. Other Parameters permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the permissions for the role.\ncolor : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the role's color.\ncolour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for color .\nhoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role.\nmentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.snowflakes.Snowflake The dummy ID for this role that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID. Raises builtins.ValueError If you are defining the first role, but did not name it @everyone .\nbuiltins.TypeError If you specify both color and colour together or if you try to specify color , colour , hoisted , mentionable or position for the @everyone role.", "f": 1}, {"r": "hikari.impl.special_endpoints.GuildBuilder.add_category", "u": 46, "d": "Create a category channel. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category. Returns hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.", "f": 1}, {"r": "hikari.impl.special_endpoints.GuildBuilder.add_text_channel", "u": 46, "d": "Create a text channel. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[builtins.int] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. Returns hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.", "f": 1}, {"r": "hikari.impl.special_endpoints.GuildBuilder.add_voice_channel", "u": 46, "d": "Create a voice channel. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. Returns hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.", "f": 1}, {"r": "hikari.impl.special_endpoints.GuildBuilder.add_stage_channel", "u": 46, "d": "Create a stage channel. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. Returns hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.", "f": 1}, {"r": "hikari.impl.special_endpoints.GuildBuilder.default_message_notifications", "u": 46, "d": "Default message notification level that can be overwritten. If not overridden, this will use the Discord default level. Returns hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] The default message notification level, if overwritten."}, {"r": "hikari.impl.special_endpoints.GuildBuilder.explicit_content_filter_level", "u": 46, "d": "Explicit content filter level that can be overwritten. If not overridden, this will use the Discord default level. Returns hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] The explicit content filter level, if overwritten."}, {"r": "hikari.impl.special_endpoints.GuildBuilder.icon", "u": 46, "d": "Guild icon to use that can be overwritten. If not overridden, the guild will not have an icon. Returns hikari.undefined.UndefinedOr[hikari.files.Resourceish] The guild icon to use, if overwritten."}, {"r": "hikari.impl.special_endpoints.GuildBuilder.verification_level", "u": 46, "d": "Verification level required to join the guild that can be overwritten. If not overridden, the guild will use the default verification level for Returns hikari.undefined.UndefinedOr[typing.Union[hikari.guilds.GuildVerificationLevel, builtins.int The verification level required to join the guild, if overwritten."}, {"r": "hikari.impl.special_endpoints.InteractionDeferredBuilder", "u": 46, "d": "Standard implementation of hikari.api.special_endpoints.InteractionDeferredBuilder . Parameters type : hikari.interactions.base_interactions.DeferredResponseTypesT The type of interaction response this is. Method generated by attrs for class InteractionDeferredBuilder."}, {"r": "hikari.impl.special_endpoints.InteractionDeferredBuilder.type", "u": 46, "d": "Return the type of this response. Returns hikari.interactions.base_interactions.DeferredResponseTypesT The type of response this is."}, {"r": "hikari.impl.special_endpoints.InteractionDeferredBuilder.flags", "u": 46, "d": "Message flags this response should have. ! note As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . Returns typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The message flags this response should have if set else hikari.undefined.UNDEFINED ."}, {"r": "hikari.impl.special_endpoints.InteractionDeferredBuilder.set_flags", "u": 46, "d": "Set message flags for this response. ! note As of writing, the only message flag which can be set is EPHEMERAL. Parameters flags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The message flags to set for this response. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractionDeferredBuilder.build", "u": 46, "d": "Build a JSON object from this builder. Parameters entity_factory : hikari.api.entity_factory.EntityFactory The entity factory to use to serialize entities within this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder", "u": 46, "d": "Standard implementation of hikari.api.special_endpoints.InteractionMessageBuilder . Parameters type : hikari.interactions.base_interactions.MessageResponseTypesT The type of interaction response this is. Other Parameters content : hikari.undefined.UndefinedOr[builtins.str] The content of this response, if supplied. This follows the same rules as \"content\" on create message. Method generated by attrs for class InteractionMessageBuilder."}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.content", "u": 46, "d": "Response's message content. Returns hikari.undefined.UndefinedOr[builtins.str] The response's message content, if set."}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.embeds", "u": 46, "d": "Sequence of up to 10 of the embeds included in this response. Returns typing.Sequence[hikari.embeds.Embed] A sequence of up to 10 of the embeds included in this response."}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.flags", "u": 46, "d": "Message flags this response should have. ! note As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL . Returns typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The message flags this response should have if set else hikari.undefined.UNDEFINED ."}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.is_tts", "u": 46, "d": "Whether this response's content should be treated as text-to-speech. Returns builtins.bool Whether this response's content should be treated as text-to-speech. If left as hikari.undefined.UNDEFINED then this will be disabled."}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.mentions_everyone", "u": 46, "d": "Whether @everyone and @here mentions should be enabled for this response. Returns hikari.undefined.UndefinedOr[builtins.bool] Whether @everyone mentions should be enabled for this response. If left as hikari.undefined.UNDEFINED then they will be disabled."}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.role_mentions", "u": 46, "d": "Whether and what role mentions should be enabled for this response. Returns hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Either a sequence of object/IDs of the roles mentions should be enabled for, builtins.False or hikari.undefined.UNDEFINED to disallow any role mentions or True to allow all role mentions."}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.type", "u": 46, "d": "Return the type of this response. Returns hikari.interactions.base_interactions.MessageResponseTypesT The type of response this is."}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.user_mentions", "u": 46, "d": "Whether and what user mentions should be enabled for this response. Returns hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Either a sequence of object/IDs of the users mentions should be enabled for, builtins.False or hikari.undefined.UNDEFINED to disallow any user mentions or True to allow all user mentions."}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.add_embed", "u": 46, "d": "Add an embed to this response. Parameters embed : hikari.embeds.Embed Object of the embed to add to this response. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.set_content", "u": 46, "d": "Set the response's message content. Parameters content : hikari.undefined.UndefinedOr[builtins.str] The message content to set for this response. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.set_flags", "u": 46, "d": "Set message flags for this response. ! note As of writing, the only message flag which can be set is EPHEMERAL. Parameters flags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The message flags to set for this response. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.set_tts", "u": 46, "d": "Set whether this response should trigger text-to-speech processing. Parameters tts : Whether this response should trigger text-to-speech processing. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.set_mentions_everyone", "u": 46, "d": "Set whether this response should be able to mention @everyone/@here. Parameters mentions : hikari.undefined.UndefinedOr[builtins.bool] Whether this response should be able to mention @everyone/@here. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.set_role_mentions", "u": 46, "d": "Set whether and what role mentions should be possible for this response. Parameters mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Either a sequence of object/IDs of the roles mentions should be enabled for, builtins.False or hikari.undefined.UNDEFINED to disallow any role mentions or True to allow all role mentions. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.set_user_mentions", "u": 46, "d": "Set whether and what user mentions should be possible for this response. Parameters mentions: hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Either a sequence of object/IDs of the users mentions should be enabled for, builtins.False or hikari.undefined.UNDEFINED to disallow any user mentions or True to allow all user mentions. Returns InteractionMessageBuilder Object of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractionMessageBuilder.build", "u": 46, "d": "Build a JSON object from this builder. Parameters entity_factory : hikari.api.entity_factory.EntityFactory The entity factory to use to serialize entities within this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder", "u": 46, "d": "Builder class for interactive buttons. Method generated by attrs for class InteractiveButtonBuilder."}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder.custom_id", "u": 46, "d": "Developer set custom ID used for identifying interactions with this button. Returns builtins.str Developer set custom ID used for identifying interactions with this button."}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder.style", "u": 46, "d": "Button's style. Returns typing.Union[builtins.int, hikari.messages.ButtonStyle] The button's style."}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder.emoji", "u": 46, "d": "Emoji which should appear on this button. Returns typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object or ID or raw string of the emoji which should be displayed on this button if set."}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder.label", "u": 46, "d": "Text label which should appear on this button. ! note The text label to that should appear on this button. This may be up to 80 characters long. Returns hikari.undefined.UndefinedOr[builtins.str] Text label which should appear on this button."}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder.is_disabled", "u": 46, "d": "Whether the button should be marked as disabled. ! note Defaults to builtins.False . Returns builtins.bool Whether the button should be marked as disabled."}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder.set_emoji", "u": 46, "d": "Set the emoji to display on this button. Parameters emoji : typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object, ID or raw string of the emoji which should be displayed on this button. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder.set_label", "u": 46, "d": "Set the text label which should be displayed on this button. Parameters label : hikari.undefined.UndefinedOr[builtins.str] The text label to show on this button. This may be up to 80 characters long. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder.set_is_disabled", "u": 46, "d": "Set whether this button should be disabled. Parameters state : bool Whether this button should be disabled. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder.add_to_container", "u": 46, "d": "Add this button to the container component it belongs to. This is used as the finalising call during chained calls. Returns _ContainerT The container component that owns this button.", "f": 1}, {"r": "hikari.impl.special_endpoints.InteractiveButtonBuilder.build", "u": 46, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder", "u": 46, "d": "Builder class for link buttons. Method generated by attrs for class LinkButtonBuilder."}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder.url", "u": 46, "d": "Url this button should link to when pressed. Returns builtins.str Url this button should link to when pressed."}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder.style", "u": 46, "d": "Button's style. Returns typing.Union[builtins.int, hikari.messages.ButtonStyle] The button's style."}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder.emoji", "u": 46, "d": "Emoji which should appear on this button. Returns typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object or ID or raw string of the emoji which should be displayed on this button if set."}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder.label", "u": 46, "d": "Text label which should appear on this button. ! note The text label to that should appear on this button. This may be up to 80 characters long. Returns hikari.undefined.UndefinedOr[builtins.str] Text label which should appear on this button."}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder.is_disabled", "u": 46, "d": "Whether the button should be marked as disabled. ! note Defaults to builtins.False . Returns builtins.bool Whether the button should be marked as disabled."}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder.set_emoji", "u": 46, "d": "Set the emoji to display on this button. Parameters emoji : typing.Union[hikari.snowflakes.Snowflakeish, hikari.emojis.Emoji, builtins.str, hikari.undefined.UndefinedType] Object, ID or raw string of the emoji which should be displayed on this button. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder.set_label", "u": 46, "d": "Set the text label which should be displayed on this button. Parameters label : hikari.undefined.UndefinedOr[builtins.str] The text label to show on this button. This may be up to 80 characters long. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder.set_is_disabled", "u": 46, "d": "Set whether this button should be disabled. Parameters state : bool Whether this button should be disabled. Returns ButtonBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder.add_to_container", "u": 46, "d": "Add this button to the container component it belongs to. This is used as the finalising call during chained calls. Returns _ContainerT The container component that owns this button.", "f": 1}, {"r": "hikari.impl.special_endpoints.LinkButtonBuilder.build", "u": 46, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder", "u": 46, "d": "Builder class for select menus. Method generated by attrs for class SelectMenuBuilder."}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.custom_id", "u": 46, "d": "Developer set custom ID used for identifying interactions with this menu. Returns builtins.str Developer set custom ID used for identifying interactions with this menu."}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.is_disabled", "u": 46, "d": "Whether the select menu should be marked as disabled. ! note Defaults to builtins.False . Returns builtins.bool Whether the select menu should be marked as disabled."}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.options", "u": 46, "d": "Sequence of the options set for this select menu. Returns typing.Sequence[SelectOptionBuilder[Self Sequence of the options set for this select menu."}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.placeholder", "u": 46, "d": "Return the placeholder text to display when no options are selected. Returns hikari.undefined.UndefinedOr[builtins.str] Placeholder text to display when no options are selected, if defined."}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.min_values", "u": 46, "d": "Minimum number of options which must be chosen. Defaults to 1.\nMust be greater than or equal to SelectMenuBuilder.min_values and less\nthan or equal to 25. Returns builtins.str Minimum number of options which must be chosen."}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.max_values", "u": 46, "d": "Maximum number of options which must be chosen. Defaults to 1.\nMust be greater than or equal to SelectMenuBuilder.max_values and\ngreater than or equal to 0. Returns builtins.str Maximum number of options which must be chosen."}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.add_option", "u": 46, "d": "Add an option to this menu. Parameters label : builtins.str The user-facing name of this option, max 100 characters.\nvalue : builtins.str The developer defined value of this option, max 100 characters. Returns SelectOptionBuilder[Self] Option builder object. This should be finalised by calling SelectOptionBuilder.add_to_menu .", "f": 1}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.add_raw_option", "u": 46, "d": "", "f": 1}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.set_is_disabled", "u": 46, "d": "Set whether this option is disabled. Defaults to builtins.False . Parameters state : builtins.bool Whether this option is disabled. Returns SelectMenuBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.set_placeholder", "u": 46, "d": "Set place-holder text to be shown when no option is selected. Parameters value : hikari.undefined.UndefinedOr[builtins.str] Place-holder text to be displayed when no option is selected. Max 100 characters. Returns SelectMenuBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.set_min_values", "u": 46, "d": "Set the minimum amount of options which need to be selected for this menu. ! note This defaults to 1 if not set and can be greater than or equal to 0 and less than or equal to SelectMenuBuilder.max_values . Parameters value : builtins.int The minimum amount of options which need to be selected for this menu. Returns SelectMenuBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.set_max_values", "u": 46, "d": "Set the maximum amount of options which need to be selected for this menu. ! note This defaults to 1 if not set and can be less than or equal to 25 and greater than or equal to SelectMenuBuilder.min_values . Parameters value : builtins.int The maximum amount of options which need to be selected for this menu. Returns SelectMenuBuilder The builder object to enable chained calls.", "f": 1}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.add_to_container", "u": 46, "d": "Finalise this builder by adding it to its parent container component. Returns _ContainerT The parent container component builder.", "f": 1}, {"r": "hikari.impl.special_endpoints.SelectMenuBuilder.build", "u": 46, "d": "Build a JSON object from this builder. Returns hikari.internal.data_binding.JSONObject The built json object representation of this builder.", "f": 1}, {"r": "hikari.impl.event_manager", "u": 47, "d": "Event handling logic for more info."}, {"r": "hikari.impl.event_manager.EventManagerImpl", "u": 47, "d": "Provides event handling logic for Discord events."}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_ready", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway ready for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_resumed", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway resumed for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_channel_create", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway channel-create for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_channel_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway channel-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_channel_delete", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway channel-delete for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_channel_pins_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway channel-pins-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_create", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-create for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_delete", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-delete for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_ban_add", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-ban-add for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_ban_remove", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-ban-remove for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_emojis_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-emojis-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_integrations_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-integrations-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_integration_create", "u": 47, "d": "", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_integration_delete", "u": 47, "d": "", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_integration_update", "u": 47, "d": "", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_member_add", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-member-add for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_member_remove", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-member-remove for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_member_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-member-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_members_chunk", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-members-chunk for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_role_create", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-role-create for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_role_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-role-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_guild_role_delete", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway guild-role-delete for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_invite_create", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway invite-create for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_invite_delete", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway invite-delete for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_message_create", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway message-create for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_message_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway message-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_message_delete", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway message-delete for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_message_delete_bulk", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway message-delete-bulk for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_message_reaction_add", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway message-reaction-add for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_message_reaction_remove", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway message-reaction-remove for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_message_reaction_remove_all", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway message-reaction-remove-all for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_message_reaction_remove_emoji", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway message-reaction-remove-emoji for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_presence_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway presence-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_typing_start", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway typing-start for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_user_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway user-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_voice_state_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway voice-state-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_voice_server_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway voice-server-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_webhooks_update", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway webhooks-update for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.on_interaction_create", "u": 47, "d": "See https: discord.com/developers/docs/topics/gateway interaction-create for more info.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.consume_raw_event", "u": 47, "d": "Consume a raw event. Parameters event_name : str The case-insensitive name of the event being triggered.\nshard : hikari.api.shard.GatewayShard Object of the shard that received this event.\npayload : hikari.internal.data_binding.JSONObject Payload of the event being triggered. Raises builtins.LookupError If there is no consumer for the event.", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.subscribe", "u": 47, "d": "Subscribe a given callback to a given event type. Parameters event_type : typing.Type[T] The event type to listen for. This will also listen for any subclasses of the given type. T must be a subclass of hikari.events.base_events.Event .\ncallback Must be a coroutine function to invoke. This should consume an instance of the given event, or an instance of a valid subclass if one exists. Any result is discarded. Example The following demonstrates subscribing a callback to message creation\nevents. py\nfrom hikari.events.messages import MessageCreateEvent async def on_message(event): . bot.subscribe(MessageCreateEvent, on_message) See Also Listen: hikari.api.event_manager.EventManager.listen Stream: hikari.api.event_manager.EventManager.stream Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.get_listeners", "u": 47, "d": "Get the listeners for a given event type, if there are any. Parameters event_type : typing.Type[T] The event type to look for. T must be a subclass of hikari.events.base_events.Event .\npolymorphic : builtins.bool If builtins.True , this will also return the listeners of the subclasses of the given event type. If builtins.False , then only listeners for this class specifically are returned. The default is builtins.True . Returns typing.Collection[typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None A copy of the collection of listeners for the event. Will return an empty collection if nothing is registered. T must be a subclass of hikari.events.base_events.Event . See Also Has listener: hikari.api.event_manager.EventManager.has_listener ", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.unsubscribe", "u": 47, "d": "Unsubscribe a given callback from a given event type, if present. Parameters event_type : typing.Type[T] The event type to unsubscribe from. This must be the same exact type as was originally subscribed with to be removed correctly. T must derive from hikari.events.base_events.Event .\ncallback The callback to unsubscribe. Example The following demonstrates unsubscribing a callback from a message\ncreation event. py\nfrom hikari.events.messages import MessageCreateEvent async def on_message(event): . bot.unsubscribe(MessageCreateEvent, on_message) ", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.listen", "u": 47, "d": "Generate a decorator to subscribe a callback to an event type. This is a second-order decorator. Parameters event_type : typing.Optional[typing.Type[T The event type to subscribe to. The implementation may allow this to be undefined. If this is the case, the event type will be inferred instead from the type hints on the function signature. T must be a subclass of hikari.events.base_events.Event . Returns typing.Callable T], T] A decorator for a coroutine function that passes it to EventManager.subscribe before returning the function reference. See Also Dispatch: hikari.api.event_manager.EventManager.dispatch Stream: hikari.api.event_manager.EventManager.stream Subscribe: hikari.api.event_manager.EventManager.subscribe Unsubscribe: hikari.api.event_manager.EventManager.unsubscribe Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.dispatch", "u": 47, "d": "Dispatch an event. Parameters event : hikari.events.base_events.Event The event to dispatch. Example We can dispatch custom events by first defining a class that\nderives from hikari.events.base_events.Event . py\nimport attr from hikari.traits import RESTAware\nfrom hikari.events.base_events import Event\nfrom hikari.users import User\nfrom hikari.snowflakes import Snowflake @attr.define()\nclass EveryoneMentionedEvent(Event): app: RESTAware = attr.field() author: User = attr.field() 'The user who mentioned everyone. ' content: str = attr.field() 'The message that was sent. ' message_id: Snowflake = attr.field() 'The message ID. ' channel_id: Snowflake = attr.field() 'The channel ID. ' We can then dispatch our event as we see fit. py\nfrom hikari.events.messages import MessageCreateEvent @bot.listen(MessageCreateEvent)\nasync def on_message(event): if \"@everyone\" in event.content or \"@here\" in event.content: event = EveryoneMentionedEvent( author=event.author, content=event.content, message_id=event.id, channel_id=event.channel_id, ) bot.dispatch(event) This event can be listened to elsewhere by subscribing to it with EventManager.subscribe . py\n@bot.listen(EveryoneMentionedEvent)\nasync def on_everyone_mentioned(event): print(event.user, \"just pinged everyone in\", event.channel_id) Returns asyncio.Future[typing.Any] A future that can be optionally awaited. If awaited, the future will complete once all corresponding event listeners have been invoked. If not awaited, this will schedule the dispatch of the events in the background for later. See Also Subscribe: hikari.api.event_manager.EventManager.subscribe Stream: hikari.api.event_manager.EventManager.stream Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.stream", "u": 47, "d": "Return a stream iterator for the given event and sub-events. Parameters event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally.\ntimeout : typing.Optional[builtins.int, builtins.float] How long this streamer should wait for the next event before ending the iteration. If builtins.None then this will continue until explicitly broken from.\nlimit : typing.Optional[builtins.int] The limit for how many events this should queue at one time before dropping extra incoming events, leave this as builtins.None for the cache size to be unlimited. Returns EventStream[hikari.events.base_events.Event] The async iterator to handle streamed events. This must be started with async with stream: or await stream.open() before asynchronously iterating over it. ! warning If you use await stream.open() to start the stream then you must also close it with await stream.close() otherwise it may queue events in memory indefinitely. Examples  \nasync with bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id as stream: async for user_id in stream.map(\"user_id\").limit(50): . or using await open() and await close()  \nstream = bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id await stream.open() async for user_id in stream.map(\"user_id\").limit(50) . await stream.close() See Also Dispatch: hikari.api.event_manager.EventManager.dispatch Listen: hikari.api.event_manager.EventManager.listen Subscribe: hikari.api.event_manager.EventManager.subscribe Unsubscribe: hikari.api.event_manager.EventManager.unsubscribe Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.impl.event_manager.EventManagerImpl.wait_for", "u": 47, "d": "Wait for a given event to occur once, then return the event. Parameters event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally.\npredicate A function taking the event as the single parameter. This should return builtins.True if the event is one you want to return, or builtins.False if the event should not be returned. If left as None (the default), then the first matching event type that the bot receives (or any subtype) will be the one returned. ! warning Async predicates are not supported.\ntimeout : typing.Union[builtins.float, builtins.int, builtins.None] The amount of time to wait before raising an asyncio.TimeoutError and giving up instead. This is measured in seconds. If builtins.None , then no timeout will be waited for (no timeout can result in \"leaking\" of coroutines that never complete if called in an uncontrolled way, so is not recommended). Returns hikari.events.base_events.Event The event that was provided. Raises asyncio.TimeoutError If the timeout is not builtins.None and is reached before an event is received that the predicate returns builtins.True for. See Also Listen: hikari.api.event_manager.EventManager.listen Stream: hikari.api.event_manager.EventManager.stream Subscribe: hikari.api.event_manager.EventManager.subscribe Dispatch: hikari.api.event_manager.EventManager.dispatch ", "f": 1}, {"r": "hikari.impl.voice", "u": 48, "d": "Implementation of a simple voice management system."}, {"r": "hikari.impl.voice.VoiceComponentImpl", "u": 48, "d": "A standard voice component management implementation. This is the regular implementation you will generally use to connect to\nvoice channels with."}, {"r": "hikari.impl.voice.VoiceComponentImpl.is_alive", "u": 48, "d": "Whether this component is alive."}, {"r": "hikari.impl.voice.VoiceComponentImpl.disconnect", "u": 48, "d": "Disconnect from a given guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.Guild] The guild to disconnect from.", "f": 1}, {"r": "hikari.impl.voice.VoiceComponentImpl.disconnect_all", "u": 48, "d": "Disconnect all the active voice connections.", "f": 1}, {"r": "hikari.impl.voice.VoiceComponentImpl.close", "u": 48, "d": "Shut down all connections, waiting for them to terminate. Once this is done, unsubscribe from any events. If you simply wish to disconnect every connection, use disconnect instead.", "f": 1}, {"r": "hikari.impl.voice.VoiceComponentImpl.start", "u": 48, "d": "Start this voice component.", "f": 1}, {"r": "hikari.impl.voice.VoiceComponentImpl.connect_to", "u": 48, "d": "Connect to a given voice channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.Guild] The guild to connect to.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel] The channel or channel ID to connect to.\nvoice_connection_type : typing.Type[VoiceConnection] The type of voice connection to use. This should be initialized internally using the VoiceConnection.initialize  builtins.classmethod .\ndeaf : builtins.bool Defaulting to builtins.False , if builtins.True , the client will enter the voice channel deafened (thus unable to hear other users).\nmute : builtins.bool Defaulting to builtins.False , if builtins.True , the client will enter the voice channel muted (thus unable to send audio). kwargs : typing.Any Any arguments to provide to the VoiceConnection.initialize method. Returns VoiceConnection A voice connection implementation of some sort.", "f": 1}, {"r": "hikari.impl.voice.VoiceComponentImpl.connections", "u": 48, "d": "Return a mapping of guild-id to active voice connection."}, {"r": "hikari.impl.rest", "u": 49, "d": "Implementation of a V8 compatible REST API for Discord. This also includes implementations designed towards providing\nRESTful functionality."}, {"r": "hikari.impl.rest.ClientCredentialsStrategy", "u": 49, "d": "Strategy class for handling client credential OAuth2 authorization. Parameters client: typing.Optional[snowflakes.SnowflakeishOr[guilds.PartialApplication Object or ID of the application this client credentials strategy should authorize as.\nclient_secret : typing.Optional[builtins.str] Client secret to use when authorizing. Other Parameters scopes : typing.Sequence[str] The scopes to authorize for."}, {"r": "hikari.impl.rest.ClientCredentialsStrategy.client_id", "u": 49, "d": "ID of the application this token strategy authenticates with. Returns hikari.snowflakes.Snowflake ID of the application this token strategy authenticates with."}, {"r": "hikari.impl.rest.ClientCredentialsStrategy.scopes", "u": 49, "d": "Scopes this token strategy authenticates for. Returns typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, builtins.str The scopes this token strategy authenticates for."}, {"r": "hikari.impl.rest.ClientCredentialsStrategy.token_type", "u": 49, "d": "Type of token this strategy returns. Returns typing.Union[hikari.applications.TokenType, builtins.str] The type of token this strategy returns."}, {"r": "hikari.impl.rest.ClientCredentialsStrategy.acquire", "u": 49, "d": "Acquire an authorization token (including the prefix). Returns builtins.str The current authorization token to use for this client and it's prefix.", "f": 1}, {"r": "hikari.impl.rest.ClientCredentialsStrategy.invalidate", "u": 49, "d": "Invalidate the cached token in this handler. ! note token may be provided in-order to avoid newly generated tokens from being invalidated due to multiple calls being made by separate subroutines which are handling the same token. Parameters token : typing.Optional[builtins.str] The token to specifically invalidate. If provided then this will only invalidate the cached token if it matches this, otherwise it'll be invalidated regardless.", "f": 1}, {"r": "hikari.impl.rest.RESTApp", "u": 49, "d": "The base for a HTTP-only Discord application. This comprises of a shared TCP connector connection pool, and can have RESTClientImpl instances for specific credentials acquired\nfrom it. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to use for blocking file IO operations. If builtins.None is passed, then the default concurrent.futures.ThreadPoolExecutor for the asyncio.AbstractEventLoop will be used instead.\nhttp_settings : typing.Optional[hikari.config.HTTPSettings] HTTP settings to use. Sane defaults are used if this is builtins.None .\nmax_rate_limit : builtins.float Maximum number of seconds to sleep for when rate limited. If a rate limit occurs that is longer than this value, then a hikari.errors.RateLimitedError will be raised instead of waiting. This is provided since some endpoints may respond with non-sensible rate limits. Defaults to five minutes if unspecified.\nmax_retries : typing.Optional[builtins.int] Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to builtins.None .\nproxy_settings : typing.Optional[hikari.config.ProxySettings] Proxy settings to use. If builtins.None then no proxy configuration will be used.\nurl : typing.Optional[builtins.str] The base URL for the API. You can generally leave this as being builtins.None and the correct default API base URL will be generated. ! note This event loop will be bound to a connector when the first call to acquire is made."}, {"r": "hikari.impl.rest.RESTApp.executor", "u": 49, "d": "Return the executor to use for blocking operations. This may return builtins.None if the default asyncio thread pool\nshould be used instead. Returns typing.Optional[concurrent.futures.Executor] The executor to use, or builtins.None to use the asyncio default instead."}, {"r": "hikari.impl.rest.RESTApp.http_settings", "u": 49, "d": ""}, {"r": "hikari.impl.rest.RESTApp.proxy_settings", "u": 49, "d": ""}, {"r": "hikari.impl.rest.RESTApp.acquire", "u": 49, "d": "Acquire an instance of this REST client. ! note The returned REST client should be started before it can be used, either by calling RESTClientImpl.start or by using it as an asynchronous context manager. Examples  \nrest_app = RESTApp() Using the returned client as a context manager to implicitly start and stop it.\nasync with rest_app.acquire(\"A token\", \"Bot\") as client: user = await client.fetch_my_user() Parameters token : typing.Union[builtins.str, builtins.None, hikari.api.rest.TokenStrategy] The bot or bearer token. If no token is to be used, this can be undefined.\ntoken_type : typing.Union[builtins.str, hikari.applications.TokenType, builtins.None] The type of token in use. This should only be passed when builtins.str is passed for token , can be \"Bot\" or \"Bearer\" and will be defaulted to \"Bearer\" in this situation. This should be left as builtins.None when either hikari.api.rest.TokenStrategy or builtins.None is passed for token . Returns RESTClientImpl An instance of the REST client. Raises builtins.ValueError If token_type is provided when a token strategy is passed for token .", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl", "u": 49, "d": "Implementation of the V8-compatible Discord HTTP API. This manages making HTTP/1.1 requests to the API and using the entity\nfactory within the passed application instance to deserialize JSON responses\nto Pythonic data classes that are used throughout this library. Parameters entity_factory : hikari.api.entity_factory.EntityFactory The entity factory to use.\nexecutor : typing.Optional[concurrent.futures.Executor] The executor to use for blocking IO. Defaults to the asyncio thread pool if set to builtins.None .\nmax_rate_limit : builtins.float Maximum number of seconds to sleep for when rate limited. If a rate limit occurs that is longer than this value, then a hikari.errors.RateLimitedError will be raised instead of waiting. This is provided since some endpoints may respond with non-sensible rate limits.\nmax_retries : typing.Optional[builtins.int] Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to builtins.None .\ntoken : typing.Union[builtins.str, builtins.None, hikari.api.rest.TokenStrategy] The bot or bearer token. If no token is to be used, this can be undefined.\ntoken_type : typing.Union[builtins.str, hikari.applications.TokenType, builtins.None] The type of token in use. This must be passed when a builtins.str is passed for token but and can be \"Bot\" or \"Bearer\" . This should be left as builtins.None when either hikari.api.rest.TokenStrategy or builtins.None is passed for token .\nrest_url : builtins.str The HTTP API base URL. This can contain format-string specifiers to interpolate information such as API version in use. Raises builtins.ValueError If token_type is provided when a token strategy is passed for token . if token_type is left as builtins.None when a string is passed for token . If the a value more than 5 is provided for max_retries "}, {"r": "hikari.impl.rest.RESTClientImpl.is_alive", "u": 49, "d": "Whether this component is alive."}, {"r": "hikari.impl.rest.RESTClientImpl.http_settings", "u": 49, "d": "Return the HTTP settings in use by this component. Returns hikari.config.HTTPSettings The HTTP settings in use."}, {"r": "hikari.impl.rest.RESTClientImpl.proxy_settings", "u": 49, "d": "Return the proxy settings in use by this component. Returns hikari.config.ProxySettings The proxy settings in use."}, {"r": "hikari.impl.rest.RESTClientImpl.token_type", "u": 49, "d": "Type of token this client is using for most requests. Returns typing.Union[builtins.str, hikari.applications.TokenType, builtins.None] The type of token this client is using for most requests. If this is builtins.None then this client will likely only work for some endpoints such as public and webhook ones."}, {"r": "hikari.impl.rest.RESTClientImpl.close", "u": 49, "d": "Close the HTTP client and any open HTTP connections.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.start", "u": 49, "d": "Start the HTTP client. ! note This must be called within an active event loop. Raises RuntimeError If this is called in an environment without an active event loop.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_channel", "u": 49, "d": "Fetch a channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The channel to fetch. This may be the object or the ID of an existing channel. Returns hikari.channels.PartialChannel The channel. This will be a _derivative_ of hikari.channels.PartialChannel , depending on the type of channel you request for. This means that you may get one of hikari.channels.DMChannel , hikari.channels.GroupDMChannel , hikari.channels.GuildTextChannel , hikari.channels.GuildVoiceChannel , hikari.channels.GuildStoreChannel , hikari.channels.GuildNewsChannel . Likewise, the hikari.channels.GuildChannel can be used to determine if a channel is guild-bound, and hikari.channels.TextableChannel can be used to determine if the channel provides textual functionality to the application. You can check for these using the builtins.isinstance builtin function. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_channel", "u": 49, "d": "Edit a channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to edit. This may be the object or the ID of an existing channel. Other Parameters name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel.\nposition : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel.\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[builtins.str, hikari.voices.VoiceRegion If provided, the voice region to set for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel.\nparent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.PartialChannel The edited channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing permissions to edit the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.follow_channel", "u": 49, "d": "Follow a news channel to send messages to a target channel. Parameters news_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel] The object or ID of the news channel to follow.\ntarget_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The object or ID of the channel to target. Returns hikari.channels.ChannelFollow Information about the new relationship that was made. Raises hikari.errors.BadRequestError If you try to follow a channel that's not a news channel or if the target channel has reached it's webhook limit, which is 10 at the time of writing.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission in the target channel or are missing the VIEW_CHANNEL permission in the origin channel.\nhikari.errors.NotFoundError If the origin or target channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_channel", "u": 49, "d": "Delete a channel in a guild, or close a DM. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The channel to delete. This may be the object or the ID of an existing channel. Returns hikari.channels.PartialChannel Object of the channel that was deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_my_voice_state", "u": 49, "d": "Edit the current user's voice state in a stage channel. ! note The current user has to have already joined the target stage channel before any calls can be made to this endpoint. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or Id of the guild to edit a voice state in.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildStageChannel] Object or Id of the channel to edit a voice state in. Other Parameters suppress : hikari.undefined.UndefinedOr[builtins.bool] If specified, whether the user should be allowed to become a speaker in the target stage channel with builtin.True suppressing them from becoming one.\nrequest_to_speak : typing.Union[hikari.undefined.UndefinedType, builtins.bool, datetime.datetime] Whether to request to speak. This may be one of the following:  True to indicate that the bot wants to speak.  False to remove any previously set request to speak.  datetime.datetime to specify when they want their request to speak timestamp to be set to. ! note If a datetime from the past is passed then Discord will use the current time instead. Raises hikari.errors.BadRequestError If you try to target a non-staging channel.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MUTE_MEMBERS permission in the channel.\nhikari.errors.NotFoundError If the channel, message or voice state is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_voice_state", "u": 49, "d": "Edit an existing voice state in a stage channel. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or Id of the guild to edit a voice state in.\nchannel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildStageChannel] Object or Id of the channel to edit a voice state in.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or Id of the user to to edit the voice state of. Other Parameters suppress : hikari.undefined.UndefinedOr[builtins.bool] If defined, whether the user should be allowed to become a speaker in the target stage channel. ! note The target user must already be present in the stage channel before any calls are made to this endpoint. Raises hikari.errors.BadRequestError If you try to target a non-staging channel.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MUTE_MEMBERS permission in the channel.\nhikari.errors.NotFoundError If the channel, message or voice state is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_permission_overwrites", "u": 49, "d": "Edit permissions for a specific entity in the given guild channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to edit a permission overwrite in. This may be the object, or the ID of an existing channel.\ntarget : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int If provided, the type of the target to update. If unset, will attempt to get the type from target .\nallow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions.\ndeny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises builtins.TypeError If target_type is unset and we were unable to determine the type from target .\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_permission_overwrite", "u": 49, "d": "Delete a custom permission for an entity in a given guild channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to delete a permission overwrite in. This may be the object, or the ID of an existing channel.\ntarget : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_PERMISSIONS permission in the channel.\nhikari.errors.NotFoundError If the channel is not found or the target is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_channel_invites", "u": 49, "d": "Fetch all invites pointing to the given guild channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to fetch the invites from. This may be a channel object, or the ID of an existing channel. Returns typing.Sequence[hikari.invites.InviteWithMetadata] The invites pointing to the given guild channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found in any guilds you are a member of.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_invite", "u": 49, "d": "Create an invite to the given guild channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to create a invite for. This may be the object or the ID of an existing channel. Other Parameters max_age : hikari.undefined.UndefinedOr[typing.Union[datetime.timedelta, builtins.float, builtins.int If provided, the duration of the invite before expiry.\nmax_uses : hikari.undefined.UndefinedOr[builtins.int] If provided, the max uses the invite can have.\ntemporary : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the invite only grants temporary membership.\nunique : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the invite should be unique.\ntarget_type : hikari.undefined.UndefinedOr[hikari.invites.TargetType] If provided, the target type of this invite.\ntarget_user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser If provided, the target user id for this invite. This may be the object or the ID of an existing user. ! note This is required if target_type is STREAM and the targeted user must be streaming into the channel.\ntarget_application : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication If provided, the target application id for this invite. This may be the object or the ID of an existing application. ! note This is required if target_type is EMBEDDED_APPLICATION and the targeted application must have the EMBEDDED flag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.invites.InviteWithMetadata The invite to the given guild channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNELS permission.\nhikari.errors.NotFoundError If the channel is not found, or if the target user does not exist, if provided.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.trigger_typing", "u": 49, "d": "Trigger typing in a text channel. The result of this call can be awaited to trigger typing once, or\ncan be used as an async context manager to continually type until the\ncontext manager is left. Examples   Trigger typing just once.\nawait rest.trigger_typing(channel) Trigger typing repeatedly for 1 minute.\nasync with rest.trigger_typing(channel): await asyncio.sleep(60)  ! warning Sending a message to the channel will cause the typing indicator to disappear until it is re-triggered. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to trigger typing in. This may be the object or the ID of an existing channel. Returns hikari.api.special_endpoints.TypingIndicator A typing indicator to use. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise any of the above types.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_pins", "u": 49, "d": "Fetch the pinned messages in this text channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to fetch pins from. This may be the object or the ID of an existing channel. Returns typing.Sequence[hikari.messages.Message] The pinned messages in this text channel. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.pin_message", "u": 49, "d": "Pin an existing message in the given text channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to pin a message in. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to pin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES in the channel.\nhikari.errors.NotFoundError If the channel is not found, or if the message does not exist in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.unpin_message", "u": 49, "d": "Unpin a given message from a given text channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to unpin a message in. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to unpin. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.NotFoundError If the channel is not found or the message is not a pinned message in the given channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_messages", "u": 49, "d": "Browse the message history for a given text channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to fetch messages in. This may be the object or the ID of an existing channel. Other Parameters before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\nafter : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\naround : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns hikari.iterators.LazyIterator[hikari.messages.Message] An iterator to fetch the messages. ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See hikari.iterators for the full API for this iterator type. Raises builtins.TypeError If you specify more than one of before , after , about .\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint (other than builtins.TypeError ) will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything (other than builtins.TypeError ).", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_message", "u": 49, "d": "Fetch a specific message in the given text channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to fetch messages in. This may be the object or the ID of an existing message.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGE_HISTORY in the channel.\nhikari.errors.NotFoundError If the channel is not found or the message is not found in the given text channel.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_message", "u": 49, "d": "Create a message in the given channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to create the message in.\ncontent : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nnonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.\nreply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage If provided, the message to reply to.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if not being used with reply .\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions or if both attachment and attachments , component and components or embed and embeds are specified.\nbuiltins.TypeError If attachments , components or embeds is passed but is not a sequence.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; if reply is not found or not in the same channel as channel ; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.crosspost_message", "u": 49, "d": "Broadcast an announcement message. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel] The object or ID of the news channel to crosspost a message in.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The object or ID of the message to crosspost. Returns hikari.messages.Message The message object that was crossposted. Raises hikari.errors.BadRequestError If you tried to crosspost a message that has already been broadcast.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you try to crosspost a message by the current user without the SEND_MESSAGES permission for the target news channel or try to crosspost a message by another user without both the SEND_MESSAGES and MANAGE_MESSAGES permissions for the target channel.\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_message", "u": 49, "d": "Edit an existing message in a given channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to create the message in. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to edit. This may be the object or the ID of an existing message.\ncontent : hikari.undefined.UndefinedOr[typing.Any] If provided, the message content to update with. If hikari.undefined.UNDEFINED , then the content will not be changed. If builtins.None , then the content will be removed. Any other value will be cast to a builtins.str before sending. If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mention the author of the message that is being replied to. This will not do anything if message is not a reply message.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, sanitation for user mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , all valid user mentions will behave as mentions. If builtins.False , all valid user mentions will not behave as mentions. You may alternatively pass a collection of hikari.snowflakes.Snowflake user IDs, or hikari.users.PartialUser -derived objects.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, sanitation for role mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , all valid role mentions will behave as mentions. If builtins.False , all valid role mentions will not behave as mentions. You may alternatively pass a collection of hikari.snowflakes.Snowflake role IDs, or hikari.guilds.PartialRole -derived objects.\nflags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag] If provided, optional flags to set on the message. If hikari.undefined.UNDEFINED , then nothing is changed. Note that some flags may not be able to be set. Currently the only flags that can be set are NONE and SUPPRESS_EMBEDS . If you have MANAGE_MESSAGES permissions, you can use this call to suppress embeds on another user's message. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all four of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all four of them each time. ! warning If the message was not sent by your user, the only parameter you may provide to this call is the flags parameter. Anything else will result in a hikari.errors.ForbiddenError being raised. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If both attachment and attachments , component and components or embed and embeds are specified.\nbuiltins.TypeError If attachments , components or embeds is passed but is not a sequence.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the SEND_MESSAGES in the channel; if you try to change the contents of another user's message; or if you try to edit the flags on another user's message without the MANAGE_MESSAGES permission.\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_message", "u": 49, "d": "Delete a given message in a given channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to delete the message in. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES , and the message is not sent by you.\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_messages", "u": 49, "d": "Bulk-delete messages from the channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel to bulk delete the messages in. This may be the object or the ID of an existing channel.\nmessages : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], hikari.snowflakes.SnowflakeishIterable[hikari.messages.PartialMessage Either the object/ID of an existing message to delete or an iterable of the objects and/or IDs of existing messages to delete. Other Parameters  other_messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The objects and/or IDs of other existing messages to delete. ! note This API endpoint will only be able to delete 100 messages at a time. For anything more than this, multiple requests will be executed one-after-the-other, since the rate limits for this endpoint do not favour more than one request per bucket. If one message is left over from chunking per 100 messages, or only one message is passed to this coroutine function, then the logic is expected to defer to delete_message . The implication of this is that the delete_message endpoint is ratelimited by a different bucket with different usage rates. ! warning This endpoint is not atomic. If an error occurs midway through a bulk delete, you will not be able to revert any changes made up to this point. ! warning Specifying any messages more than 14 days old will cause the call to fail, potentially with partial completion. Raises hikari.errors.BulkDeleteError An error containing the messages successfully deleted, and the messages that were not removed. The builtins.BaseException.__cause__ of the exception will be the original error that terminated this process.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.add_reaction", "u": 49, "d": "Add a reaction emoji to a message in a given channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to add the reaction to is. This may be a hikari.channels.TextableChannel or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to add a reaction to. This may be the object or the ID of an existing message.\nemoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to react with. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to react with. This should only be provided when a custom emoji's name is passed for emoji . Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the ADD_REACTIONS (this is only necessary if you are the first person to add the reaction).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_my_reaction", "u": 49, "d": "Delete a reaction that your application user created. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to delete the reaction from is. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reaction from. This may be the object or the ID of an existing message.\nemoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to remove your reaction for. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to remove your reaction for. This should only be provided when a custom emoji's name is passed for emoji . Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_all_reactions_for_emoji", "u": 49, "d": "Delete all reactions for a single emoji on a given message. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to delete the reactions from is. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reactions from. This may be the object or the ID of an existing message.\nemoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to remove all the reactions for. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to remove all the reactions for. This should only be provided when a custom emoji's name is passed for emoji . Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_reaction", "u": 49, "d": "Delete a reaction from a message. If you are looking to delete your own applications reaction, use delete_my_reaction . Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to delete the reaction from is. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reaction from. This may be the object or the ID of an existing message.\nuser: hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] Object or ID of the user to remove the reaction of.\nemoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to react with. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to react with. This should only be provided when a custom emoji's name is passed for emoji . Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_all_reactions", "u": 49, "d": "Delete all reactions from a message. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to delete all reactions from is. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete all reaction from. This may be the object or the ID of an existing message. Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.ForbiddenError If you are missing the MANAGE_MESSAGES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_reactions_for_emoji", "u": 49, "d": "Fetch reactions for an emoji from a message. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel] The channel where the message to delete all reactions from is. This may be the object or the ID of an existing channel.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete all reaction from. This may be the object or the ID of an existing message.\nemoji : typing.Union[builtins.str, hikari.emojis.Emoji] Object or name of the emoji to get the reactions for. Other Parameters emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji ID of the custom emoji to get the reactions for. This should only be provided when a custom emoji's name is passed for emoji . Returns hikari.iterators.LazyIterator[hikari.users.User] An iterator to fetch the users. ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See hikari.iterators for the full API for this iterator type. Raises hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel or message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_webhook", "u": 49, "d": "Create webhook in a channel. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT] The channel where the webhook will be created. This may be the object or the ID of an existing channel.\nname : str The name for the webhook. This cannot be clyde . Other Parameters avatar : typing.Optional[hikari.files.Resourceish] If provided, the avatar for the webhook.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.webhooks.IncomingWebhook The created webhook. Raises hikari.errors.BadRequestError If name doesn't follow the restrictions enforced by discord.\nhikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_webhook", "u": 49, "d": "Fetch an existing webhook. Parameters webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook] The webhook to fetch. This may be the object or the ID of an existing webhook. Other Parameters token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to fetch the webhook instead of the token the client was initialized with. Returns hikari.webhooks.PartialWebhook The requested webhook. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission when not using a token.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_channel_webhooks", "u": 49, "d": "Fetch all channel webhooks. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT] The channel to fetch the webhooks for. This may be an instance of any of the classes which are valid for hikari.channels.WebhookChannelT or the ID of an existing channel. Returns typing.Sequence[hikari.webhooks.PartialWebhook] The fetched webhooks. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_guild_webhooks", "u": 49, "d": "Fetch all guild webhooks. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the webhooks for. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.webhooks.PartialWebhook] The fetched webhooks. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_webhook", "u": 49, "d": "Edit a webhook. Parameters webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook] The webhook to edit. This may be the object or the ID of an existing webhook. Other Parameters token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to edit the webhook instead of the token the client was initialized with.\nname : hikari.undefined.UndefinedOr[builtins.str] If provided, the new webhook name.\navatar : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new webhook avatar. If builtins.None , will remove the webhook avatar.\nchannel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT If provided, the text channel to move the webhook to.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.webhooks.PartialWebhook The edited webhook. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission when not using a token.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_webhook", "u": 49, "d": "Delete a webhook. Parameters webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook] The webhook to delete. This may be the object or the ID of an existing webhook. Other Parameters token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to delete the webhook instead of the token the client was initialized with. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_WEBHOOKS permission when not using a token.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhoook is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.execute_webhook", "u": 49, "d": "Execute a webhook. Parameters webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook] The webhook to execute. This may be the object or the ID of an existing webhook.\ntoken: builtins.str The webhook token.\ncontent : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor no embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters username : hikari.undefined.UndefinedOr[builtins.str] If provided, the username to override the webhook's username for this request.\navatar_url : hikari.undefined.UndefinedOr[builtins.str] If provided, the url of an image to override the webhook's avatar with for this request.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nnonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.\nflags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The flags to set for this webhook message. ! warning As of writing this can only be set for interaction webhooks and the only settable flag is EPHEMERAL; this field is just ignored for non-interaction webhooks. ! warning As of writing, username and avatar_url are ignored for interaction webhooks. ! note Attachments can be passed as many different things, to aid in convenience. - If a pathlib.PurePath or builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns hikari.messages.Message The created message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions or if both attachment and attachments or embed and embeds are specified.\nbuiltins.TypeError If attachments , or embeds is passed but is not a sequence.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_webhook_message", "u": 49, "d": "Fetch an old message sent by the webhook. Parameters webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook] The webhook to execute. This may be the object or the ID of an existing webhook.\ntoken: builtins.str The webhook token.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found or the webhook's message wasn't found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_webhook_message", "u": 49, "d": "Edit a message sent by a webhook. Parameters webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook] The webhook to execute. This may be the object or the ID of an existing webhook.\ntoken: builtins.str The webhook token.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message.\ncontent : hikari.undefined.UndefinedOr[typing.Any] If provided, the message content to update with. If hikari.undefined.UNDEFINED , then the content will not be changed. If builtins.None , then the content will be removed. Any other value will be cast to a builtins.str before sending. If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all three of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If both attachment and attachments , component and components or embed and embeds are specified.\nbuiltins.TypeError If attachments , components or embeds is passed but is not a sequence.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_webhook_message", "u": 49, "d": "Delete a given message in a given channel. Parameters webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook] The webhook to execute. This may be the object or the ID of an existing webhook.\ntoken: builtins.str The webhook token.\nmessage : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_gateway_url", "u": 49, "d": "Fetch the gateway url. ! note This endpoint does not require any valid authorization. Raises hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_gateway_bot_info", "u": 49, "d": "Fetch the gateway gateway info for the bot. Returns hikari.sessions.GatewayBotInfo The gateway bot information. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_invite", "u": 49, "d": "Fetch an existing invite. Parameters invite : typing.Union[hikari.invites.InviteCode, builtins.str] The invite to fetch. This may be an invite object or the code of an existing invite. Returns hikari.invites.Invite The requested invite. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the invite is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_invite", "u": 49, "d": "Delete an existing invite. Parameters invite : typing.Union[hikari.invites.InviteCode, builtins.str] The invite to delete. This may be an invite object or the code of an existing invite. Returns hikari.invites.Invite Object of the invite that was deleted. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission in the guild the invite is from or if you are missing the MANAGE_CHANNELS permission in the channel the invite is from.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the invite is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_my_user", "u": 49, "d": "Fetch the token's associated user. Returns hikari.users.OwnUser The token's associated user. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_my_user", "u": 49, "d": "Edit the token's associated user. Other Parameters username : undefined.UndefinedOr[builtins.str] If provided, the new username.\navatar : undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new avatar. If builtins.None , the avatar will be removed. Returns hikari.users.OwnUser The edited token's associated user. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Discord also returns this on a ratelimit: https: github.com/discord/discord-api-docs/issues/1462\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_my_connections", "u": 49, "d": "Fetch the token's associated connections. Returns hikari.applications.OwnConnection The token's associated connections. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_my_guilds", "u": 49, "d": "Fetch the token's associated guilds. Other Parameters newest_first : builtins.bool Whether to fetch the newest first or the olders first. Defaults to builtins.False .\nstart_at : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.guilds.PartialGuild If provided, will start at this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may also be a guild object. In this case, the date the object was first created will be used. Returns hikari.iterators.LazyIterator[hikari.applications.OwnGuild] The token's associated guilds. ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See hikari.iterators for the full API for this iterator type. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.leave_guild", "u": 49, "d": "Leave a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to leave. This may be the object or the ID of an existing guild. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found or you own the guild.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_dm_channel", "u": 49, "d": "Create a DM channel with a user. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to create the DM channel with. This may be the object or the ID of an existing user. Returns hikari.channels.DMChannel The created DM channel. Raises hikari.errors.BadRequestError If the user is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_application", "u": 49, "d": "Fetch the token's associated application. ! warning This endpoint can only be used with a Bot token. Using this with a Bearer token will result in a hikari.errors.UnauthorizedError . Returns hikari.applications.Application The token's associated application. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_authorization", "u": 49, "d": "Fetch the token's authorization information. ! warning This endpoint can only be used with a Bearer token. Using this with a Bot token will result in a hikari.errors.UnauthorizedError . Returns hikari.applications.AuthorizationInformation The token's authorization information. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.authorize_client_credentials_token", "u": 49, "d": "Authorize a client credentials token for an application. Parameters client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to authorize as.\nclient_secret : builtins.str Secret of the application to authorize as.\nscopes : typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, builtins.str The scopes to authorize for. Returns hikari.applications.PartialOAuth2Token Object of the authorized partial OAuth2 token. Raises hikari.errors.BadRequestError If invalid any invalid or malformed scopes are passed.\nhikari.errors.UnauthorizedError When an client or client secret is passed.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.authorize_access_token", "u": 49, "d": "Authorize an OAuth2 token using the authorize code grant type. Parameters client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to authorize with.\nclient_secret : builtins.str Secret of the application to authorize with.\ncode : builtins.str The authorization code to exchange for an OAuth2 access token.\nredirect_uri : builtins.str The redirect uri that was included in the authorization request. Returns hikari.applications.OAuth2AuthorizationToken Object of the authorized OAuth2 token. Raises hikari.errors.BadRequestError If an invalid redirect uri or code is passed.\nhikari.errors.UnauthorizedError When an client or client secret is passed.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.refresh_access_token", "u": 49, "d": "Refresh an access token. ! warning As of writing this Discord currently ignores any passed scopes, therefore you should use hikari.applications.OAuth2AuthorizationToken.scopes to validate that the expected scopes were actually authorized here. Parameters client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to authorize with.\nclient_secret : builtins.str Secret of the application to authorize with.\nrefresh_token : builtins.str The refresh token to use. Other Parameters scopes : typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, builtins.str The scope of the access request. Returns hikari.applications.OAuth2AuthorizationToken Object of the authorized OAuth2 token. Raises hikari.errors.BadRequestError If an invalid redirect uri or refresh_token is passed.\nhikari.errors.UnauthorizedError When an client or client secret is passed.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.revoke_access_token", "u": 49, "d": "Revoke an OAuth2 token. Parameters client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to authorize with.\nclient_secret : builtins.str Secret of the application to authorize with.\ntoken : typing.Union[builtins.str, hikari.applications.PartialOAuth2Token] Object or string of the access token to revoke. Raises hikari.errors.UnauthorizedError When an client or client secret is passed.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.add_user_to_guild", "u": 49, "d": "Add a user to a guild. ! note This requires the access_token to have the hikari.applications.OAuth2Scope.GUILDS_JOIN scope enabled along with the authorization of a Bot which has MANAGE_INVITES permission within the target guild. Parameters access_token : typing.Union[builtins.str, hikari.applications.PartialOAuth2Token] Object or string of the access token to use for this request.\nguild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to add the user to. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to add to the guild. This may be the object or the ID of an existing user. Other Parameters nick : hikari.undefined.UndefinedOr[builtins.str] If provided, the nick to add to the user when he joins the guild. Requires the MANAGE_NICKNAMES permission on the guild.\nroles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, the roles to add to the user when he joins the guild. This may be a collection objects or IDs of existing roles. Requires the MANAGE_ROLES permission on the guild.\nmute : hikari.undefined.UndefinedOr[builtins.bool] If provided, the mute state to add the user when he joins the guild. Requires the MUTE_MEMBERS permission on the guild.\ndeaf : hikari.undefined.UndefinedOr[builtins.bool] If provided, the deaf state to add the user when he joins the guild. Requires the DEAFEN_MEMBERS permission on the guild. Returns typing.Optional[hikari.guilds.Member] builtins.None if the user was already part of the guild, else hikari.guilds.Member . Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are not part of the guild you want to add the user to, if you are missing permissions to do one of the things you specified, if you are using an access token for another user, if the token is bound to another bot or if the access token doesn't have the hikari.applications.OAuth2Scope.GUILDS_JOIN scope enabled.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If you own the guild or the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_voice_regions", "u": 49, "d": "Fetch available voice regions. ! note This endpoint doesn't return VIP voice regions. Returns typing.Sequence[hikari.voices.VoiceRegion] The available voice regions. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_user", "u": 49, "d": "Fetch a user. Parameters user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to fetch. This can be the object or the ID of an existing user. Returns hikari.users.User The requested user Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_audit_log", "u": 49, "d": "Fetch the guild's audit log. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the audit logs from. This can be a guild object or the ID of an existing guild. Other Parameters before : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, filter to only actions after this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.\nuser : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser If provided, the user to filter for.\nevent_type : hikari.undefined.UndefinedOr[typing.Union[hikari.audit_logs.AuditLogEventType, builtins.int If provided, the event type to filter for. Returns hikari.iterators.LazyIterator[hikari.audit_logs.AuditLog] The guild's audit log. ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See hikari.iterators for the full API for this iterator type. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the VIEW_AUDIT_LOG permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_emoji", "u": 49, "d": "Fetch a guild emoji. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the emoji from. This can be a guild object or the ID of an existing guild.\nemoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns hikari.emojis.KnownCustomEmoji The requested emoji. Raises hikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_guild_emojis", "u": 49, "d": "Fetch the emojis of a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the emojis from. This can be a guild object or the ID of an existing guild. Returns typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_emoji", "u": 49, "d": "Create an emoji in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the emoji on. This can be a guild object or the ID of an existing guild.\nname : builtins.str The name for the emoji.\nimage : hikari.files.Resourceish The 128x128 image for the emoji. Maximum upload size is 256kb. This can be a still or an animated image. Other Parameters roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, a collection of the roles that will be able to use this emoji. This can be a hikari.guilds.PartialRole or the ID of an existing role.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.emojis.KnownCustomEmoji The created emoji. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the type of emoji in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_emoji", "u": 49, "d": "Edit an emoji in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the emoji on. This can be a guild object or the ID of an existing guild.\nemoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to edit. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the emoji.\nroles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, the new collection of roles that will be able to use this emoji. This can be a hikari.guilds.PartialRole or the ID of an existing role.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.emojis.KnownCustomEmoji The edited emoji. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_emoji", "u": 49, "d": "Delete an emoji in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete the emoji on. This can be a guild object or the ID of an existing guild.\nemoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to delete. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_available_sticker_packs", "u": 49, "d": "Fetch the available sticker packs. Returns typing.Sequence[hikari.stickers.StickerPack] The available sticker packs. Raises hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_sticker", "u": 49, "d": "Fetch a sticker. Parameters sticker : snowflakes.SnowflakeishOr[stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns typing.Union[hikari.stickers.GuildSticker, hikari.stickers.StandardSticker] The requested sticker. Raises hikari.errors.NotFoundError If the sticker is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_guild_stickers", "u": 49, "d": "Fetch a standard sticker. Parameters guild : snowflakes.SnowflakeishOr[stickers.PartialGuild] The guild to request stickers for. This can be a guild object or the ID of an existing guild. Returns typing.Sequence[hikari.stickers.GuildSticker] The requested stickers. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_guild_sticker", "u": 49, "d": "Fetch a guild sticker. Parameters guild : snowflakes.SnowflakeishOr[stickers.PartialGuild] The guild the sticker is in. This can be a guild object or the ID of an existing guild.\nsticker : snowflakes.SnowflakeishOr[stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns hikari.stickers.GuildSticker The requested sticker. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_sticker", "u": 49, "d": "Create a sticker in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the sticker on. This can be a guild object or the ID of an existing guild.\nname : builtins.str The name for the sticker.\ntag : builtins.str The tag for the sticker.\nimage : hikari.files.Resourceish The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie. ! note Lottie support is only available for verified and partnered servers. Other Parameters description: hikari.undefined.UndefinedOr[builtins.str] If provided, the description of the sticker.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The created sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_sticker", "u": 49, "d": "Edit a sticker in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the sticker on. This can be a guild object or the ID of an existing guild.\nsticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to edit. This can be a sticker object or the ID of an existing sticker. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the sticker.\ndescription : hikari.undefined.UndefinedOr[builtins.str] If provided, the new description for the sticker.\ntag : hikari.undefined.UndefinedOr[builtins.str] If provided, the new sticker tag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The edited sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_sticker", "u": 49, "d": "Delete a sticker in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete the sticker on. This can be a guild object or the ID of an existing guild.\nsticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to delete. This can be a sticker object or the ID of an existing sticker. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.guild_builder", "u": 49, "d": "Make a guild builder to create a guild with. Parameters name : builtins.str The new guilds name. Returns hikari.api.special_endpoints.GuildBuilder The guild builder to use. This will allow to create a guild later with hikari.api.special_endpoints.GuildBuilder.create . ! note This endpoint can only be used by bots in less than 10 guilds. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if you call this as a bot that's in more than 10 guilds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once hikari.api.special_endpoints.GuildBuilder.create is called. Invoking this function itself will not raise any of the above types. See Also Guild builder: hikari.api.special_endpoints.GuildBuilder ", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_guild", "u": 49, "d": "Fetch a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch. This can be the object or the ID of an existing guild. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_guild_preview", "u": 49, "d": "Fetch a guild preview. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the preview of. This can be a guild object or the ID of an existing guild. Returns hikari.guilds.GuildPreview The requested guild preview. ! note This will only work for guilds you are a part of or are public. Raises hikari.errors.NotFoundError If the guild is not found or you are not part of the guild.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_guild", "u": 49, "d": "Edit a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild.\nverification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level.\ndefault_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level.\nexplicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level.\nafk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires afk_timeout to be set to work.\nafk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout.\nicon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature.\nowner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner. ! warning You need to be the owner of the server to use this.\nsplash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the INVITE_SPLASH feature.\nbanner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the BANNER feature.\nsystem_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel.\nrules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel.\npublic_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel.\npreferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.RESTGuild The edited guild. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission or if you tried to pass ownership without being the server owner.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_guild", "u": 49, "d": "Delete a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete. This may be the object or the ID of an existing guild. Raises hikari.errors.ForbiddenError If you are not the owner of the guild.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If you own the guild or if you are not in it.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_guild_channels", "u": 49, "d": "Fetch the channels in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the channels from. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.channels.GuildChannel] The requested channels. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_guild_text_channel", "u": 49, "d": "Create a text channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildTextChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_guild_news_channel", "u": 49, "d": "Create a news channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildNewsChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_guild_voice_channel", "u": 49, "d": "Create a voice channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildVoiceChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_guild_stage_channel", "u": 49, "d": "Create a stage channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channel's name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildStageChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_guild_category", "u": 49, "d": "Create a category in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildCategory The created category. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.reposition_channels", "u": 49, "d": "Reposition the channels in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to reposition the channels in. This may be the object or the ID of an existing guild.\npositions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel A mapping of of the object or the ID of an existing channel to the new position, relative to their parent category, if any. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_member", "u": 49, "d": "Fetch a guild member. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to get the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to get the member for. This may be the object or the ID of an existing user. Returns hikari.guilds.Member The requested member. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or the user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_members", "u": 49, "d": "Fetch the members from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the members of. This may be the object or the ID of an existing guild. Returns hikari.iterators.LazyIterator[hikari.guilds.Member] An iterator to fetch the members. ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See hikari.iterators for the full API for this iterator type. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything. ! warning This endpoint requires the GUILD_MEMBERS intent to be enabled in the dashboard, not necessarily authenticated with it if using the gateway. If you don't have the intents you can use search_members which doesn't require any intents.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.search_members", "u": 49, "d": "Search the members in a guild by nickname and username. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The object or ID of the guild to search members in.\nname : str The query to match username(s) and nickname(s) against. Returns typing.Sequence[hikari.guilds.Member] A sequence of the members who matched the provided name . Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note Unlike RESTClient.fetch_members this endpoint isn't paginated and therefore will return all the members in one go rather than needing to be asynchronously iterated over.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_member", "u": 49, "d": "Edit a guild member. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. Other Parameters nick : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new nick for the member. If builtins.None , will remove the members nick. Requires the MANAGE_NICKNAMES permission.\nroles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, the new roles for the member. Requires the MANAGE_ROLES permission.\nmute : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server mute state for the member. Requires the MUTE_MEMBERS permission.\ndeaf : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server deaf state for the member. Requires the DEAFEN_MEMBERS permission.\nvoice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel ] If provided, builtins.None or the object or the ID of an existing voice channel to move the member to. If builtins.None , will disconnect the member from voice. Requires the MOVE_MEMBERS permission and the CONNECT permission in the original voice channel and the target voice channel. ! note If the member is not in a voice channel, this will take no effect.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.Member Object of the member that was updated. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing a permission to do an action.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or the user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_my_nick", "u": 49, "d": "Edit the associated token's member nick. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild.\nnick : typing.Optional[builtins.str] The new nick. If builtins.None , will remove the nick. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the CHANGE_NICKNAME permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.add_role_to_member", "u": 49, "d": "Add a role to a member. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild where the member is in. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to add the role to. This may be the object or the ID of an existing user.\nrole : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to add. This may be the object or the ID of an existing role. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild, user or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.remove_role_from_member", "u": 49, "d": "Remove a role from a member. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild where the member is in. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to remove the role from. This may be the object or the ID of an existing user.\nrole : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to remove. This may be the object or the ID of an existing role. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild, user or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.kick_user", "u": 49, "d": "Kick a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to kick the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.kick_member", "u": 49, "d": "Kick a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to kick the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.ban_user", "u": 49, "d": "Ban a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to ban the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.ban_member", "u": 49, "d": "Ban a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to ban the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.unban_user", "u": 49, "d": "Unban a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to unban the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to unban. This may be the object or the ID of an existing user. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.unban_member", "u": 49, "d": "Unban a member from a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to unban the member from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to unban. This may be the object or the ID of an existing user. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_ban", "u": 49, "d": "Fetch the guild's ban info for a user. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the ban from. This may be the object or the ID of an existing guild.\nuser : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to fetch the ban of. This may be the object or the ID of an existing user. Returns hikari.guilds.GuildBan The requested ban info. Raises hikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found or if the user is not banned.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_bans", "u": 49, "d": "Fetch the bans of a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the bans from. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.guilds.GuildBan] The requested bans. Raises hikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_roles", "u": 49, "d": "Fetch the roles of a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the roles from. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.guilds.Role] The requested roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_role", "u": 49, "d": "Create a role. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the role in. This may be the object or the ID of an existing guild. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the name for the role.\npermissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] The permissions to give the role. This will default to setting NO roles if left to the default value. This is in contrast to default behaviour on Discord where some random permissions will be set by default.\ncolor : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the role's color.\ncolour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for color .\nhoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role.\nmentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.Role The created role. Raises builtins.TypeError If both color and colour are specified.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.reposition_roles", "u": 49, "d": "Reposition the roles in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to reposition the roles in. This may be the object or the ID of an existing guild.\npositions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole A mapping of the position to the role. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_role", "u": 49, "d": "Edit a role. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the role in. This may be the object or the ID of an existing guild.\nrole : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to edit. This may be the object or the ID of an existing role. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the role.\npermissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new permissions for the role.\ncolor : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the new color for the role.\ncolour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for color .\nhoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role.\nmentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.Role The edited role. Raises builtins.TypeError If both color and colour are specified.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_role", "u": 49, "d": "Delete a role. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete the role in. This may be the object or the ID of an existing guild.\nrole : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to delete. This may be the object or the ID of an existing role. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_ROLES permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or role are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.estimate_guild_prune_count", "u": 49, "d": "Estimate the guild prune count. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to estimate the guild prune count for. This may be the object or the ID of an existing guild. Other Parameters days : hikari.undefined.UndefinedOr[builtins.int] If provided, number of days to count prune for.\ninclude_roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole ] If provided, the role(s) to include. By default, this endpoint will not count users with roles. Providing roles using this attribute will make members with the specified roles also get included into the count. Returns builtins.int The estimated guild prune count. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.begin_guild_prune", "u": 49, "d": "Begin the guild prune. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to begin the guild prune in. This may be the object or the ID of an existing guild. Other Parameters days : hikari.undefined.UndefinedOr[builtins.int] If provided, number of days to count prune for.\ncompute_prune_count: hikari.snowflakes.SnowflakeishOr[builtins.bool] If provided, whether to return the prune count. This is discouraged for large guilds.\ninclude_roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole If provided, the role(s) to include. By default, this endpoint will not count users with roles. Providing roles using this attribute will make members with the specified roles also get included into the count.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns typing.Optional[builtins.int] If compute_prune_count is not provided or builtins.True , the number of members pruned. Else builtins.None . Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_guild_voice_regions", "u": 49, "d": "Fetch the available voice regions for a guild. ! note Unlike RESTClient.fetch_voice_regions , this will return the VIP regions if the guild has access to them. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the voice regions for. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.voices.VoiceRegion] The available voice regions for the guild. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_guild_invites", "u": 49, "d": "Fetch the guild's invites. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the invites for. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.invites.InviteWithMetadata] The invites for the guild. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_integrations", "u": 49, "d": "Fetch the guild's integrations. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the integrations for. This may be the object or the ID of an existing guild. Returns typing.Sequence[hikari.guilds.Integration] The integrations for the guild. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_widget", "u": 49, "d": "Fetch a guilds's widget. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the widget from. This can be the object or the ID of an existing guild. Returns hikari.guilds.GuildWidget The requested guild widget. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_widget", "u": 49, "d": "Fetch a guilds's widget. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the widget in. This can be the object or the ID of an existing guild. Other Parameters channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel If provided, the channel to set the widget to. If builtins.None , will not set to any.\nenabled : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to enable the widget.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.GuildWidget The edited guild widget. Raises hikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_welcome_screen", "u": 49, "d": "Fetch a guild's welcome screen. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to fetch the welcome screen for. Returns hikari.guilds.WelcomeScreen The requested welcome screen. Raises hikari.errors.NotFoundError If the guild is not found or the welcome screen has never been set for this guild (if the welcome screen has been set for a guild before and then disabled you should still be able to fetch it).\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_welcome_screen", "u": 49, "d": "Edit the welcome screen of a community guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] ID or object of the guild to edit the welcome screen for. Other Parameters description : undefined.UndefinedNoneOr[builtins.str] If provided, the description to set for the guild's welcome screen. This may be builtins.None to unset the description.\nenabled : undefined.UndefinedOr[builtins.bool] If provided, Whether the guild's welcome screen should be enabled.\nchannels : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.guilds.WelcomeChannel If provided, a sequence of up to 5 public channels to set in this guild's welcome screen. This may be passed as builtins.None to remove all welcome channels ! note Custom emojis may only be included in a guild's welcome channels if it's boost status is tier 2 or above. Returns hikari.guilds.WelcomeScreen The edited guild welcome screen. Raises hikari.errors.BadRequestError If more than 5 welcome channels are provided or if a custom emoji is included on a welcome channel in a guild that doesn't have tier 2 of above boost status or if a private channel is included as a welcome channel.\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission, are not part of the guild or the guild doesn't have access to the community welcome screen feature.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_vanity_url", "u": 49, "d": "Fetch a guild's vanity url. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the vanity url from. This can be the object or the ID of an existing guild. Returns hikari.invites.VanityURL The requested invite. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_template", "u": 49, "d": "Fetch a guild template. Parameters template : typing.Union[builtins.str, hikari.templates.Template] The object or string code of the template to fetch. Returns hikari.templates.Template The object of the found template. Raises hikari.errors.NotFoundError If the template was not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_guild_templates", "u": 49, "d": "Fetch the templates for a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The object or ID of the guild to get the templates for. Returns typing.Sequence[hikari.templates.Template] A sequence of the found template objects. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found or are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.sync_guild_template", "u": 49, "d": "Create a guild template. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to sync a template in.\ntemplate : typing.Union[builtins.str, hikari.templates.Template] Object or code of the template to sync. Returns hikari.templates.Template The object of the synced template. Raises hikari.errors.ForbiddenError If you are not part of the guild or are missing the MANAGE_GUILD permission.\nhikari.errors.NotFoundError If the guild or template is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_guild_from_template", "u": 49, "d": "Make a guild from a template. Parameters template : typing.Union[builtins.str, hikari.templates.Template] The object or string code of the template to create a guild based on.\nname : builtins.str The new guilds name. Other Parameters icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the guild icon to set. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature. Returns hikari.guilds.RESTGuild Object of the created guild. ! note This endpoint can only be used by bots in less than 10 guilds. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if you call this as a bot that's in more than 10 guilds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_template", "u": 49, "d": "Create a guild template. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create a template from.\nname : str The name to use for the created template. Other Parameters description : hikari.undefined.UndefinedNoneOr[builtins.str] The description to set for the template. Returns hikari.templates.Template The object of the created template. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found or you are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_template", "u": 49, "d": "Modify a guild template. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit a template in.\ntemplate : typing.Union[builtins.str, hikari.templates.Template] Object or string code of the template to modify. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] The name to set for this template.\ndescription : hikari.undefined.UndefinedNoneOr[builtins.str] The description to set for the template. Returns hikari.templates.Template The object of the edited template. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found or you are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_template", "u": 49, "d": "Delete a guild template. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete a template in.\ntemplate : typing.Union[str, hikari.templates.Template] Object or string code of the template to delete. Returns hikari.templates.Template The deleted template's object. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found or you are missing the MANAGE_GUILD permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.command_builder", "u": 49, "d": "Create a command builder for use in RESTClient.set_application_commands . Parameters name : builtins.str The command's name. This should match the regex ^[a-z0-9_-]{1,32}$ .\ndescription : builtins.str The description to set for the command. This should be inclusively between 1-100 characters in length. Returns hikari.api.special_endpoints.CommandBuilder The created command builder object.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_application_command", "u": 49, "d": "Fetch a command set for an application. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to fetch a command for.\ncommand: hikari.snowflakes.SnowflakeishOr[hikari.commands.Command] Object or ID of the command to fetch. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to fetch the command for. If left as hikari.undefined.UNDEFINED then this will return a global command, otherwise this will return a command made for the specified guild. Returns hikari.commands.Command Object of the fetched command. Raises hikari.errors.ForbiddenError If you cannot access the target command.\nhikari.errors.NotFoundError If the command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_application_commands", "u": 49, "d": "Fetch the commands set for an application. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to fetch the commands for. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the guild to fetch the commands for. If left as hikari.undefined.UNDEFINED then this will only return the global commands, otherwise this will only return the commands set exclusively for the specific guild. Returns typing.Sequence[hikari.commands.Command] A sequence of the commands declared for the provided application. This will exclusively either contain the commands set for a specific guild if guild is provided or the global commands if not. Raises hikari.errors.ForbiddenError If you cannot access the target guild.\nhikari.errors.NotFoundError If the provided application isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_application_command", "u": 49, "d": "Create an application command. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to create a command for.\nname : builtins.str The command's name. This should match the regex ^[a-z0-9_-]{1,32}$ .\ndescription : builtins.str The description to set for the command. This should be inclusively between 1-100 characters in length. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the specific guild this should be made for. If left as hikari.undefined.UNDEFINED then this call will create a global command rather than a guild specific one.\noptions : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption A sequence of up to 10 options for this command.\ndefault_permission : hikari.undefined.UndefinedOr[builtins.bool] Whether this command should be enabled by default (without any permissions) when added to a guild. Defaults to builtins.True . Returns hikari.commands.Command Object of the created command. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands.\nhikari.errors.NotFoundError If the provided application isn't found.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.set_application_commands", "u": 49, "d": "Set the commands for an application. ! warning Any existing commands not included in the provided commands array will be deleted. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to create a command for.\ncommands: typing.Sequence[hikari.api.special_endpoints.CommandBuilder] A sequence of up to 100 initialised command builder objects of the commands to set for this the application. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] Object or ID of the specific guild to set the commands for. If left as hikari.undefined.UNDEFINED then this set the global commands rather than guild specific commands. Returns typing.Sequence[hikari.commands.Command] A sequence of the set command objects. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands.\nhikari.errors.NotFoundError If the provided application isn't found.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_application_command", "u": 49, "d": "Edit a registered application command. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to edit a command for.\ncommand : hikari.snowflakes.SnowflakeishOr[hikari.commands.Command] Object or ID of the command to modify. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to edit a command for if this is a guild specific command. Leave this as hikari.undefined.UNDEFINED to delete a global command.\nname : hikari.undefined.UndefinedOr[builtins.str] The name to set for the command. Leave as hikari.undefined.UNDEFINED to not change.\ndescription : hikari.undefined.UndefinedOr[builtins.str] The description to set for the command. Leave as hikari.undefined.UNDEFINED to not change.\noptions : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption A sequence of up to 10 options to set for this command. Leave this as hikari.undefined.UNDEFINED to not change. Returns hikari.commands.Command The edited command object. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_application_command", "u": 49, "d": "Delete a registered application command. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to delete a command for.\ncommand : hikari.snowflakes.SnowflakeishOr[hikari.commands.Command] Object or ID of the command to delete. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to delete a command for if this is a guild specific command. Leave this as hikari.undefined.UNDEFINED to delete a global command. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_application_guild_commands_permissions", "u": 49, "d": "Fetch the command permissions registered in a guild. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to fetch the command permissions for.\nguild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to fetch the command permissions for. Returns typing.Sequence[hikari.commands.GuildCommandPermissions] Sequence of the guild command permissions set for the specified guild. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands or guild.\nhikari.errors.NotFoundError If the provided application isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_application_command_permissions", "u": 49, "d": "Fetch the permissions registered for a specific command in a guild. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to fetch the command permissions for.\nguild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to fetch the command permissions for.\ncommand: hikari.snowflakes.SnowflakeishOr[hikari.commands.Command] Objecr or ID of the command to fetch the command permissions for. Returns hikari.commands.GuildCommandPermissions Object of the command permissions set for the specified command. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands or guild.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.set_application_guild_commands_permissions", "u": 49, "d": "Set permissions in a guild for multiple commands. ! note This overwrites any previously set permissions for the specified commands. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to set the command permissions for.\nguild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to set the command permissions for.\npermissions : typing.Mapping[hikari.snowflakes.SnowflakeishOr[hikari.commands.Command], typing.Sequence[hikari.commands.CommandPermission Mapping of objects and/or IDs of commands to sequences of the commands to set for the specified guild. ! warning Only a maximum of up to 10 permissions can be set per command. Returns typing.Sequence[hikari.commands.GuildCommandPermissions] Sequence of the set guild command permissions. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands or guild.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.set_application_command_permissions", "u": 49, "d": "Set permissions for a specific command. ! note This overwrites any previously set permissions. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to set the command permissions for.\nguild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to set the command permissions for.\ncommand : hikari.snowflakes.SnowflakeishOr[hikari.commands.Command] Object or ID of the command to set the permissions for.\npermissions : typing.Sequence[hikari.commands.CommandPermission] Sequence of up to 10 of the permission objects to set. Returns hikari.commands.GuildCommandPermissions Object of the set permissions. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands or guild.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.interaction_deferred_builder", "u": 49, "d": "Create a builder for a deferred message interaction response. Parameters type: typing.Union[hikari.interactions.base_interactions.ResponseType, builtins.int] The type of deferred message response this builder is for. Returns hikari.api.special_endpoints.InteractionDeferredBuilder The deferred message interaction response builder object.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.interaction_message_builder", "u": 49, "d": "Create a builder for a message interaction response. Parameters type : typing.Union[hikari.interactions.base_interactions.ResponseType, builtins.int] The type of message response this builder is for. Returns hikari.api.special_endpoints.InteractionMessageBuilder The interaction message response builder object.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.fetch_interaction_response", "u": 49, "d": "Fetch the initial response for an interaction. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to fetch a command for.\ntoken: builtins.str Token of the interaction to get the initial response for. Returns hikari.messages.Message Message object of the initial response. Raises hikari.errors.ForbiddenError If you cannot access the target interaction.\nhikari.errors.NotFoundError If the initial response isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.create_interaction_response", "u": 49, "d": "Create the initial response for a interaction. ! warning Calling this with an interaction which already has an initial response will result in this raising a hikari.errors.NotFoundError . This includes if the REST interaction server has already responded to the request. Parameters interaction : hikari.snowflakes.SnowflakeishOr[hikari.interactions.base_interactions.PartialInteraction] Object or ID of the interaction this response is for.\ntoken : builtins.str The command interaction's token.\nresponse_type : typing.Union[builtins.int, hikari.interactions.base_interactions.ResponseType] The type of interaction response this is. Other Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor no embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nflags : typing.Union[builtins.int, hikari.messages.MessageFlag, hikari.undefined.UndefinedType] If provided, the message flags this response should have. As of writing the only message flag which can be set here is hikari.messages.MessageFlag.EPHEMERAL .\ntts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions .\nbuiltins.TypeError If both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits invalid image URLs in embeds.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction is not found or if the interaction's initial response has already been created.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.edit_interaction_response", "u": 49, "d": "Edit the initial response to a command interaction. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to edit a command response for.\ntoken : builtins.str The interaction's token. Other Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message content to update with. If hikari.undefined.UNDEFINED , then the content will not be changed. If builtins.None , then the content will be removed. Any other value will be cast to a builtins.str before sending. If this is a hikari.embeds.Embed and neither the embed or embeds kwargs are provided or if this is a hikari.files.Resourceish and neither the attachment or attachments kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify one of mentions_everyone , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If both attachment and attachments , component and components or embed and embeds are specified.\nbuiltins.TypeError If attachments , components or embeds is passed but is not a sequence.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.delete_interaction_response", "u": 49, "d": "Delete the initial response of an interaction. Parameters application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication] Object or ID of the application to delete a command response for.\ntoken : builtins.str The interaction's token. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the interaction or response is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.impl.rest.RESTClientImpl.build_action_row", "u": 49, "d": "Build an action row message component for use in message create and REST calls. Returns hikari.api.special_endpoints.ActionRowBuilder The initialised action row builder.", "f": 1}, {"r": "hikari.impl.bot", "u": 50, "d": "Basic implementation the components for a single-process bot."}, {"r": "hikari.impl.bot.GatewayBot", "u": 50, "d": "Basic auto-sharding bot implementation. This is the class you will want to use to start, control, and build a bot\nwith. Parameters token : builtins.str The bot token to sign in with. Other Parameters allow_color : builtins.bool Defaulting to builtins.True , this will enable coloured console logs on any platform that is a TTY. Setting a \"CLICOLOR\" environment variable to any non 0 value will override this setting. Users should consider this an advice to the application on whether it is safe to show colours if possible or not. Since some terminals can be awkward or not support features in a standard way, the option to explicitly disable this is provided. See force_color for an alternative.\nbanner : typing.Optional[builtins.str] The package to search for a banner.txt in. Defaults to \"hikari\" for the \"hikari/banner.txt\" banner. Setting this to builtins.None will disable the banner being shown.\nexecutor : typing.Optional[concurrent.futures.Executor] Defaults to builtins.None . If non- builtins.None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter.\nforce_color : builtins.bool Defaults to builtins.False . If builtins.True , then this application will __force__ colour to be used in console-based output. Specifying a \"CLICOLOR_FORCE\" environment variable with a non- \"0\" value will override this setting.\ncache_settings : typing.Optional[hikari.config.CacheSettings] Optional cache settings. If unspecified, will use the defaults.\nhttp_settings : typing.Optional[hikari.config.HTTPSettings] Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts aiohttp should expect to use for requests, and behavior regarding HTTP-redirects.\nintents : hikari.intents.Intents Defaults to hikari.intents.Intents.ALL_UNPRIVILEGED . This allows you to change which intents your application will use on the gateway. This can be used to control and change the types of events you will receive.\nlogs : typing.Union[builtins.None, LoggerLevel, typing.Dict[str, typing.Any Defaults to \"INFO\" . If builtins.None , then the Python logging system is left uninitialized on startup, and you will need to configure it manually to view most logs that are output by components of this library. If one of the valid values in a LoggerLevel , then this will match a call to colorlog.basicConfig (a facade for logging.basicConfig with additional conduit for enabling coloured logging levels) with the level kwarg matching this value. If a typing.Dict[str, typing.Any] equivalent, then this value is passed to logging.config.dictConfig to allow the user to provide a specialized logging configuration of their choice. As a side note, you can always opt to leave this on the default value and then use an incremental logging.config.dictConfig that applies any additional changes on top of the base configuration, if you prefer. An example of can be found in the Example section. Note that \"TRACE_HIKARI\" is a library-specific logging level which is expected to be more verbose than \"DEBUG\" .\nmax_rate_limit : builtins.float The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes if left to the default value. This is to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use.\nmax_retries : typing.Optional[builtins.int] Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to builtins.None .\nproxy_settings : typing.Optional[config.ProxySettings] Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy.\nrest_url : typing.Optional[builtins.str] Defaults to the Discord REST API URL if builtins.None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this. ! note force_color will always take precedence over allow_color . ! note Settings that control the gateway session are provided to the GatewayBot.run and GatewayBot.start functions in this class. This is done to allow you to contextually customise details such as sharding configuration without having to re-initialize the entire application each time. Example Setting up logging using a dictionary configuration: py\nimport os import hikari We want to make gateway logs output as DEBUG, and TRACE for all ratelimit content.\nbot = hikari.GatewayBot( token=os.environ[\"BOT_TOKEN\"], logs={ \"version\": 1, \"incremental\": True, \"loggers\": { \"hikari.gateway\": {\"level\": \"DEBUG\"}, \"hikari.ratelimits\": {\"level\": \"TRACE_HIKARI\"}, }, },\n) "}, {"r": "hikari.impl.bot.GatewayBot.cache", "u": 50, "d": "Return the immutable cache implementation for this object. Returns hikari.api.cache.Cache The cache component for this object."}, {"r": "hikari.impl.bot.GatewayBot.event_manager", "u": 50, "d": "Return the event manager for this object. Returns hikari.api.event_manager.EventManager The event manager component."}, {"r": "hikari.impl.bot.GatewayBot.entity_factory", "u": 50, "d": "Return the entity factory implementation for this object. Returns hikari.api.entity_factory.EntityFactory The entity factory component."}, {"r": "hikari.impl.bot.GatewayBot.event_factory", "u": 50, "d": "Return the event factory component. Returns hikari.api.event_factory.EventFactory The event factory component."}, {"r": "hikari.impl.bot.GatewayBot.executor", "u": 50, "d": "Return the executor to use for blocking operations. This may return builtins.None if the default asyncio thread pool\nshould be used instead. Returns typing.Optional[concurrent.futures.Executor] The executor to use, or builtins.None to use the asyncio default instead."}, {"r": "hikari.impl.bot.GatewayBot.heartbeat_latencies", "u": 50, "d": "Return a mapping of shard ID to heartbeat latency. Any shards that are not yet started will be float('nan') . Returns typing.Mapping[builtins.int, builtins.float] Each shard ID mapped to the corresponding heartbeat latency. Each latency is measured in seconds."}, {"r": "hikari.impl.bot.GatewayBot.heartbeat_latency", "u": 50, "d": "Return the average heartbeat latency of all started shards. If no shards are started, this will return float('nan') . Returns builtins.float The average heartbeat latency of all started shards, or float('nan') if no shards are started. This is measured in seconds."}, {"r": "hikari.impl.bot.GatewayBot.http_settings", "u": 50, "d": "Return the HTTP settings in use by this component. Returns hikari.config.HTTPSettings The HTTP settings in use."}, {"r": "hikari.impl.bot.GatewayBot.intents", "u": 50, "d": "Return the intents registered for the application. Returns hikari.intents.Intents The intents registered on this application."}, {"r": "hikari.impl.bot.GatewayBot.proxy_settings", "u": 50, "d": "Return the proxy settings in use by this component. Returns hikari.config.ProxySettings The proxy settings in use."}, {"r": "hikari.impl.bot.GatewayBot.shard_count", "u": 50, "d": "Return the number of shards in the total application. This may not be the same as the size of shards . If the application\nis auto-sharded, this may be 0 until the shards are started. Returns builtins.int The number of shards in the total application."}, {"r": "hikari.impl.bot.GatewayBot.voice", "u": 50, "d": "Return the voice connection manager component for this application. Returns hikari.api.voice.VoiceComponent The voice component for the application."}, {"r": "hikari.impl.bot.GatewayBot.rest", "u": 50, "d": "Return the REST client to use for HTTP requests. Returns hikari.api.rest.RESTClient The REST client to use."}, {"r": "hikari.impl.bot.GatewayBot.is_alive", "u": 50, "d": "Check whether the application is running or not. This is useful as some functions might raise hikari.errors.ComponentStateConflictError if this is builtins.False . Returns builtins.bool Whether the bot is running or not."}, {"r": "hikari.impl.bot.GatewayBot.get_me", "u": 50, "d": "Return the bot user, if known. This should be available as soon as the bot has fired the hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be builtins.None . Returns typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise builtins.None .", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.close", "u": 50, "d": "Kill the application by shutting all components down.", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.dispatch", "u": 50, "d": "", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.get_listeners", "u": 50, "d": "", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.join", "u": 50, "d": "Wait indefinitely until the application closes. This can be placed in a task and cancelled without affecting the\napplication runtime itself. Any exceptions raised by shards will be\npropagated to here. Other Parameters until_close : builtins.bool Defaults to builtins.True . If set, the waiter will stop as soon as a request for shut down is processed. This can allow you to break and begin closing your own resources. If builtins.False , then this will wait until all shards' tasks have died.", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.listen", "u": 50, "d": "", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.print_banner", "u": 50, "d": "Print the banner. This allows library vendors to override this behaviour, or choose to\ninject their own \"branding\" on top of what hikari provides by default. Normal users should not need to invoke this function, and can simply\nchange the banner argument passed to the constructor to manipulate\nwhat is displayed. Parameters banner : typing.Optional[builtins.str] The package to find a banner.txt in.\nallow_color : builtins.bool A flag that allows advising whether to allow color if supported or not. Can be overridden by setting a \"CLICOLOR\" environment variable to a non- \"0\" string.\nforce_color : builtins.bool A flag that allows forcing color to always be output, even if the terminal device may not support it. Setting the \"CLICOLOR_FORCE\" environment variable to a non- \"0\" string will override this. ! note force_color will always take precedence over allow_color .", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.run", "u": 50, "d": "Start the bot, wait for all shards to become ready, and then return. Other Parameters activity : typing.Optional[hikari.presences.Activity] The initial activity to display in the bot user presence, or builtins.None (default) to not show any.\nafk : builtins.bool The initial AFK state to display in the bot user presence, or builtins.False (default) to not show any.\nasyncio_debug : builtins.bool Defaults to builtins.False . If builtins.True , then debugging is enabled for the asyncio event loop in use.\ncheck_for_updates : builtins.bool Defaults to builtins.True . If builtins.True , will check for newer versions of hikari on PyPI and notify if available.\nclose_passed_executor : builtins.bool Defaults to builtins.False . If builtins.True , any custom concurrent.futures.Executor passed to the constructor will be shut down when the application terminates. This does not affect the default executor associated with the event loop, and will not do anything if you do not provide a custom executor to the constructor.\nclose_loop : builtins.bool Defaults to builtins.True . If builtins.True , then once the bot enters a state where all components have shut down permanently during application shutdown, then all asyngens and background tasks will be destroyed, and the event loop will be shut down. This will wait until all hikari -owned aiohttp connectors have had time to attempt to shut down correctly (around 250ms), and on Python 3.9 and newer, will also shut down the default event loop executor too.\ncoroutine_tracking_depth : typing.Optional[builtins.int] Defaults to builtins.None . If an integer value and supported by the interpreter, then this many nested coroutine calls will be tracked with their call origin state. This allows you to determine where non-awaited coroutines may originate from, but generally you do not want to leave this enabled for performance reasons.\nenable_signal_handlers : builtins.bool Defaults to builtins.True . If on a __non-Windows__ OS with builtin support for kernel-level POSIX signals, then setting this to builtins.True will allow treating keyboard interrupts and other OS signals to safely shut down the application as calls to shut down the application properly rather than just killing the process in a dirty state immediately. You should leave this disabled unless you plan to implement your own signal handling yourself.\nidle_since : typing.Optional[datetime.datetime] The datetime.datetime the user should be marked as being idle since, or builtins.None (default) to not show this.\nignore_session_start_limit : builtins.bool Defaults to builtins.False . If builtins.False , then attempting to start more sessions than you are allowed in a 24 hour window will throw a hikari.errors.GatewayError rather than going ahead and hitting the IDENTIFY limit, which may result in your token being reset. Setting to builtins.True disables this behavior.\nlarge_threshold : builtins.int Threshold for members in a guild before it is treated as being \"large\" and no longer sending member details in the GUILD CREATE event. Defaults to 250 .\npropagate_interrupts : builtins.bool Defaults to builtins.False . If set to builtins.True , then any internal hikari.errors.HikariInterrupt that is raises as a result of catching an OS level signal will result in the exception being rethrown once the application has closed. This can allow you to use hikari signal handlers and still be able to determine what kind of interrupt the application received after it closes. When builtins.False , nothing is raised and the call will terminate cleanly and silently where possible instead.\nshard_ids : typing.Optional[typing.AbstractSet[builtins.int The shard IDs to create shards for. If not builtins.None , then a non- None  shard_count must ALSO be provided. Defaults to builtins.None , which means the Discord-recommended count is used for your application instead.\nshard_count : typing.Optional[builtins.int] The number of shards to use in the entire distributed application. Defaults to builtins.None which results in the count being determined dynamically on startup.\nstatus : hikari.presences.Status The initial status to show for the user presence on startup. Defaults to hikari.presences.Status.ONLINE . Raises hikari.errors.ComponentStateConflictError If bot is already running.\nbuiltins.TypeError If shard_ids is passed without shard_count .", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.start", "u": 50, "d": "Start the bot, wait for all shards to become ready, and then return. Other Parameters activity : typing.Optional[hikari.presences.Activity] The initial activity to display in the bot user presence, or builtins.None (default) to not show any.\nafk : builtins.bool The initial AFK state to display in the bot user presence, or builtins.False (default) to not show any.\ncheck_for_updates : builtins.bool Defaults to builtins.True . If builtins.True , will check for newer versions of hikari on PyPI and notify if available.\nidle_since : typing.Optional[datetime.datetime] The datetime.datetime the user should be marked as being idle since, or builtins.None (default) to not show this.\nignore_session_start_limit : builtins.bool Defaults to builtins.False . If builtins.False , then attempting to start more sessions than you are allowed in a 24 hour window will throw a hikari.errors.GatewayError rather than going ahead and hitting the IDENTIFY limit, which may result in your token being reset. Setting to builtins.True disables this behavior.\nlarge_threshold : builtins.int Threshold for members in a guild before it is treated as being \"large\" and no longer sending member details in the GUILD CREATE event. Defaults to 250 .\nshard_ids : typing.Optional[typing.AbstractSet[builtins.int The shard IDs to create shards for. If not builtins.None , then a non- None  shard_count must ALSO be provided. Defaults to builtins.None , which means the Discord-recommended count is used for your application instead.\nshard_count : typing.Optional[builtins.int] The number of shards to use in the entire distributed application. Defaults to builtins.None which results in the count being determined dynamically on startup.\nstatus : hikari.presences.Status The initial status to show for the user presence on startup. Defaults to hikari.presences.Status.ONLINE . Raises hikari.errors.ComponentStateConflictError If bot is already running.\nbuiltins.TypeError If shard_ids is passed without shard_count .", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.stream", "u": 50, "d": "", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.subscribe", "u": 50, "d": "", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.unsubscribe", "u": 50, "d": "", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.wait_for", "u": 50, "d": "", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.update_presence", "u": 50, "d": "Update the presence on all shards. This call will patch the presence on each shard. This means that\nunless you explicitly specify a parameter, the previous value will be\nretained. This means you do not have to track the global presence\nin your code. Other Parameters idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed.\nafk : hikari.undefined.UndefinedOr[builtins.bool] If builtins.True , the user is marked as AFK. If builtins.False , the user is marked as being active. If undefined, this will not be changed.\nactivity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed.\nstatus : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed. ! note This will only send the update payloads to shards that are alive. Any shards that are not alive will cache the new presence for when they do start. ! note If you want to set presences per shard, access the shard you wish to update (e.g. by using GatewayBot.shards ), and call hikari.api.shard.GatewayShard.update_presence on that shard. This method is simply a facade to make performing this in bulk simpler.", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.update_voice_state", "u": 50, "d": "Update the voice state for this bot in a given guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild or guild ID to update the voice state for.\nchannel : typing.Optional[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel The channel or channel ID to update the voice state for. If builtins.None then the bot will leave the voice channel that it is in for the given guild.\nself_mute : builtins.bool If specified and builtins.True , the bot will mute itself in that voice channel. If builtins.False , then it will unmute itself.\nself_deaf : builtins.bool If specified and builtins.True , the bot will deafen itself in that voice channel. If builtins.False , then it will undeafen itself. Raises builtins.RuntimeError If the guild passed isn't covered by any of the shards in this sharded client.", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.request_guild_members", "u": 50, "d": "Request for a guild chunk. Parameters guild: hikari.guilds.Guild The guild to request chunk for. Other Parameters include_presences: hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences.\nquery: builtins.str If not   , request the members which username starts with the string.\nlimit: builtins.int Maximum number of members to send matching the query.\nusers: hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.users.User If provided, the users to request for.\nnonce: hikari.undefined.UndefinedOr[builtins.str] If provided, the nonce to be sent with guild chunks. ! note To request the full list of members, set query to   (empty string) and limit to 0 . Raises ValueError When trying to specify users with query / limit , if limit is not between 0 and 100, both inclusive or if users length is over 100.\nhikari.errors.MissingIntentError When trying to request presences without the GUILD_MEMBERS or when trying to request the full list of members without GUILD_PRESENCES .\nbuiltins.RuntimeError If the guild passed isn't covered by any of the shards in this sharded client.", "f": 1}, {"r": "hikari.impl.bot.GatewayBot.shards", "u": 50, "d": "Return a mapping of shards in this application instance. Each shard ID is mapped to the corresponding shard instance. If the application has not started, it is acceptable to assume the\nresult of this call will be an empty mapping. Returns typing.Mapping[int, hikari.api.shard.GatewayShard] The shard mapping."}, {"r": "hikari.impl.event_manager_base", "u": 51, "d": "A base implementation for an event manager."}, {"r": "hikari.impl.event_manager_base.EventManagerBase", "u": 51, "d": "Provides functionality to consume and dispatch events. Specific event handlers should be in functions named on_xxx where xxx is the raw event name being dispatched in lower-case."}, {"r": "hikari.impl.event_manager_base.EventManagerBase.consume_raw_event", "u": 51, "d": "Consume a raw event. Parameters event_name : str The case-insensitive name of the event being triggered.\nshard : hikari.api.shard.GatewayShard Object of the shard that received this event.\npayload : hikari.internal.data_binding.JSONObject Payload of the event being triggered. Raises builtins.LookupError If there is no consumer for the event.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventManagerBase.subscribe", "u": 51, "d": "Subscribe a given callback to a given event type. Parameters event_type : typing.Type[T] The event type to listen for. This will also listen for any subclasses of the given type. T must be a subclass of hikari.events.base_events.Event .\ncallback Must be a coroutine function to invoke. This should consume an instance of the given event, or an instance of a valid subclass if one exists. Any result is discarded. Example The following demonstrates subscribing a callback to message creation\nevents. py\nfrom hikari.events.messages import MessageCreateEvent async def on_message(event): . bot.subscribe(MessageCreateEvent, on_message) See Also Listen: hikari.api.event_manager.EventManager.listen Stream: hikari.api.event_manager.EventManager.stream Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.impl.event_manager_base.EventManagerBase.get_listeners", "u": 51, "d": "Get the listeners for a given event type, if there are any. Parameters event_type : typing.Type[T] The event type to look for. T must be a subclass of hikari.events.base_events.Event .\npolymorphic : builtins.bool If builtins.True , this will also return the listeners of the subclasses of the given event type. If builtins.False , then only listeners for this class specifically are returned. The default is builtins.True . Returns typing.Collection[typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None A copy of the collection of listeners for the event. Will return an empty collection if nothing is registered. T must be a subclass of hikari.events.base_events.Event . See Also Has listener: hikari.api.event_manager.EventManager.has_listener ", "f": 1}, {"r": "hikari.impl.event_manager_base.EventManagerBase.unsubscribe", "u": 51, "d": "Unsubscribe a given callback from a given event type, if present. Parameters event_type : typing.Type[T] The event type to unsubscribe from. This must be the same exact type as was originally subscribed with to be removed correctly. T must derive from hikari.events.base_events.Event .\ncallback The callback to unsubscribe. Example The following demonstrates unsubscribing a callback from a message\ncreation event. py\nfrom hikari.events.messages import MessageCreateEvent async def on_message(event): . bot.unsubscribe(MessageCreateEvent, on_message) ", "f": 1}, {"r": "hikari.impl.event_manager_base.EventManagerBase.listen", "u": 51, "d": "Generate a decorator to subscribe a callback to an event type. This is a second-order decorator. Parameters event_type : typing.Optional[typing.Type[T The event type to subscribe to. The implementation may allow this to be undefined. If this is the case, the event type will be inferred instead from the type hints on the function signature. T must be a subclass of hikari.events.base_events.Event . Returns typing.Callable T], T] A decorator for a coroutine function that passes it to EventManager.subscribe before returning the function reference. See Also Dispatch: hikari.api.event_manager.EventManager.dispatch Stream: hikari.api.event_manager.EventManager.stream Subscribe: hikari.api.event_manager.EventManager.subscribe Unsubscribe: hikari.api.event_manager.EventManager.unsubscribe Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.impl.event_manager_base.EventManagerBase.dispatch", "u": 51, "d": "Dispatch an event. Parameters event : hikari.events.base_events.Event The event to dispatch. Example We can dispatch custom events by first defining a class that\nderives from hikari.events.base_events.Event . py\nimport attr from hikari.traits import RESTAware\nfrom hikari.events.base_events import Event\nfrom hikari.users import User\nfrom hikari.snowflakes import Snowflake @attr.define()\nclass EveryoneMentionedEvent(Event): app: RESTAware = attr.field() author: User = attr.field() 'The user who mentioned everyone. ' content: str = attr.field() 'The message that was sent. ' message_id: Snowflake = attr.field() 'The message ID. ' channel_id: Snowflake = attr.field() 'The channel ID. ' We can then dispatch our event as we see fit. py\nfrom hikari.events.messages import MessageCreateEvent @bot.listen(MessageCreateEvent)\nasync def on_message(event): if \"@everyone\" in event.content or \"@here\" in event.content: event = EveryoneMentionedEvent( author=event.author, content=event.content, message_id=event.id, channel_id=event.channel_id, ) bot.dispatch(event) This event can be listened to elsewhere by subscribing to it with EventManager.subscribe . py\n@bot.listen(EveryoneMentionedEvent)\nasync def on_everyone_mentioned(event): print(event.user, \"just pinged everyone in\", event.channel_id) Returns asyncio.Future[typing.Any] A future that can be optionally awaited. If awaited, the future will complete once all corresponding event listeners have been invoked. If not awaited, this will schedule the dispatch of the events in the background for later. See Also Subscribe: hikari.api.event_manager.EventManager.subscribe Stream: hikari.api.event_manager.EventManager.stream Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.impl.event_manager_base.EventManagerBase.stream", "u": 51, "d": "Return a stream iterator for the given event and sub-events. Parameters event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally.\ntimeout : typing.Optional[builtins.int, builtins.float] How long this streamer should wait for the next event before ending the iteration. If builtins.None then this will continue until explicitly broken from.\nlimit : typing.Optional[builtins.int] The limit for how many events this should queue at one time before dropping extra incoming events, leave this as builtins.None for the cache size to be unlimited. Returns EventStream[hikari.events.base_events.Event] The async iterator to handle streamed events. This must be started with async with stream: or await stream.open() before asynchronously iterating over it. ! warning If you use await stream.open() to start the stream then you must also close it with await stream.close() otherwise it may queue events in memory indefinitely. Examples  \nasync with bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id as stream: async for user_id in stream.map(\"user_id\").limit(50): . or using await open() and await close()  \nstream = bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id await stream.open() async for user_id in stream.map(\"user_id\").limit(50) . await stream.close() See Also Dispatch: hikari.api.event_manager.EventManager.dispatch Listen: hikari.api.event_manager.EventManager.listen Subscribe: hikari.api.event_manager.EventManager.subscribe Unsubscribe: hikari.api.event_manager.EventManager.unsubscribe Wait for: hikari.api.event_manager.EventManager.wait_for ", "f": 1}, {"r": "hikari.impl.event_manager_base.EventManagerBase.wait_for", "u": 51, "d": "Wait for a given event to occur once, then return the event. Parameters event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally.\npredicate A function taking the event as the single parameter. This should return builtins.True if the event is one you want to return, or builtins.False if the event should not be returned. If left as None (the default), then the first matching event type that the bot receives (or any subtype) will be the one returned. ! warning Async predicates are not supported.\ntimeout : typing.Union[builtins.float, builtins.int, builtins.None] The amount of time to wait before raising an asyncio.TimeoutError and giving up instead. This is measured in seconds. If builtins.None , then no timeout will be waited for (no timeout can result in \"leaking\" of coroutines that never complete if called in an uncontrolled way, so is not recommended). Returns hikari.events.base_events.Event The event that was provided. Raises asyncio.TimeoutError If the timeout is not builtins.None and is reached before an event is received that the predicate returns builtins.True for. See Also Listen: hikari.api.event_manager.EventManager.listen Stream: hikari.api.event_manager.EventManager.stream Subscribe: hikari.api.event_manager.EventManager.subscribe Dispatch: hikari.api.event_manager.EventManager.dispatch ", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream", "u": 51, "d": "An implementation of an event EventStream class. ! note While calling EventStream.filter on an active \"opened\" event stream will return a wrapping lazy iterator, calling it on an inactive \"closed\" event stream will return the event stream and add the given predicates to the streamer."}, {"r": "hikari.impl.event_manager_base.EventStream.close", "u": 51, "d": "Mark this streamer as closed to stop it from queueing and receiving events. If called on an already closed streamer then this will do nothing. ! note async with streamer may be used as a short-cut for opening and closing a streamer.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.filter", "u": 51, "d": "Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item\nthat this iterator would return when it is requested. All conditions must evaluate to builtins.True for the item to be\nreturned. If this is not met, then the item is discarded and ignored,\nthe next matching item will be returned instead, if there is one. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.filter \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values where all conditions are matched.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.open", "u": 51, "d": "Mark this streamer as opened to let it start receiving and queueing events. If called on an already started streamer then this will do nothing. ! note async with streamer may be used as a short-cut for opening and closing a stream.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.chunk", "u": 51, "d": "Return results in chunks of up to chunk_size amount of entries. Parameters chunk_size : int The limit for how many results should be returned in each chunk. Returns LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.map", "u": 51, "d": "Map the values to a different value. Parameters transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the . operator. Returns LazyIterator[AnotherValueT] LazyIterator that maps each value to another value.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.for_each", "u": 51, "d": "Pass each value to a given consumer immediately.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.take_while", "u": 51, "d": "Return each item until any conditions fail or the end is reached. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.take_while \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.take_until", "u": 51, "d": "Return each item until any conditions pass or the end is reached. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.take_until \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.skip_while", "u": 51, "d": "Discard items while all conditions are True. Items after this will be yielded as normal. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.skip_while \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.skip_until", "u": 51, "d": "Discard items while all conditions are False. Items after this will be yielded as normal. Parameters  predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return builtins.True if it is of interest, or builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a builtins.str attribute name (nested attributes are referred to using the . operator), and values to compare for equality. This allows you to specify conditions such as members.skip_until \"user.bot\", True  . attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.enumerate", "u": 51, "d": "Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of builtins.enumerate which uses much less memory than collecting all the results first and\ncalling builtins.enumerate across them. Parameters start : builtins.int Optional int to start at. If omitted, this is 0 . Examples >>> async for i, item in paginated_results.enumerate(): . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9): . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3): . print(i, item) (9, foo) (10, bar) (11, baz) Returns LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.limit", "u": 51, "d": "Limit the number of items you receive from this async iterator. Parameters limit : builtins.int The number of items to get. This must be greater than zero. Examples >>> async for item in paginated_results.limit(3): . print(item) Returns LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.skip", "u": 51, "d": "Drop the given number of items, then yield anything after. Parameters number : builtins.int The max number of items to drop before any items are yielded. Returns LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.next", "u": 51, "d": "Return the next element of this iterator only. Returns ValueT The next result. Raises builtins.LookupError If no more results exist.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.last", "u": 51, "d": "Return the last element of this iterator only. Returns ValueT The last result. ! note This method will consume the whole iterator if run. Raises builtins.LookupError If no result exists.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.reversed", "u": 51, "d": "Return a lazy iterator of the remainder of this iterator's values reversed. Returns LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.sort", "u": 51, "d": "Collect all results, then sort the collection before returning it.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.collect", "u": 51, "d": "Collect the results into a given type and return it. Parameters collector A function that consumes a sequence of values and returns a collection.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.count", "u": 51, "d": "Count the number of results. Returns builtins.int Number of results found.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.flat_map", "u": 51, "d": "Perform a flat mapping operation. This will pass each item in the iterator to the given function parameter, expecting a new typing.Iterable or typing.AsyncIterator to be returned as the result. This means you can map to a new LazyIterator , typing.AsyncIterator , typing.Iterable ,\nasync generator, or generator. Remember that typing.Iterator implicitly provides typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement\nreactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded\nlazily. Parameters flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example The following example generates a distinct collection of all mentioned\nusers in the given channel from the past 500 messages. py\ndef iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\"<@!?(\\d+)>\", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct()\n) Returns LazyIterator[AnotherValueT] The new lazy iterator to return.", "f": 1}, {"r": "hikari.impl.event_manager_base.EventStream.awaiting", "u": 51, "d": "Await each item concurrently in a fixed size window. Parameters window_size : int The window size of how many tasks to await at once. You can set this to 0 to await everything at once, but see the below warning. Returns LazyIterator[ValueT] The new lazy iterator to return. ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the fetch_user endpoint seems to be notorious for doing this). ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.", "f": 1}, {"r": "hikari.impl.interaction_server", "u": 52, "d": "Standard implementation of a REST based interactions server."}, {"r": "hikari.impl.interaction_server.InteractionServer", "u": 52, "d": "Standard implementation of hikari.api.interaction_server.InteractionServer . Parameters entity_factory : hikari.api.entity_factory.EntityFactory The entity factory instance this server should use. Other Parameters dumps : aiohttp.typedefs.JSONEncoder The JSON encoder this server should use. Defaults to json.dumps .\nloads : aiohttp.typedefs.JSONDecoder The JSON decoder this server should use. Defaults to json.loads .\npublic_key : builtins.bytes The public key this server should use for verifying request payloads from Discord. If left as builtins.None then the client will try to work this out using rest_client .\nrest_client : hikari.api.rest.RESTClient The client this should use for making REST requests."}, {"r": "hikari.impl.interaction_server.InteractionServer.is_alive", "u": 52, "d": "Whether this interaction server is active. Returns builtins.bool Whether this interaction server is active"}, {"r": "hikari.impl.interaction_server.InteractionServer.aiohttp_hook", "u": 52, "d": "Handle an AIOHTTP interaction request. This method handles aiohttp specific detail before calling InteractionServer.on_interaction with the data extracted from the\nrequest if it can and handles building an aiohttp response. Parameters request : aiohttp.web.Request The received request. Returns aiohtttp.web.Response The aiohttp response.", "f": 1}, {"r": "hikari.impl.interaction_server.InteractionServer.close", "u": 52, "d": "Gracefully close the server and any open connections.", "f": 1}, {"r": "hikari.impl.interaction_server.InteractionServer.join", "u": 52, "d": "Wait for the process to halt before continuing.", "f": 1}, {"r": "hikari.impl.interaction_server.InteractionServer.on_interaction", "u": 52, "d": "Handle an interaction received from Discord as a REST server. ! note If this server instance is alive then this will be called internally by the server but if the instance isn't alive then this may still be called externally to trigger interaction dispatch. Parameters body : builtins.bytes The interaction payload.\nsignature : builtins.bytes Value of the \"X-Signature-Ed25519\" header used to verify the body.\ntimestamp : builtins.bytes Value of the \"X-Signature-Timestamp\" header used to verify the body. Returns hikari.api.interaction_server.Response Instructions on how the REST server calling this should respond to the interaction request.", "f": 1}, {"r": "hikari.impl.interaction_server.InteractionServer.start", "u": 52, "d": "Start the bot and wait for the internal server to startup then return. Other Parameters backlog : builtins.int The number of unaccepted connections that the system will allow before refusing new connections.\nenable_signal_handlers : builtins.bool Defaults to builtins.True . If on a __non-Windows__ OS with builtin support for kernel-level POSIX signals, then setting this to builtins.True will allow treating keyboard interrupts and other OS signals to safely shut down the application as calls to shut down the application properly rather than just killing the process in a dirty state immediately. You should leave this disabled unless you plan to implement your own signal handling yourself.\nhost : typing.Optional[typing.Union[builtins.str, aiohttp.web.HostSequence TCP/IP host or a sequence of hosts for the HTTP server.\nport : typing.Optional[builtins.int] TCP/IP port for the HTTP server.\npath : typing.Optional[builtins.str] File system path for HTTP server unix domain socket.\nreuse_address : typing.Optional[builtins.bool] Tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire.\nreuse_port : typing.Optional[builtins.bool] Tells the kernel to allow this endpoint to be bound to the same port as other existing endpoints are also bound to.\nsocket : typing.Optional[socket.socket] A pre-existing socket object to accept connections on.\nshutdown_timeout : builtins.float A delay to wait for graceful server shutdown before forcefully disconnecting all open client sockets. This defaults to 60 seconds.\nssl_context : typing.Optional[ssl.SSLContext] SSL context for HTTPS servers. ! note For more information on the other parameters such as defaults see AIOHTTP's documentation.", "f": 1}, {"r": "hikari.impl.interaction_server.InteractionServer.get_listener", "u": 52, "d": "Get the listener registered for an interaction. Parameters interaction_type : typing.Type[hikari.interactions.base_interactions.PartialInteraction] Type of the interaction to get the registered listener for. Returns typing.Optional[ListenersT[hikari.interactions.base_interactions.PartialInteraction, hikari.api.special_endpoints.InteractionResponseBuilder] The callback registered for the provided interaction type if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.interaction_server.InteractionServer.set_listener", "u": 52, "d": "Set the listener callback for this interaction server. Parameters interaction_type : typing.Type[hikari.interactions.base_interactions.PartialInteraction] The type of interaction this listener should be registered for.\nlistener : typing.Optional[ListenerT[hikari.interactions.base_interactions.PartialInteraction, hikari.api.special_endpoints.InteractionResponseBuilder The asynchronous listener callback to set or builtins.None to unset the previous listener. Other Parameters replace : builtins.bool Whether this call should replace the previously set listener or not. This call will raise a builtins.ValueError if set to builtins.False when a listener is already set. Raises builtins.TypeError If replace is builtins.False when a listener is already set.", "f": 1}, {"r": "hikari.impl.buckets", "u": 53, "d": "Rate-limit extensions for RESTful bucketed endpoints. Provides implementations for the complex rate limiting mechanisms that Discord\nrequires for rate limit handling that conforms to the passed bucket headers\ncorrectly. This was initially a bit of a headache for me to understand, personally, since\nthere is a lot of \"implicit detail\" that is easy to miss from the documentation. In an attempt to make this somewhat understandable by anyone else, I have tried\nto document the theory of how this is handled here. What is the theory behind this implementation? In this module, we refer to a hikari.internal.routes.CompiledRoute as a definition\nof a route with specific major parameter values included (e.g. POST /channels/123/messages ), and a hikari.internal.routes.Route as a\ndefinition of a route without specific parameter values included (e.g. POST /channels/{channel}/messages ). We can compile a hikari.internal.routes.CompiledRoute from a hikari.internal.routes.Route by providing the corresponding parameters as kwargs, as you may already know. In this module, a \"bucket\" is an internal data structure that tracks and\nenforces the rate limit state for a specific hikari.internal.routes.CompiledRoute ,\nand can manage delaying tasks in the event that we begin to get rate limited.\nIt also supports providing in-order execution of queued tasks. Discord allocates types of buckets to routes. If you are making a request and\nthere is a valid rate limit on the route you hit, you should receive an X-RateLimit-Bucket header from the server in your response. This is a hash\nthat identifies a route based on internal criteria that does not include major\nparameters. This X-RateLimitBucket is known in this module as an \"bucket hash\". This means that generally, the route POST /channels/123/messages and POST /channels/456/messages will usually sit in the same bucket, but GET /channels/123/messages/789 and PATCH /channels/123/messages/789 will\nusually not share the same bucket. Discord may or may not change this at any\ntime, so hard coding this logic is not a useful thing to be doing. Rate limits, on the other hand, apply to a bucket and are specific to the major\nparameters of the compiled route. This means that POST /channels/123/messages and POST /channels/456/messages do not share the same real bucket, despite\nDiscord providing the same bucket hash. A real bucket hash is the builtins.str hash of\nthe bucket that Discord sends us in a response concatenated to the corresponding\nmajor parameters. This is used for quick bucket indexing internally in this\nmodule. One issue that occurs from this is that we cannot effectively hash a hikari.internal.routes.CompiledRoute that has not yet been hit, meaning that\nuntil we receive a response from this endpoint, we have no idea what our rate\nlimits could be, nor the bucket that they sit in. This is usually not\nproblematic, as the first request to an endpoint should never be rate limited\nunless you are hitting it from elsewhere in the same time window outside your\nhikari.applications. To manage this situation, unknown endpoints are allocated to\na special unlimited bucket until they have an initial bucket hash code allocated\nfrom a response. Once this happens, the route is reallocated a dedicated bucket.\nUnknown buckets have a hardcoded initial hash code internally. Initially acquiring time on a bucket Each time you BaseRateLimiter.acquire() a request timeslice for a given hikari.internal.routes.Route , several things happen. The first is that we\nattempt to find the existing bucket for that route, if there is one, or get an\nunknown bucket otherwise. This is done by creating a real bucket hash from the\ncompiled route. The initial hash is calculated using a lookup table that maps hikari.internal.routes.CompiledRoute objects to their corresponding initial hash\ncodes, or to the unknown bucket hash code if not yet known. This initial hash is\nprocessed by the hikari.internal.routes.CompiledRoute to provide the real bucket\nhash we need to get the route's bucket object internally. The BaseRateLimiter.acquire() method will take the bucket and acquire a new\ntimeslice on it. This takes the form of a asyncio.Future which should be\nawaited by the caller and will complete once the caller is allowed to make a\nrequest. Most of the time, this is done instantly, but if the bucket has an\nactive rate limit preventing requests being sent, then the future will be paused\nuntil the rate limit is over. This may be longer than the rate limit period if\nyou have queued a large number of requests during this limit, as it is\nfirst-come-first-served. Acquiring a rate limited bucket will start a bucket-wide task (if not already\nrunning) that will wait until the rate limit has completed before allowing more\nfutures to complete. This is done while observing the rate limits again, so can\neasily begin to re-ratelimit itself if needed. Once the task is complete, it\ntidies itself up and disposes of itself. This task will complete once the queue\nbecomes empty. The result of RESTBucketManager.acquire() is a tuple of a asyncio.Future to\nawait on which completes when you are allowed to proceed with making a request,\nand a real bucket hash which should be stored temporarily. This will be\nexplained in the next section. Handling the rate limit headers of a response Once you have received your response, you are expected to extract the values of\nthe vital rate limit headers manually and parse them to the correct data types.\nThese headers are:  X-RateLimit-Limit : an builtins.int describing the max requests in the bucket from empty to being rate limited.  X-RateLimit-Remaining : an builtins.int describing the remaining number of requests before rate limiting occurs in the current window.  X-RateLimit-Bucket : a builtins.str containing the initial bucket hash.  X-RateLimit-Reset-After : a builtins.float containing the number of seconds when the current rate limit bucket will reset with decimal millisecond precision. Each of the above values should be passed to the update_rate_limits method to\nensure that the bucket you acquired time from is correctly updated should\nDiscord decide to alter their ratelimits on the fly without warning (including\ntimings and the bucket). This method will manage creating new buckets as needed and resetting vital\ninformation in each bucket you use. Tidying up To prevent unused buckets cluttering up memory, each RESTBucketManager instance spins up a asyncio.Task that periodically locks the bucket list\n(not threadsafe, only using the concept of asyncio not yielding in regular\nfunctions) and disposes of any clearly stale buckets that are no longer needed.\nThese will be recreated again in the future if they are needed. When shutting down an application, one must remember to close() the RESTBucketManager that has been used. This will ensure the garbage collection\ntask is stopped, and will also ensure any remaining futures in any bucket queues\nhave an asyncio.CancelledError set on them to prevent deadlocking ratelimited\ncalls that may be waiting to be unlocked. Body-field-specific rate limiting As of the start of June, 2020, Discord appears to be enforcing another layer\nof rate limiting logic to their HTTP APIs which is field-specific. This means\nthat special rate limits will also exist on some endpoints that limit based\non what attributes you send in a JSON or form data payload. No information is sent in headers about these specific limits. You will only\nbe made aware that they exist once you get ratelimited. In the 429 ratelimited\nresponse, you will have the \"global\" attribute set to builtins.False , and a \"reset_after\" attribute that differs entirely to the X-RateLimit-Reset-After header. Thus, it is important to not assume the value in the 429 response\nfor the reset time is the same as the one in the bucket headers. Hikari's hikari.api.rest.RESTClient implementation specifically uses the value furthest\nin the future when working out which bucket to adhere to. It is worth remembering that there is an API limit to the number of 401s,\n403s, and 429s you receive, which is around 10,000 per 15 minutes. Passing this\nlimit results in a soft ban of your account. At the time of writing, the only example of this appears to be on the PATCH /channels/{channel_id} endpoint. This has a limit of two changes per\n10 minutes. More details about how this is implemented have yet to be\nreleased or documented ."}, {"r": "hikari.impl.buckets.UNKNOWN_HASH", "u": 53, "d": "The hash used for an unknown bucket that has not yet been resolved."}, {"r": "hikari.impl.buckets.RESTBucket", "u": 53, "d": "Represents a rate limit for an HTTP endpoint. Component to represent an active rate limit bucket on a specific HTTP route\nwith a specific major parameter combo. This is somewhat similar to the WindowedBurstRateLimiter in how it\nworks. This algorithm will use fixed-period time windows that have a given limit\n(capacity). Each time a task requests processing time, it will drip another\nunit into the bucket. Once the bucket has reached its limit, nothing can\ndrip and new tasks will be queued until the time window finishes. Once the time window finishes, the bucket will empty, returning the current\ncapacity to zero, and tasks that are queued will start being able to drip\nagain. Additional logic is provided by the RESTBucket.update_rate_limit call\nwhich allows dynamically changing the enforced rate limits at any time."}, {"r": "hikari.impl.buckets.RESTBucket.is_unknown", "u": 53, "d": "Return builtins.True if the bucket represents an UNKNOWN bucket."}, {"r": "hikari.impl.buckets.RESTBucket.acquire", "u": 53, "d": "Acquire time on this rate limiter. ! note You should afterwards invoke RESTBucket.update_rate_limit to update any rate limit information you are made aware of. Raises hikari.errors.RateLimitTooLongError If the rate limit is longer than max_rate_limit .", "f": 1}, {"r": "hikari.impl.buckets.RESTBucket.update_rate_limit", "u": 53, "d": "Update the rate limit information. Parameters remaining : builtins.int The calls remaining in this time window.\nlimit : builtins.int The total calls allowed in this time window.\nreset_at : builtins.float The epoch at which to reset the limit. ! note The reset_at epoch is expected to be a time.monotonic_timestamp monotonic epoch, rather than a time.time date-based epoch.", "f": 1}, {"r": "hikari.impl.buckets.RESTBucket.drip", "u": 53, "d": "Decrement the remaining count for this bucket. ! note If the bucket is marked as RESTBucket.is_unknown , then this will not do anything. Unknown buckets have infinite rate limits.", "f": 1}, {"r": "hikari.impl.buckets.RESTBucket.resolve", "u": 53, "d": "Resolve an unknown bucket. Parameters real_bucket_hash: builtins.str The real bucket hash for this bucket. Raises builtins.RuntimeError If the hash of the bucket is already known.", "f": 1}, {"r": "hikari.impl.buckets.RESTBucket.get_time_until_reset", "u": 53, "d": "Determine how long until the current rate limit is reset. Parameters now : builtins.float The monotonic time.monotonic_timestamp timestamp. ! warning Invoking this method will update the internal state if we were previously rate limited, but at the given time are no longer under that limit. This makes it imperative that you only pass the current timestamp to this function, and not past or future timestamps. The effects of doing the latter are undefined behaviour. Returns builtins.float The time left to sleep before the rate limit is reset. If no rate limit is in effect, then this will return 0.0 instead.", "f": 1}, {"r": "hikari.impl.buckets.RESTBucket.is_rate_limited", "u": 53, "d": "Determine if we are under a rate limit at the given time. Parameters now : builtins.float The monotonic time.monotonic_timestamp timestamp. Returns builtins.bool builtins.True if we are being rate limited, or builtins.False if we are not. ! warning Invoking this method will update the internal state if we were previously rate limited, but at the given time are no longer under that limit. This makes it imperative that you only pass the current timestamp to this function, and not past or future timestamps. The effects of doing the latter are undefined behaviour.", "f": 1}, {"r": "hikari.impl.buckets.RESTBucket.throttle", "u": 53, "d": "Perform the throttling rate limiter logic. Iterates repeatedly while the queue is not empty, adhering to any\nrate limits that occur in the mean time. ! note You should usually not need to invoke this directly, but if you do, ensure to call it using asyncio.create_task , and store the task immediately in throttle_task . When this coroutine function completes, it will set the throttle_task to builtins.None . This means you can check if throttling is occurring by checking if throttle_task is not builtins.None .", "f": 1}, {"r": "hikari.impl.buckets.RESTBucket.limit", "u": 53, "d": "The maximum number of WindowedBurstRateLimiter.acquire 's allowed in\nthis time window."}, {"r": "hikari.impl.buckets.RESTBucket.period", "u": 53, "d": "How long the window lasts for from the start in seconds."}, {"r": "hikari.impl.buckets.RESTBucket.remaining", "u": 53, "d": "The number of WindowedBurstRateLimiter.acquire 's left in this window\nbefore you will get rate limited."}, {"r": "hikari.impl.buckets.RESTBucket.reset_at", "u": 53, "d": "The time.monotonic_timestamp that the limit window ends at."}, {"r": "hikari.impl.buckets.RESTBucket.close", "u": 53, "d": "Close the rate limiter, and shut down any pending tasks. Once this is invoked, you should not reuse this object.", "f": 1}, {"r": "hikari.impl.buckets.RESTBucket.is_empty", "u": 53, "d": "Return builtins.True if no futures are on the queue being rate limited."}, {"r": "hikari.impl.buckets.RESTBucket.name", "u": 53, "d": "The name of the rate limiter."}, {"r": "hikari.impl.buckets.RESTBucket.queue", "u": 53, "d": "The queue of any futures under a rate limit."}, {"r": "hikari.impl.buckets.RESTBucket.throttle_task", "u": 53, "d": "The throttling task, or builtins.None if it is not running."}, {"r": "hikari.impl.buckets.RESTBucketManager", "u": 53, "d": "The main rate limiter implementation for HTTP clients. This is designed to provide bucketed rate limiting for Discord HTTP\nendpoints that respects the X-RateLimit-Bucket rate limit header. To do\nthis, it makes the assumption that any limit can change at any time. Parameters max_rate_limit : builtins.float The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error."}, {"r": "hikari.impl.buckets.RESTBucketManager.start", "u": 53, "d": "Start this ratelimiter up. This spins up internal garbage collection logic in the background to\nkeep memory usage to an optimal level as old routes and bucket hashes\nget discarded and replaced. Parameters poll_period : builtins.float Period to poll the garbage collector at in seconds. Defaults to 20 seconds.\nexpire_after : builtins.float Time after which the last reset_at was hit for a bucket to remove it. Higher values will retain unneeded ratelimit info for longer, but may produce more effective rate-limiting logic as a result. Using 0 will make the bucket get garbage collected as soon as the rate limit has reset. Defaults to 10 seconds.", "f": 1}, {"r": "hikari.impl.buckets.RESTBucketManager.close", "u": 53, "d": "Close the garbage collector and kill any tasks waiting on ratelimits. Once this has been called, this object is considered to be effectively\ndead. To reuse it, one should create a new instance.", "f": 1}, {"r": "hikari.impl.buckets.RESTBucketManager.gc", "u": 53, "d": "The garbage collector loop. This is designed to run in the background and manage removing unused\nroute references from the rate-limiter collection to save memory. This will run forever until RESTBucketManager.closed_event is set.\nThis will invoke RESTBucketManager.do_gc_pass periodically. Parameters poll_period : builtins.float The period to poll at.\nexpire_after : builtins.float Time after which the last reset_at was hit for a bucket to remove it. Higher values will retain unneeded ratelimit info for longer, but may produce more effective ratelimiting logic as a result. Using 0 will make the bucket get garbage collected as soon as the rate limit has reset. ! warning You generally have no need to invoke this directly. Use RESTBucketManager.start and RESTBucketManager.close to control this instead.", "f": 1}, {"r": "hikari.impl.buckets.RESTBucketManager.do_gc_pass", "u": 53, "d": "Perform a single garbage collection pass. This will assess any routes stored in the internal mappings of this\nobject and remove any that are deemed to be inactive or dead in order\nto save memory. If the removed routes are used again in the future, they will be\nre-cached automatically. Parameters expire_after : builtins.float Time after which the last reset_at was hit for a bucket to remove it. Defaults to reset_at + 20 seconds. Higher values will retain unneeded ratelimit info for longer, but may produce more effective ratelimiting logic as a result. ! warning You generally have no need to invoke this directly. Use RESTBucketManager.start and RESTBucketManager.close to control this instead.", "f": 1}, {"r": "hikari.impl.buckets.RESTBucketManager.acquire", "u": 53, "d": "Acquire a bucket for the given route. Parameters compiled_route : hikari.internal.routes.CompiledRoute The route to get the bucket for. Returns typing.AsyncContextManager[builtins.None] A context manager to enter while doing the request. ! note You MUST keep the context manager acquired during the whole of the request. From making the request until calling update_rate_limits .", "f": 1}, {"r": "hikari.impl.buckets.RESTBucketManager.update_rate_limits", "u": 53, "d": "Update the rate limits for a bucket using info from a response. Parameters compiled_route : hikari.internal.routes.CompiledRoute The compiled route to get the bucket for.\nbucket_header : typing.Optional[builtins.str] The X-RateLimit-Bucket header that was provided in the response.\nremaining_header : builtins.int The X-RateLimit-Remaining header cast to an builtins.int .\nlimit_header : builtins.int The X-RateLimit-Limit header cast to an builtins.int .\nreset_after : builtins.float The X-RateLimit-Reset-After header cast to a builtins.float .", "f": 1}, {"r": "hikari.impl.buckets.RESTBucketManager.is_started", "u": 53, "d": "Return builtins.True if the rate limiter GC task is started."}, {"r": "hikari.impl.buckets.RESTBucketManager.closed_event", "u": 53, "d": "An internal event that is set when the object is shut down."}, {"r": "hikari.impl.buckets.RESTBucketManager.gc_task", "u": 53, "d": "The internal garbage collector task."}, {"r": "hikari.impl.buckets.RESTBucketManager.max_rate_limit", "u": 53, "d": "The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error."}, {"r": "hikari.impl.buckets.RESTBucketManager.real_hashes_to_buckets", "u": 53, "d": "Maps full bucket hashes ( X-RateLimit-Bucket appended with a hash of\nmajor parameters used in that compiled route) to their corresponding rate\nlimiters."}, {"r": "hikari.impl.buckets.RESTBucketManager.routes_to_hashes", "u": 53, "d": "Maps routes to their X-RateLimit-Bucket header being used."}, {"r": "hikari.impl.shard", "u": 54, "d": "Single-shard implementation for the V8 event gateway for Discord."}, {"r": "hikari.impl.shard.GatewayShardImpl", "u": 54, "d": "Implementation of a V8 compatible gateway. Parameters token : builtins.str The bot token to use.\nurl : builtins.str The gateway URL to use. This should not contain a query-string or fragments.\nevent_manager : hikari.api.event_manager.EventManager The event manager this shard should make calls to.\nevent_factory : hikari.api.event_factory.EventFactory The event factory this shard should use. Other Parameters compression : typing.Optional[builtins.str] Compression format to use for the shard. Only supported values are \"transport_zlib_stream\" or builtins.None to disable it.\ninitial_activity : typing.Optional[hikari.presences.Activity] The initial activity to appear to have for this shard, or builtins.None if no activity should be set initially. This is the default.\ninitial_idle_since : typing.Optional[datetime.datetime] The datetime to appear to be idle since, or builtins.None if the shard should not provide this. The default is builtins.None .\ninitial_is_afk : bool Whether to appear to be AFK or not on login. Defaults to builtins.False .\ninitial_status : hikari.presences.Status The initial status to set on login for the shard. Defaults to hikari.presences.Status.ONLINE .\nintents : hikari.intents.Intents Collection of intents to use.\nlarge_threshold : builtins.int The number of members to have in a guild for it to be considered large.\nshard_id : builtins.int The shard ID.\nshard_count : builtins.int The shard count.\nhttp_settings : hikari.config.HTTPSettings The HTTP-related settings to use while negotiating a websocket.\nproxy_settings : hikari.config.ProxySettings The proxy settings to use while negotiating a websocket.\ndata_format : builtins.str Data format to use for inbound data. Only supported format is \"json\" . ! note If all four of initial_activity , initial_idle_since , initial_is_afk , and initial_status are not defined and left to their default values, then the presence will not be _updated_ on startup at all. If any of these _are_ specified, then any that are not specified will be set to sane defaults, which may change the previous status. This will only occur during startup, and is an artifact of how Discord manages these updates internally. All other calls to update the status of the shard will support partial updates."}, {"r": "hikari.impl.shard.GatewayShardImpl.heartbeat_latency", "u": 54, "d": "Return the shard's most recent heartbeat latency. Returns builtins.float Heartbeat latency measured in seconds. If the information is not yet available, then this will be float('nan') instead."}, {"r": "hikari.impl.shard.GatewayShardImpl.id", "u": 54, "d": "Return the shard ID for this shard. Returns builtins.int The integer 0-based shard ID."}, {"r": "hikari.impl.shard.GatewayShardImpl.intents", "u": 54, "d": "Return the intents set on this shard. Returns hikari.intents.Intents The intents being used on this shard."}, {"r": "hikari.impl.shard.GatewayShardImpl.is_alive", "u": 54, "d": "Return builtins.True if the shard is alive and connected. Returns builtins.bool builtins.True if connected, or builtins.False if not."}, {"r": "hikari.impl.shard.GatewayShardImpl.shard_count", "u": 54, "d": "Return the total number of shards expected in the entire application. Returns builtins.int A number of shards greater than or equal to 1."}, {"r": "hikari.impl.shard.GatewayShardImpl.close", "u": 54, "d": "Close the websocket if it is connected, otherwise do nothing.", "f": 1}, {"r": "hikari.impl.shard.GatewayShardImpl.get_user_id", "u": 54, "d": "Return the user ID. If the shard has not connected fully yet, this should wait until the ID\nis set before returning. Returns hikari.snowflakes.Snowflake The user ID for the application user.", "f": 1}, {"r": "hikari.impl.shard.GatewayShardImpl.join", "u": 54, "d": "Wait for this shard to close, if running.", "f": 1}, {"r": "hikari.impl.shard.GatewayShardImpl.request_guild_members", "u": 54, "d": "Request for a guild chunk. Parameters guild: hikari.guilds.Guild The guild to request chunk for. Other Parameters include_presences: hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences.\nquery: builtins.str If not   , request the members which username starts with the string.\nlimit: builtins.int Maximum number of members to send matching the query.\nusers: hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.users.User If provided, the users to request for.\nnonce: hikari.undefined.UndefinedOr[builtins.str] If provided, the nonce to be sent with guild chunks. ! note To request the full list of members, set query to   (empty string) and limit to 0 . Raises ValueError When trying to specify users with query / limit , if limit is not between 0 and 100, both inclusive or if users length is over 100.\nhikari.errors.MissingIntentError When trying to request presences without the GUILD_MEMBERS or when trying to request the full list of members without GUILD_PRESENCES .", "f": 1}, {"r": "hikari.impl.shard.GatewayShardImpl.start", "u": 54, "d": "Start the shard, wait for it to become ready.", "f": 1}, {"r": "hikari.impl.shard.GatewayShardImpl.update_presence", "u": 54, "d": "Update the presence of the shard user. If the shard is not alive, no physical data will be sent, however,\nthe new presence settings will be remembered for when the shard\ndoes connect. Other Parameters idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed.\nafk : hikari.undefined.UndefinedOr[builtins.bool] If builtins.True , the user is marked as AFK. If builtins.False , the user is marked as being active. If undefined, this will not be changed.\nactivity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed.\nstatus : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed.", "f": 1}, {"r": "hikari.impl.shard.GatewayShardImpl.update_voice_state", "u": 54, "d": "Update the voice state for this shard in a given guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild or guild ID to update the voice state for.\nchannel : typing.Optional[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel The channel or channel ID to update the voice state for. If builtins.None then the bot will leave the voice channel that it is in for the given guild.\nself_mute : builtins.bool If specified and builtins.True , the bot will mute itself in that voice channel. If builtins.False , then it will unmute itself.\nself_deaf : builtins.bool If specified and builtins.True , the bot will deafen itself in that voice channel. If builtins.False , then it will undeafen itself.", "f": 1}, {"r": "hikari.impl.event_factory", "u": 55, "d": "Implementation for a singleton bot event factory."}, {"r": "hikari.impl.event_factory.EventFactoryImpl", "u": 55, "d": "Implementation for a single-application bot event factory."}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_channel_create_event", "u": 55, "d": "Parse a raw payload from Discord into a channel create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.channel_events.ChannelCreateEvent The parsed channel create event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_channel_update_event", "u": 55, "d": "Parse a raw payload from Discord into a channel update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_channel : typing.Optional[hikari.channels.GuildChannel] The guild channel object or builtins.None . Returns hikari.events.channel_events.ChannelUpdateEvent The parsed event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_channel_delete_event", "u": 55, "d": "Parse a raw payload from Discord into a channel delete event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.channel_events.ChannelDeleteEvent The parsed channel delete event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_channel_pins_update_event", "u": 55, "d": "Parse a raw payload from Discord into a channel pins update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.channel_events.PinsUpdateEvent The parsed channel pins update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_webhook_update_event", "u": 55, "d": "Parse a raw payload from Discord into a webhook update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.channel_events.WebhookUpdateEvent The parsed webhook update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_invite_create_event", "u": 55, "d": "Parse a raw payload from Discord into an invite create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.channel_events.InviteCreateEvent The parsed invite create event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_invite_delete_event", "u": 55, "d": "Parse a raw payload from Discord into an invite delete event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_invite: typing.Optional[hikari.invites.InviteWithMetadata] The invite object or builtins.None . Returns hikari.events.channel_events.InviteDeleteEvent The parsed invite delete event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_typing_start_event", "u": 55, "d": "Parse a raw payload from Discord into a typing start event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.typing_events.TypingEvent The parsed typing start event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_create_event", "u": 55, "d": "Parse a raw payload from Discord into a guild create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.GuildAvailableEvent The parsed guild create event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_update_event", "u": 55, "d": "Parse a raw payload from Discord into a guild update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_guild : typing.Optional[hikari.guilds.Guild] The guild object or builtins.None . Returns hikari.events.guild_events.GuildUpdateEvent The parsed guild update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_leave_event", "u": 55, "d": "Parse a raw payload from Discord into a guild leave event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.GuildLeaveEvent The parsed guild leave event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_unavailable_event", "u": 55, "d": "Parse a raw payload from Discord into a guild unavailable event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.GuildUnavailableEvent The parsed guild unavailable event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_ban_add_event", "u": 55, "d": "Parse a raw payload from Discord into a guild ban add event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.BanCreateEvent The parsed guild ban add event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_ban_remove_event", "u": 55, "d": "Parse a raw payload from Discord into a guild ban remove event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.BanDeleteEvent The parsed guild ban remove event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_emojis_update_event", "u": 55, "d": "Parse a raw payload from Discord into a guild emojis update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_emojis : typing.Optional[typing.Sequence[hikari.emojis.KnownCustomEmoji The sequence of emojis or builtins.None . Returns hikari.events.guild_events.EmojisUpdateEvent The parsed guild emojis update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_integration_create_event", "u": 55, "d": "Parse a raw payload from Discord into an integration create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.IntegrationCreateEvent The parsed integration create event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_integration_delete_event", "u": 55, "d": "Parse a raw payload from Discord into an integration delete event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.IntegrationDeleteEvent The parsed integration delete event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_integration_update_event", "u": 55, "d": "Parse a raw payload from Discord into an integration update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.guild_events.IntegrationUpdateEvent The parsed integration update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_presence_update_event", "u": 55, "d": "Parse a raw payload from Discord into a presence update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_presence: typing.Optional[hikari.presences.MemberPresence] The presence object or builtins.None . Returns hikari.events.guild_events.PresenceUpdateEvent The parsed presence update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_interaction_create_event", "u": 55, "d": "Parse a raw payload from Discord into a interaction create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.interaction_events.InteractionCreateEvent The parsed interaction create event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_member_add_event", "u": 55, "d": "Parse a raw payload from Discord into a guild member add event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.member_events.MemberCreateEvent The parsed guild member add event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_member_update_event", "u": 55, "d": "Parse a raw payload from Discord into a guild member update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_member: typing.Optional[hikari.guilds.Member] The member object or builtins.None . Returns hikari.events.member_events.MemberUpdateEvent The parsed guild member update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_member_remove_event", "u": 55, "d": "Parse a raw payload from Discord into a guild member remove event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_member: typing.Optional[hikari.guilds.Member] The member object or builtins.None . Returns hikari.events.member_events.MemberDeleteEvent The parsed guild member remove event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_role_create_event", "u": 55, "d": "Parse a raw payload from Discord into a guild role create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.role_events.RoleCreateEvent The parsed guild role create event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_role_update_event", "u": 55, "d": "Parse a raw payload from Discord into a guild role update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_role: typing.Optional[hikari.guilds.Role] The role object or builtins.None . Returns hikari.events.role_events.RoleUpdateEvent The parsed guild role update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_role_delete_event", "u": 55, "d": "Parse a raw payload from Discord into a guild role delete event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_role: typing.Optional[hikari.guilds.Role] The role object or builtins.None . Returns hikari.events.role_events.RoleDeleteEvent The parsed guild role delete event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_starting_event", "u": 55, "d": "Build a starting event object. Returns hikari.events.lifetime_events.StartingEvent The built starting event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_started_event", "u": 55, "d": "Build a started event object. Returns hikari.events.lifetime_events.StartingEvent The built started event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_stopping_event", "u": 55, "d": "Build a starting event object. Returns hikari.events.lifetime_events.StartingEvent The built starting event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_stopped_event", "u": 55, "d": "Build a stopped event object. Returns hikari.events.lifetime_events.StartingEvent The built starting event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_message_create_event", "u": 55, "d": "Parse a raw payload from Discord into a message create event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.message_events.MessageCreateEvent The parsed message create event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_message_update_event", "u": 55, "d": "Parse a raw payload from Discord into a message update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_message: typing.Optional[hikari.messages.PartialMessage] The message object or builtins.None . Returns hikari.events.message_events.MessageUpdateEvent The parsed message update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_message_delete_event", "u": 55, "d": "Parse a raw payload from Discord into a message delete event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.message_events.MessageDeleteEvent The parsed message delete event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_message_delete_bulk_event", "u": 55, "d": "Parse a raw payload from Discord into a message delete bulk event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.message_events.MessageDeleteEvent The parsed message delete bulk event object. Raises builtins.NotImplementedError If a bulk delete occurs in a DM channel.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_message_reaction_add_event", "u": 55, "d": "Parse a raw payload from Discord into a message reaction add event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.reaction_events.ReactionAddEvent The parsed message reaction add event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_message_reaction_remove_event", "u": 55, "d": "Parse a raw payload from Discord into a message reaction remove event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.reaction_events.ReactionDeleteEvent The parsed message reaction remove event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_message_reaction_remove_all_event", "u": 55, "d": "Parse a raw payload from Discord into a message reaction remove all event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.reaction_events.ReactionDeleteAllEvent The parsed message reaction remove all event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_message_reaction_remove_emoji_event", "u": 55, "d": "Parse a raw payload from Discord into a message reaction remove emoji event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.reaction_events.ReactionDeleteEmojiEvent The parsed message reaction remove emoji event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_shard_payload_event", "u": 55, "d": "Parse a raw payload from Discord into a shard payload event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nname : builtins.str Name of the event. Returns hikari.events.shard_events.ShardPayloadEvent The parsed shard payload event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_ready_event", "u": 55, "d": "Parse a raw payload from Discord into a ready event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.shard_events.ShardReadyEvent The parsed ready event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_connected_event", "u": 55, "d": "Build a shard connected event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event. Returns hikari.events.shard_events.ShardReadyEvent The built shard connected event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_disconnected_event", "u": 55, "d": "Build a shard disconnected event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event. Returns hikari.events.shard_events.ShardReadyEvent The built shard disconnected event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_resumed_event", "u": 55, "d": "Build a shard resumed event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event. Returns hikari.events.shard_events.ShardReadyEvent The built shard resumed event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_member_chunk_event", "u": 55, "d": "Parse a raw payload from Discord into a member chunk event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.shard_events.MemberChunkEvent The parsed member chunk object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_own_user_update_event", "u": 55, "d": "Parse a raw payload from Discord into a own user update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_user: typing.Optional[hikari.users.OwnUser] The OwnUser object or builtins.None . Returns hikari.events.user_events.OwnUserUpdateEvent The parsed own user update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_voice_state_update_event", "u": 55, "d": "Parse a raw payload from Discord into a voice state update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse.\nold_state: typing.Optional[hikari.voices.VoiceState] The VoiceState object or builtins.None . Returns hikari.events.voice_events.VoiceStateUpdateEvent The parsed voice state update event object.", "f": 1}, {"r": "hikari.impl.event_factory.EventFactoryImpl.deserialize_voice_server_update_event", "u": 55, "d": "Parse a raw payload from Discord into a voice server update event object. Parameters shard : hikari.api.shard.GatewayShard The shard that emitted this event.\npayload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns hikari.events.voice_events.VoiceServerUpdateEvent The parsed voice server update event object.", "f": 1}, {"r": "hikari.impl.rest_bot", "u": 56, "d": "Standard implementations of a Interaction based REST-only bot."}, {"r": "hikari.impl.rest_bot.RESTBot", "u": 56, "d": "Basic implementation of an interaction based REST-only bot. Parameters token : typing.Union[builtins.str, builtins.None, hikari.api.rest.TokenStrategy] The bot or bearer token. If no token is to be used, this can be undefined.\ntoken_type : typing.Union[builtins.str, hikari.applications.TokenType, builtins.None] The type of token in use. This should only be passed when builtins.str is passed for token , can be \"Bot\" or \"Bearer\" and will be defaulted to \"Bearer\" in this situation. This should be left as builtins.None when either hikari.api.rest.TokenStrategy or builtins.None is passed for token . Other Parameters allow_color : builtins.bool Defaulting to builtins.True , this will enable coloured console logs on any platform that is a TTY. Setting a \"CLICOLOR\" environment variable to any non 0 value will override this setting. Users should consider this an advice to the application on whether it is safe to show colours if possible or not. Since some terminals can be awkward or not support features in a standard way, the option to explicitly disable this is provided. See force_color for an alternative.\nbanner : typing.Optional[builtins.str] The package to search for a banner.txt in. Defaults to \"hikari\" for the \"hikari/banner.txt\" banner. Setting this to builtins.None will disable the banner being shown.\nexecutor : typing.Optional[concurrent.futures.Executor] Defaults to builtins.None . If non- builtins.None , then this executor is used instead of the concurrent.futures.ThreadPoolExecutor attached to the asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter.\nforce_color : builtins.bool Defaults to builtins.False . If builtins.True , then this application will __force__ colour to be used in console-based output. Specifying a \"CLICOLOR_FORCE\" environment variable with a non- \"0\" value will override this setting.\nhttp_settings : typing.Optional[hikari.config.HTTPSettings] Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts aiohttp should expect to use for requests, and behavior regarding HTTP-redirects.\nlogs : typing.Union[builtins.None, LoggerLevel, typing.Dict[str, typing.Any Defaults to \"INFO\" . If builtins.None , then the Python logging system is left uninitialized on startup, and you will need to configure it manually to view most logs that are output by components of this library. If one of the valid values in a LoggerLevel , then this will match a call to colorlog.basicConfig (a facade for logging.basicConfig with additional conduit for enabling coloured logging levels) with the level kwarg matching this value. If a typing.Dict[str, typing.Any] equivalent, then this value is passed to logging.config.dictConfig to allow the user to provide a specialized logging configuration of their choice. As a side note, you can always opt to leave this on the default value and then use an incremental logging.config.dictConfig that applies any additional changes on top of the base configuration, if you prefer. An example of can be found in the Example section. Note that \"TRACE_HIKARI\" is a library-specific logging level which is expected to be more verbose than \"DEBUG\" .\nmax_rate_limit : builtins.float The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes if left to the default value. This is to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use.\nmax_retries : typing.Optional[builtins.int] Maximum number of times a request will be retried if it fails with a 5xx status. Defaults to 3 if set to builtins.None .\nproxy_settings : typing.Optional[config.ProxySettings] Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy.\npublic_key : typing.Union[builtins.str, builtins.bytes, builtins.None] The public key to use to verify received interaction requests. This may be a hex encoded builtins.str or the raw builtins.bytes . If left as builtins.None then the client will try to work this value out based on token .\nrest_url : typing.Optional[builtins.str] Defaults to the Discord REST API URL if builtins.None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this. ! note force_color will always take precedence over allow_color . Raises builtins.ValueError If token_type is provided when a token strategy is passed for token . if token_type is left as builtins.None when a string is passed for token ."}, {"r": "hikari.impl.rest_bot.RESTBot.is_alive", "u": 56, "d": "Check whether the application is running or not. This is useful as some functions might raise hikari.errors.ComponentStateConflictError if this is builtins.False . Returns builtins.bool Whether the bot is running or not."}, {"r": "hikari.impl.rest_bot.RESTBot.interaction_server", "u": 56, "d": "Interaction server this app is bound to. Returns hikari.api.interaction_server.InteractionServer The interaction server this app is bound to."}, {"r": "hikari.impl.rest_bot.RESTBot.rest", "u": 56, "d": "Return the REST client to use for HTTP requests. Returns hikari.api.rest.RESTClient The REST client to use."}, {"r": "hikari.impl.rest_bot.RESTBot.entity_factory", "u": 56, "d": "Return the entity factory implementation for this object. Returns hikari.api.entity_factory.EntityFactory The entity factory component."}, {"r": "hikari.impl.rest_bot.RESTBot.http_settings", "u": 56, "d": "Return the HTTP settings in use by this component. Returns hikari.config.HTTPSettings The HTTP settings in use."}, {"r": "hikari.impl.rest_bot.RESTBot.proxy_settings", "u": 56, "d": "Return the proxy settings in use by this component. Returns hikari.config.ProxySettings The proxy settings in use."}, {"r": "hikari.impl.rest_bot.RESTBot.executor", "u": 56, "d": "Return the executor to use for blocking operations. This may return builtins.None if the default asyncio thread pool\nshould be used instead. Returns typing.Optional[concurrent.futures.Executor] The executor to use, or builtins.None to use the asyncio default instead."}, {"r": "hikari.impl.rest_bot.RESTBot.print_banner", "u": 56, "d": "Print the banner. This allows library vendors to override this behaviour, or choose to\ninject their own \"branding\" on top of what hikari provides by default. Normal users should not need to invoke this function, and can simply\nchange the banner argument passed to the constructor to manipulate\nwhat is displayed. Parameters banner : typing.Optional[builtins.str] The package to find a banner.txt in.\nallow_color : builtins.bool A flag that allows advising whether to allow color if supported or not. Can be overridden by setting a \"CLICOLOR\" environment variable to a non- \"0\" string.\nforce_color : builtins.bool A flag that allows forcing color to always be output, even if the terminal device may not support it. Setting the \"CLICOLOR_FORCE\" environment variable to a non- \"0\" string will override this. ! note force_color will always take precedence over allow_color .", "f": 1}, {"r": "hikari.impl.rest_bot.RESTBot.close", "u": 56, "d": "Kill the application by shutting all components down.", "f": 1}, {"r": "hikari.impl.rest_bot.RESTBot.join", "u": 56, "d": "Wait indefinitely until the application closes. This can be placed in a task and cancelled without affecting the\napplication runtime itself. Any exceptions raised by shards will be\npropagated to here.", "f": 1}, {"r": "hikari.impl.rest_bot.RESTBot.on_interaction", "u": 56, "d": "Handle an interaction received from Discord as a REST server. Parameters body : builtins.bytes The interaction payload.\nsignature : builtins.bytes Value of the \"X-Signature-Ed25519\" header used to verify the body.\ntimestamp : builtins.bytes Value of the \"X-Signature-Timestamp\" header used to verify the body. Returns Response Instructions on how the REST server calling this should respond to the interaction request.", "f": 1}, {"r": "hikari.impl.rest_bot.RESTBot.run", "u": 56, "d": "Open this REST server and block until it closes. Other Parameters asyncio_debug : builtins.bool Defaults to builtins.False . If builtins.True , then debugging is enabled for the asyncio event loop in use.\nbacklog : builtins.int The number of unaccepted connections that the system will allow before refusing new connections.\ncheck_for_updates : builtins.bool Defaults to builtins.True . If builtins.True , will check for newer versions of hikari on PyPI and notify if available.\nclose_loop : builtins.bool Defaults to builtins.True . If builtins.True , then once the bot enters a state where all components have shut down permanently during application shutdown, then all asyngens and background tasks will be destroyed, and the event loop will be shut down. This will wait until all hikari -owned aiohttp connectors have had time to attempt to shut down correctly (around 250ms), and on Python 3.9 and newer, will also shut down the default event loop executor too.\nclose_passed_executor : builtins.bool Defaults to builtins.False . If builtins.True , any custom concurrent.futures.Executor passed to the constructor will be shut down when the application terminates. This does not affect the default executor associated with the event loop, and will not do anything if you do not provide a custom executor to the constructor.\ncoroutine_tracking_depth : typing.Optional[builtins.int] Defaults to builtins.None . If an integer value and supported by the interpreter, then this many nested coroutine calls will be tracked with their call origin state. This allows you to determine where non-awaited coroutines may originate from, but generally you do not want to leave this enabled for performance reasons.\nenable_signal_handlers : builtins.bool Defaults to builtins.True . If on a __non-Windows__ OS with builtin support for kernel-level POSIX signals, then setting this to builtins.True will allow treating keyboard interrupts and other OS signals to safely shut down the application as calls to shut down the application properly rather than just killing the process in a dirty state immediately. You should leave this disabled unless you plan to implement your own signal handling yourself.\nhost : typing.Optional[typing.Union[builtins.str, aiohttp.web.HostSequence TCP/IP host or a sequence of hosts for the HTTP server.\nport : typing.Optional[builtins.int] TCP/IP port for the HTTP server.\npath : typing.Optional[builtins.str] File system path for HTTP server unix domain socket.\nreuse_address : typing.Optional[builtins.bool] Tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire.\nreuse_port : typing.Optional[builtins.bool] Tells the kernel to allow this endpoint to be bound to the same port as other existing endpoints are also bound to.\nsocket : typing.Optional[socket.socket] A pre-existing socket object to accept connections on.\nshutdown_timeout : builtins.float A delay to wait for graceful server shutdown before forcefully disconnecting all open client sockets. This defaults to 60 seconds.\nssl_context : typing.Optional[ssl.SSLContext] SSL context for HTTPS servers.", "f": 1}, {"r": "hikari.impl.rest_bot.RESTBot.start", "u": 56, "d": "Start the bot and wait for the internal server to startup then return. Other Parameters backlog : builtins.int The number of unaccepted connections that the system will allow before refusing new connections.\ncheck_for_updates : builtins.bool Defaults to builtins.True . If builtins.True , will check for newer versions of hikari on PyPI and notify if available.\nenable_signal_handlers : builtins.bool Defaults to builtins.True . If on a __non-Windows__ OS with builtin support for kernel-level POSIX signals, then setting this to builtins.True will allow treating keyboard interrupts and other OS signals to safely shut down the application as calls to shut down the application properly rather than just killing the process in a dirty state immediately. You should leave this disabled unless you plan to implement your own signal handling yourself.\nhost : typing.Optional[typing.Union[builtins.str, aiohttp.web.HostSequence TCP/IP host or a sequence of hosts for the HTTP server.\nport : typing.Optional[builtins.int] TCP/IP port for the HTTP server.\npath : typing.Optional[builtins.str] File system path for HTTP server unix domain socket.\nreuse_address : typing.Optional[builtins.bool] Tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire.\nreuse_port : typing.Optional[builtins.bool] Tells the kernel to allow this endpoint to be bound to the same port as other existing endpoints are also bound to.\nsocket : typing.Optional[socket.socket] A pre-existing socket object to accept connections on.\nshutdown_timeout : builtins.float A delay to wait for graceful server shutdown before forcefully disconnecting all open client sockets. This defaults to 60 seconds.\nssl_context : typing.Optional[ssl.SSLContext] SSL context for HTTPS servers. ! note For more information on the other parameters such as defaults see AIOHTTP's documentation.", "f": 1}, {"r": "hikari.impl.rest_bot.RESTBot.get_listener", "u": 56, "d": "Get the listener registered for an interaction. Parameters interaction_type : typing.Type[hikari.interactions.base_interactions.PartialInteraction] Type of the interaction to get the registered listener for. Returns typing.Optional[ListenersT[hikari.interactions.base_interactions.PartialInteraction, hikari.api.special_endpoints.InteractionResponseBuilder] The callback registered for the provided interaction type if found, else builtins.None .", "f": 1}, {"r": "hikari.impl.rest_bot.RESTBot.set_listener", "u": 56, "d": "Set the listener callback for this interaction server. Parameters interaction_type : typing.Type[hikari.interactions.base_interactions.PartialInteraction] The type of interaction this listener should be registered for.\nlistener : typing.Optional[ListenerT[hikari.interactions.base_interactions.PartialInteraction, hikari.api.special_endpoints.InteractionResponseBuilder The asynchronous listener callback to set or builtins.None to unset the previous listener. Other Parameters replace : builtins.bool Whether this call should replace the previously set listener or not. This call will raise a builtins.ValueError if set to builtins.False when a listener is already set. Raises builtins.TypeError If replace is builtins.False when a listener is already set.", "f": 1}, {"r": "hikari.templates", "u": 57, "d": "Application and entities that are used to describe guild templates on Discord."}, {"r": "hikari.templates.Template", "u": 57, "d": "Represents a template used for creating guilds. Method generated by attrs for class Template."}, {"r": "hikari.templates.Template.code", "u": 57, "d": "The template's unique ID."}, {"r": "hikari.templates.Template.created_at", "u": 57, "d": "When the template was created."}, {"r": "hikari.templates.Template.creator", "u": 57, "d": "The user who created the template."}, {"r": "hikari.templates.Template.description", "u": 57, "d": "The template's description."}, {"r": "hikari.templates.Template.is_unsynced", "u": 57, "d": "Whether this template is missing changes from it's source guild."}, {"r": "hikari.templates.Template.name", "u": 57, "d": "The template's name."}, {"r": "hikari.templates.Template.source_guild", "u": 57, "d": "The partial object of the guild this template is based on."}, {"r": "hikari.templates.Template.updated_at", "u": 57, "d": "When the template was last synced with the source guild."}, {"r": "hikari.templates.Template.usage_count", "u": 57, "d": "The number of times the template has been used to create a guild."}, {"r": "hikari.templates.TemplateGuild", "u": 57, "d": "The partial guild object attached to Template . Method generated by attrs for class TemplateGuild."}, {"r": "hikari.templates.TemplateGuild.afk_channel_id", "u": 57, "d": "The ID for the channel that AFK voice users get sent to. If builtins.None , then no AFK channel is set up for this guild."}, {"r": "hikari.templates.TemplateGuild.afk_timeout", "u": 57, "d": "Timeout for activity before a member is classed as AFK. How long a voice user has to be AFK for before they are classed as being\nAFK and are moved to the AFK channel ( Guild.afk_channel_id )."}, {"r": "hikari.templates.TemplateGuild.channels", "u": 57, "d": "The channels for the guild. ! note hikari.channels.GuildChannel.id will be a unique placeholder on all the channel objects found attached this template guild."}, {"r": "hikari.templates.TemplateGuild.default_message_notifications", "u": 57, "d": "The default setting for message notifications in this guild."}, {"r": "hikari.templates.TemplateGuild.description", "u": 57, "d": "The guild's description, if set."}, {"r": "hikari.templates.TemplateGuild.explicit_content_filter", "u": 57, "d": "The setting for the explicit content filter in this guild."}, {"r": "hikari.templates.TemplateGuild.preferred_locale", "u": 57, "d": "The preferred locale to use for this guild. This can only be change if GuildFeature.COMMUNITY is in Guild.features for this guild and will otherwise default to en-US ."}, {"r": "hikari.templates.TemplateGuild.roles", "u": 57, "d": "The roles in the guild. ! note hikari.guilds.Role.id will be a unique placeholder on all the role objects found attached this template guild."}, {"r": "hikari.templates.TemplateGuild.system_channel_flags", "u": 57, "d": "Return flags for the guild system channel. These are used to describe which notifications are suppressed."}, {"r": "hikari.templates.TemplateGuild.system_channel_id", "u": 57, "d": "The ID of the system channel or builtins.None if it is not enabled. Welcome messages and Nitro boost messages may be sent to this channel."}, {"r": "hikari.templates.TemplateGuild.verification_level", "u": 57, "d": "The verification level needed for a user to participate in this guild."}, {"r": "hikari.templates.TemplateGuild.icon_url", "u": 57, "d": "Icon URL for the guild, if set; otherwise builtins.None ."}, {"r": "hikari.templates.TemplateGuild.shard_id", "u": 57, "d": "Return the ID of the shard this guild is served by. This may return None if the application does not have a gateway\nconnection."}, {"r": "hikari.templates.TemplateGuild.make_icon_url", "u": 57, "d": "Generate the guild's icon URL, if set. Parameters ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to png or gif . Supports png , jpeg , jpg , webp and gif (when animated). If builtins.None , then the correct default extension is determined based on whether the icon is animated or not.\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns typing.Optional[hikari.files.URL] The URL to the resource, or builtins.None if no icon is set. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.templates.TemplateGuild.ban", "u": 57, "d": "Ban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to ban from the guild Other Parameters delete_message_days : hikari.undefined.UndefinedNoneOr[builtins.int] If provided, the number of days to delete messages for. This must be between 0 and 7.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.unban", "u": 57, "d": "Unban the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to unban from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the BAN_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.kick", "u": 57, "d": "Kicks the given user from this guild. Parameters user: hikari.snowflakes.Snowflakeish[hikari.users.PartialUser] The user to kick from the guild Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the KICK_MEMBERS permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild or user are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.edit", "u": 57, "d": "Edits the guild. Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild.\nverification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level.\ndefault_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level.\nexplicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level.\nafk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires afk_timeout to be set to work.\nafk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout.\nicon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the ANIMATED_ICON feature.\nowner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner. ! warning You need to be the owner of the server to use this.\nsplash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the INVITE_SPLASH feature.\nbanner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the BANNER feature.\nsystem_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel.\nrules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel.\npublic_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel.\npreferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.guilds.RESTGuild The edited guild. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the\nhikari.errors.ForbiddenError If you are missing the MANAGE_GUILD permission or if you tried to pass ownership without being the server owner.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.fetch_emojis", "u": 57, "d": "Fetch the emojis of the guild. Returns typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.fetch_emoji", "u": 57, "d": "Fetch an emoji from the guild. Parameters emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns hikari.emojis.KnownCustomEmoji The requested emoji. Raises hikari.errors.NotFoundError If the guild or the emoji are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.fetch_stickers", "u": 57, "d": "Fetch the stickers of the guild. Returns typing.Sequence[hikari.stickers.GuildSticker] The requested stickers. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.fetch_sticker", "u": 57, "d": "Fetch a sticker from the guild. Parameters sticker : snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to fetch. This can be a sticker object or the ID of an existing sticker. Returns hikari.stickers.GuildSticker The requested sticker. Raises hikari.errors.ForbiddenError If you are not part of the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.create_sticker", "u": 57, "d": "Create a sticker in a guild. Parameters name : builtins.str The name for the sticker.\ntag : builtins.str The tag for the sticker.\nimage : hikari.files.Resourceish The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie. ! note Lottie support is only available for verified and partnered servers. Other Parameters description: hikari.undefined.UndefinedOr[builtins.str] If provided, the description of the sticker.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The created sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.edit_sticker", "u": 57, "d": "Edit a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to edit. This can be a sticker object or the ID of an existing sticker. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the sticker.\ndescription : hikari.undefined.UndefinedOr[builtins.str] If provided, the new description for the sticker.\ntag : hikari.undefined.UndefinedOr[builtins.str] If provided, the new sticker tag.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.stickers.GuildSticker The edited sticker. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.delete_sticker", "u": 57, "d": "Delete a sticker in a guild. Parameters sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker] The sticker to delete. This can be a sticker object or the ID of an existing sticker. Other Parameters reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises hikari.errors.ForbiddenError If you are missing MANAGE_EMOJIS_AND_STICKERS in the server.\nhikari.errors.NotFoundError If the guild or the sticker are not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.create_category", "u": 57, "d": "Create a category in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildCategory The created category. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.create_text_channel", "u": 57, "d": "Create a text channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildTextChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.create_news_channel", "u": 57, "d": "Create a news channel in the guild. Parameters name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\ntopic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters.\nnsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW.\nrate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildNewsChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.create_voice_channel", "u": 57, "d": "Create a voice channel in a guild. Parameters guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild.\nname : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\nvideo_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, builtins.int If provided, the new video quality mode for the channel.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildVoiceChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the gui ld is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.create_stage_channel", "u": 57, "d": "Create a stage channel in the guild. Parameters name : builtins.str The channel's name. Must be between 2 and 1000 characters. Other Parameters position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any).\nuser_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.\nbitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.\npermission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel.\nregion : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, builtins.str If provided, the voice region to for this channel. Passing builtins.None here will set it to \"auto\" mode where the used region will be decided based on the first person who connects to it when it's empty.\ncategory : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns hikari.channels.GuildStageChannel The created channel. Raises hikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.delete_channel", "u": 57, "d": "Delete a channel in the guild. ! note This method can also be used for deleting guild categories as well. Parameters channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel or category to delete. This may be the object or the ID of an existing channel. Returns hikari.channels.GuildChannel Object of the channel or category that was deleted. Raises hikari.errors.UnauthorizedError, or close a DM. If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the MANAGE_CHANNEL permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.", "f": 1}, {"r": "hikari.templates.TemplateGuild.fetch_self", "u": 57, "d": "Fetch the guild. Returns hikari.guilds.RESTGuild The requested guild. Raises hikari.errors.ForbiddenError If you are not part of the guild.\nhikari.errors.NotFoundError If the guild is not found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.fetch_roles", "u": 57, "d": "Fetch the roles of the guild. Returns typing.Sequence[hikari.guilds.Role] The requested roles. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.templates.TemplateGuild.app", "u": 57, "d": "The client application that models may use for procedures."}, {"r": "hikari.templates.TemplateGuild.icon_hash", "u": 57, "d": "The hash for the guild icon, if there is one."}, {"r": "hikari.templates.TemplateGuild.id", "u": 57, "d": "The ID of this entity."}, {"r": "hikari.templates.TemplateGuild.name", "u": 57, "d": "The name of the guild."}, {"r": "hikari.templates.TemplateGuild.created_at", "u": 57, "d": "When the object was created."}, {"r": "hikari.templates.TemplateRole", "u": 57, "d": "The partial role object attached to Template . Method generated by attrs for class TemplateRole."}, {"r": "hikari.templates.TemplateRole.color", "u": 57, "d": "The colour of this role. This will be applied to a member's name in chat if it's their top coloured role."}, {"r": "hikari.templates.TemplateRole.is_hoisted", "u": 57, "d": "Whether this role is hoisting the members it's attached to in the member list. members will be hoisted under their highest role where this is set to builtins.True ."}, {"r": "hikari.templates.TemplateRole.is_mentionable", "u": 57, "d": "Whether this role can be mentioned by all regardless of permissions."}, {"r": "hikari.templates.TemplateRole.permissions", "u": 57, "d": "The guild wide permissions this role gives to the members it's attached to, This may be overridden by channel overwrites."}, {"r": "hikari.templates.TemplateRole.mention", "u": 57, "d": "Return a raw mention string for the role. Returns builtins.str The mention string to use."}, {"r": "hikari.templates.TemplateRole.app", "u": 57, "d": "The client application that models may use for procedures."}, {"r": "hikari.templates.TemplateRole.id", "u": 57, "d": "The ID of this entity."}, {"r": "hikari.templates.TemplateRole.name", "u": 57, "d": "The role's name."}, {"r": "hikari.templates.TemplateRole.created_at", "u": 57, "d": "When the object was created."}, {"r": "hikari.colors", "u": 58, "d": "Model that represents a common RGB color and provides simple conversions to other common color systems."}, {"r": "hikari.colors.Color", "u": 58, "d": "Representation of a color. This value is immutable. This is a specialization of builtins.int which provides alternative overrides for\ncommon methods and color system conversions. This currently supports: RGB RGB (float) 3-digit hex codes (e.g. 0xF1A web safe) 6-digit hex codes (e.g. 0xFF11AA) 3-digit RGB strings (e.g. 1A2 web safe) 6-digit RGB hash strings (e.g. 1A2B3C) Examples Examples of conversions to given formats include: py\n>>> c = Color(0xFF051A)\nColor(r=0xff, g=0x5, b=0x1a) >>> hex(c)\n0xff051a >>> c.hex_code FF051A >>> str(c) FF051A >>> int(c)\n16712986 >>> c.rgb\n(255, 5, 26) >>> c.rgb_float\n(1.0, 0.0196078431372549, 0.10196078431372549) Alternatively, if you have an arbitrary input in one of the above formats\nthat you wish to become a color, you can use Color.of on the class itself\nto automatically attempt to resolve the color: py\n>>> Color.of(0xFF051A)\nColor(r=0xff, g=0x5, b=0x1a) >>> Color.of(16712986)\nColor(r=0xff, g=0x5, b=0x1a) >>> c = Color.of 255, 5, 26 Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of(255, 5, 26)\nColor(r=0xff, g=0x5, b=1xa) >>> c = Color.of([0xFF, 0x5, 0x1a])\nColor(r=0xff, g=0x5, b=1xa) >>> c = Color.of(\" 1a2b3c\")\nColor(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.of(\" 1AB\")\nColor(r=0x11, g=0xaa, b=0xbb) >>> c = Color.of 1.0, 0.0196078431372549, 0.10196078431372549 Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of([1.0, 0.0196078431372549, 0.10196078431372549])\nColor(r=0xff, g=0x5, b=0x1a) Examples of initialization of Color objects from given formats include: py\n>>> c = Color(16712986)\nColor(r=0xff, g=0x5, b=0x1a) >>> c = Color.from_rgb(255, 5, 26)\nColor(r=0xff, g=0x5, b=1xa) >>> c = Color.from_hex_code(\" 1a2b3c\")\nColor(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.from_hex_code(\" 1AB\")\nColor(r=0x11, g=0xaa, b=0xbb) >>> c = Color.from_rgb_float(1.0, 0.0196078431372549, 0.10196078431372549)\nColor(r=0xff, g=0x5, b=0x1a) "}, {"r": "hikari.colors.Color.rgb", "u": 58, "d": "The RGB representation of this Color. Represented as a tuple of R, G, B. Each value is\nin the range [0, 0xFF]. Example  (123, 234, 47) "}, {"r": "hikari.colors.Color.rgb_float", "u": 58, "d": "Return the floating-point RGB representation of this Color. Represented as a tuple of R, G, B. Each value is in the range [0, 1]. Example  (0.1, 0.2, 0.76) "}, {"r": "hikari.colors.Color.hex_code", "u": 58, "d": "Six-digit hexadecimal color code for this Color. This is prepended with a symbol, and will be in upper case. Example  1A2B3C "}, {"r": "hikari.colors.Color.raw_hex_code", "u": 58, "d": "Raw hex code. Example  1A2B3C "}, {"r": "hikari.colors.Color.is_web_safe", "u": 58, "d": " builtins.True if the color is web safe, builtins.False otherwise."}, {"r": "hikari.colors.Color.from_rgb", "u": 58, "d": "Convert the given RGB to a Color object. Each channel must be within the range [0, 255] (0x0, 0xFF). Parameters red : builtins.int Red channel.\ngreen : builtins.int Green channel.\nblue : builtins.int Blue channel. Returns Color A Color object. Raises builtins.ValueError If red, green, or blue are outside the range [0x0, 0xFF].", "f": 1}, {"r": "hikari.colors.Color.from_rgb_float", "u": 58, "d": "Convert the given RGB to a Color object. The color-space represented values have to be within the\nrange [0, 1]. Parameters red : builtins.float Red channel.\ngreen : builtins.float Green channel.\nblue : builtins.float Blue channel. Returns Color A Color object. Raises builtins.ValueError If red, green or blue are outside the range [0, 1].", "f": 1}, {"r": "hikari.colors.Color.from_hex_code", "u": 58, "d": "Convert the given hexadecimal color code to a Color . The inputs may be of the following format (case insensitive): 1a2 , 1a2 , 0x1a2 (for web-safe colors), or 1a2b3c , 1a2b3c , 0x1a2b3c (for regular 3-byte color-codes). Parameters hex_code : builtins.str A hexadecimal color code to parse. This may optionally start with a case insensitive 0x or . Returns Color A corresponding Color object. Raises builtins.ValueError If hex_code is not a hexadecimal or is a invalid length.", "f": 1}, {"r": "hikari.colors.Color.from_int", "u": 58, "d": "Convert the given typing.SupportsInt to a Color . Parameters integer : typing.SupportsInt The raw color integer. Returns Color The Color object.", "f": 1}, {"r": "hikari.colors.Color.from_tuple_string", "u": 58, "d": "Convert a string in a tuple-like format to a Color . This allows formats that are optionally enclosed by () , {} , or [] , and contain three floats or ints, either space separated or\ncomma separated. If comma separated, trailing and leading whitespace around each member\nis truncated. This is provided to allow command frontends to directly pass user\ninput for representing a given colour into this class safely. Examples   Floats\n\"1.0 1.0 1.0\"\n\"(1.0 1.0 1.0)\"\n\"[1.0 1.0 1.0]\"\n\"{1.0 1.0 1.0}\"\n\"1.0, 1.0, 1.0\"\n\"(1.0, 1.0, 1.0)\"\n\"[1.0, 1.0, 1.0]\"\n\"{1.0, 1.0, 1.0}\" Ints\n\"252 252 252\"\n\"(252 252 252)\"\n\"[252 252 252]\"\n\"{252 252 252}\"\n\"252, 252, 252\"\n\"(252, 252, 252)\"\n\"[252, 252, 252]\"\n\"{252, 252, 252}\" Parameters tuple_str : builtins.str The string to parse. Returns Color The parsed colour object. Raises ValueError If an invalid format is given, or if any values exceed 1.0 for floats or 255 for ints.", "f": 1}, {"r": "hikari.colors.Color.from_bytes", "u": 58, "d": "Convert the bytes to a Color . Parameters bytes_ : typing.Iterable[builtins.int] A iterable of int byte values.\nbyteorder : builtins.str The endianness of the value represented by the bytes. Can be \"big\" endian or \"little\" endian.\nsigned : builtins.bool Whether the value is signed or unsigned. Returns Color The Color object.", "f": 1}, {"r": "hikari.colors.Color.of", "u": 58, "d": "Convert the value to a Color . This attempts to determine the correct data format based on the\ninformation provided. Parameters value : Colorish A color compatible values. Examples  \n>>> Color.of(0xFF051A)\nColor(r=0xff, g=0x5, b=0x1a) >>> Color.of(16712986)\nColor(r=0xff, g=0x5, b=0x1a) >>> c = Color.of 255, 5, 26 Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of([0xFF, 0x5, 0x1a])\nColor(r=0xff, g=0x5, b=1xa) >>> c = Color.of(\" 1a2b3c\")\nColor(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.of(\" 1AB\")\nColor(r=0x11, g=0xaa, b=0xbb) >>> c = Color.of 1.0, 0.0196078431372549, 0.10196078431372549 Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of([1.0, 0.0196078431372549, 0.10196078431372549])\nColor(r=0xff, g=0x5, b=0x1a) Commas and brackets are optional, whitespace is ignored, and these are compatible with all-ints between 0-255 or all-floats between 0.0 and 1.0 only.\n>>> c = Color.of(\"5, 22, 33\")\nColor(r=0x5, g=0x16, b=0x21)\n>>> c = Color.of(\"(5, 22, 33)\")\nColor(r=0x5, g=0x16, b=0x21)\n>>> c = Color.of(\"[5, 22, 33]\")\nColor(r=0x5, g=0x16, b=0x21)\n>>> c = Color.of(\"{5, 22, 33}\")\nColor(r=0x5, g=0x16, b=0x21) Returns Color The Color object.", "f": 1}, {"r": "hikari.colors.Color.to_bytes", "u": 58, "d": "Convert the color code to bytes. Parameters length : builtins.int The number of bytes to produce. Should be around 3 , but not less.\nbyteorder : builtins.str The endianness of the value represented by the bytes. Can be \"big\" endian or \"little\" endian.\nsigned : builtins.bool Whether the value is signed or unsigned. Returns builtins.bytes The bytes representation of the Color.", "f": 1}, {"r": "hikari.colors.Colorish", "u": 58, "d": "Type hint representing types of value compatible with a colour type. This may be: 1. hikari.colors.Color 2. hikari.colours.Colour (an alias for hikari.colors.Color ).\n3. A value that can be cast to an builtins.int (RGB hex-code).\n4. a 3- builtins.tuple of builtins.int (RGB integers in range 0 through 255).\n5. a 3- builtins.tuple of builtins.float (RGB floats in range 0 through 1).\n6. a list of builtins.int .\n7. a list of builtins.float .\n8. a builtins.str hex colour code. A hex colour code is expected to be in one of the following formats. Each of the\nfollowing examples means the same thing semantically. 1. (web-safe) \"12F\" (equivalent to \"1122FF\" )\n2. (web-safe) \"0x12F\" (equivalent to \"0x1122FF\" )\n3. (web-safe) \"0X12F\" (equivalent to \"0X1122FF\" )\n4. (web-safe) \" 12F\" (equivalent to \" 1122FF\" )\n5. \"1122FF\" 6. \"0x1122FF\" 7. \"0X1122FF\" 8. \" 1122FF\" Web-safe colours are three hex-digits wide, XYZ becomes XXYYZZ in full-form."}, {"r": "hikari.commands", "u": 59, "d": "Models and enums used for application commands on Discord."}, {"r": "hikari.commands.Command", "u": 59, "d": "Represents an application command on Discord. Method generated by attrs for class Command."}, {"r": "hikari.commands.Command.fetch_self", "u": 59, "d": "Fetch an up-to-date version of this command object. Returns Command Object of the fetched command. Raises hikari.errors.ForbiddenError If you cannot access the target command.\nhikari.errors.NotFoundError If the command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.commands.Command.edit", "u": 59, "d": "Edit this command. Other Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to edit a command for if this is a guild specific command. Leave this as hikari.undefined.UNDEFINED to delete a global command.\nname : hikari.undefined.UndefinedOr[builtins.str] The name to set for the command. Leave as hikari.undefined.UNDEFINED to not change.\ndescription : hikari.undefined.UndefinedOr[builtins.str] The description to set for the command. Leave as hikari.undefined.UNDEFINED to not change.\noptions : hikari.undefined.UndefinedOr[typing.Sequence[CommandOption A sequence of up to 10 options to set for this command. Leave this as hikari.undefined.UNDEFINED to not change. Returns Command The edited command object. Raises hikari.errors.ForbiddenError If you cannot access the application's commands.\nhikari.errors.NotFoundError If the application or command isn't found.\nhikari.errors.BadRequestError If any of the fields that are passed have an invalid value.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.commands.Command.delete", "u": 59, "d": "Delete this command. Raises hikari.errors.ForbiddenError If you cannot access the application's commands.\nhikari.errors.NotFoundError If the application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.commands.Command.fetch_guild_permissions", "u": 59, "d": "Fetch the permissions registered for this command in a specific guild. Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to fetch the command permissions for. Returns GuildCommandPermissions Object of the command permissions set for the specified command. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands or guild.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.commands.Command.set_guild_permissions", "u": 59, "d": "Set permissions for this command in a specific guild. ! note This overwrites any previously set permissions. Parameters guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild Object or ID of the guild to set the command permissions in.\npermissions : typing.Sequence[CommandPermission] Sequence of up to 10 of the permission objects to set. Returns GuildCommandPermissions Object of the set permissions. Raises hikari.errors.ForbiddenError If you cannot access the provided application's commands or guild.\nhikari.errors.NotFoundError If the provided application or command isn't found.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.commands.Command.app", "u": 59, "d": "The client application that models may use for procedures."}, {"r": "hikari.commands.Command.application_id", "u": 59, "d": "ID of the application this command belongs to."}, {"r": "hikari.commands.Command.default_permission", "u": 59, "d": "Whether the command is enabled by default when added to a guild. Defaults to builtins.True . This behaviour is overridden by command\npermissions."}, {"r": "hikari.commands.Command.description", "u": 59, "d": "The command's description. ! note This will be inclusively between 1-100 characters in length."}, {"r": "hikari.commands.Command.guild_id", "u": 59, "d": "ID of the guild this command is in. This will be builtins.None if this is a global command."}, {"r": "hikari.commands.Command.id", "u": 59, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.commands.Command.name", "u": 59, "d": "The command's name. ! note This will match the regex ^[a-z0-9_-]{1,32}$ ."}, {"r": "hikari.commands.Command.options", "u": 59, "d": "Sequence of up to (and including) 25 of the options for this command."}, {"r": "hikari.commands.Command.version", "u": 59, "d": "Auto-incrementing version identifier updated during substantial record changes."}, {"r": "hikari.commands.Command.created_at", "u": 59, "d": "When the object was created."}, {"r": "hikari.commands.CommandChoice", "u": 59, "d": "Represents the choices set for an application command's argument. Method generated by attrs for class CommandChoice."}, {"r": "hikari.commands.CommandChoice.name", "u": 59, "d": "The choice's name (inclusively between 1-100 characters)."}, {"r": "hikari.commands.CommandChoice.value", "u": 59, "d": "Value of the choice (up to 100 characters if a string)."}, {"r": "hikari.commands.CommandOption", "u": 59, "d": "Represents an application command's argument. Method generated by attrs for class CommandOption."}, {"r": "hikari.commands.CommandOption.choices", "u": 59, "d": "A sequence of up to (and including) 25 choices for this command. This will be builtins.None if the input values for this option aren't\nlimited to specific values or if it's a subcommand or subcommand-group type\noption."}, {"r": "hikari.commands.CommandOption.description", "u": 59, "d": "The command option's description. ! note This will be inclusively between 1-100 characters in length."}, {"r": "hikari.commands.CommandOption.is_required", "u": 59, "d": "Whether this command"}, {"r": "hikari.commands.CommandOption.name", "u": 59, "d": "The command option's name. ! note This will match the regex ^[a-z0-9_-]{1,32}$ ."}, {"r": "hikari.commands.CommandOption.options", "u": 59, "d": "Sequence of up to (and including) 25 of the options for this command option."}, {"r": "hikari.commands.CommandOption.type", "u": 59, "d": "The type of command option this is."}, {"r": "hikari.commands.CommandPermission", "u": 59, "d": "Representation of a permission which enables or disables a command for a user or role. Method generated by attrs for class CommandPermission."}, {"r": "hikari.commands.CommandPermission.has_access", "u": 59, "d": "Whether this permission marks the target entity as having access to the command."}, {"r": "hikari.commands.CommandPermission.id", "u": 59, "d": "Id of the role or user this permission changes the permission's state for."}, {"r": "hikari.commands.CommandPermission.type", "u": 59, "d": "The entity this permission overrides the command's state for."}, {"r": "hikari.commands.CommandPermissionType", "u": 59, "d": "The type of entity a command permission targets."}, {"r": "hikari.commands.CommandPermissionType.name", "u": 59, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.commands.CommandPermissionType.value", "u": 59, "d": "Return the value of the enum member."}, {"r": "hikari.commands.CommandPermissionType.ROLE", "u": 59, "d": "A command permission which toggles access for a specific role."}, {"r": "hikari.commands.CommandPermissionType.USER", "u": 59, "d": "A command permission which toggles access for a specific user."}, {"r": "hikari.commands.GuildCommandPermissions", "u": 59, "d": "Representation of the permissions set for a command within a guild. Method generated by attrs for class GuildCommandPermissions."}, {"r": "hikari.commands.GuildCommandPermissions.application_id", "u": 59, "d": "ID of the application the relevant command belongs to."}, {"r": "hikari.commands.GuildCommandPermissions.command_id", "u": 59, "d": "ID of the command these permissions are for."}, {"r": "hikari.commands.GuildCommandPermissions.guild_id", "u": 59, "d": "ID of the guild these permissions are in."}, {"r": "hikari.commands.GuildCommandPermissions.permissions", "u": 59, "d": "Sequence of up to (and including) 10 of the command permissions set in this guild."}, {"r": "hikari.commands.OptionType", "u": 59, "d": "The type of a command option."}, {"r": "hikari.commands.OptionType.name", "u": 59, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.commands.OptionType.value", "u": 59, "d": "Return the value of the enum member."}, {"r": "hikari.commands.OptionType.SUB_COMMAND", "u": 59, "d": "Denotes a command option where the value will be a sub command."}, {"r": "hikari.commands.OptionType.SUB_COMMAND_GROUP", "u": 59, "d": "Denotes a command option where the value will be a sub command group."}, {"r": "hikari.commands.OptionType.STRING", "u": 59, "d": "Denotes a command option where the value will be a string."}, {"r": "hikari.commands.OptionType.INTEGER", "u": 59, "d": "Denotes a command option where the value will be a int. This is range limited between -2^53 and 2^53."}, {"r": "hikari.commands.OptionType.BOOLEAN", "u": 59, "d": "Denotes a command option where the value will be a bool."}, {"r": "hikari.commands.OptionType.USER", "u": 59, "d": "Denotes a command option where the value will be resolved to a user."}, {"r": "hikari.commands.OptionType.CHANNEL", "u": 59, "d": "Denotes a command option where the value will be resolved to a channel."}, {"r": "hikari.commands.OptionType.ROLE", "u": 59, "d": "Denotes a command option where the value will be resolved to a role."}, {"r": "hikari.commands.OptionType.MENTIONABLE", "u": 59, "d": "Denotes a command option where the value will be a snowflake ID."}, {"r": "hikari.commands.OptionType.FLOAT", "u": 59, "d": "Denotes a command option where the value will be a float. This is range limited between -2^53 and 2^53."}, {"r": "hikari.files", "u": 60, "d": "Utilities and classes for interacting with files and web resources."}, {"r": "hikari.files.ensure_path", "u": 60, "d": "Convert a path-like object to a pathlib.Path instance.", "f": 1}, {"r": "hikari.files.ensure_resource", "u": 60, "d": "Given a resource or string, convert it to a valid resource as needed. Parameters url_or_resource : Resourceish The item to convert. Ff a Resource is passed, it is simply returned again. Anything else is converted to a Resource first. Returns Resource The resource to use.", "f": 1}, {"r": "hikari.files.unwrap_bytes", "u": 60, "d": "Convert a byte-like object to bytes.", "f": 1}, {"r": "hikari.files.Pathish", "u": 60, "d": "Type hint representing a literal file or path. This may be one of: - builtins.str path.\n- os.PathLike derivative, such as pathlib.PurePath and pathlib.Path ."}, {"r": "hikari.files.Rawish", "u": 60, "d": "Type hint representing valid raw data types. This may be one of: - bytes - bytearray - memoryview - io.BytesIO - io.StringIO (assuming UTF-8 encoding)."}, {"r": "hikari.files.Resourceish", "u": 60, "d": "Type hint representing a file or path to a file/URL/data URI. This may be one of: - Resource or a derivative.\n- builtins.str path.\n- os.PathLike derivative, such as pathlib.PurePath and pathlib.Path .\n- bytes - bytearray - memoryview - io.BytesIO - io.StringIO (assuming UTF-8 encoding)."}, {"r": "hikari.files.LazyByteIteratorish", "u": 60, "d": "Type hint representing an iterator/iterable of bytes. This may be one of: - typing.AsyncIterator[bytes] - typing.AsyncIterable[bytes] - typing.Iterator[bytes] - typing.Iterable[bytes] - typing.AsyncIterator[str] (assuming UTF-8 encoding).\n- typing.AsyncIterable[str] (assuming UTF-8 encoding).\n- typing.Iterator[str] (assuming UTF-8 encoding).\n- typing.Iterable[str] (assuming UTF-8 encoding).\n- asyncio.StreamReader - aiohttp.StreamReader "}, {"r": "hikari.files.AsyncReader", "u": 60, "d": "Protocol for reading a resource asynchronously using bit inception. This supports being used as an async iterable, although the implementation\ndetail is left to each implementation of this class to define. Method generated by attrs for class AsyncReader."}, {"r": "hikari.files.AsyncReader.data_uri", "u": 60, "d": "Fetch the data URI. This reads the entire resource.", "f": 1}, {"r": "hikari.files.AsyncReader.read", "u": 60, "d": "Read the rest of the resource and return it in a builtins.bytes object.", "f": 1}, {"r": "hikari.files.AsyncReader.filename", "u": 60, "d": "The filename of the resource."}, {"r": "hikari.files.AsyncReader.mimetype", "u": 60, "d": "The mimetype of the resource. May be builtins.None if not known."}, {"r": "hikari.files.AsyncReaderContextManager", "u": 60, "d": "Context manager that returns a reader."}, {"r": "hikari.files.Resource", "u": 60, "d": "Base for any uploadable or downloadable representation of information. These representations can be streamed using bit inception for performance,\nwhich may result in significant decrease in memory usage for larger\nresources."}, {"r": "hikari.files.Resource.url", "u": 60, "d": "URL of the resource."}, {"r": "hikari.files.Resource.filename", "u": 60, "d": "Filename of the resource."}, {"r": "hikari.files.Resource.extension", "u": 60, "d": "File extension, if there is one."}, {"r": "hikari.files.Resource.read", "u": 60, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.files.Resource.stream", "u": 60, "d": "Produce a stream of data for the resource. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. This will fetch the headers for the HTTP resource this object points to without downloading the entire content, which can be significantly faster if you are scanning file types in messages, for example. Returns AsyncReaderContextManager[AsyncReader] An async iterable of bytes to stream.", "f": 1}, {"r": "hikari.files.File", "u": 60, "d": "A resource that exists on the local machine's storage to be uploaded. Parameters path : typing.Union[builtins.str, os.PathLike, pathlib.Path] The path to use. ! note If passing a pathlib.Path , this must not be a pathlib.PurePath directly, as it will be used to expand tokens such as ~ that denote the home directory, and   for relative paths. This will all be performed as required in an executor to prevent blocking the event loop.\nfilename : typing.Optional[builtins.str] The filename to use. If this is builtins.None , the name of the file is taken from the path instead.\nspoiler : bool Whether to mark the file as a spoiler in Discord. Defaults to builtins.False ."}, {"r": "hikari.files.File.url", "u": 60, "d": "URL of the resource."}, {"r": "hikari.files.File.filename", "u": 60, "d": "Filename of the resource."}, {"r": "hikari.files.File.stream", "u": 60, "d": "Start streaming the resource using a thread pool executor. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run the blocking read operations in. If builtins.None , the default executor for the running event loop will be used instead.\nhead_only : builtins.bool Not used. Provided only to match the underlying interface. Returns AsyncReaderContextManager[FileReader] An async context manager that when entered, produces the data stream.", "f": 1}, {"r": "hikari.files.File.is_spoiler", "u": 60, "d": "Whether the file will be marked as a spoiler."}, {"r": "hikari.files.File.path", "u": 60, "d": "The path to the file."}, {"r": "hikari.files.File.extension", "u": 60, "d": "File extension, if there is one."}, {"r": "hikari.files.File.read", "u": 60, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.files.FileReader", "u": 60, "d": "Abstract base for a file reader object. Various implementations have to exist in order to cater for situations\nwhere we cannot pass IO objects around (e.g. ProcessPoolExecutors, since\nthey pickle things). Method generated by attrs for class FileReader."}, {"r": "hikari.files.FileReader.executor", "u": 60, "d": "The associated concurrent.futures.Executor to use for blocking IO."}, {"r": "hikari.files.FileReader.path", "u": 60, "d": "The path to the resource to read."}, {"r": "hikari.files.FileReader.data_uri", "u": 60, "d": "Fetch the data URI. This reads the entire resource.", "f": 1}, {"r": "hikari.files.FileReader.read", "u": 60, "d": "Read the rest of the resource and return it in a builtins.bytes object.", "f": 1}, {"r": "hikari.files.FileReader.filename", "u": 60, "d": "The filename of the resource."}, {"r": "hikari.files.FileReader.mimetype", "u": 60, "d": "The mimetype of the resource. May be builtins.None if not known."}, {"r": "hikari.files.WebResource", "u": 60, "d": "Base class for a resource that resides on the internet. The logic for identifying this resource is left to each implementation\nto define. ! info For a usable concrete implementation, use URL instead. ! note Some components may choose to not upload this resource directly and instead simply refer to the URL as needed. The main place this will occur is within embeds. If you need to re-upload the resource, you should download it into a builtins.bytes and pass that instead in these cases."}, {"r": "hikari.files.WebResource.stream", "u": 60, "d": "Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource,\nor just to view any metadata that may be provided. Parameters executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples Downloading an entire resource at once into memory: py\nasync with obj.stream() as stream: data = await stream.read() Checking the metadata: py\nasync with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None: .\nelif mimetype not in whitelisted_mimetypes: .\nelse: . Fetching the data-uri of a resource: py\nasync with obj.stream() as stream: data_uri = await stream.data_uri() Returns AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises hikari.errors.BadRequestError If a 400 is returned.\nhikari.errors.UnauthorizedError If a 401 is returned.\nhikari.errors.ForbiddenError If a 403 is returned.\nhikari.errors.NotFoundError If a 404 is returned.\nhikari.errors.ClientHTTPResponseError If any other 4xx is returned.\nhikari.errors.InternalServerError If any other 5xx is returned.\nhikari.errors.HTTPResponseError If any other unexpected response code is returned.", "f": 1}, {"r": "hikari.files.WebResource.url", "u": 60, "d": "URL of the resource."}, {"r": "hikari.files.WebResource.filename", "u": 60, "d": "Filename of the resource."}, {"r": "hikari.files.WebResource.extension", "u": 60, "d": "File extension, if there is one."}, {"r": "hikari.files.WebResource.read", "u": 60, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.files.URL", "u": 60, "d": "A URL that represents a web resource. Parameters url : builtins.str The URL of the resource. ! note Some components may choose to not upload this resource directly and instead simply refer to the URL as needed. The main place this will occur is within embeds. If you need to re-upload the resource, you should download it into a builtins.bytes and pass that instead in these cases."}, {"r": "hikari.files.URL.url", "u": 60, "d": "URL of the resource."}, {"r": "hikari.files.URL.filename", "u": 60, "d": "Filename of the resource."}, {"r": "hikari.files.URL.stream", "u": 60, "d": "Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource,\nor just to view any metadata that may be provided. Parameters executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples Downloading an entire resource at once into memory: py\nasync with obj.stream() as stream: data = await stream.read() Checking the metadata: py\nasync with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None: .\nelif mimetype not in whitelisted_mimetypes: .\nelse: . Fetching the data-uri of a resource: py\nasync with obj.stream() as stream: data_uri = await stream.data_uri() Returns AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises hikari.errors.BadRequestError If a 400 is returned.\nhikari.errors.UnauthorizedError If a 401 is returned.\nhikari.errors.ForbiddenError If a 403 is returned.\nhikari.errors.NotFoundError If a 404 is returned.\nhikari.errors.ClientHTTPResponseError If any other 4xx is returned.\nhikari.errors.InternalServerError If any other 5xx is returned.\nhikari.errors.HTTPResponseError If any other unexpected response code is returned.", "f": 1}, {"r": "hikari.files.URL.extension", "u": 60, "d": "File extension, if there is one."}, {"r": "hikari.files.URL.read", "u": 60, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.files.WebReader", "u": 60, "d": "Asynchronous reader to use to read data from a web resource. Method generated by attrs for class WebReader."}, {"r": "hikari.files.WebReader.read", "u": 60, "d": "Read the rest of the resource and return it in a builtins.bytes object.", "f": 1}, {"r": "hikari.files.WebReader.charset", "u": 60, "d": "Optional character set information, if known."}, {"r": "hikari.files.WebReader.head_only", "u": 60, "d": "If builtins.True , then only the HEAD was requested. In this case, neither __aiter__ nor read would return anything other\nthan an empty byte string."}, {"r": "hikari.files.WebReader.reason", "u": 60, "d": "The HTTP response status reason."}, {"r": "hikari.files.WebReader.size", "u": 60, "d": "The size of the resource, if known."}, {"r": "hikari.files.WebReader.status", "u": 60, "d": "The initial HTTP response status."}, {"r": "hikari.files.WebReader.stream", "u": 60, "d": "The aiohttp.StreamReader to read the content from."}, {"r": "hikari.files.WebReader.url", "u": 60, "d": "The URL being read from."}, {"r": "hikari.files.WebReader.data_uri", "u": 60, "d": "Fetch the data URI. This reads the entire resource.", "f": 1}, {"r": "hikari.files.WebReader.filename", "u": 60, "d": "The filename of the resource."}, {"r": "hikari.files.WebReader.mimetype", "u": 60, "d": "The mimetype of the resource. May be builtins.None if not known."}, {"r": "hikari.files.Bytes", "u": 60, "d": "Representation of in-memory data to upload. Parameters data : typing.Union[Rawish, LazyByteIteratorish] The raw data.\nfilename : builtins.str The filename to use.\nmimetype : typing.Optional[builtins.str] The mimetype, or builtins.None if you do not wish to specify this. If not provided, then this will be generated from the file extension of the filename instead.\nspoiler : bool Whether to mark the file as a spoiler in Discord. Defaults to builtins.False ."}, {"r": "hikari.files.Bytes.url", "u": 60, "d": "URL of the resource."}, {"r": "hikari.files.Bytes.filename", "u": 60, "d": "Filename of the resource."}, {"r": "hikari.files.Bytes.stream", "u": 60, "d": "Start streaming the content in chunks. Parameters executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface.\nhead_only : builtins.bool Not used. Provided only to match the underlying interface. Returns AsyncReaderContextManager[IteratorReader] An async context manager that when entered, produces the data stream.", "f": 1}, {"r": "hikari.files.Bytes.from_data_uri", "u": 60, "d": "Parse a given data URI. Parameters data_uri : builtins.str The data URI to parse.\nfilename : typing.Optional[builtins.str] Filename to use. If this is not provided, then this is generated instead. Returns Bytes The parsed data URI as a Bytes object. Raises builtins.ValueError If the parsed argument is not a data URI.", "f": 1}, {"r": "hikari.files.Bytes.data", "u": 60, "d": "The raw data/provider of raw data to upload."}, {"r": "hikari.files.Bytes.is_spoiler", "u": 60, "d": "Whether the file will be marked as a spoiler."}, {"r": "hikari.files.Bytes.mimetype", "u": 60, "d": "The provided mimetype, if provided. Otherwise builtins.None ."}, {"r": "hikari.files.Bytes.extension", "u": 60, "d": "File extension, if there is one."}, {"r": "hikari.files.Bytes.read", "u": 60, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.files.IteratorReader", "u": 60, "d": "Asynchronous file reader that operates on in-memory data. Method generated by attrs for class IteratorReader."}, {"r": "hikari.files.IteratorReader.data", "u": 60, "d": "The data that will be yielded in chunks."}, {"r": "hikari.files.IteratorReader.data_uri", "u": 60, "d": "Fetch the data URI. This reads the entire resource.", "f": 1}, {"r": "hikari.files.IteratorReader.read", "u": 60, "d": "Read the rest of the resource and return it in a builtins.bytes object.", "f": 1}, {"r": "hikari.files.IteratorReader.filename", "u": 60, "d": "The filename of the resource."}, {"r": "hikari.files.IteratorReader.mimetype", "u": 60, "d": "The mimetype of the resource. May be builtins.None if not known."}, {"r": "hikari.permissions", "u": 61, "d": "Bitfield of permissions."}, {"r": "hikari.permissions.Permissions", "u": 61, "d": "Represents the permissions available in a given channel or guild. This enum is an enum.IntFlag . This means that you can combine multiple\npermissions together into one value using the bitwise-OR operator ( | ). my_perms = Permissions.MANAGE_CHANNELS | Permissions.MANAGE_GUILD your_perms = ( Permissions.CREATE_INSTANT_INVITE | Permissions.KICK_MEMBERS | Permissions.BAN_MEMBERS | Permissions.MANAGE_GUILD ) You can check if a permission is present in a set of combined\npermissions by using the bitwise-AND operator ( & ). This will return\nthe int-value of the permission if it is present, or 0 if not present. my_perms = Permissions.MANAGE_CHANNELS | Permissions.MANAGE_GUILD if my_perms & Permissions.MANAGE_CHANNELS: if my_perms & Permissions.MANAGE_GUILD: print(\"I have the permission to both manage the guild and the channels in it!\") else: print(\"I have the permission to manage channels!\") else: print(\"I don't have the permission to manage channels!\") Or you could simplify it: if my_perms & (Permissions.MANAGE_CHANNELS | Permissions.MANAGE_GUILD): print(\"I have the permission to both manage the guild and the channels in it!\") elif my_perms & Permissions.MANAGE_CHANNELS: print(\"I have the permission to manage channels!\") else: print(\"I don't have the permission to manage channels!\") If you need to check that a permission is not present , you can use the\nbitwise-XOR operator ( ^ ) to check. If the permission is not present, it\nwill return a non-zero value, otherwise if it is present, it will return 0 . my_perms = Permissions.MANAGE_CHANNELS | Permissions.MANAGE_GUILD if my_perms ^ Permissions.MANAGE_CHANNELS: print(\"Please give me the MANAGE_CHANNELS permission!\") Lastly, if you need all the permissions set except the permission you want,\nyou can use the inversion operator ( ~ ) to do that. All permissions except ADMINISTRATOR. my_perms = ~Permissions.ADMINISTRATOR"}, {"r": "hikari.permissions.Permissions.name", "u": 61, "d": "Return the name of the flag combination as a builtins.str ."}, {"r": "hikari.permissions.Permissions.value", "u": 61, "d": "Return the builtins.int value of the flag."}, {"r": "hikari.permissions.Permissions.all", "u": 61, "d": "Check if all of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.permissions.Permissions.any", "u": 61, "d": "Check if any of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.permissions.Permissions.difference", "u": 61, "d": "Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction - operator.", "f": 1}, {"r": "hikari.permissions.Permissions.intersection", "u": 61, "d": "Return a combination of flags that are set for both given values. Equivalent to using the \"AND\" & operator.", "f": 1}, {"r": "hikari.permissions.Permissions.invert", "u": 61, "d": "Return a set of all flags not in the current set.", "f": 1}, {"r": "hikari.permissions.Permissions.is_disjoint", "u": 61, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.permissions.Permissions.is_subset", "u": 61, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.permissions.Permissions.is_superset", "u": 61, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.permissions.Permissions.none", "u": 61, "d": "Check if none of the given flags are part of this value. ! note This is essentially the opposite of Flag.any . Returns builtins.bool builtins.True if none of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.permissions.Permissions.split", "u": 61, "d": "Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted typing.Sequence of each membe", "f": 1}, {"r": "hikari.permissions.Permissions.symmetric_difference", "u": 61, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.permissions.Permissions.union", "u": 61, "d": "Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\" ~ operator.", "f": 1}, {"r": "hikari.permissions.Permissions.isdisjoint", "u": 61, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.permissions.Permissions.issubset", "u": 61, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.permissions.Permissions.issuperset", "u": 61, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.permissions.Permissions.symmetricdifference", "u": 61, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.permissions.Permissions.all_permissions", "u": 61, "d": "Get an instance of Permissions with all the known permissions. Returns Permissions A permissions instance with all the known permissions.", "f": 1}, {"r": "hikari.permissions.Permissions.NONE", "u": 61, "d": "Empty permission."}, {"r": "hikari.permissions.Permissions.CREATE_INSTANT_INVITE", "u": 61, "d": "Allows creation of instant invites."}, {"r": "hikari.permissions.Permissions.KICK_MEMBERS", "u": 61, "d": "Allows kicking members. ! note In guilds with server-wide 2FA enabled this permission can only be used by users who have two-factor authentication enabled on their account (or their owner's account in the case of bot users) and the guild owner."}, {"r": "hikari.permissions.Permissions.BAN_MEMBERS", "u": 61, "d": "Allows banning members. ! note In guilds with server-wide 2FA enabled this permission can only be used by users who have two-factor authentication enabled on their account (or their owner's account in the case of bot users) and the guild owner."}, {"r": "hikari.permissions.Permissions.ADMINISTRATOR", "u": 61, "d": "Allows all permissions and bypasses channel permission overwrites. ! note In guilds with server-wide 2FA enabled this permission can only be used by users who have two-factor authentication enabled on their account (or their owner's account in the case of bot users) and the guild owner."}, {"r": "hikari.permissions.Permissions.MANAGE_CHANNELS", "u": 61, "d": "Allows management and editing of channels. ! note In guilds with server-wide 2FA enabled this permission can only be used by users who have two-factor authentication enabled on their account (or their owner's account in the case of bot users) and the guild owner."}, {"r": "hikari.permissions.Permissions.MANAGE_GUILD", "u": 61, "d": "Allows management and editing of the guild. ! note In guilds with server-wide 2FA enabled this permission can only be used by users who have two-factor authentication enabled on their account (or their owner's account in the case of bot users) and the guild owner."}, {"r": "hikari.permissions.Permissions.ADD_REACTIONS", "u": 61, "d": "Allows for the addition of reactions to messages."}, {"r": "hikari.permissions.Permissions.VIEW_AUDIT_LOG", "u": 61, "d": "Allows for viewing of audit logs."}, {"r": "hikari.permissions.Permissions.PRIORITY_SPEAKER", "u": 61, "d": "Allows for using priority speaker in a voice channel."}, {"r": "hikari.permissions.Permissions.STREAM", "u": 61, "d": "Allows the user to go live."}, {"r": "hikari.permissions.Permissions.VIEW_CHANNEL", "u": 61, "d": "Allows guild members to view a channel, which includes reading messages in text channels."}, {"r": "hikari.permissions.Permissions.SEND_MESSAGES", "u": 61, "d": "Allows for sending messages in a channel."}, {"r": "hikari.permissions.Permissions.SEND_TTS_MESSAGES", "u": 61, "d": "Allows for sending of /tts messages."}, {"r": "hikari.permissions.Permissions.MANAGE_MESSAGES", "u": 61, "d": "Allows for deletion of other users messages. ! note In guilds with server-wide 2FA enabled this permission can only be used by users who have two-factor authentication enabled on their account (or their owner's account in the case of bot users) and the guild owner."}, {"r": "hikari.permissions.Permissions.EMBED_LINKS", "u": 61, "d": "Links sent by users with this permission will be auto-embedded."}, {"r": "hikari.permissions.Permissions.ATTACH_FILES", "u": 61, "d": "Allows for uploading images and files."}, {"r": "hikari.permissions.Permissions.READ_MESSAGE_HISTORY", "u": 61, "d": "Allows for reading of message history."}, {"r": "hikari.permissions.Permissions.MENTION_ROLES", "u": 61, "d": "Allows for using the @everyone tag to notify all users in a channel,\nand the @here tag to notify all online users in a channel, and the @role tag (even if the role is not mentionable) to notify all users with\nthat role in a channel."}, {"r": "hikari.permissions.Permissions.USE_EXTERNAL_EMOJIS", "u": 61, "d": "Allows the usage of custom emojis from other guilds."}, {"r": "hikari.permissions.Permissions.VIEW_GUILD_INSIGHTS", "u": 61, "d": "Allows the user to view guild insights for eligible guilds."}, {"r": "hikari.permissions.Permissions.CONNECT", "u": 61, "d": "Allows for joining of a voice channel."}, {"r": "hikari.permissions.Permissions.SPEAK", "u": 61, "d": "Allows for speaking in a voice channel."}, {"r": "hikari.permissions.Permissions.MUTE_MEMBERS", "u": 61, "d": "Allows for muting members in a voice channel."}, {"r": "hikari.permissions.Permissions.DEAFEN_MEMBERS", "u": 61, "d": "Allows for deafening of members in a voice channel."}, {"r": "hikari.permissions.Permissions.MOVE_MEMBERS", "u": 61, "d": "Allows for moving of members between voice channels."}, {"r": "hikari.permissions.Permissions.USE_VOICE_ACTIVITY", "u": 61, "d": "Allows for using voice-activity-detection in a voice channel."}, {"r": "hikari.permissions.Permissions.CHANGE_NICKNAME", "u": 61, "d": "Allows for modification of own nickname."}, {"r": "hikari.permissions.Permissions.MANAGE_NICKNAMES", "u": 61, "d": "Allows for modification of other users nicknames."}, {"r": "hikari.permissions.Permissions.MANAGE_ROLES", "u": 61, "d": "Allows management and editing of roles. ! note In guilds with server-wide 2FA enabled this permission can only be used by users who have two-factor authentication enabled on their account (or their owner's account in the case of bot users) and the guild owner."}, {"r": "hikari.permissions.Permissions.MANAGE_WEBHOOKS", "u": 61, "d": "Allows management and editing of webhooks. ! note In guilds with server-wide 2FA enabled this permission can only be used by users who have two-factor authentication enabled on their account (or their owner's account in the case of bot users) and the guild owner."}, {"r": "hikari.permissions.Permissions.MANAGE_EMOJIS_AND_STICKERS", "u": 61, "d": "Allows management and editing of emojis and stickers. ! note In guilds with server-wide 2FA enabled this permission can only be used by users who have two-factor authentication enabled on their account (or their owner's account in the case of bot users) and the guild owner."}, {"r": "hikari.permissions.Permissions.USE_APPLICATION_COMMANDS", "u": 61, "d": "Allows for using the application commands of guild integrations within a text channel."}, {"r": "hikari.permissions.Permissions.REQUEST_TO_SPEAK", "u": 61, "d": "Allows for requesting to speak in stage channels. ! warning This permissions is currently defined as being \"under active development\" by Discord meaning that \"it may be changed or removed\" without warning."}, {"r": "hikari.permissions.Permissions.MANAGE_THREADS", "u": 61, "d": "Allows for deleting and archiving threads, and viewing all private threads. ! note In guilds with server-wide 2FA enabled this permission can only be used by users who have two-factor authentication enabled on their account (or their owner's account in the case of bot users) and the guild owner."}, {"r": "hikari.permissions.Permissions.USE_PUBLIC_THREADS", "u": 61, "d": "Allows for creating and participating in threads."}, {"r": "hikari.permissions.Permissions.USE_PRIVATE_THREADS", "u": 61, "d": "Allows for creating and participating in private threads."}, {"r": "hikari.permissions.Permissions.USE_EXTERNAL_STICKERS", "u": 61, "d": "Allows the usage of custom stickers from other servers."}, {"r": "hikari.audit_logs", "u": 62, "d": "Application and entities that are used to describe audit logs on Discord."}, {"r": "hikari.audit_logs.AuditLog", "u": 62, "d": "Represents a guilds audit log. Method generated by attrs for class AuditLog."}, {"r": "hikari.audit_logs.AuditLog.entries", "u": 62, "d": "A mapping of snowflake IDs to the audit log's entries."}, {"r": "hikari.audit_logs.AuditLog.integrations", "u": 62, "d": "A mapping of the partial objects of integrations found in this audit log."}, {"r": "hikari.audit_logs.AuditLog.users", "u": 62, "d": "A mapping of the objects of users found in this audit log."}, {"r": "hikari.audit_logs.AuditLog.webhooks", "u": 62, "d": "A mapping of the objects of webhooks found in this audit log."}, {"r": "hikari.audit_logs.AuditLogChange", "u": 62, "d": "Represents a change made to an audit log entry's target entity. Method generated by attrs for class AuditLogChange."}, {"r": "hikari.audit_logs.AuditLogChange.key", "u": 62, "d": "The name of the audit log change's key."}, {"r": "hikari.audit_logs.AuditLogChange.new_value", "u": 62, "d": "The new value of the key, if something was added or changed."}, {"r": "hikari.audit_logs.AuditLogChange.old_value", "u": 62, "d": "The old value of the key, if something was removed or changed."}, {"r": "hikari.audit_logs.AuditLogChangeKey", "u": 62, "d": "Commonly known and documented keys for audit log change objects. Others may exist. These should be expected to default to the raw string\nDiscord provided us. These are defined for documentation purposes and\ncan be treated as regular strings for all other purposes."}, {"r": "hikari.audit_logs.AuditLogChangeKey.name", "u": 62, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.audit_logs.AuditLogChangeKey.value", "u": 62, "d": "Return the value of the enum member."}, {"r": "hikari.audit_logs.AuditLogChangeKey.NAME", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.DESCRIPTION", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.ICON_HASH", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.SPLASH_HASH", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.DISCOVERY_SPLASH_HASH", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.BANNER_HASH", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.OWNER_ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.REGION", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.PREFERRED_LOCALE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.RTC_REGION", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.AFK_CHANNEL_ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.AFK_TIMEOUT", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.RULES_CHANNEL_ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.PUBLIC_UPDATES_CHANNEL_ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.MFA_LEVEL", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.VERIFICATION_LEVEL", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.EXPLICIT_CONTENT_FILTER", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.DEFAULT_MESSAGE_NOTIFICATIONS", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.VANITY_URL_CODE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.PRUNE_DELETE_DAYS", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.WIDGET_ENABLED", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.WIDGET_CHANNEL_ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.POSITION", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.TOPIC", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.BITRATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.PERMISSION_OVERWRITES", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.NSFW", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.APPLICATION_ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.PERMISSIONS", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.USER_LIMIT", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.COLOR", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.HOIST", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.MENTIONABLE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.ALLOW", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.DENY", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.INVITE_CODE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.CHANNEL_ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.INVITER_ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.MAX_USES", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.USES", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.MAX_AGE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.TEMPORARY", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.DEAF", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.MUTE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.NICK", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.AVATAR_HASH", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.TYPE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.ENABLE_EMOTICONS", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.EXPIRE_BEHAVIOR", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.EXPIRE_GRACE_PERIOD", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.RATE_LIMIT_PER_USER", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.SYSTEM_CHANNEL_ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.TAGS", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.FORMAT_TYPE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.ASSETS", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.AVAILABLE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.GUILD_ID", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.ADD_ROLE_TO_MEMBER", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.REMOVE_ROLE_FROM_MEMBER", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogChangeKey.COLOUR", "u": 62, "d": "Alias for \"COLOR"}, {"r": "hikari.audit_logs.AuditLogEntry", "u": 62, "d": "Represents an entry in a guild's audit log. Method generated by attrs for class AuditLogEntry."}, {"r": "hikari.audit_logs.AuditLogEntry.fetch_user", "u": 62, "d": "Fetch the user who made this change. Returns typing.Optional[hikari.users.User] The user who made this change, if available. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.audit_logs.AuditLogEntry.action_type", "u": 62, "d": "The type of action this entry represents."}, {"r": "hikari.audit_logs.AuditLogEntry.app", "u": 62, "d": "The client application that models may use for procedures."}, {"r": "hikari.audit_logs.AuditLogEntry.changes", "u": 62, "d": "A sequence of the changes made to AuditLogEntry.target_id ."}, {"r": "hikari.audit_logs.AuditLogEntry.id", "u": 62, "d": "The ID of this entity."}, {"r": "hikari.audit_logs.AuditLogEntry.options", "u": 62, "d": "Extra information about this entry. Only be provided for certain event_type ."}, {"r": "hikari.audit_logs.AuditLogEntry.reason", "u": 62, "d": "The reason for this change, if set (between 0-512 characters)."}, {"r": "hikari.audit_logs.AuditLogEntry.target_id", "u": 62, "d": "The ID of the entity affected by this change, if applicable."}, {"r": "hikari.audit_logs.AuditLogEntry.user_id", "u": 62, "d": "The ID of the user who made this change."}, {"r": "hikari.audit_logs.AuditLogEntry.created_at", "u": 62, "d": "When the object was created."}, {"r": "hikari.audit_logs.AuditLogEventType", "u": 62, "d": "The type of event that occurred."}, {"r": "hikari.audit_logs.AuditLogEventType.name", "u": 62, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.audit_logs.AuditLogEventType.value", "u": 62, "d": "Return the value of the enum member."}, {"r": "hikari.audit_logs.AuditLogEventType.GUILD_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.CHANNEL_CREATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.CHANNEL_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.CHANNEL_DELETE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.CHANNEL_OVERWRITE_CREATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.CHANNEL_OVERWRITE_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.CHANNEL_OVERWRITE_DELETE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MEMBER_KICK", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MEMBER_PRUNE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MEMBER_BAN_ADD", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MEMBER_BAN_REMOVE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MEMBER_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MEMBER_ROLE_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MEMBER_MOVE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MEMBER_DISCONNECT", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.BOT_ADD", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.ROLE_CREATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.ROLE_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.ROLE_DELETE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.INVITE_CREATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.INVITE_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.INVITE_DELETE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.WEBHOOK_CREATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.WEBHOOK_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.WEBHOOK_DELETE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.EMOJI_CREATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.EMOJI_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.EMOJI_DELETE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MESSAGE_DELETE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MESSAGE_BULK_DELETE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MESSAGE_PIN", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.MESSAGE_UNPIN", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.INTEGRATION_CREATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.INTEGRATION_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.INTEGRATION_DELETE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.STICKER_CREATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.STICKER_UPDATE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.AuditLogEventType.STICKER_DELETE", "u": 62, "d": ""}, {"r": "hikari.audit_logs.BaseAuditLogEntryInfo", "u": 62, "d": "A base object that all audit log entry info objects will inherit from. Method generated by attrs for class BaseAuditLogEntryInfo."}, {"r": "hikari.audit_logs.BaseAuditLogEntryInfo.app", "u": 62, "d": "The client application that models may use for procedures."}, {"r": "hikari.audit_logs.ChannelOverwriteEntryInfo", "u": 62, "d": "Represents the extra information for overwrite related audit log entries. Will be attached to the overwrite create, update and delete audit log\nentries. Method generated by attrs for class ChannelOverwriteEntryInfo."}, {"r": "hikari.audit_logs.ChannelOverwriteEntryInfo.id", "u": 62, "d": "The ID of this entity."}, {"r": "hikari.audit_logs.ChannelOverwriteEntryInfo.role_name", "u": 62, "d": "The name of the role this overwrite targets, if it targets a role."}, {"r": "hikari.audit_logs.ChannelOverwriteEntryInfo.type", "u": 62, "d": "The type of entity this overwrite targets."}, {"r": "hikari.audit_logs.ChannelOverwriteEntryInfo.app", "u": 62, "d": "The client application that models may use for procedures."}, {"r": "hikari.audit_logs.ChannelOverwriteEntryInfo.created_at", "u": 62, "d": "When the object was created."}, {"r": "hikari.audit_logs.MemberDisconnectEntryInfo", "u": 62, "d": "Extra information for the voice chat member disconnect entry. Method generated by attrs for class MemberDisconnectEntryInfo."}, {"r": "hikari.audit_logs.MemberDisconnectEntryInfo.count", "u": 62, "d": "The amount of members who were disconnected from voice in this entry."}, {"r": "hikari.audit_logs.MemberDisconnectEntryInfo.app", "u": 62, "d": "The client application that models may use for procedures."}, {"r": "hikari.audit_logs.MemberMoveEntryInfo", "u": 62, "d": "Extra information for the voice chat based member move entry. Method generated by attrs for class MemberMoveEntryInfo."}, {"r": "hikari.audit_logs.MemberMoveEntryInfo.fetch_channel", "u": 62, "d": "Fetch the guild voice based channel where the member(s) have been moved to. Returns hikari.channels.GuildVoiceChannel The guild voice based channel where the member(s) have been moved to. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.audit_logs.MemberMoveEntryInfo.channel_id", "u": 62, "d": "The channel that the member(s) have been moved to"}, {"r": "hikari.audit_logs.MemberMoveEntryInfo.count", "u": 62, "d": "The amount of members who were disconnected from voice in this entry."}, {"r": "hikari.audit_logs.MemberMoveEntryInfo.app", "u": 62, "d": "The client application that models may use for procedures."}, {"r": "hikari.audit_logs.MemberPruneEntryInfo", "u": 62, "d": "Extra information attached to guild prune log entries. Method generated by attrs for class MemberPruneEntryInfo."}, {"r": "hikari.audit_logs.MemberPruneEntryInfo.delete_member_days", "u": 62, "d": "The timedelta of how many days members were pruned for inactivity based on."}, {"r": "hikari.audit_logs.MemberPruneEntryInfo.members_removed", "u": 62, "d": "The number of members who were removed by this prune."}, {"r": "hikari.audit_logs.MemberPruneEntryInfo.app", "u": 62, "d": "The client application that models may use for procedures."}, {"r": "hikari.audit_logs.MessageBulkDeleteEntryInfo", "u": 62, "d": "Extra information for the message bulk delete audit entry. Method generated by attrs for class MessageBulkDeleteEntryInfo."}, {"r": "hikari.audit_logs.MessageBulkDeleteEntryInfo.count", "u": 62, "d": "The amount of messages that were deleted."}, {"r": "hikari.audit_logs.MessageBulkDeleteEntryInfo.app", "u": 62, "d": "The client application that models may use for procedures."}, {"r": "hikari.audit_logs.MessageDeleteEntryInfo", "u": 62, "d": "Extra information attached to the message delete audit entry. Method generated by attrs for class MessageDeleteEntryInfo."}, {"r": "hikari.audit_logs.MessageDeleteEntryInfo.fetch_channel", "u": 62, "d": "Fetch the guild text based channel where these message(s) were deleted. Returns hikari.channels.TextableGuildChannel The guild text based channel where these message(s) were deleted. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.audit_logs.MessageDeleteEntryInfo.channel_id", "u": 62, "d": "The ID of guild text based channel where these message(s) were deleted."}, {"r": "hikari.audit_logs.MessageDeleteEntryInfo.count", "u": 62, "d": "The amount of messages that were deleted."}, {"r": "hikari.audit_logs.MessageDeleteEntryInfo.app", "u": 62, "d": "The client application that models may use for procedures."}, {"r": "hikari.audit_logs.MessagePinEntryInfo", "u": 62, "d": "The extra information for message pin related audit log entries. Will be attached to the message pin and message unpin audit log entries. Method generated by attrs for class MessagePinEntryInfo."}, {"r": "hikari.audit_logs.MessagePinEntryInfo.fetch_channel", "u": 62, "d": "Fetch The channel where this message was pinned or unpinned. Returns hikari.channels.TextableChannel The channel where this message was pinned or unpinned. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel.\nhikari.errors.NotFoundError If the channel is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.audit_logs.MessagePinEntryInfo.fetch_message", "u": 62, "d": "Fetch the object of the message that's being pinned or unpinned. Returns hikari.messages.Message The message that's being pinned or unpinned. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.ForbiddenError If you are missing the READ_MESSAGES permission in the channel that the message is in.\nhikari.errors.NotFoundError If the message is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.audit_logs.MessagePinEntryInfo.channel_id", "u": 62, "d": "The ID of the text based channel where a pinned message is being targeted."}, {"r": "hikari.audit_logs.MessagePinEntryInfo.message_id", "u": 62, "d": "The ID of the message that's being pinned or unpinned."}, {"r": "hikari.audit_logs.MessagePinEntryInfo.app", "u": 62, "d": "The client application that models may use for procedures."}, {"r": "hikari.embeds", "u": 63, "d": "Application and entities that are used to describe message embeds on Discord."}, {"r": "hikari.embeds.Embed", "u": 63, "d": "Represents an embed."}, {"r": "hikari.embeds.Embed.from_received_embed", "u": 63, "d": "Generate an embed from the given attributes. You should never call this.", "f": 1}, {"r": "hikari.embeds.Embed.title", "u": 63, "d": "Return the title of the embed. This will be builtins.None if not set. Returns typing.Optional[builtins.str] The title of the embed."}, {"r": "hikari.embeds.Embed.description", "u": 63, "d": "Return the description of the embed. This will be builtins.None if not set. Returns typing.Optional[builtins.str] The description of the embed."}, {"r": "hikari.embeds.Embed.url", "u": 63, "d": "Return the URL of the embed title. This will be builtins.None if not set. Returns typing.Optional[builtins.str] The URL of the embed title"}, {"r": "hikari.embeds.Embed.color", "u": 63, "d": "Return the colour of the embed. This will be builtins.None if not set. Returns typing.Optional[hikari.colors.Color] The colour that is set."}, {"r": "hikari.embeds.Embed.colour", "u": 63, "d": "Return the colour of the embed. This is an alias of Embed.color . This will be builtins.None if not set. Returns typing.Optional[hikari.colors.Color] The colour that is set."}, {"r": "hikari.embeds.Embed.timestamp", "u": 63, "d": "Return the timestamp of the embed. This will be builtins.None if not set. Returns typing.Optional[datetime.datetime] The timestamp set on the embed. ! warning Setting a non-timezone-aware datetime will result in a warning being raised. This is done due to potential confusion caused by Discord requiring a UTC timestamp for this field. Any non-timezone aware timestamp is interpreted as using the system's current timezone instead. Thus, using datetime.datetime.utcnow will result in a potentially incorrect timezone being set. To generate a timezone aware timestamp, use one of the following snippets: Use UTC. >>> datetime.datetime.now(tz=datetime.timezone.utc) datetime.datetime(2020, 6, 5, 18, 29, 56, 424744, tzinfo=datetime.timezone.utc) Use your current timezone. >>> datetime.datetime.now().astimezone() datetime.datetime(2020, 7, 7, 8, 57, 9, 775328, tzinfo= ., 'BST' By specifying a timezone, Hikari can automatically adjust the given time to UTC without you needing to think about it. You can generate a timezone-aware timestamp instead of a timezone-naive one by specifying a timezone. Hikari will detect any difference in timezone if the timestamp is non timezone-naive and fix it for you. I am British, and it is June, so we are in daylight saving (UTC+1 or GMT+1, specifically). >>> import datetime This is timezone naive, notice no timezone in the repr that gets printed. This is no good to us, as Discord will interpret it as being in the future! >>> datetime.datetime.now() datetime.datetime(2020, 6, 5, 19, 29, 48, 281716) Instead, this is a timezone-aware timestamp, and we can use this correctly. This will always return the current time in UTC. >>> datetime.datetime.now(tz=datetime.timezone.utc) datetime.datetime(2020, 6, 5, 18, 29, 56, 424744, tzinfo=datetime.timezone.utc) We could instead use a custom timezone. Since the timezone is explicitly specified, Hikari will convert it to UTC for you when you send the embed. >>> . A library on PyPI called [tzlocal]( .) also exists that may be useful to you if you need to get your local timezone for any reason. >>> import datetime >>> import tzlocal Naive datetime that will show the wrong time on Discord. >>> datetime.datetime.now() datetime.datetime(2020, 6, 5, 19, 33, 21, 329950) Timezone-aware datetime that uses my local timezone correctly. >>> datetime.datetime.now(tz=tzlocal.get_localzone( datetime.datetime(2020, 6, 5, 19, 33, 40, 967939, tzinfo=<DstTzInfo 'Europe/London' BST+1:00:00 DST>) Changing timezones. >>> dt = datetime.datetime.now(tz=datetime.timezone.utc) >>> print(dt) datetime.datetime(2020, 6, 5, 18, 38, 27, 863990, tzinfo=datetime.timezone.utc) >>> dt.astimezone(tzlocal.get_localzone( datetime.datetime(2020, 6, 5, 19, 38, 27, 863990, tzinfo=<DstTzInfo 'Europe/London' BST+1:00:00 DST>) .this is not required, but you may find it more useful if using the timestamps in debug logs, for example."}, {"r": "hikari.embeds.Embed.footer", "u": 63, "d": "Return the footer of the embed. Will be builtins.None if not set. typing.Optional[EmbedFooter] The footer of the embed."}, {"r": "hikari.embeds.Embed.image", "u": 63, "d": "Return the image set in the embed. Will be builtins.None if not set. typing.Optional[EmbedImage] The image of the embed. ! note Use set_image to update this value."}, {"r": "hikari.embeds.Embed.thumbnail", "u": 63, "d": "Return the thumbnail set in the embed. Will be builtins.None if not set. typing.Optional[EmbedImage] The thumbnail of the embed. ! note Use set_thumbnail to update this value."}, {"r": "hikari.embeds.Embed.video", "u": 63, "d": "Return the video to show in the embed. Will be builtins.None if not set. Returns typing.Optional[EmbedVideo] The video of the embed. ! note This object cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event with a video attached."}, {"r": "hikari.embeds.Embed.provider", "u": 63, "d": "Return the provider to show in the embed. Will be builtins.None if not set. Returns typing.Optional[EmbedProvider] The provider of the embed. ! note This object cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event with a custom provider set."}, {"r": "hikari.embeds.Embed.author", "u": 63, "d": "Return the author to show in the embed. Will be builtins.None if not set. Returns typing.Optional[EmbedAuthor] The author of the embed. ! note Use set_author to update this value."}, {"r": "hikari.embeds.Embed.fields", "u": 63, "d": "Return the sequence of fields in the embed. ! note Use add_field to add a new field, edit_field to edit an existing field, or remove_field to remove a field."}, {"r": "hikari.embeds.Embed.set_author", "u": 63, "d": "Set the author of this embed. Parameters name : typing.Optional[builtins.str] The optional name of the author.\nurl : typing.Optional[builtins.str] The optional URL of the author.\nicon : typing.Optional[hikari.files.Resourceish] The optional image to show next to the embed author. This can be many different things, to aid in convenience. - If builtins.None , nothing is set. - If a pathlib.PurePath or builtins.str to a valid URL, the URL is linked to directly. - Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will have their URL linked to directly. this field. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded as an attachment and linked into the embed. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and linked into the embed. Returns Embed This embed. Allows for call chaining.", "f": 1}, {"r": "hikari.embeds.Embed.set_footer", "u": 63, "d": "Set the footer of this embed. Parameters text : typing.Optional[str] The mandatory text string to set in the footer. If builtins.None , the footer is removed.\nicon : typing.Optional[hikari.files.Resourceish] The optional image to show next to the embed footer. This can be many different things, to aid in convenience. - If builtins.None , nothing is set. - If a pathlib.PurePath or builtins.str to a valid URL, the URL is linked to directly. - Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will have their URL linked to directly. this field. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded as an attachment and linked into the embed. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and linked into the embed. Returns Embed This embed. Allows for call chaining.", "f": 1}, {"r": "hikari.embeds.Embed.set_image", "u": 63, "d": "Set the image on this embed. Parameters image : typing.Optional[hikari.files.Resourceish] The optional resource to show for the embed image. This can be many different things, to aid in convenience. - If builtins.None , nothing is set. - If a pathlib.PurePath or builtins.str to a valid URL, the URL is linked to directly. - Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will have their URL linked to directly. this field. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded as an attachment and linked into the embed. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and linked into the embed. Returns Embed This embed. Allows for call chaining.", "f": 1}, {"r": "hikari.embeds.Embed.set_thumbnail", "u": 63, "d": "Set the image on this embed. Parameters image : typing.Optional[hikari.files.Resourceish] The optional resource to show for the embed thumbnail. This can be many different things, to aid in convenience. - If builtins.None , nothing is set. - If a pathlib.PurePath or builtins.str to a valid URL, the URL is linked to directly. - Subclasses of hikari.files.WebResource such as hikari.files.URL , hikari.messages.Attachment , hikari.emojis.Emoji , EmbedResource , etc will have their URL linked to directly. - If a hikari.files.Bytes is passed, or a builtins.str that contains a valid data URI is passed, then this is uploaded as an attachment and linked into the embed. - If a hikari.files.File , pathlib.PurePath or builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and linked into the embed. Returns Embed This embed. Allows for call chaining.", "f": 1}, {"r": "hikari.embeds.Embed.add_field", "u": 63, "d": "Add a new field to this embed. Parameters name : str The mandatory non-empty field name. This must contain at least one non-whitespace character to be valid.\nvalue : str The mandatory non-empty field value. This must contain at least one non-whitespace character to be valid. Other Parameters inline : bool If builtins.True , the embed field may be shown \"inline\" on some Discord clients with other fields. If builtins.False , it is always placed on a separate line. This will default to builtins.False . Returns Embed This embed. Allows for call chaining.", "f": 1}, {"r": "hikari.embeds.Embed.edit_field", "u": 63, "d": "Edit an existing field on this embed. Parameters index : int The index of the field to edit. Other Parameters name : hikari.undefined.UndefinedOr[str] The new field name to use. If left to the default ( undefined ), then it will not be changed.\nvalue : hikari.undefined.UndefinedOr[str] The new field value to use. If left to the default ( undefined ), then it will not be changed.\ninline : hikari.undefined.UndefinedOr[builtins.bool] builtins.True to inline the field, or builtins.False to force it to be on a separate line. If left to the default ( undefined ), then it will not be changed. Returns Embed This embed. Allows for call chaining. Raises builtins.IndexError Raised if the index is greater than len(embed.fields) - 1 or less than -len(embed.fields) ", "f": 1}, {"r": "hikari.embeds.Embed.remove_field", "u": 63, "d": "Remove an existing field from this embed. Parameters index : int The index of the embed field to remove. Returns Embed This embed. Allows for call chaining. Raises builtins.IndexError Raised if the index is greater than len(embed.fields) - 1 or less than -len(embed.fields) ", "f": 1}, {"r": "hikari.embeds.EmbedResource", "u": 63, "d": "A base type for any resource provided in an embed. Resources can be downloaded and uploaded. Method generated by attrs for class EmbedResource."}, {"r": "hikari.embeds.EmbedResource.url", "u": 63, "d": "URL of this embed resource. Returns typing.Optional[builtins.str] The URL of this embed resource."}, {"r": "hikari.embeds.EmbedResource.filename", "u": 63, "d": "File name of this embed resource. Returns typing.Optional[builtins.str] The file name of this embed resource."}, {"r": "hikari.embeds.EmbedResource.stream", "u": 63, "d": "Produce a stream of data for the resource. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.", "f": 1}, {"r": "hikari.embeds.EmbedResource.resource", "u": 63, "d": "The resource this object wraps around."}, {"r": "hikari.embeds.EmbedResource.extension", "u": 63, "d": "File extension, if there is one."}, {"r": "hikari.embeds.EmbedResource.read", "u": 63, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.embeds.EmbedResourceWithProxy", "u": 63, "d": "Resource with a corresponding proxied element. Method generated by attrs for class EmbedResourceWithProxy."}, {"r": "hikari.embeds.EmbedResourceWithProxy.proxy_url", "u": 63, "d": "Proxied URL of this embed resource if applicable. Returns typing.Optional[builtins.str] The proxied URL of this embed resource if applicable, else builtins.None ."}, {"r": "hikari.embeds.EmbedResourceWithProxy.proxy_filename", "u": 63, "d": "File name of the proxied version of this embed resource if applicable. Returns typing.Optional[builtins.str] The file name of the proxied version of this embed resource if applicable, else builtins.None ."}, {"r": "hikari.embeds.EmbedResourceWithProxy.proxy_resource", "u": 63, "d": "The proxied version of the resource, or builtins.None if not present. ! note This field cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event."}, {"r": "hikari.embeds.EmbedResourceWithProxy.url", "u": 63, "d": "URL of this embed resource. Returns typing.Optional[builtins.str] The URL of this embed resource."}, {"r": "hikari.embeds.EmbedResourceWithProxy.filename", "u": 63, "d": "File name of this embed resource. Returns typing.Optional[builtins.str] The file name of this embed resource."}, {"r": "hikari.embeds.EmbedResourceWithProxy.stream", "u": 63, "d": "Produce a stream of data for the resource. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.", "f": 1}, {"r": "hikari.embeds.EmbedResourceWithProxy.resource", "u": 63, "d": "The resource this object wraps around."}, {"r": "hikari.embeds.EmbedResourceWithProxy.extension", "u": 63, "d": "File extension, if there is one."}, {"r": "hikari.embeds.EmbedResourceWithProxy.read", "u": 63, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.embeds.EmbedVideo", "u": 63, "d": "Represents an embed video. ! note This object cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event with a video attached. Therefore, you should never need to initialize an instance of this class yourself. Method generated by attrs for class EmbedVideo."}, {"r": "hikari.embeds.EmbedVideo.height", "u": 63, "d": "The height of the video."}, {"r": "hikari.embeds.EmbedVideo.width", "u": 63, "d": "The width of the video."}, {"r": "hikari.embeds.EmbedVideo.proxy_url", "u": 63, "d": "Proxied URL of this embed resource if applicable. Returns typing.Optional[builtins.str] The proxied URL of this embed resource if applicable, else builtins.None ."}, {"r": "hikari.embeds.EmbedVideo.proxy_filename", "u": 63, "d": "File name of the proxied version of this embed resource if applicable. Returns typing.Optional[builtins.str] The file name of the proxied version of this embed resource if applicable, else builtins.None ."}, {"r": "hikari.embeds.EmbedVideo.proxy_resource", "u": 63, "d": "The proxied version of the resource, or builtins.None if not present. ! note This field cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event."}, {"r": "hikari.embeds.EmbedVideo.url", "u": 63, "d": "URL of this embed resource. Returns typing.Optional[builtins.str] The URL of this embed resource."}, {"r": "hikari.embeds.EmbedVideo.filename", "u": 63, "d": "File name of this embed resource. Returns typing.Optional[builtins.str] The file name of this embed resource."}, {"r": "hikari.embeds.EmbedVideo.stream", "u": 63, "d": "Produce a stream of data for the resource. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.", "f": 1}, {"r": "hikari.embeds.EmbedVideo.resource", "u": 63, "d": "The resource this object wraps around."}, {"r": "hikari.embeds.EmbedVideo.extension", "u": 63, "d": "File extension, if there is one."}, {"r": "hikari.embeds.EmbedVideo.read", "u": 63, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.embeds.EmbedImage", "u": 63, "d": "Represents an embed image. Method generated by attrs for class EmbedImage."}, {"r": "hikari.embeds.EmbedImage.height", "u": 63, "d": "The height of the image, if present and known, otherwise builtins.None . ! note This field cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event."}, {"r": "hikari.embeds.EmbedImage.width", "u": 63, "d": "The width of the image, if present and known, otherwise builtins.None . ! note This field cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event."}, {"r": "hikari.embeds.EmbedImage.proxy_url", "u": 63, "d": "Proxied URL of this embed resource if applicable. Returns typing.Optional[builtins.str] The proxied URL of this embed resource if applicable, else builtins.None ."}, {"r": "hikari.embeds.EmbedImage.proxy_filename", "u": 63, "d": "File name of the proxied version of this embed resource if applicable. Returns typing.Optional[builtins.str] The file name of the proxied version of this embed resource if applicable, else builtins.None ."}, {"r": "hikari.embeds.EmbedImage.proxy_resource", "u": 63, "d": "The proxied version of the resource, or builtins.None if not present. ! note This field cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event."}, {"r": "hikari.embeds.EmbedImage.url", "u": 63, "d": "URL of this embed resource. Returns typing.Optional[builtins.str] The URL of this embed resource."}, {"r": "hikari.embeds.EmbedImage.filename", "u": 63, "d": "File name of this embed resource. Returns typing.Optional[builtins.str] The file name of this embed resource."}, {"r": "hikari.embeds.EmbedImage.stream", "u": 63, "d": "Produce a stream of data for the resource. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop.\nhead_only : builtins.bool Defaults to builtins.False . If builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.", "f": 1}, {"r": "hikari.embeds.EmbedImage.resource", "u": 63, "d": "The resource this object wraps around."}, {"r": "hikari.embeds.EmbedImage.extension", "u": 63, "d": "File extension, if there is one."}, {"r": "hikari.embeds.EmbedImage.read", "u": 63, "d": "Read the entire resource at once into memory. py\ndata = await resource.read( .) ^ This is a shortcut for the following v\nasync with resource.stream( .) as reader: data = await reader.read()  ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If builtins.None , then the default executor is used for the current event loop. Returns builtins.bytes The entire resource.", "f": 1}, {"r": "hikari.embeds.EmbedProvider", "u": 63, "d": "Represents an embed provider. ! note This object cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event provided by an external source. Therefore, you should never need to initialize an instance of this class yourself. Method generated by attrs for class EmbedProvider."}, {"r": "hikari.embeds.EmbedProvider.name", "u": 63, "d": "The name of the provider."}, {"r": "hikari.embeds.EmbedProvider.url", "u": 63, "d": "The URL of the provider."}, {"r": "hikari.embeds.EmbedAuthor", "u": 63, "d": "Represents an author of an embed. Method generated by attrs for class EmbedAuthor."}, {"r": "hikari.embeds.EmbedAuthor.icon", "u": 63, "d": "The author's icon, or builtins.None if not present."}, {"r": "hikari.embeds.EmbedAuthor.name", "u": 63, "d": "The name of the author, or builtins.None if not specified."}, {"r": "hikari.embeds.EmbedAuthor.url", "u": 63, "d": "The URL that the author's name should act as a hyperlink to. This may be builtins.None if no hyperlink on the author's name is specified."}, {"r": "hikari.embeds.EmbedFooter", "u": 63, "d": "Represents an embed footer. Method generated by attrs for class EmbedFooter."}, {"r": "hikari.embeds.EmbedFooter.icon", "u": 63, "d": "The URL of the footer icon, or builtins.None if not present."}, {"r": "hikari.embeds.EmbedFooter.text", "u": 63, "d": "The footer text, or builtins.None if not present."}, {"r": "hikari.embeds.EmbedField", "u": 63, "d": "Represents a field in a embed. Method generated by attrs for class EmbedField."}, {"r": "hikari.embeds.EmbedField.is_inline", "u": 63, "d": "Return builtins.True if the field should display inline. Defaults to False."}, {"r": "hikari.embeds.EmbedField.name", "u": 63, "d": "The name of the field."}, {"r": "hikari.embeds.EmbedField.value", "u": 63, "d": "The value of the field."}, {"r": "hikari.internal", "u": 64, "d": "Package containing internal utilities used within this API."}, {"r": "hikari.internal.cache", "u": 65, "d": "Various utilities that may be used in a cache-impl."}, {"r": "hikari.internal.cache.CacheMappingView", "u": 65, "d": "A cache mapping view implementation used for representing cached data. Parameters items : typing.Union[typing.Mapping[KeyT, ValueT], typing.Mapping[KeyT, DataT A mapping of keys to the values in their raw forms, wrapped by a ref wrapper or in a data form.\nbuilder : typing.Optional[typing.Callable DataT], ValueT The callable used to build entities before they're returned by the mapping. This is used to cover the case when items stores DataT objects."}, {"r": "hikari.internal.cache.CacheMappingView.get_item_at", "u": 65, "d": "", "f": 1}, {"r": "hikari.internal.cache.CacheMappingView.iterator", "u": 65, "d": "Get a lazy iterator of the entities in the view.", "f": 1}, {"r": "hikari.internal.cache.EmptyCacheView", "u": 65, "d": "An empty cache view implementation."}, {"r": "hikari.internal.cache.EmptyCacheView.get_item_at", "u": 65, "d": "", "f": 1}, {"r": "hikari.internal.cache.EmptyCacheView.iterator", "u": 65, "d": "Get a lazy iterator of the entities in the view.", "f": 1}, {"r": "hikari.internal.cache.GuildRecord", "u": 65, "d": "An object used for storing guild specific cached information in-memory. This includes references to the cached entities that \"belong\" to the guild\nby ID if it's globally unique or by object if it's only unique within the\nguild. Method generated by attrs for class GuildRecord."}, {"r": "hikari.internal.cache.GuildRecord.empty", "u": 65, "d": "Check whether this guild record has any resources attached to it. Returns builtins.bool Whether this guild record has any resources attached to it.", "f": 1}, {"r": "hikari.internal.cache.GuildRecord.channels", "u": 65, "d": "A set of the IDs of the guild channels cached for this guild. This will be builtins.None if no channels are cached for this guild else typing.MutableSet[hikari.snowflakes.Snowflake] of channel IDs."}, {"r": "hikari.internal.cache.GuildRecord.emojis", "u": 65, "d": "A set of the IDs of the emojis cached for this guild. This will be builtins.None if no emojis are cached for this guild else typing.MutableSet[hikari.snowflakes.Snowflake] of emoji IDs."}, {"r": "hikari.internal.cache.GuildRecord.guild", "u": 65, "d": "A cached guild object. This will be hikari.guilds.GatewayGuild or builtins.None if not cached."}, {"r": "hikari.internal.cache.GuildRecord.invites", "u": 65, "d": "A set of the builtins.str codes of the invites cached for this guild. This will be builtins.None if no invites are cached for this guild else typing.MutableSequence[str] of invite codes."}, {"r": "hikari.internal.cache.GuildRecord.is_available", "u": 65, "d": "Whether the cached guild is available or not. This will be builtins.None when no GuildRecord.guild is also builtins.None else builtins.bool ."}, {"r": "hikari.internal.cache.GuildRecord.members", "u": 65, "d": "A mapping of user IDs to the objects of members cached for this guild. This will be builtins.None if no members are cached for this guild else hikari.internal.collections.ExtendedMutableMapping[hikari.snowflakes.Snowflake, MemberData] ."}, {"r": "hikari.internal.cache.GuildRecord.presences", "u": 65, "d": "A mapping of user IDs to objects of the presences cached for this guild. This will be builtins.None if no presences are cached for this guild else hikari.internal.collections.ExtendedMutableMapping[hikari.snowflakes.Snowflake, MemberPresenceData] ."}, {"r": "hikari.internal.cache.GuildRecord.roles", "u": 65, "d": "A set of the IDs of the roles cached for this guild. This will be builtins.None if no roles are cached for this guild else typing.MutableSet[hikari.snowflakes.Snowflake] of role IDs."}, {"r": "hikari.internal.cache.GuildRecord.voice_states", "u": 65, "d": "A mapping of user IDs to objects of the voice states cached for this guild. This will be builtins.None if no voice states are cached for this guild else hikari.internal.collections.ExtendedMutableMapping[hikari.snowflakes.Snowflake, VoiceStateData] ."}, {"r": "hikari.internal.cache.BaseData", "u": 65, "d": "A data class used for in-memory storage of entities in a more primitive form. ! note This base implementation assumes that all the fields it'll handle will be immutable and to handle mutable fields you'll have to override build_entity and build_from_entity to explicitly copy them."}, {"r": "hikari.internal.cache.BaseData.build_entity", "u": 65, "d": "Build an entity object from this data object. Parameters app : hikari.traits.RESTAware The hikari application the built object should be bound to. Returns The initialised entity object.", "f": 1}, {"r": "hikari.internal.cache.BaseData.build_from_entity", "u": 65, "d": "Build a data object from an initialised entity. Parameters entity : ValueT The entity object to build a data class from. Returns The built data class.", "f": 1}, {"r": "hikari.internal.cache.InviteData", "u": 65, "d": "A data model for storing invite data in an in-memory cache. Method generated by attrs for class InviteData."}, {"r": "hikari.internal.cache.InviteData.build_entity", "u": 65, "d": "Build an entity object from this data object. Parameters app : hikari.traits.RESTAware The hikari application the built object should be bound to. Returns The initialised entity object.", "f": 1}, {"r": "hikari.internal.cache.InviteData.build_from_entity", "u": 65, "d": "Build a data object from an initialised entity. Parameters entity : ValueT The entity object to build a data class from. Returns The built data class.", "f": 1}, {"r": "hikari.internal.cache.InviteData.channel_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.code", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.created_at", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.guild_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.inviter", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.is_temporary", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.max_age", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.max_uses", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.target_application", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.target_type", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.target_user", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.InviteData.uses", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberData", "u": 65, "d": "A data model for storing member data in an in-memory cache. Method generated by attrs for class MemberData."}, {"r": "hikari.internal.cache.MemberData.build_from_entity", "u": 65, "d": "Build a data object from an initialised entity. Parameters entity : ValueT The entity object to build a data class from. Returns The built data class.", "f": 1}, {"r": "hikari.internal.cache.MemberData.build_entity", "u": 65, "d": "Build an entity object from this data object. Parameters app : hikari.traits.RESTAware The hikari application the built object should be bound to. Returns The initialised entity object.", "f": 1}, {"r": "hikari.internal.cache.MemberData.guild_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberData.has_been_deleted", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberData.is_deaf", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberData.is_mute", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberData.is_pending", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberData.joined_at", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberData.nickname", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberData.premium_since", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberData.role_ids", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberData.user", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.KnownCustomEmojiData", "u": 65, "d": "A data model for storing known custom emoji data in an in-memory cache. Method generated by attrs for class KnownCustomEmojiData."}, {"r": "hikari.internal.cache.KnownCustomEmojiData.build_from_entity", "u": 65, "d": "Build a data object from an initialised entity. Parameters entity : ValueT The entity object to build a data class from. Returns The built data class.", "f": 1}, {"r": "hikari.internal.cache.KnownCustomEmojiData.build_entity", "u": 65, "d": "Build an entity object from this data object. Parameters app : hikari.traits.RESTAware The hikari application the built object should be bound to. Returns The initialised entity object.", "f": 1}, {"r": "hikari.internal.cache.KnownCustomEmojiData.guild_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.KnownCustomEmojiData.id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.KnownCustomEmojiData.is_animated", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.KnownCustomEmojiData.is_available", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.KnownCustomEmojiData.is_colons_required", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.KnownCustomEmojiData.is_managed", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.KnownCustomEmojiData.name", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.KnownCustomEmojiData.role_ids", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.KnownCustomEmojiData.user", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData", "u": 65, "d": "A data model for storing rich activity data in an in-memory cache. Method generated by attrs for class RichActivityData."}, {"r": "hikari.internal.cache.RichActivityData.build_from_entity", "u": 65, "d": "Build a data object from an initialised entity. Parameters entity : ValueT The entity object to build a data class from. Returns The built data class.", "f": 1}, {"r": "hikari.internal.cache.RichActivityData.build_entity", "u": 65, "d": "Build an entity object from this data object. Parameters app : hikari.traits.RESTAware The hikari application the built object should be bound to. Returns The initialised entity object.", "f": 1}, {"r": "hikari.internal.cache.RichActivityData.application_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.assets", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.buttons", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.created_at", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.details", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.emoji", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.flags", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.is_instance", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.name", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.party", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.secrets", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.state", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.timestamps", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.type", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RichActivityData.url", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberPresenceData", "u": 65, "d": "A data model for storing presence data in an in-memory cache. Method generated by attrs for class MemberPresenceData."}, {"r": "hikari.internal.cache.MemberPresenceData.build_from_entity", "u": 65, "d": "Build a data object from an initialised entity. Parameters entity : ValueT The entity object to build a data class from. Returns The built data class.", "f": 1}, {"r": "hikari.internal.cache.MemberPresenceData.build_entity", "u": 65, "d": "Build an entity object from this data object. Parameters app : hikari.traits.RESTAware The hikari application the built object should be bound to. Returns The initialised entity object.", "f": 1}, {"r": "hikari.internal.cache.MemberPresenceData.activities", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberPresenceData.client_status", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberPresenceData.guild_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberPresenceData.user_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MemberPresenceData.visible_status", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MentionsData", "u": 65, "d": "A model for storing message mentions data in an in-memory cache. Method generated by attrs for class MentionsData."}, {"r": "hikari.internal.cache.MentionsData.build_from_entity", "u": 65, "d": "Build a data object from an initialised entity. Parameters entity : ValueT The entity object to build a data class from. Returns The built data class.", "f": 1}, {"r": "hikari.internal.cache.MentionsData.build_entity", "u": 65, "d": "Build an entity object from this data object. Parameters app : hikari.traits.RESTAware The hikari application the built object should be bound to. Returns The initialised entity object.", "f": 1}, {"r": "hikari.internal.cache.MentionsData.update", "u": 65, "d": "", "f": 1}, {"r": "hikari.internal.cache.MentionsData.channels", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MentionsData.everyone", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MentionsData.role_ids", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MentionsData.users", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageInteractionData", "u": 65, "d": "A model for storing message interaction data. Method generated by attrs for class MessageInteractionData."}, {"r": "hikari.internal.cache.MessageInteractionData.build_from_entity", "u": 65, "d": "Build a data object from an initialised entity. Parameters entity : ValueT The entity object to build a data class from. Returns The built data class.", "f": 1}, {"r": "hikari.internal.cache.MessageInteractionData.build_entity", "u": 65, "d": "Build an entity object from this data object. Parameters app : hikari.traits.RESTAware The hikari application the built object should be bound to. Returns The initialised entity object.", "f": 1}, {"r": "hikari.internal.cache.MessageInteractionData.id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageInteractionData.name", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageInteractionData.type", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageInteractionData.user", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData", "u": 65, "d": "A model for storing message data in an in-memory cache. Method generated by attrs for class MessageData."}, {"r": "hikari.internal.cache.MessageData.build_from_entity", "u": 65, "d": "Build a data object from an initialised entity. Parameters entity : ValueT The entity object to build a data class from. Returns The built data class.", "f": 1}, {"r": "hikari.internal.cache.MessageData.build_entity", "u": 65, "d": "Build an entity object from this data object. Parameters app : hikari.traits.RESTAware The hikari application the built object should be bound to. Returns The initialised entity object.", "f": 1}, {"r": "hikari.internal.cache.MessageData.update", "u": 65, "d": "", "f": 1}, {"r": "hikari.internal.cache.MessageData.activity", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.application", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.application_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.attachments", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.author", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.channel_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.components", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.content", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.edited_timestamp", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.embeds", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.flags", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.guild_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.interaction", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.is_pinned", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.is_tts", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.member", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.mentions", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.message_reference", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.nonce", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.reactions", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.referenced_message", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.stickers", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.timestamp", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.type", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.MessageData.webhook_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData", "u": 65, "d": "A data model for storing voice state data in an in-memory cache. Method generated by attrs for class VoiceStateData."}, {"r": "hikari.internal.cache.VoiceStateData.build_entity", "u": 65, "d": "Build an entity object from this data object. Parameters app : hikari.traits.RESTAware The hikari application the built object should be bound to. Returns The initialised entity object.", "f": 1}, {"r": "hikari.internal.cache.VoiceStateData.build_from_entity", "u": 65, "d": "Build a data object from an initialised entity. Parameters entity : ValueT The entity object to build a data class from. Returns The built data class.", "f": 1}, {"r": "hikari.internal.cache.VoiceStateData.channel_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.guild_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.is_guild_deafened", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.is_guild_muted", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.is_self_deafened", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.is_self_muted", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.is_streaming", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.is_suppressed", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.is_video_enabled", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.member", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.requested_to_speak_at", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.VoiceStateData.session_id", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RefCell", "u": 65, "d": "Object used to track mutable references to a value in multiple places. This is intended to enable reference counting for entities that are only kept\nalive by reference (e.g. the unknown emoji objects attached to presence\nactivities and user objects) without the use of a \"Data\" object which lowers\nthe time spent building these entities for the objects that reference them. Method generated by attrs for class RefCell."}, {"r": "hikari.internal.cache.RefCell.copy", "u": 65, "d": "Get a copy of the contents of this cell. Returns ValueT The copied contents of this cell.", "f": 1}, {"r": "hikari.internal.cache.RefCell.object", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.RefCell.ref_count", "u": 65, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.cache.unwrap_ref_cell", "u": 65, "d": "Unwrap a RefCell instance to it's contents. Parameters cell : RefCell[ValueT] The reference cell instance to unwrap Returns ValueT The reference cell's content.", "f": 1}, {"r": "hikari.internal.cache.copy_guild_channel", "u": 65, "d": "Logic for handling the copying of guild channel objects. This exists account for the permission overwrite objects attached to guild\nchannel objects which need to be copied themselves.", "f": 1}, {"r": "hikari.internal.cache.Cache3DMappingView", "u": 65, "d": "A special case of the Mapping View which avoids copying the immutable values contained within it."}, {"r": "hikari.internal.cache.Cache3DMappingView.iterator", "u": 65, "d": "Get a lazy iterator of the entities in the view.", "f": 1}, {"r": "hikari.internal.cache.DataT", "u": 65, "d": "Type-hint for \"data\" objects used for storing and building entities."}, {"r": "hikari.internal.cache.KeyT", "u": 65, "d": "Type-hint for mapping keys."}, {"r": "hikari.internal.cache.ValueT", "u": 65, "d": "Type-hint for mapping values."}, {"r": "hikari.internal.deprecation", "u": 66, "d": "Deprecation utils."}, {"r": "hikari.internal.deprecation.deprecated", "u": 66, "d": "Mark a function as deprecated. Other Parameters version: typing.Optional[str] If specified, the version it will be removed in.\nalternative: typing.Optional[str] If specified, the alternative to use.", "f": 1}, {"r": "hikari.internal.deprecation.warn_deprecated", "u": 66, "d": "Raise a deprecated warning. Parameters obj: typing.Any The object that is deprecated. Other Parameters version: typing.Optional[str] If specified, the version it will be removed in.\nalternative: typing.Optional[str] If specified, the alternative to use.\nstack_level: int The stack level for the warning. Defaults to 1 .", "f": 1}, {"r": "hikari.internal.data_binding", "u": 67, "d": "Data binding utilities."}, {"r": "hikari.internal.data_binding.Headers", "u": 67, "d": "Type hint for HTTP headers."}, {"r": "hikari.internal.data_binding.Query", "u": 67, "d": "Type hint for HTTP query string."}, {"r": "hikari.internal.data_binding.JSONObject", "u": 67, "d": "Type hint for a JSON-decoded object representation as a mapping."}, {"r": "hikari.internal.data_binding.JSONArray", "u": 67, "d": "Type hint for a JSON-decoded array representation as a sequence."}, {"r": "hikari.internal.data_binding.JSONish", "u": 67, "d": "Type hint for any valid JSON-decoded type."}, {"r": "hikari.internal.data_binding.FormData", "u": 67, "d": "Helper class for multipart/form-data and\napplication/x-www-form-urlencoded body generation."}, {"r": "hikari.internal.data_binding.FormData.is_multipart", "u": 67, "d": ""}, {"r": "hikari.internal.data_binding.FormData.add_field", "u": 67, "d": "", "f": 1}, {"r": "hikari.internal.data_binding.FormData.add_fields", "u": 67, "d": "", "f": 1}, {"r": "hikari.internal.data_binding.dump_json", "u": 67, "d": "Serialize obj to a JSON formatted str . If skipkeys is true then dict keys that are not basic types\n( str , int , float , bool , None ) will be skipped\ninstead of raising a TypeError . If ensure_ascii is false, then the return value can contain non-ASCII\ncharacters if they appear in strings contained in obj . Otherwise, all\nsuch characters are escaped in JSON strings. If check_circular is false, then the circular reference check\nfor container types will be skipped and a circular reference will\nresult in an OverflowError (or worse). If allow_nan is false, then it will be a ValueError to\nserialize out of range float values ( nan , inf , -inf ) in\nstrict compliance of the JSON specification, instead of using the\nJavaScript equivalents ( NaN , Infinity , -Infinity ). If indent is a non-negative integer, then JSON array elements and\nobject members will be pretty-printed with that indent level. An indent\nlevel of 0 will only insert newlines. None is the most compact\nrepresentation. If specified, separators should be an (item_separator, key_separator) tuple. The default is (', ', ': ') if indent is None and (',', ': ') otherwise. To get the most compact JSON representation,\nyou should specify (',', ':') to eliminate whitespace. default(obj) is a function that should return a serializable version\nof obj or raise TypeError. The default simply raises TypeError. If sort_keys is true (default: False ), then the output of\ndictionaries will be sorted by key. To use a custom JSONEncoder subclass (e.g. one that overrides the .default() method to serialize additional types), specify it with\nthe cls kwarg; otherwise JSONEncoder is used.", "f": 1}, {"r": "hikari.internal.data_binding.load_json", "u": 67, "d": "Deserialize s (a str , bytes or bytearray instance\ncontaining a JSON document) to a Python object. object_hook is an optional function that will be called with the\nresult of any object literal decode (a dict ). The return value of object_hook will be used instead of the dict . This feature\ncan be used to implement custom decoders (e.g. JSON-RPC class hinting). object_pairs_hook is an optional function that will be called with the\nresult of any object literal decoded with an ordered list of pairs. The\nreturn value of object_pairs_hook will be used instead of the dict .\nThis feature can be used to implement custom decoders. If object_hook is also defined, the object_pairs_hook takes priority. parse_float , if specified, will be called with the string\nof every JSON float to be decoded. By default this is equivalent to\nfloat(num_str). This can be used to use another datatype or parser\nfor JSON floats (e.g. decimal.Decimal). parse_int , if specified, will be called with the string\nof every JSON int to be decoded. By default this is equivalent to\nint(num_str). This can be used to use another datatype or parser\nfor JSON integers (e.g. float). parse_constant , if specified, will be called with one of the\nfollowing strings: -Infinity, Infinity, NaN.\nThis can be used to raise an exception if invalid JSON numbers\nare encountered. To use a custom JSONDecoder subclass, specify it with the cls kwarg; otherwise JSONDecoder is used. The encoding argument is ignored and deprecated since Python 3.1.", "f": 1}, {"r": "hikari.internal.data_binding.JSONDecodeError", "u": 67, "d": "Subclass of ValueError with the following additional properties: msg: The unformatted error message\ndoc: The JSON document being parsed\npos: The start index of doc where parsing failed\nlineno: The line corresponding to pos\ncolno: The column corresponding to pos"}, {"r": "hikari.internal.data_binding.JSONObjectBuilder", "u": 67, "d": "Helper class used to quickly build JSON objects from various values. If provided with any values that are hikari.undefined.UNDEFINED ,\nthen these values will be ignored. This speeds up generation of JSON payloads for low level HTTP and websocket\nAPI interaction. ! warning Because this subclasses builtins.dict , you should not use the index operator to set items on this object. Doing so will skip any form of validation on the type. Use the put methods instead."}, {"r": "hikari.internal.data_binding.JSONObjectBuilder.put", "u": 67, "d": "Put a JSON value. If the value is hikari.undefined.UNDEFINED it will not be stored. Parameters key : builtins.str The key to give the element.\nvalue : hikari.undefined.UndefinedOr[typing.Any] The JSON type to put. This may be a non-JSON type if a conversion is also specified. This may alternatively be undefined. In the latter case, nothing is performed. Other Parameters conversion : typing.Optional[typing.Callable typing.Any], JSONish The optional conversion to apply.", "f": 1}, {"r": "hikari.internal.data_binding.JSONObjectBuilder.put_array", "u": 67, "d": "Put a JSON array. If the value is hikari.undefined.UNDEFINED it will not be stored. If provided, a conversion will be applied to each item. Parameters key : builtins.str The key to give the element.\nvalues : hikari.undefined.UndefinedOr[typing.Iterable[T The JSON types to put. This may be an iterable of non-JSON types if a conversion is also specified. This may alternatively be undefined. In the latter case, nothing is performed. Other Parameters conversion : typing.Optional[typing.Callable typing.Any], JSONType The optional conversion to apply.", "f": 1}, {"r": "hikari.internal.data_binding.JSONObjectBuilder.put_snowflake", "u": 67, "d": "Put a key with a snowflake value into the builder. If the value is hikari.undefined.UNDEFINED it will not be stored. Parameters key : builtins.str The key to give the element.\nvalue : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique The JSON type to put. This may alternatively be undefined, in this case, nothing is performed. This may also be builtins.None , in this case the value isn't cast.", "f": 1}, {"r": "hikari.internal.data_binding.JSONObjectBuilder.put_snowflake_array", "u": 67, "d": "Put an array of snowflakes with the given key into this builder. If the value is hikari.undefined.UNDEFINED it will not be stored. Each snowflake should be castable to an builtins.int . Parameters key : builtins.str The key to give the element.\nvalues : hikari.undefined.UndefinedOr[typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique ] The JSON snowflakes to put. This may alternatively be undefined. In the latter case, nothing is performed.", "f": 1}, {"r": "hikari.internal.net", "u": 68, "d": "General bits and pieces that are reused between components."}, {"r": "hikari.internal.net.generate_error_response", "u": 68, "d": "Given an erroneous HTTP response, return a corresponding exception.", "f": 1}, {"r": "hikari.internal.net.create_client_session", "u": 68, "d": "Generate a client session using the given settings. ! warning You must invoke this from within a running event loop. ! note If you pass an explicit connector, then the connection that is created will not own the connector. You will be expected to manually close it __after__ the returned client session is closed to prevent leaking resources. Parameters connector : aiohttp.BaseConnector The connector to use.\nconnector_owner : builtins.bool If builtins.True , then the client session will close the connector on shutdown. Otherwise, you must do it manually.\nhttp_settings : hikari.config.HTTPSettings HTTP settings to use.\nraise_for_status : builtins.bool builtins.True to default to throwing exceptions if a request fails, or builtins.False to default to not.\ntrust_env : builtins.bool builtins.True to trust anything in environment variables and the netrc file, builtins.False to ignore it.\nws_response_cls : typing.Type[aiohttp.ClientWebSocketResponse] The websocket response class to use. Defaults to aiohttp.ClientWebSocketResponse . Returns aiohttp.ClientSession The client session to use.", "f": 1}, {"r": "hikari.internal.reflect", "u": 69, "d": "Reflection utilities."}, {"r": "hikari.internal.reflect.resolve_signature", "u": 69, "d": "Get the inspect.Signature of func with resolved forward annotations. Parameters func : typing.Callable  .], .] The function to get the resolved annotations from. ! warning This will use builtins.eval to resolve string type-hints and forward references. This has a slight performance overhead, so attempt to cache this info as much as possible. Returns inspect.Signature A inspect.Signature object with all forward reference annotations resolved.", "f": 1}, {"r": "hikari.internal.attr_extensions", "u": 70, "d": "Utility for extending and optimising the usage of attr models."}, {"r": "hikari.internal.attr_extensions.with_copy", "u": 70, "d": "Add a custom implementation for copying attrs models to a class. ! note This will only work if the class has an attrs generated init.", "f": 1}, {"r": "hikari.internal.attr_extensions.copy_attrs", "u": 70, "d": "Shallow copy an attrs model with init enabled. Parameters model : ModelT The attrs model to shallow copy. Returns ModelT The new shallow copied attrs model.", "f": 1}, {"r": "hikari.internal.attr_extensions.deep_copy_attrs", "u": 70, "d": "Deep copy an attrs model with init enabled. Parameters model : ModelT The attrs model to deep copy.\nmemo : typing.Optional[typing.MutableMapping[builtins.int, typing.Any A memo dictionary of objects already copied during the current copying pass, see https: docs.python.org/3/library/copy.html for more details. ! note This won't deep copy attributes where \"skip_deep_copy\" is set to builtins.True in their metadata. Returns ModelT The new deep copied attrs model.", "f": 1}, {"r": "hikari.internal.attr_extensions.invalidate_deep_copy_cache", "u": 70, "d": "Remove all the globally cached generated deep copy functions.", "f": 1}, {"r": "hikari.internal.attr_extensions.invalidate_shallow_copy_cache", "u": 70, "d": "Remove all the globally cached copy functions.", "f": 1}, {"r": "hikari.internal.spel", "u": 71, "d": "HikariSPEL (Hikari SimPle Expression Language). HikariSPEL (Hikari SimPle Expression Language) is a super-simple expression\nlanguage used in this module for quickly mapping values to other values and\nproducing streams of changes. This somewhat mirrors other programming languages\nlike Java which have a proper Stream API. The concept of HikariSPEL is that you are trying to look at the attribute\nof something. So, running \"bar.baz.bork\" against an object foo would be\nequivalent to foo.bar.baz.bork in pure Python. The reason for doing this is\nPython lambdas are clunky, and using a nested function is nasty boilerplate. For applying \"bar.baz\" to foo , we assume bar is an attribute or property\nof foo , and baz is an attribute or property of foo.bar . We may instead\nwant to invoke a method that takes no parameters (looking at str.islower , as\nan example. To do this, we append () onto the attribute name. For example,\napplying author.username.islower() to a hikari.messages.Message object. All expressions may start with a . . You can negate the whole expression\nby instead starting them with !. . You may also want to negate a condition. To do this, prepend ! to the\nattribute name. For example, to check if a message was not made by a bot,\nyou could run author.!is_bot on a Message object. Likewise, to check if\nthe input was not a number, you could run content.!isdigit() . This expression language is highly experimental and may change without\nprior notice for the time being."}, {"r": "hikari.internal.spel.AttrGetter", "u": 71, "d": "An attribute getter that can resolve nested attributes and methods. This follows the SPEL definition for how to define expressions. Expressions\nmay be preceded with an optional . to aid in readability."}, {"r": "hikari.internal.spel.AttrGetter.invert_all", "u": 71, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.spel.AttrGetter.pipeline", "u": 71, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.routes", "u": 72, "d": "Provides the valid routes that can be used on the API and the CDN."}, {"r": "hikari.internal.routes.CompiledRoute", "u": 72, "d": "A compiled representation of a route to a specific resource. This is a similar representation to what Route provides, except Route is treated as a template, this is treated as an instance. Method generated by attrs for class CompiledRoute."}, {"r": "hikari.internal.routes.CompiledRoute.method", "u": 72, "d": "Return the HTTP method of this compiled route."}, {"r": "hikari.internal.routes.CompiledRoute.create_url", "u": 72, "d": "Create the full URL with which you can make a request. Parameters base_url : builtins.str The base of the URL to prepend to the compiled path. Returns builtins.str The full URL for the route.", "f": 1}, {"r": "hikari.internal.routes.CompiledRoute.create_real_bucket_hash", "u": 72, "d": "Create a full bucket hash from a given initial hash. The result of this hash will be decided by the value of the major\nparameters passed to the route during the compilation phase. Parameters initial_bucket_hash : builtins.str The initial bucket hash provided by Discord in the HTTP headers for a given response. Returns builtins.str The input hash amalgamated with a hash code produced by the major parameters in this compiled route instance.", "f": 1}, {"r": "hikari.internal.routes.CompiledRoute.compiled_path", "u": 72, "d": "The compiled route path to use."}, {"r": "hikari.internal.routes.CompiledRoute.major_param_hash", "u": 72, "d": "The major parameters in a bucket hash-compatible representation."}, {"r": "hikari.internal.routes.CompiledRoute.route", "u": 72, "d": "The route this compiled route was created from."}, {"r": "hikari.internal.routes.Route", "u": 72, "d": "A template used to create compiled routes for specific parameters. These compiled routes are used to identify rate limit buckets. Compiled\nroutes may have a single major parameter. Parameters method : builtins.str The HTTP method\npath_template : builtins.str The template string for the path to use."}, {"r": "hikari.internal.routes.Route.compile", "u": 72, "d": "Generate a formatted CompiledRoute for this route. This takes into account any URL parameters that have been passed. Parameters  kwargs : typing.Any Any parameters to interpolate into the route path. Returns CompiledRoute The compiled route.", "f": 1}, {"r": "hikari.internal.routes.Route.major_params", "u": 72, "d": "The optional major parameter name combination for this endpoint."}, {"r": "hikari.internal.routes.Route.method", "u": 72, "d": "The HTTP method."}, {"r": "hikari.internal.routes.Route.path_template", "u": 72, "d": "The template string used for the path."}, {"r": "hikari.internal.routes.CDNRoute", "u": 72, "d": "Route implementation for a CDN resource. Method generated by attrs for class CDNRoute."}, {"r": "hikari.internal.routes.CDNRoute.compile", "u": 72, "d": "Generate a full CDN url from this endpoint. Parameters base_url : builtins.str The base URL for the CDN. The generated route is concatenated onto this.\nfile_format : builtins.str The file format to use for the asset.\nsize : typing.Optional[builtins.int] The custom size query parameter to set. If builtins.None , it is not passed. kwargs : typing.Any Parameters to interpolate into the path template. Returns builtins.str The full asset URL. Raises builtins.TypeError If a GIF is requested, but the asset is not animated; if an invalid file format for the endpoint is passed; or if a size is passed but the route is not sizable . builtins.ValueError If size is specified, but is not an integer power of 2 between 16 and 4096 inclusive or is negative.", "f": 1}, {"r": "hikari.internal.routes.CDNRoute.compile_to_file", "u": 72, "d": "Perform the same as compile , but return the URL as a files.URL .", "f": 1}, {"r": "hikari.internal.routes.CDNRoute.path_template", "u": 72, "d": "Template string for this endpoint."}, {"r": "hikari.internal.routes.CDNRoute.sizable", "u": 72, "d": " builtins.True if a size param can be specified, or builtins.False otherwise."}, {"r": "hikari.internal.routes.CDNRoute.valid_formats", "u": 72, "d": "Valid file formats for this endpoint."}, {"r": "hikari.internal.enums", "u": 73, "d": "Implementation of parts of Python's enum protocol to be more performant."}, {"r": "hikari.internal.enums.Enum", "u": 73, "d": "Clone of Python's enum.Enum implementation. This is designed to be faster and more efficient than Python's\nimplementation, while retaining the majority of the external interface\nthat Python's enum.Enum provides. An Enum is a simple class containing a discrete set of constant values\nthat can be used in place of this type. This acts as a type-safe way\nof representing a set number of \"things\". ! warning Some semantics such as subtype checking and instance checking may differ. It is recommended to compare these values using the   operator rather than the is operator for safety reasons. Special Members on the class   __enumtype__ : Always Enum .  __members__ : An immutable typing.Mapping that maps each member name to the member value.  __objtype__ : Always the first type that the enum is derived from. For example: py\n>>> class UserType(str, Enum): . USER = \"user\" . PARTIAL = \"partial\" . MEMBER = \"member\"\n>>> print(UserType.__objtype__)   Operators on the class   EnumType[\"FOO\"] : Return the member that has the name FOO , raising a builtins.KeyError if it is not present.  EnumType.FOO : Return the member that has the name FOO , raising a builtins.AttributeError if it is not present.  EnumType(x) : Attempt to cast x to the enum type by finding an existing member that has the same __value__. If this fails, you should expect a builtins.ValueError to be raised. Operators on each enum member   e1 e2 : builtins.bool Compare equality.  e1 != e2 : builtins.bool Compare inequality.  builtins.repr(e) : builtins.str Get the machine readable representation of the enum member e .  builtins.str(e) : builtins.str Get the builtins.str name of the enum member e . Special properties on each enum member   name : builtins.str The name of the member.  value : The value of the member. The type depends on the implementation type of the enum you are using. All other methods and operators on enum members are inherited from the\nmember's __value__. For example, an enum extending builtins.int would\nbe able to be used as an int type outside these overridden definitions."}, {"r": "hikari.internal.enums.Enum.name", "u": 73, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.internal.enums.Enum.value", "u": 73, "d": "Return the value of the enum member."}, {"r": "hikari.internal.enums.Flag", "u": 73, "d": "Clone of Python's enum.Flag implementation. This is designed to be faster and more efficient than Python's\nimplementation, while retaining the majority of the external interface\nthat Python's enum.Flag provides. In simple terms, an Flag is a set of wrapped constant builtins.int values that can be combined in any combination to make a special value.\nThis is a more efficient way of combining things like permissions together\ninto a single integral value, and works by setting individual 1 s and 0 s\non the binary representation of the integer. This implementation has extra features, in that it will actively behave\nlike a builtins.set as well. ! warning Despite wrapping builtins.int values, conceptually this does not behave as if it were a subclass of int . ! danger Some semantics such as subtype checking and instance checking may differ. It is recommended to compare these values using the   operator rather than the is operator for safety reasons. Especially where pseudo-members created from combinations are cached, results of using of is may not be deterministic. This is a side effect of some internal performance improvements. Failing to observe this __will__ result in unexpected behaviour occurring in your application! Special Members on the class   __enumtype__ : Always Flag .  __everything__ : A special member with all documented bits set.  __members__ : An immutable typing.Mapping that maps each member name to the member value.  __objtype__ : Always builtins.int . Operators on the class   FlagType[\"FOO\"] : Return the member that has the name FOO , raising a builtins.KeyError if it is not present.  FlagType.FOO : Return the member that has the name FOO , raising a builtins.AttributeError if it is not present.  FlagType(x) : Attempt to cast x to the enum type by finding an existing member that has the same __value__. If this fails, then a special __composite__ instance of the type is made. The name of this type is a combination of all members that combine to make the bitwise value. Operators on each flag member   e1 & e2 : Bitwise AND operation. Will return a member that contains all flags that are common between both oprands on the values. This also works with one of the oprands being an builtins.int eger. You may instead use the intersection method.  e1 | e2 : Bitwise OR operation. Will return a member that contains all flags that appear on at least one of the oprands. This also works with one of the oprands being an builtins.int eger. You may instead use the union method.  e1 ^ e2 : Bitwise XOR operation. Will return a member that contains all flags that only appear on at least one and at most one of the oprands. This also works with one of the oprands being an builtins.int eger. You may instead use the symmetric_difference method.  ~e : Return the inverse of this value. This is equivalent to disabling all flags that are set on this value and enabling all flags that are not set on this value. Note that this will behave slightly differently to inverting a pure int value. You may instead use the invert method.  e1 - e2 : Bitwise set difference operation. Returns all flags set on e1 that are not set on e2 as well. You may instead use the difference method.  bool(e) : builtins.bool Return builtins.True if e has a non-zero value, otherwise builtins.False .  E.A in e : builtins.bool  builtins.True if E.A is in e . This is functionally equivalent to E.A & e E.A .  iter(e) : Explode the value into a iterator of each __documented__ flag that can be combined to make up the value e . Returns an iterator across all well-defined flags that make up this value. This will only include the flags explicitly defined on this Flag type and that are individual powers of two (this means if converted to twos-compliment binary, exactly one bit must be a 1 ). In simple terms, this means that you should not expect combination flags to be returned.  e1 e2 : builtins.bool Compare equality.  e1 != e2 : builtins.bool Compare inequality.  e1 < e2 : builtins.bool Compare by ordering.  builtins.int(e) : builtins.int Get the integer value of this flag  builtins.repr(e) : builtins.str Get the machine readable representation of the flag member e .  builtins.str(e) : builtins.str Get the builtins.str name of the flag member e . Special properties on each flag member   e.name : builtins.str The name of the member. For composite members, this will be generated.  e.value : builtins.int The value of the member. Special members on each flag member   e.all(E.A, E.B, E.C, .) : builtins.bool Returns builtins.True if __all__ of E.A , E.B , E.C , et cetera make up the value of e .  e.any(E.A, E.B, E.C, .) : builtins.bool Returns builtins.True if __any__ of E.A , E.B , E.C , et cetera make up the value of e .  e.none(E.A, E.B, E.C, .) : builtins.bool Returns builtins.True if __none__ of E.A , E.B , E.C , et cetera make up the value of e .  e.split() : typing.Sequence Explode the value into a sequence of each __documented__ flag that can be combined to make up the value e . Returns a sorted sequence of each power-of-two flag that makes up the value e . This is equivalent to list(iter(e  . All other methods and operators on Flag members are inherited from the\nmember's __value__. ! note Due to limitations around how this is re-implemented, this class is not considered a subclass of Enum at runtime, even if MyPy believes this is possible"}, {"r": "hikari.internal.enums.Flag.name", "u": 73, "d": "Return the name of the flag combination as a builtins.str ."}, {"r": "hikari.internal.enums.Flag.value", "u": 73, "d": "Return the builtins.int value of the flag."}, {"r": "hikari.internal.enums.Flag.all", "u": 73, "d": "Check if all of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.internal.enums.Flag.any", "u": 73, "d": "Check if any of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.internal.enums.Flag.difference", "u": 73, "d": "Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction - operator.", "f": 1}, {"r": "hikari.internal.enums.Flag.intersection", "u": 73, "d": "Return a combination of flags that are set for both given values. Equivalent to using the \"AND\" & operator.", "f": 1}, {"r": "hikari.internal.enums.Flag.invert", "u": 73, "d": "Return a set of all flags not in the current set.", "f": 1}, {"r": "hikari.internal.enums.Flag.is_disjoint", "u": 73, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.internal.enums.Flag.is_subset", "u": 73, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.internal.enums.Flag.is_superset", "u": 73, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.internal.enums.Flag.none", "u": 73, "d": "Check if none of the given flags are part of this value. ! note This is essentially the opposite of Flag.any . Returns builtins.bool builtins.True if none of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.internal.enums.Flag.split", "u": 73, "d": "Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted typing.Sequence of each membe", "f": 1}, {"r": "hikari.internal.enums.Flag.symmetric_difference", "u": 73, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.internal.enums.Flag.union", "u": 73, "d": "Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\" ~ operator.", "f": 1}, {"r": "hikari.internal.enums.Flag.isdisjoint", "u": 73, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.internal.enums.Flag.issubset", "u": 73, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.internal.enums.Flag.issuperset", "u": 73, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.internal.enums.Flag.symmetricdifference", "u": 73, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.internal.ux", "u": 74, "d": "User-experience extensions and utilities."}, {"r": "hikari.internal.ux.init_logging", "u": 74, "d": "Attempt to initialize logging for the user. If any handlers already exist, this is ignored entirely. This ensures the\nuser can use any existing logging configuration without us interfering.\nYou can manually disable this by passing None as the flavor parameter. Parameters flavor : typing.Optional[builtins.None, builtins.str, typing.Dict[builtins.str, typing.Any The hint for configuring logging. This can be builtins.None to not enable logging automatically. If you pass a builtins.str or a builtins.int , it is interpreted as the global logging level to use, and should match one of \"DEBUG\" , \"INFO\" , \"WARNING\" , \"ERROR\" or \"CRITICAL\" , if builtins.str . The configuration will be set up to use a colorlog coloured logger, and to use a sane logging format strategy. The output will be written to sys.stderr using this configuration. If you pass a builtins.dict , it is treated as the mapping to pass to logging.config.dictConfig .\nallow_color : builtins.bool If builtins.False , no colour is allowed. If builtins.True , the output device must be supported for this to return builtins.True .\nforce_color : builtins.bool If builtins.True , return builtins.True always, otherwise only return builtins.True if the device supports colour output and the allow_color flag is not builtins.False .", "f": 1}, {"r": "hikari.internal.ux.print_banner", "u": 74, "d": "Print a banner of choice to sys.stdout . Inspired by Spring Boot, we display an ASCII logo on startup. This is styled\nto grab the user's attention, and contains info such as the library version,\nthe Python interpreter, the OS, and links to our Discord server and\ndocumentation. Users can override this by placing a banner.txt' in some\npackage and referencing it in this call. Parameters package : typing.Optional[builtins.str] The package to find the banner.txt in, or builtins.None if no banner should be shown. ! note The banner.txt must be in the root folder of the package.\nallow_color : builtins.bool If builtins.False , no colour is allowed. If builtins.True , the output device must be supported for this to return builtins.True .\nforce_color : builtins.bool If builtins.True , return builtins.True always, otherwise only return builtins.True if the device supports colour output and the allow_color flag is not builtins.False .", "f": 1}, {"r": "hikari.internal.ux.supports_color", "u": 74, "d": "Return builtins.True if the terminal device supports color output. Parameters allow_color : builtins.bool If builtins.False , no color is allowed. If builtins.True , the output device must be supported for this to return builtins.True .\nforce_color : builtins.bool If builtins.True , return builtins.True always, otherwise only return builtins.True if the device supports color output and the allow_color flag is not builtins.False . Returns builtins.bool builtins.True if color is allowed on the output terminal, or builtins.False otherwise.", "f": 1}, {"r": "hikari.internal.ux.HikariVersion", "u": 74, "d": "Hikari strict version."}, {"r": "hikari.internal.ux.HikariVersion.prerelease", "u": 74, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.ux.HikariVersion.version", "u": 74, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.internal.ux.check_for_updates", "u": 74, "d": "Perform a check for newer versions of the library, logging any found.", "f": 1}, {"r": "hikari.internal.fast_protocol", "u": 75, "d": "A utility for faster typing.Protocol instance checks."}, {"r": "hikari.internal.fast_protocol.FastProtocolChecking", "u": 75, "d": "An extension to make protocols with faster instance checks. ! note All protocols that subclass this class must be decorated with @typing.runtime_checkable to keep mypy happy."}, {"r": "hikari.internal.mentions", "u": 76, "d": "Utility functions used for managing mentions on Discord."}, {"r": "hikari.internal.mentions.generate_allowed_mentions", "u": 76, "d": "Generate an allowed mentions JSON object. Parameters mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] Whether @everyone and @here mentions are enabled. If hikari.undefined.UNDEFINED or builtins.False then this will be disabled.\nmentions_reply : hikari.undefined.UndefinedOr[builtins.bool] Whether the reply mention should be enabled. If hikari.undefined.UNDEFINED or builtins.False then this will be disabled.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool Either a sequence of objects/IDs of the users to enabled mentions for, True to allow all mentions or builtins.False / hikari.undefined.UNDEFINED to disable all user mentions.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool Either a sequence of objects/IDs of the roles to enabled mentions for, True to allow all mentions or builtins.False / hikari.undefined.UNDEFINED to disable all user mentions. Returns hikari.internal.data_binding.JSONObject The allowed mentions JSON Object.", "f": 1}, {"r": "hikari.internal.ed25519", "u": 77, "d": "Helper classes used for handling EdDSA cryptography in the interaction server."}, {"r": "hikari.internal.ed25519.VerifyBuilderT", "u": 77, "d": "Build a callable used to verify an interaction payload received from Discord. Parameters public_key : builtins.bytes The public key to use to verify received interaction requests against. Returns VerifierT The callable used to verify interaction requests."}, {"r": "hikari.internal.ed25519.VerifierT", "u": 77, "d": "A callable used to verify an interaction payload received from Discord. Parameters body : builtins.bytes The interaction payload.\nsignature : builtins.bytes Value of the \"X-Signature-Ed25519\" header.\ntimestamp : builtins.bytes Value of the \"X-Signature-Timestamp\" header. Returns builtins.bool Whether the provided arguments match this public key."}, {"r": "hikari.internal.ed25519.build_ed25519_verifier", "u": 77, "d": " VerifyBuilderT implementation which will always be present.", "f": 1}, {"r": "hikari.internal.collections", "u": 78, "d": "Custom data structures used within Hikari's core implementation."}, {"r": "hikari.internal.collections.ExtendedMapT", "u": 78, "d": "Type-hint A type hint used for mapped collection objects."}, {"r": "hikari.internal.collections.KeyT", "u": 78, "d": "Type-hint A type hint used for the type of a mapping's key."}, {"r": "hikari.internal.collections.ValueT", "u": 78, "d": "Type-hint A type hint used for the type of a mapping's value."}, {"r": "hikari.internal.collections.SnowflakeSet", "u": 78, "d": "Set of hikari.snowflakes.Snowflake objects. This internally uses a sorted bisect-array of 64 bit integers to represent\nthe information. This reduces the space needed to store these objects\nsignificantly down to the size of 8 bytes per item. In contrast, a regular list would take generally 8 bytes per item just to\nstore the memory address, and then a further 28 bytes or more to physically\nstore the integral value if it does not get interned by the Python\nimplementation you are using. A regular set would consume even more\nspace, being a hashtable internally. The detail of this implementation has the side effect that searches\nwill take \\mathcal{O} \\left( \\log n \\right) operations in the worst\ncase, and \\Omega \\left (k \\right) in the best case. Average case\nwill be \\mathcal{O} \\left( \\log n \\right) Insertions and removals will take \\mathcal{O} \\left( \\log n \\right) operations in the worst case, due to bisect using a binary insertion sort\nalgorithm internally. Average case will be \\mathcal{O} \\left( \\log n \\right) and best case will be \\Omega \\left\\( k \\right)  ! warning This is not thread-safe and must not be iterated across whilst being concurrently modified. Other Parameters  ids : builtins.int The IDs to fill this table with."}, {"r": "hikari.internal.collections.SnowflakeSet.add", "u": 78, "d": "Add a snowflake to this set.", "f": 1}, {"r": "hikari.internal.collections.SnowflakeSet.add_all", "u": 78, "d": "Add a collection of snowflakes to this set.", "f": 1}, {"r": "hikari.internal.collections.SnowflakeSet.clear", "u": 78, "d": "Clear all items from this collection.", "f": 1}, {"r": "hikari.internal.collections.SnowflakeSet.discard", "u": 78, "d": "Remove a snowflake from this set if it's present.", "f": 1}, {"r": "hikari.internal.collections.ExtendedMutableMapping", "u": 78, "d": "The abstract class of mutable mappings used within Hikari. These are mutable mappings that have a couple of extra methods to allow\nfor further optimised copy operations, as well as the ability to freeze\nthe implementation of a mapping to make it read-only."}, {"r": "hikari.internal.collections.ExtendedMutableMapping.copy", "u": 78, "d": "Return a copy of this mapped collection. Unlike simply doing dict(mapping) , this may rely on internal detail\naround how the data is being stored to allow for a more efficient copy.\nThis may look like calling dict.copy and wrapping the result in a\nmapped collection. ! note Any removal policy on this mapped collection will be copied over. Returns MapT[KeyT, ValueT] A copy of this mapped collection.", "f": 1}, {"r": "hikari.internal.collections.ExtendedMutableMapping.freeze", "u": 78, "d": "Return a frozen mapping view of the items in this mapped collection. Unlike simply doing dict(mapping) , this may rely on internal detail\naround how the data is being stored to allow for a more efficient copy.\nThis may look like calling dict.copy . ! note Unlike ExtendedMutableMapping.copy , this should return a pure mapping with no removal policy at all. Returns typing.MutableMapping[KeyT, ValueT] A frozen mapping view of the items in this mapped collection.", "f": 1}, {"r": "hikari.internal.collections.FreezableDict", "u": 78, "d": "A mapping that wraps a dict, but can also be frozen."}, {"r": "hikari.internal.collections.FreezableDict.clear", "u": 78, "d": "D.clear() -> None. Remove all items from D.", "f": 1}, {"r": "hikari.internal.collections.FreezableDict.copy", "u": 78, "d": "Return a copy of this mapped collection. Unlike simply doing dict(mapping) , this may rely on internal detail\naround how the data is being stored to allow for a more efficient copy.\nThis may look like calling dict.copy and wrapping the result in a\nmapped collection. ! note Any removal policy on this mapped collection will be copied over. Returns MapT[KeyT, ValueT] A copy of this mapped collection.", "f": 1}, {"r": "hikari.internal.collections.FreezableDict.freeze", "u": 78, "d": "Return a frozen mapping view of the items in this mapped collection. Unlike simply doing dict(mapping) , this may rely on internal detail\naround how the data is being stored to allow for a more efficient copy.\nThis may look like calling dict.copy . ! note Unlike ExtendedMutableMapping.copy , this should return a pure mapping with no removal policy at all. Returns typing.MutableMapping[KeyT, ValueT] A frozen mapping view of the items in this mapped collection.", "f": 1}, {"r": "hikari.internal.collections.TimedCacheMap", "u": 78, "d": "A most-recently-inserted limited mutable mapping implementation. This will remove entries on modification as as they pass the expiry limit. Parameters expiry : datetime.timedelta The timedelta of how long entries should be stored for before removal. Other Parameters source : typing.Optional[typing.Dict[KeyT, typing.Tuple[builtins.float, ValueT A source dictionary of keys to tuples of float timestamps and values to create this from.\non_expire : typing.Optional[typing.Callable ValueT], None A function to call each time an item is garbage collected from this map. This should take one positional argument of the same type stored in this mapping as the value and should return builtins.None . This will always be called after the entry has been removed."}, {"r": "hikari.internal.collections.TimedCacheMap.clear", "u": 78, "d": "D.clear() -> None. Remove all items from D.", "f": 1}, {"r": "hikari.internal.collections.TimedCacheMap.copy", "u": 78, "d": "Return a copy of this mapped collection. Unlike simply doing dict(mapping) , this may rely on internal detail\naround how the data is being stored to allow for a more efficient copy.\nThis may look like calling dict.copy and wrapping the result in a\nmapped collection. ! note Any removal policy on this mapped collection will be copied over. Returns MapT[KeyT, ValueT] A copy of this mapped collection.", "f": 1}, {"r": "hikari.internal.collections.TimedCacheMap.freeze", "u": 78, "d": "Return a frozen mapping view of the items in this mapped collection. Unlike simply doing dict(mapping) , this may rely on internal detail\naround how the data is being stored to allow for a more efficient copy.\nThis may look like calling dict.copy . ! note Unlike ExtendedMutableMapping.copy , this should return a pure mapping with no removal policy at all. Returns typing.MutableMapping[KeyT, ValueT] A frozen mapping view of the items in this mapped collection.", "f": 1}, {"r": "hikari.internal.collections.LimitedCapacityCacheMap", "u": 78, "d": "Implementation of a capacity-limited most-recently-inserted mapping. This will start removing the oldest entries after it's maximum capacity is\nreached as new entries are added. Parameters limit : int The limit for how many objects should be stored by this mapping before it starts removing the oldest entries. Other Parameters source : typing.Optional[typing.Dict[KeyT, ValueT A source dictionary of keys to values to create this from.\non_expire : typing.Optional[typing.Callable ValueT], None A function to call each time an item is garbage collected from this map. This should take one positional argument of the same type stored in this mapping as the value and should return builtins.None. This will always be called after the entry has been removed."}, {"r": "hikari.internal.collections.LimitedCapacityCacheMap.clear", "u": 78, "d": "D.clear() -> None. Remove all items from D.", "f": 1}, {"r": "hikari.internal.collections.LimitedCapacityCacheMap.copy", "u": 78, "d": "Return a copy of this mapped collection. Unlike simply doing dict(mapping) , this may rely on internal detail\naround how the data is being stored to allow for a more efficient copy.\nThis may look like calling dict.copy and wrapping the result in a\nmapped collection. ! note Any removal policy on this mapped collection will be copied over. Returns MapT[KeyT, ValueT] A copy of this mapped collection.", "f": 1}, {"r": "hikari.internal.collections.LimitedCapacityCacheMap.freeze", "u": 78, "d": "Return a frozen mapping view of the items in this mapped collection. Unlike simply doing dict(mapping) , this may rely on internal detail\naround how the data is being stored to allow for a more efficient copy.\nThis may look like calling dict.copy . ! note Unlike ExtendedMutableMapping.copy , this should return a pure mapping with no removal policy at all. Returns typing.MutableMapping[KeyT, ValueT] A frozen mapping view of the items in this mapped collection.", "f": 1}, {"r": "hikari.internal.collections.get_index_or_slice", "u": 78, "d": "Get a mapping's entry at a given index as if it's a sequence of it's values. Parameters mapping : typing.Mapping[KeyT, ValueT] The mapping of entries to treat as a sequence.\nindex_or_slice : typing.Sequence[KeyT, ValueT] The index to get an entry to get or slice of multiple entries to get. Returns ValueT or typing.Sequence[ValueT] The value found at the given integer index or a sequence of the values found based on the given slice's rules. Raises TypeError If index_or_slice isn't a builtins.slice or builtins.int .\nIndexError If index_or_slice is an int and is outside the range of the mapping's contents.", "f": 1}, {"r": "hikari.internal.aio", "u": 79, "d": "Asyncio extensions and utilities."}, {"r": "hikari.internal.aio.completed_future", "u": 79, "d": "Create a future on the current running loop that is completed, then return it. Parameters result : T The value to set for the result of the future. T is a generic type placeholder for the type that the future will have set as the result. T may be builtins.None , in which case, this will return asyncio.Future[builtins.None] . Returns asyncio.Future[T] The completed future. Raises RuntimeError When called in an environment with no running event loop.", "f": 1}, {"r": "hikari.internal.aio.get_or_make_loop", "u": 79, "d": "Get the current usable event loop or create a new one. Returns asyncio.AbstractEventLoop", "f": 1}, {"r": "hikari.internal.aio.is_async_iterator", "u": 79, "d": "Determine if the object is an async iterator or not.", "f": 1}, {"r": "hikari.internal.aio.is_async_iterable", "u": 79, "d": "Determine if the object is an async iterable or not.", "f": 1}, {"r": "hikari.internal.aio.first_completed", "u": 79, "d": "Wait for the first awaitable to complete. The awaitables that don't complete first will be cancelled. Completion is defined as having a result or an exception set. Thus,\ncancelling any of the awaitables will also result in the others being\ncancelled. If the first awaitable raises an exception, then that exception will be\npropagated. Parameters  aws : typing.Awaitable[typing.Any] Awaitables to wait for.\ntimeout : typing.Optional[float] Optional timeout to wait for, or builtins.None to not use one. If the timeout is reached, all awaitables are cancelled immediately. ! note If more than one awaitable is completed before entering this call, then the first future is always returned.", "f": 1}, {"r": "hikari.internal.aio.all_of", "u": 79, "d": "Await the completion of all the given awaitable items. If any fail or time out, then they are all cancelled. Parameters  aws : typing.Awaitable[T_co] Awaitables to wait for.\ntimeout : typing.Optional[float] Optional timeout to wait for, or builtins.None to not use one. If the timeout is reached, all awaitables are cancelled immediately. Returns typing.Sequence[T_co] The results of each awaitable in the order they were provided invoked in.", "f": 1}, {"r": "hikari.internal.time", "u": 80, "d": "Utility methods used for parsing timestamps and datetimes from Discord."}, {"r": "hikari.internal.time.DISCORD_EPOCH", "u": 80, "d": "Discord epoch used within snowflake identifiers. This is defined as the number of seconds between 1/1/1970 00:00:00 UTC and 1/1/2015 00:00:00 UTC . References  [Discord API documentation - Snowflakes](https: discord.com/developers/docs/reference snowflakes)"}, {"r": "hikari.internal.time.datetime_to_discord_epoch", "u": 80, "d": "Parse a datetime.datetime object into an builtins.int  DISCORD_EPOCH offset. Parameters timestamp : datetime.datetime Number of seconds since 1/1/1970 00:00:00 UTC . Returns builtins.int Number of milliseconds since 1/1/2015 00:00:00 UTC .", "f": 1}, {"r": "hikari.internal.time.discord_epoch_to_datetime", "u": 80, "d": "Parse a Discord epoch into a datetime.datetime object. Parameters epoch : builtins.int Number of milliseconds since 1/1/2015 00:00:00 UTC . Returns datetime.datetime Number of seconds since 1/1/1970 00:00:00 UTC .", "f": 1}, {"r": "hikari.internal.time.unix_epoch_to_datetime", "u": 80, "d": "Parse a UNIX epoch to a datetime.datetime object. ! note If an epoch that's outside the range of what this system can handle, this will return datetime.datetime.max if the timestamp is positive, or datetime.datetime.min otherwise. Parameters epoch : typing.Union[builtins.int, builtins.float] Number of seconds/milliseconds since 1/1/1970 00:00:00 UTC .\nis_millis : builtins.bool builtins.True by default, indicates the input timestamp is measured in milliseconds rather than seconds Returns datetime.datetime Number of seconds since 1/1/1970 00:00:00 UTC .", "f": 1}, {"r": "hikari.internal.time.Intervalish", "u": 80, "d": "Type hint representing a naive time period or time span. This is a type that is like an interval of some sort. This is an alias for typing.Union[int, float, datetime.datetime] ,\nwhere builtins.int and builtins.float types are interpreted as a number of seconds."}, {"r": "hikari.internal.time.timespan_to_int", "u": 80, "d": "Cast the given timespan in seconds to an integer value. Parameters value : Intervalish The number of seconds. Returns builtins.int The integer number of seconds. Fractions are discarded. Negative values are removed.", "f": 1}, {"r": "hikari.internal.time.local_datetime", "u": 80, "d": "Return the current date/time for the system's time zone.", "f": 1}, {"r": "hikari.internal.time.utc_datetime", "u": 80, "d": "Return the current date/time for UTC (GMT+0).", "f": 1}, {"r": "hikari.internal.time.monotonic", "u": 80, "d": "Performance counter for benchmarking.", "f": 1}, {"r": "hikari.internal.time.monotonic_ns", "u": 80, "d": "Performance counter for benchmarking as nanoseconds.", "f": 1}, {"r": "hikari.internal.time.uuid", "u": 80, "d": "Generate a unique UUID (1ns precision).", "f": 1}, {"r": "hikari.snowflakes", "u": 81, "d": "Implementation of a Snowflake type."}, {"r": "hikari.snowflakes.Snowflake", "u": 81, "d": "A concrete representation of a unique ID for an entity on Discord. This object can be treated as a regular builtins.int for most purposes."}, {"r": "hikari.snowflakes.Snowflake.created_at", "u": 81, "d": "When the object was created."}, {"r": "hikari.snowflakes.Snowflake.internal_worker_id", "u": 81, "d": "ID of the worker that created this snowflake on Discord's systems."}, {"r": "hikari.snowflakes.Snowflake.internal_process_id", "u": 81, "d": "ID of the process that created this snowflake on Discord's systems."}, {"r": "hikari.snowflakes.Snowflake.increment", "u": 81, "d": "Increment of Discord's system when this object was made."}, {"r": "hikari.snowflakes.Snowflake.from_datetime", "u": 81, "d": "Get a snowflake object from a datetime object.", "f": 1}, {"r": "hikari.snowflakes.Snowflake.min", "u": 81, "d": "Minimum value for a snowflakes.", "f": 1}, {"r": "hikari.snowflakes.Snowflake.max", "u": 81, "d": "Maximum value for a snowflakes.", "f": 1}, {"r": "hikari.snowflakes.Snowflake.from_data", "u": 81, "d": "Convert the pieces of info that comprise an ID into a Snowflake.", "f": 1}, {"r": "hikari.snowflakes.Unique", "u": 81, "d": "Mixin for a class that enforces uniqueness by a snowflake ID."}, {"r": "hikari.snowflakes.Unique.id", "u": 81, "d": "Return the ID of this entity. Returns Snowflake The snowflake ID of this object."}, {"r": "hikari.snowflakes.Unique.created_at", "u": 81, "d": "When the object was created."}, {"r": "hikari.snowflakes.calculate_shard_id", "u": 81, "d": "Calculate the shard ID for a guild based on it's shard aware app or shard count. Parameters app_or_count : typing.Union[hikari.traits.ShardAware, builtins.int] The shard aware app of the current application or the integer count of the current app's shards.\nguild : SnowflakeishOr[hikari.guilds.PartialGuild] The object or ID of the guild to get the shard ID of. Returns builtins.int The zero-indexed integer ID of the shard that should cover this guild.", "f": 1}, {"r": "hikari.snowflakes.Snowflakeish", "u": 81, "d": "Type hint for a value that resembles a Snowflake object functionally. This is a value that is Snowflake -ish. A value is Snowflake -ish if casting it to an int allows it to be cast to\na Snowflake . The valid types for this type hint are: - builtins.int - Snowflake "}, {"r": "hikari.snowflakes.SearchableSnowflakeish", "u": 81, "d": "Type hint for a snowflakeish that can be searched for in history. This is just a Snowflakeish that can alternatively be some form of datetime.datetime instance. The valid types for this type hint are: - builtins.str containing digits.\n- builtins.int - Snowflake - datetime.datetime "}, {"r": "hikari.snowflakes.SnowflakeishOr", "u": 81, "d": "Type hint representing a unique object entity. This is a value that is Snowflake -ish or a specific type covariant. If you see SnowflakeishOr[Foo] anywhere as a type hint, it means the value\nmay be a Foo instance, a Snowflake , a builtins.int or a builtins.str with numeric digits only. Essentially this represents any concrete object, or ID of that object. It is\nused across Hikari's API to allow use of functions when information is only\npartially available (due to Discord inconsistencies, edge case behaviour, or\nuse of intents). The valid types for this type hint are: - buitlins.int - Snowflake "}, {"r": "hikari.snowflakes.SearchableSnowflakeishOr", "u": 81, "d": "Type hint for a unique object entity that can be searched for. This is a variant of SnowflakeishOr that also allows an alternative value\nof a datetime.datetime to be specified. Essentially this represents any concrete object, or ID of that object. It is\nused across Hikari's API to allow use of functions when information is only\npartially available (due to Discord inconsistencies, edge case behaviour, or\nuse of intents). The valid types for this type hint are: - buitlins.int - Snowflake - datetime.datetime "}, {"r": "hikari.snowflakes.SnowflakeishIterable", "u": 81, "d": "Type hint representing an iterable of unique object entities."}, {"r": "hikari.snowflakes.SnowflakeishSequence", "u": 81, "d": "Type hint representing a collection of unique object entities."}, {"r": "hikari.sessions", "u": 82, "d": "Entities directly related to creating and managing gateway shard sessions."}, {"r": "hikari.sessions.GatewayBotInfo", "u": 82, "d": "Used to represent gateway information for the connected bot. Method generated by attrs for class GatewayBotInfo."}, {"r": "hikari.sessions.GatewayBotInfo.session_start_limit", "u": 82, "d": "Information about the bot's current session start limit."}, {"r": "hikari.sessions.GatewayBotInfo.shard_count", "u": 82, "d": "The recommended number of shards to use when connecting to the gateway."}, {"r": "hikari.sessions.GatewayBotInfo.url", "u": 82, "d": "The WSS URL that can be used for connecting to the gateway."}, {"r": "hikari.sessions.SessionStartLimit", "u": 82, "d": "Used to represent information about the current session start limits. Method generated by attrs for class SessionStartLimit."}, {"r": "hikari.sessions.SessionStartLimit.used", "u": 82, "d": "Return how many times you have sent an IDENTIFY in the window."}, {"r": "hikari.sessions.SessionStartLimit.reset_at", "u": 82, "d": "Return the approximate time that the IDENTIFY limit resets at."}, {"r": "hikari.sessions.SessionStartLimit.max_concurrency", "u": 82, "d": "Maximum connection concurrency. This defines how many shards can be started at once within a 5 second\nwindow. For most bots, this will always be 1 , but for very large bots,\nthis may be increased to reduce startup times. Contact Discord for\nmore information."}, {"r": "hikari.sessions.SessionStartLimit.remaining", "u": 82, "d": "The remaining number of session starts this bot has."}, {"r": "hikari.sessions.SessionStartLimit.reset_after", "u": 82, "d": "When SessionStartLimit.remaining will reset for the current bot. After it resets it will be set to SessionStartLimit.total ."}, {"r": "hikari.sessions.SessionStartLimit.total", "u": 82, "d": "The total number of session starts the current bot is allowed."}, {"r": "hikari.presences", "u": 83, "d": "Application and entities that are used to describe guilds on Discord."}, {"r": "hikari.presences.Activity", "u": 83, "d": "Represents a regular activity that can be associated with a presence. Method generated by attrs for class Activity."}, {"r": "hikari.presences.Activity.name", "u": 83, "d": "The activity name."}, {"r": "hikari.presences.Activity.type", "u": 83, "d": "The activity type."}, {"r": "hikari.presences.Activity.url", "u": 83, "d": "The activity URL. Only valid for STREAMING activities."}, {"r": "hikari.presences.ActivityAssets", "u": 83, "d": "Used to represent possible assets for an activity. Method generated by attrs for class ActivityAssets."}, {"r": "hikari.presences.ActivityAssets.large_image", "u": 83, "d": "The ID of the asset's large image, if set."}, {"r": "hikari.presences.ActivityAssets.large_text", "u": 83, "d": "The text that'll appear when hovering over the large image, if set."}, {"r": "hikari.presences.ActivityAssets.small_image", "u": 83, "d": "The ID of the asset's small image, if set."}, {"r": "hikari.presences.ActivityAssets.small_text", "u": 83, "d": "The text that'll appear when hovering over the small image, if set."}, {"r": "hikari.presences.ActivityFlag", "u": 83, "d": "Flags that describe what an activity includes. This can be more than one using bitwise-combinations."}, {"r": "hikari.presences.ActivityFlag.name", "u": 83, "d": "Return the name of the flag combination as a builtins.str ."}, {"r": "hikari.presences.ActivityFlag.value", "u": 83, "d": "Return the builtins.int value of the flag."}, {"r": "hikari.presences.ActivityFlag.all", "u": 83, "d": "Check if all of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.presences.ActivityFlag.any", "u": 83, "d": "Check if any of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.presences.ActivityFlag.difference", "u": 83, "d": "Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction - operator.", "f": 1}, {"r": "hikari.presences.ActivityFlag.intersection", "u": 83, "d": "Return a combination of flags that are set for both given values. Equivalent to using the \"AND\" & operator.", "f": 1}, {"r": "hikari.presences.ActivityFlag.invert", "u": 83, "d": "Return a set of all flags not in the current set.", "f": 1}, {"r": "hikari.presences.ActivityFlag.is_disjoint", "u": 83, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.presences.ActivityFlag.is_subset", "u": 83, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.presences.ActivityFlag.is_superset", "u": 83, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.presences.ActivityFlag.none", "u": 83, "d": "Check if none of the given flags are part of this value. ! note This is essentially the opposite of Flag.any . Returns builtins.bool builtins.True if none of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.presences.ActivityFlag.split", "u": 83, "d": "Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted typing.Sequence of each membe", "f": 1}, {"r": "hikari.presences.ActivityFlag.symmetric_difference", "u": 83, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.presences.ActivityFlag.union", "u": 83, "d": "Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\" ~ operator.", "f": 1}, {"r": "hikari.presences.ActivityFlag.isdisjoint", "u": 83, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.presences.ActivityFlag.issubset", "u": 83, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.presences.ActivityFlag.issuperset", "u": 83, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.presences.ActivityFlag.symmetricdifference", "u": 83, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.presences.ActivityFlag.INSTANCE", "u": 83, "d": "Instance"}, {"r": "hikari.presences.ActivityFlag.JOIN", "u": 83, "d": "Join"}, {"r": "hikari.presences.ActivityFlag.SPECTATE", "u": 83, "d": "Spectate"}, {"r": "hikari.presences.ActivityFlag.JOIN_REQUEST", "u": 83, "d": "Join Request"}, {"r": "hikari.presences.ActivityFlag.SYNC", "u": 83, "d": "Sync"}, {"r": "hikari.presences.ActivityFlag.PLAY", "u": 83, "d": "Play"}, {"r": "hikari.presences.ActivitySecret", "u": 83, "d": "The secrets used for interacting with an activity party. Method generated by attrs for class ActivitySecret."}, {"r": "hikari.presences.ActivitySecret.join", "u": 83, "d": "The secret used for joining a party, if applicable."}, {"r": "hikari.presences.ActivitySecret.match", "u": 83, "d": "The secret used for matching a party, if applicable."}, {"r": "hikari.presences.ActivitySecret.spectate", "u": 83, "d": "The secret used for spectating a party, if applicable."}, {"r": "hikari.presences.ActivityTimestamps", "u": 83, "d": "The datetimes for the start and/or end of an activity session. Method generated by attrs for class ActivityTimestamps."}, {"r": "hikari.presences.ActivityTimestamps.end", "u": 83, "d": "When this activity's session will end, if applicable."}, {"r": "hikari.presences.ActivityTimestamps.start", "u": 83, "d": "When this activity's session was started, if applicable."}, {"r": "hikari.presences.ActivityType", "u": 83, "d": "The activity type."}, {"r": "hikari.presences.ActivityType.name", "u": 83, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.presences.ActivityType.value", "u": 83, "d": "Return the value of the enum member."}, {"r": "hikari.presences.ActivityType.PLAYING", "u": 83, "d": "Shows up as Playing <name> "}, {"r": "hikari.presences.ActivityType.STREAMING", "u": 83, "d": "Shows up as Streaming and links to a Twitch or YouTube stream/video. ! warning You MUST provide a valid Twitch or YouTube stream URL to the activity you create in order for this to be valid. If you fail to do this, then the activity WILL NOT update."}, {"r": "hikari.presences.ActivityType.LISTENING", "u": 83, "d": "Shows up as Listening to <name> ."}, {"r": "hikari.presences.ActivityType.WATCHING", "u": 83, "d": "Shows up as Watching <name> ."}, {"r": "hikari.presences.ActivityType.CUSTOM", "u": 83, "d": "A custom status. To set an emoji with the status, place a unicode emoji or Discord emoji\n( :smiley: ) as the first part of the status activity name. ! warning Bots DO NOT support setting custom statuses."}, {"r": "hikari.presences.ActivityType.COMPETING", "u": 83, "d": "Shows up as Competing in <name> ."}, {"r": "hikari.presences.ActivityParty", "u": 83, "d": "Used to represent activity groups of users. Method generated by attrs for class ActivityParty."}, {"r": "hikari.presences.ActivityParty.current_size", "u": 83, "d": "Current size of this party, if applicable."}, {"r": "hikari.presences.ActivityParty.id", "u": 83, "d": "The string id of this party instance, if set."}, {"r": "hikari.presences.ActivityParty.max_size", "u": 83, "d": "Maximum size of this party, if applicable."}, {"r": "hikari.presences.ClientStatus", "u": 83, "d": "The client statuses for this member. Method generated by attrs for class ClientStatus."}, {"r": "hikari.presences.ClientStatus.desktop", "u": 83, "d": "The status of the target user's desktop session."}, {"r": "hikari.presences.ClientStatus.mobile", "u": 83, "d": "The status of the target user's mobile session."}, {"r": "hikari.presences.ClientStatus.web", "u": 83, "d": "The status of the target user's web session."}, {"r": "hikari.presences.MemberPresence", "u": 83, "d": "Used to represent a guild member's presence. Method generated by attrs for class MemberPresence."}, {"r": "hikari.presences.MemberPresence.fetch_user", "u": 83, "d": "Fetch the user this presence is for. Returns hikari.users.User The requested user. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.presences.MemberPresence.fetch_member", "u": 83, "d": "Fetch the member this presence is for. Returns hikari.guilds.Member The requested member. Raises hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the user is not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.presences.MemberPresence.activities", "u": 83, "d": "All active user activities. You can assume the first activity is the one that the GUI Discord client\nwill show."}, {"r": "hikari.presences.MemberPresence.app", "u": 83, "d": "The client application that models may use for procedures."}, {"r": "hikari.presences.MemberPresence.client_status", "u": 83, "d": "Platform-specific user-statuses."}, {"r": "hikari.presences.MemberPresence.guild_id", "u": 83, "d": "The ID of the guild this presence belongs to."}, {"r": "hikari.presences.MemberPresence.user_id", "u": 83, "d": "The ID of the user this presence belongs to."}, {"r": "hikari.presences.MemberPresence.visible_status", "u": 83, "d": "This user's current status being displayed by the client."}, {"r": "hikari.presences.RichActivity", "u": 83, "d": "Represents a rich activity that can be associated with a presence. Method generated by attrs for class RichActivity."}, {"r": "hikari.presences.RichActivity.application_id", "u": 83, "d": "The ID of the application this activity is for, if applicable."}, {"r": "hikari.presences.RichActivity.assets", "u": 83, "d": "Images and their hover over text for the activity."}, {"r": "hikari.presences.RichActivity.buttons", "u": 83, "d": "A sequence of up to 2 of the button labels shown in this rich presence."}, {"r": "hikari.presences.RichActivity.created_at", "u": 83, "d": "When this activity was added to the user's session."}, {"r": "hikari.presences.RichActivity.details", "u": 83, "d": "The text that describes what the activity's target is doing, if set."}, {"r": "hikari.presences.RichActivity.emoji", "u": 83, "d": "The emoji of this activity, if it is a custom status and set."}, {"r": "hikari.presences.RichActivity.flags", "u": 83, "d": "Flags that describe what the activity includes, if present."}, {"r": "hikari.presences.RichActivity.is_instance", "u": 83, "d": "Whether this activity is an instanced game session."}, {"r": "hikari.presences.RichActivity.party", "u": 83, "d": "Information about the party associated with this activity, if set."}, {"r": "hikari.presences.RichActivity.secrets", "u": 83, "d": "Secrets for Rich Presence joining and spectating."}, {"r": "hikari.presences.RichActivity.state", "u": 83, "d": "The current status of this activity's target, if set."}, {"r": "hikari.presences.RichActivity.timestamps", "u": 83, "d": "The timestamps for when this activity's current state will start and\nend, if applicable."}, {"r": "hikari.presences.RichActivity.name", "u": 83, "d": "The activity name."}, {"r": "hikari.presences.RichActivity.type", "u": 83, "d": "The activity type."}, {"r": "hikari.presences.RichActivity.url", "u": 83, "d": "The activity URL. Only valid for STREAMING activities."}, {"r": "hikari.presences.Status", "u": 83, "d": "The status of a member."}, {"r": "hikari.presences.Status.name", "u": 83, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.presences.Status.value", "u": 83, "d": "Return the value of the enum member."}, {"r": "hikari.presences.Status.ONLINE", "u": 83, "d": "Online/green."}, {"r": "hikari.presences.Status.IDLE", "u": 83, "d": "Idle/yellow."}, {"r": "hikari.presences.Status.DO_NOT_DISTURB", "u": 83, "d": "Do not disturb/red."}, {"r": "hikari.presences.Status.OFFLINE", "u": 83, "d": "Offline or invisible/grey."}, {"r": "hikari.intents", "u": 84, "d": "Shard intents for controlling which events the application receives."}, {"r": "hikari.intents.Intents", "u": 84, "d": "Represents an intent on the gateway. This is a bitfield representation of all the categories of event\nthat you wish to receive. Any events not in an intent category will be fired regardless of what\nintents you provide. ! info Discord now places limits on certain events you can receive without whitelisting your bot first. On the Bot tab in the developer's portal for your bot, you should now have the option to enable functionality for receiving these events. If you attempt to request an intent type that you have not whitelisted your bot for, you will be disconnected on startup with a 4014 closure code. ! warning If you are using the V7 Gateway, you will be REQUIRED to provide some form of intent value when you connect. Failure to do so may result in immediate termination of the session server-side. This enum is an enum.IntFlag , which means that you can use bitwise\noperators to join and splice multiple intents into one value. For example, if we wish to only refer to the GUILDS intent, then it is\nsimply a case of accessing it normally. py\nmy_intents = Intents.GUILDS If we wanted to have several intents grouped together, we would use the\nbitwise-or operator to combine them ( | ). This can be done in-place\nwith the |= operator if needed. py One or two values that fit on one line.\nmy_intents = Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES Several intents together. You may find it useful to format these like so to keep your code readable.\nmy_intents = ( Intents.GUILDS | Intents.GUILD_BANS | Intents.GUILD_EMOJIS | Intents.GUILD_INTEGRATIONS | Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES\n) To check if an intent is present in a given intents bitfield, you can\nuse the bitwise-and operator ( & ) to check. This returns the \"intersection\"\nor \"crossover\" between the left and right-hand side of the & . You can then\nuse the   operator to check that specific values are present. You can\ncheck in-place with the &= operator if needed. py Check if an intent is set:\nif (my_intents & Intents.GUILD_MESSAGES) Intents.GUILD_MESSAGES: print(\"Guild messages are enabled\") Checking if ALL in a combination are set:\nexpected_intents = (Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES)\nif (my_intents & expected_intents) expected_intents: print(\"Messages are enabled in guilds and private messages.\") Checking if AT LEAST ONE in a combination is set:\nexpected_intents = (Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES)\nif my_intents & expected_intents: print(\"Messages are enabled in guilds or private messages.\") Removing one or more intents from a combination can be done with the\nbitwise-xor ( ^ ) operator. The ^= operator can do this in-place. py Remove GUILD_MESSAGES\nmy_intents = my_intents ^ Intents.GUILD_MESSAGES or, simplifying:\nmy_intents ^= Intents.GUILD_MESSAGES Remove all messages events.\nmy_intents = my_intents ^ (Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES) or, simplifying\nmy_intents ^= (Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES) What is and is not covered by intents? The following unprivileged events require intents to be dispatched: - GUILD_CREATE - GUILD_UPDATE - GUILD_DELETE - GUILD_ROLE_CREATE - GUILD_ROLE_UPDATE - GUILD_ROLE_DELETE - GUILD_BAN_ADD - GUILD_BAN_REMOVE - GUILD_EMOJIS_UPDATE - INTEGRATION_CREATE - INTEGRATION_DELETE - INTEGRATION_UPDATE - INVITE_CREATE - INVITE_DELETE - CHANNEL_CREATE - CHANNEL_UPDATE - CHANNEL_DELETE - CHANNEL_PINS_UPDATE (guilds only) - MESSAGE_CREATE - MESSAGE_UPDATE - MESSAGE_DELETE - MESSAGE_BULK_DELETE - MESSAGE_REACTION_ADD - MESSAGE_REACTION_REMOVE - MESSAGE_REACTION_REMOVE_ALL - MESSAGE_REACTION_REMOVE_EMOJI - TYPING_START - VOICE_STATE_UPDATE - WEBHOOKS_UPDATE The following privileged events require intents to be dispatched: - GUILD_MEMBER_ADD - GUILD_MEMBER_UPDATE - GUILD_MEMBER_REMOVE - PRESENCE_UPDATE All events not listed above will be dispatched regardless of whether\nintents are used or not."}, {"r": "hikari.intents.Intents.name", "u": 84, "d": "Return the name of the flag combination as a builtins.str ."}, {"r": "hikari.intents.Intents.value", "u": 84, "d": "Return the builtins.int value of the flag."}, {"r": "hikari.intents.Intents.all", "u": 84, "d": "Check if all of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.intents.Intents.any", "u": 84, "d": "Check if any of the given flags are part of this value. Returns builtins.bool builtins.True if any of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.intents.Intents.difference", "u": 84, "d": "Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction - operator.", "f": 1}, {"r": "hikari.intents.Intents.intersection", "u": 84, "d": "Return a combination of flags that are set for both given values. Equivalent to using the \"AND\" & operator.", "f": 1}, {"r": "hikari.intents.Intents.invert", "u": 84, "d": "Return a set of all flags not in the current set.", "f": 1}, {"r": "hikari.intents.Intents.is_disjoint", "u": 84, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.intents.Intents.is_subset", "u": 84, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.intents.Intents.is_superset", "u": 84, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.intents.Intents.none", "u": 84, "d": "Check if none of the given flags are part of this value. ! note This is essentially the opposite of Flag.any . Returns builtins.bool builtins.True if none of the given flags are part of this value. Otherwise, return builtins.False .", "f": 1}, {"r": "hikari.intents.Intents.split", "u": 84, "d": "Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted typing.Sequence of each membe", "f": 1}, {"r": "hikari.intents.Intents.symmetric_difference", "u": 84, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.intents.Intents.union", "u": 84, "d": "Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\" ~ operator.", "f": 1}, {"r": "hikari.intents.Intents.isdisjoint", "u": 84, "d": "Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns builtins.False . If no common flag values exist between them, then\nthis returns builtins.True .", "f": 1}, {"r": "hikari.intents.Intents.issubset", "u": 84, "d": "Return whether another set contains this set or not. Equivalent to using the \"in\" operator.", "f": 1}, {"r": "hikari.intents.Intents.issuperset", "u": 84, "d": "Return whether this set contains another set or not.", "f": 1}, {"r": "hikari.intents.Intents.symmetricdifference", "u": 84, "d": "Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\" ^ operator. For a ^ b , this can be considered the same as (a - b) | (b - a) .", "f": 1}, {"r": "hikari.intents.Intents.is_privileged", "u": 84, "d": "Determine whether the intent requires elevated privileges. If this is builtins.True , you will be required to opt-in to using\nthis intent on the Discord Developer Portal before you can utilise it\nin your application."}, {"r": "hikari.intents.Intents.NONE", "u": 84, "d": "Represents no intents."}, {"r": "hikari.intents.Intents.GUILDS", "u": 84, "d": "Subscribes to the following events:  GUILD_CREATE   GUILD_UPDATE   GUILD_DELETE   GUILD_ROLE_CREATE   GUILD_ROLE_UPDATE   GUILD_ROLE_DELETE   CHANNEL_CREATE   CHANNEL_UPDATE   CHANNEL_DELETE   CHANNEL_PINS_UPDATE "}, {"r": "hikari.intents.Intents.GUILD_MEMBERS", "u": 84, "d": "Subscribes to the following events:  GUILD_MEMBER_ADD   GUILD_MEMBER_UPDATE   GUILD_MEMBER_REMOVE  ! warning This intent is privileged, and requires enabling/whitelisting to use."}, {"r": "hikari.intents.Intents.GUILD_BANS", "u": 84, "d": "Subscribes to the following events:  GUILD_BAN_ADD   GUILD_BAN_REMOVE "}, {"r": "hikari.intents.Intents.GUILD_EMOJIS", "u": 84, "d": "Subscribes to the following events:  GUILD_EMOJIS_UPDATE "}, {"r": "hikari.intents.Intents.GUILD_INTEGRATIONS", "u": 84, "d": "Subscribes to the following events:  INTEGRATION_CREATE   INTEGRATION_DELETE   INTEGRATION_UPDATE "}, {"r": "hikari.intents.Intents.GUILD_WEBHOOKS", "u": 84, "d": "Subscribes to the following events:  WEBHOOKS_UPDATE "}, {"r": "hikari.intents.Intents.GUILD_INVITES", "u": 84, "d": "Subscribes to the following events:  INVITE_CREATE   INVITE_DELETE "}, {"r": "hikari.intents.Intents.GUILD_VOICE_STATES", "u": 84, "d": "Subscribes to the following events:  VOICE_STATE_UPDATE "}, {"r": "hikari.intents.Intents.GUILD_PRESENCES", "u": 84, "d": "Subscribes to the following events:  PRESENCE_UPDATE  ! warning This intent is privileged, and requires enabling/whitelisting to use."}, {"r": "hikari.intents.Intents.GUILD_MESSAGES", "u": 84, "d": "Subscribes to the following events:  MESSAGE_CREATE (in guilds only)  MESSAGE_UPDATE (in guilds only)  MESSAGE_DELETE (in guilds only)  MESSAGE_BULK_DELETE (in guilds only)"}, {"r": "hikari.intents.Intents.GUILD_MESSAGE_REACTIONS", "u": 84, "d": "Subscribes to the following events:  MESSAGE_REACTION_ADD (in guilds only)  MESSAGE_REACTION_REMOVE (in guilds only)  MESSAGE_REACTION_REMOVE_ALL (in guilds only)  MESSAGE_REACTION_REMOVE_EMOJI (in guilds only)"}, {"r": "hikari.intents.Intents.GUILD_MESSAGE_TYPING", "u": 84, "d": "Subscribes to the following events:  TYPING_START (in guilds only)"}, {"r": "hikari.intents.Intents.DM_MESSAGES", "u": 84, "d": "Subscribes to the following events:  MESSAGE_CREATE (in private message channels (non-guild bound) only)  MESSAGE_UPDATE (in private message channels (non-guild bound) only)  MESSAGE_DELETE (in private message channels (non-guild bound) only)"}, {"r": "hikari.intents.Intents.DM_MESSAGE_REACTIONS", "u": 84, "d": "Subscribes to the following events:  MESSAGE_REACTION_ADD (in private message channels (non-guild bound) only)  MESSAGE_REACTION_REMOVE (in private message channels (non-guild bound) only)  MESSAGE_REACTION_REMOVE_ALL (in private message channels (non-guild bound) only)  MESSAGE_REACTION_REMOVE_EMOJI (in private message channels (non-guild bound) only)"}, {"r": "hikari.intents.Intents.DM_MESSAGE_TYPING", "u": 84, "d": "Subscribes to the following events  TYPING_START (in private message channels (non-guild bound) only)"}, {"r": "hikari.intents.Intents.ALL_GUILDS_UNPRIVILEGED", "u": 84, "d": "All unprivileged guild-related intents."}, {"r": "hikari.intents.Intents.ALL_GUILDS_PRIVILEGED", "u": 84, "d": "All privileged guild intents. ! warning This set of intent is privileged, and requires enabling/whitelisting to use."}, {"r": "hikari.intents.Intents.ALL_GUILDS", "u": 84, "d": "All unprivileged guild intents and all privileged guild intents. This combines Intents.ALL_GUILDS_UNPRIVILEGED and Intents.ALL_GUILDS_PRIVILEGED . ! warning This set of intent is privileged, and requires enabling/whitelisting to use."}, {"r": "hikari.intents.Intents.ALL_DMS", "u": 84, "d": "All private message channel (non-guild bound) intents."}, {"r": "hikari.intents.Intents.ALL_MESSAGES", "u": 84, "d": "All message intents."}, {"r": "hikari.intents.Intents.ALL_MESSAGE_REACTIONS", "u": 84, "d": "All message reaction intents."}, {"r": "hikari.intents.Intents.ALL_MESSAGE_TYPING", "u": 84, "d": "All typing indicator intents."}, {"r": "hikari.intents.Intents.ALL_UNPRIVILEGED", "u": 84, "d": "All unprivileged intents."}, {"r": "hikari.intents.Intents.ALL_PRIVILEGED", "u": 84, "d": "All privileged intents. ! warning This set of intent is privileged, and requires enabling/whitelisting to use."}, {"r": "hikari.intents.Intents.ALL", "u": 84, "d": "All unprivileged and privileged intents. ! warning This set of intent is privileged, and requires enabling/whitelisting to use."}, {"r": "hikari.webhooks", "u": 85, "d": "Application and entities that are used to describe webhooks on Discord."}, {"r": "hikari.webhooks.ApplicationWebhook", "u": 85, "d": "Represents an application webhook object on Discord. This is from the interactions flow. Method generated by attrs for class ApplicationWebhook."}, {"r": "hikari.webhooks.ApplicationWebhook.application_id", "u": 85, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.webhooks.ApplicationWebhook.mention", "u": 85, "d": "Return a raw mention string for the given webhook's user. ! note This exists purely for consistency. Webhooks do not receive events from the gateway, and without some bot backend to support it, will not be able to detect mentions of their webhook. Example  \n>>> some_webhook.mention\n'<@123456789123456789>' Returns builtins.str The mention string to use."}, {"r": "hikari.webhooks.ApplicationWebhook.avatar_url", "u": 85, "d": "URL for this webhook's avatar, if set. May be builtins.None if no avatar is set. In this case, you should use default_avatar_url instead."}, {"r": "hikari.webhooks.ApplicationWebhook.default_avatar_url", "u": 85, "d": "Avatar URL for the user, if they have one set. May be builtins.None if no custom avatar is set. In this case, you\nshould use default_avatar_url instead."}, {"r": "hikari.webhooks.ApplicationWebhook.make_avatar_url", "u": 85, "d": "Generate the avatar URL for this webhook's custom avatar if set. If no avatar is specified, return None . In this case, you should\nuse default_avatar instead. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns typing.Optional[hikari.files.URL] The URL of the resource. builtins.None if no avatar is set (in this case, use the default_avatar instead). Raises builtins.ValueError If size is not a power of two between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.webhooks.ApplicationWebhook.app", "u": 85, "d": "The client application that models may use for procedures."}, {"r": "hikari.webhooks.ApplicationWebhook.avatar_hash", "u": 85, "d": "The avatar hash of the webhook."}, {"r": "hikari.webhooks.ApplicationWebhook.id", "u": 85, "d": "The ID of this entity."}, {"r": "hikari.webhooks.ApplicationWebhook.name", "u": 85, "d": "The name of the webhook."}, {"r": "hikari.webhooks.ApplicationWebhook.type", "u": 85, "d": "The type of the webhook."}, {"r": "hikari.webhooks.ApplicationWebhook.created_at", "u": 85, "d": "When the object was created."}, {"r": "hikari.webhooks.ChannelFollowerWebhook", "u": 85, "d": "Represents a channel follower webhook object on Discord. Method generated by attrs for class ChannelFollowerWebhook."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.delete", "u": 85, "d": "Delete this webhook. Raises hikari.errors.NotFoundError If this webhook is not found.\nhikari.errors.ForbiddenError If you either lack the MANAGE_WEBHOOKS permission or are not a member of the guild this webhook belongs to.", "f": 1}, {"r": "hikari.webhooks.ChannelFollowerWebhook.edit", "u": 85, "d": "Edit this webhook. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name string.\navatar : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new avatar image. If builtins.None , then it is removed. If not specified, nothing is changed.\nchannel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT If provided, the object or ID of the new channel the given webhook should be moved to.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the audit log reason explaining why the operation was performed. This field will be used when using the webhook's token rather than bot authorization. Returns hikari.webhooks.ChannelFollowerWebhook The updated webhook object. Raises hikari.errors.BadRequestError If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.NotFoundError If either the webhook or the channel are not found.\nhikari.errors.ForbiddenError If you either lack the MANAGE_WEBHOOKS permission or are not a member of the guild this webhook belongs to.\nhikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.ChannelFollowerWebhook.fetch_channel", "u": 85, "d": "Fetch the channel this webhook is for. Returns hikari.channels.WebhookChannelT The object of the channel this webhook targets. Raises hikari.errors.ForbiddenError If you don't have access to the channel this webhook belongs to.\nhikari.errors.NotFoundError If the channel this message was created in does not exist.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.ChannelFollowerWebhook.fetch_self", "u": 85, "d": "Fetch this webhook. Returns hikari.webhooks.ChannelFollowerWebhook The requested webhook object. Raises hikari.errors.ForbiddenError If you're not in the guild that owns this webhook or lack the MANAGE_WEBHOOKS permission.\nhikari.errors.NotFoundError If the webhook is not found.\nhikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.ChannelFollowerWebhook.author", "u": 85, "d": "The user that created the webhook ! info This will be builtins.None when received within an audit log."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.channel_id", "u": 85, "d": "The channel ID this webhook is for."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.guild_id", "u": 85, "d": "The guild ID of the webhook."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.source_channel", "u": 85, "d": "The partial object of the channel this webhook is following."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.source_guild", "u": 85, "d": "The partial object of the guild this webhook is following."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.mention", "u": 85, "d": "Return a raw mention string for the given webhook's user. ! note This exists purely for consistency. Webhooks do not receive events from the gateway, and without some bot backend to support it, will not be able to detect mentions of their webhook. Example  \n>>> some_webhook.mention\n'<@123456789123456789>' Returns builtins.str The mention string to use."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.avatar_url", "u": 85, "d": "URL for this webhook's avatar, if set. May be builtins.None if no avatar is set. In this case, you should use default_avatar_url instead."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.default_avatar_url", "u": 85, "d": "Avatar URL for the user, if they have one set. May be builtins.None if no custom avatar is set. In this case, you\nshould use default_avatar_url instead."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.make_avatar_url", "u": 85, "d": "Generate the avatar URL for this webhook's custom avatar if set. If no avatar is specified, return None . In this case, you should\nuse default_avatar instead. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns typing.Optional[hikari.files.URL] The URL of the resource. builtins.None if no avatar is set (in this case, use the default_avatar instead). Raises builtins.ValueError If size is not a power of two between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.webhooks.ChannelFollowerWebhook.app", "u": 85, "d": "The client application that models may use for procedures."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.application_id", "u": 85, "d": "The ID of the application that created this webhook."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.avatar_hash", "u": 85, "d": "The avatar hash of the webhook."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.id", "u": 85, "d": "The ID of this entity."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.name", "u": 85, "d": "The name of the webhook."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.type", "u": 85, "d": "The type of the webhook."}, {"r": "hikari.webhooks.ChannelFollowerWebhook.created_at", "u": 85, "d": "When the object was created."}, {"r": "hikari.webhooks.ExecutableWebhook", "u": 85, "d": "An abstract class with logic for executing entities as webhooks."}, {"r": "hikari.webhooks.ExecutableWebhook.app", "u": 85, "d": "Client application that models may use for procedures. Returns hikari.traits.RESTAware The client application that models may use for procedures."}, {"r": "hikari.webhooks.ExecutableWebhook.webhook_id", "u": 85, "d": "ID used to execute this entity as a webhook. Returns hikari.snowflakes.Snowflake The ID used to execute this entity as a webhook."}, {"r": "hikari.webhooks.ExecutableWebhook.token", "u": 85, "d": "Webhook's token. ! info If this is builtins.None then the methods provided by ExecutableWebhook will always raise a builtins.ValueError . Returns typing.Optional[builtins.str] The token for the webhook if known, else builtins.None ."}, {"r": "hikari.webhooks.ExecutableWebhook.execute", "u": 85, "d": "Execute the webhook to create a message. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters username : hikari.undefined.UndefinedOr[builtins.str] If provided, the username to override the webhook's username for this request.\navatar_url : hikari.undefined.UndefinedOr[builtins.str] If provided, the url of an image to override the webhook's avatar with for this request.\ntts : hikari.undefined.UndefinedOr[bool] If provided, whether the message will be sent as a TTS message.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.\nflags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The flags to set for this webhook message. ! warning As of writing this can only be set for interaction webhooks and the only settable flag is EPHEMERAL; this field is just ignored for non-interaction webhooks. ! warning As of writing, username and avatar_url are ignored for interaction webhooks. Returns hikari.messages.Message The created message object. Raises hikari.errors.NotFoundError If the current webhook is not found.\nhikari.errors.BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook.\nbuiltins.ValueError If either ExecutableWebhook.token is builtins.None or more than 100 unique objects/entities are passed for role_mentions or user_mentions or if token is not available.\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.webhooks.ExecutableWebhook.fetch_message", "u": 85, "d": "Fetch an old message sent by the webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found or the webhook's message wasn't found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.ExecutableWebhook.edit_message", "u": 85, "d": "Edit a message sent by a webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message.\ncontent : hikari.undefined.UndefinedNoneOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor no embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all three of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions or token is not available.\nbuiltins.TypeError If both attachment and attachments are specified or if both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.ExecutableWebhook.delete_message", "u": 85, "d": "Delete a given message in a given channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.PartialWebhook", "u": 85, "d": "Base class for all webhook implementations. Method generated by attrs for class PartialWebhook."}, {"r": "hikari.webhooks.PartialWebhook.mention", "u": 85, "d": "Return a raw mention string for the given webhook's user. ! note This exists purely for consistency. Webhooks do not receive events from the gateway, and without some bot backend to support it, will not be able to detect mentions of their webhook. Example  \n>>> some_webhook.mention\n'<@123456789123456789>' Returns builtins.str The mention string to use."}, {"r": "hikari.webhooks.PartialWebhook.avatar_url", "u": 85, "d": "URL for this webhook's avatar, if set. May be builtins.None if no avatar is set. In this case, you should use default_avatar_url instead."}, {"r": "hikari.webhooks.PartialWebhook.default_avatar_url", "u": 85, "d": "Avatar URL for the user, if they have one set. May be builtins.None if no custom avatar is set. In this case, you\nshould use default_avatar_url instead."}, {"r": "hikari.webhooks.PartialWebhook.make_avatar_url", "u": 85, "d": "Generate the avatar URL for this webhook's custom avatar if set. If no avatar is specified, return None . In this case, you should\nuse default_avatar instead. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns typing.Optional[hikari.files.URL] The URL of the resource. builtins.None if no avatar is set (in this case, use the default_avatar instead). Raises builtins.ValueError If size is not a power of two between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.webhooks.PartialWebhook.app", "u": 85, "d": "The client application that models may use for procedures."}, {"r": "hikari.webhooks.PartialWebhook.application_id", "u": 85, "d": "The ID of the application that created this webhook."}, {"r": "hikari.webhooks.PartialWebhook.avatar_hash", "u": 85, "d": "The avatar hash of the webhook."}, {"r": "hikari.webhooks.PartialWebhook.id", "u": 85, "d": "The ID of this entity."}, {"r": "hikari.webhooks.PartialWebhook.name", "u": 85, "d": "The name of the webhook."}, {"r": "hikari.webhooks.PartialWebhook.type", "u": 85, "d": "The type of the webhook."}, {"r": "hikari.webhooks.PartialWebhook.created_at", "u": 85, "d": "When the object was created."}, {"r": "hikari.webhooks.WebhookType", "u": 85, "d": "Types of webhook."}, {"r": "hikari.webhooks.WebhookType.name", "u": 85, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.webhooks.WebhookType.value", "u": 85, "d": "Return the value of the enum member."}, {"r": "hikari.webhooks.WebhookType.INCOMING", "u": 85, "d": "Incoming webhook."}, {"r": "hikari.webhooks.WebhookType.CHANNEL_FOLLOWER", "u": 85, "d": "Channel Follower webhook."}, {"r": "hikari.webhooks.WebhookType.APPLICATION", "u": 85, "d": "Application webhook (from the interactions flow)."}, {"r": "hikari.webhooks.IncomingWebhook", "u": 85, "d": "Represents an incoming webhook object on Discord. This is an endpoint that can have messages sent to it using standard\nHTTP requests, which enables external services that are not bots to\nsend informational messages to specific channels. Method generated by attrs for class IncomingWebhook."}, {"r": "hikari.webhooks.IncomingWebhook.webhook_id", "u": 85, "d": "ID used to execute this entity as a webhook. Returns hikari.snowflakes.Snowflake The ID used to execute this entity as a webhook."}, {"r": "hikari.webhooks.IncomingWebhook.delete", "u": 85, "d": "Delete this webhook. Other Parameters use_token : hikari.undefined.UndefinedOr[builtins.bool] If set to builtins.True then the webhook's token will be used for this request; if set to builtins.False then bot authorization will be used; if not specified then the webhook's token will be used for the request if it's set else bot authorization. Raises hikari.errors.NotFoundError If this webhook is not found.\nhikari.errors.ForbiddenError If you either lack the MANAGE_WEBHOOKS permission or are not a member of the guild this webhook belongs to.\nbuiltins.ValueError If use_token is passed as builtins.True when IncomingWebhook.token is builtins.None .", "f": 1}, {"r": "hikari.webhooks.IncomingWebhook.edit", "u": 85, "d": "Edit this webhook. Other Parameters name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name string.\navatar : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new avatar image. If builtins.None , then it is removed. If not specified, nothing is changed.\nchannel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT If provided, the object or ID of the new channel the given webhook should be moved to.\nreason : hikari.undefined.UndefinedOr[builtins.str] If provided, the audit log reason explaining why the operation was performed. This field will be used when using the webhook's token rather than bot authorization.\nuse_token : hikari.undefined.UndefinedOr[builtins.bool] If set to builtins.True then the webhook's token will be used for this request; if set to builtins.False then bot authorization will be used; if not specified then the webhook's token will be used for the request if it's set else bot authorization. Returns IncomingWebhook The updated webhook object. Raises builtins.ValueError If use_token is passed as builtins.True when IncomingWebhook.token is builtins.None .\nhikari.errors.BadRequestError If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.NotFoundError If either the webhook or the channel are not found.\nhikari.errors.ForbiddenError If you either lack the MANAGE_WEBHOOKS permission or are not a member of the guild this webhook belongs to.\nhikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.IncomingWebhook.fetch_channel", "u": 85, "d": "Fetch the channel this webhook is for. Returns hikari.channels.WebhookChannelT The object of the channel this webhook targets. Raises hikari.errors.ForbiddenError If you don't have access to the channel this webhook belongs to.\nhikari.errors.NotFoundError If the channel this message was created in does not exist.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.IncomingWebhook.fetch_self", "u": 85, "d": "Fetch this webhook. Other Parameters use_token : hikari.undefined.UndefinedOr[builtins.bool] If set to builtins.True then the webhook's token will be used for this request; if set to builtins.False then bot authorization will be used; if not specified then the webhook's token will be used for the request if it's set else bot authorization. Returns IncomingWebhook The requested webhook object. Raises builtins.ValueError If use_token is passed as builtins.True when Webhook.token is builtins.None .\nhikari.errors.ForbiddenError If you're not in the guild that owns this webhook or lack the MANAGE_WEBHOOKS permission.\nhikari.errors.NotFoundError If the webhook is not found.\nhikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.IncomingWebhook.author", "u": 85, "d": "The user that created the webhook ! info This will be builtins.None when fetched with the webhook's token rather than bot authorization or when received within audit logs."}, {"r": "hikari.webhooks.IncomingWebhook.channel_id", "u": 85, "d": "The channel ID this webhook is for."}, {"r": "hikari.webhooks.IncomingWebhook.guild_id", "u": 85, "d": "The guild ID of the webhook."}, {"r": "hikari.webhooks.IncomingWebhook.token", "u": 85, "d": "The token for the webhook. ! info This is only available for incoming webhooks that are created in the channel settings."}, {"r": "hikari.webhooks.IncomingWebhook.mention", "u": 85, "d": "Return a raw mention string for the given webhook's user. ! note This exists purely for consistency. Webhooks do not receive events from the gateway, and without some bot backend to support it, will not be able to detect mentions of their webhook. Example  \n>>> some_webhook.mention\n'<@123456789123456789>' Returns builtins.str The mention string to use."}, {"r": "hikari.webhooks.IncomingWebhook.avatar_url", "u": 85, "d": "URL for this webhook's avatar, if set. May be builtins.None if no avatar is set. In this case, you should use default_avatar_url instead."}, {"r": "hikari.webhooks.IncomingWebhook.default_avatar_url", "u": 85, "d": "Avatar URL for the user, if they have one set. May be builtins.None if no custom avatar is set. In this case, you\nshould use default_avatar_url instead."}, {"r": "hikari.webhooks.IncomingWebhook.make_avatar_url", "u": 85, "d": "Generate the avatar URL for this webhook's custom avatar if set. If no avatar is specified, return None . In this case, you should\nuse default_avatar instead. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns typing.Optional[hikari.files.URL] The URL of the resource. builtins.None if no avatar is set (in this case, use the default_avatar instead). Raises builtins.ValueError If size is not a power of two between 16 and 4096 (inclusive).", "f": 1}, {"r": "hikari.webhooks.IncomingWebhook.app", "u": 85, "d": "The client application that models may use for procedures."}, {"r": "hikari.webhooks.IncomingWebhook.application_id", "u": 85, "d": "The ID of the application that created this webhook."}, {"r": "hikari.webhooks.IncomingWebhook.avatar_hash", "u": 85, "d": "The avatar hash of the webhook."}, {"r": "hikari.webhooks.IncomingWebhook.id", "u": 85, "d": "The ID of this entity."}, {"r": "hikari.webhooks.IncomingWebhook.name", "u": 85, "d": "The name of the webhook."}, {"r": "hikari.webhooks.IncomingWebhook.type", "u": 85, "d": "The type of the webhook."}, {"r": "hikari.webhooks.IncomingWebhook.created_at", "u": 85, "d": "When the object was created."}, {"r": "hikari.webhooks.IncomingWebhook.execute", "u": 85, "d": "Execute the webhook to create a message. Parameters content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters username : hikari.undefined.UndefinedOr[builtins.str] If provided, the username to override the webhook's username for this request.\navatar_url : hikari.undefined.UndefinedOr[builtins.str] If provided, the url of an image to override the webhook's avatar with for this request.\ntts : hikari.undefined.UndefinedOr[bool] If provided, whether the message will be sent as a TTS message.\nattachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.\ncomponent : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to include in this message.\ncomponents : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects to include in this message.\nembed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed.\nembeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, the message embeds.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all mentions will be parsed. If provided, and builtins.False , no mentions will be parsed. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.\nflags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag] The flags to set for this webhook message. ! warning As of writing this can only be set for interaction webhooks and the only settable flag is EPHEMERAL; this field is just ignored for non-interaction webhooks. ! warning As of writing, username and avatar_url are ignored for interaction webhooks. Returns hikari.messages.Message The created message object. Raises hikari.errors.NotFoundError If the current webhook is not found.\nhikari.errors.BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than 2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.\nhikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook.\nbuiltins.ValueError If either ExecutableWebhook.token is builtins.None or more than 100 unique objects/entities are passed for role_mentions or user_mentions or if token is not available.\nbuiltins.TypeError If both attachment and attachments are specified.", "f": 1}, {"r": "hikari.webhooks.IncomingWebhook.fetch_message", "u": 85, "d": "Fetch an old message sent by the webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns hikari.messages.Message The requested message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook is not found or the webhook's message wasn't found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.IncomingWebhook.edit_message", "u": 85, "d": "Edit a message sent by a webhook. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message.\ncontent : hikari.undefined.UndefinedNoneOr[typing.Any] If provided, the message contents. If hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a builtins.str . If this is a hikari.embeds.Embed and no embed nor no embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a hikari.files.Resource , then the content is instead treated as an attachment if no attachment and no attachments kwargs are provided. Other Parameters attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the attachment to set on the message. If hikari.undefined.UNDEFINED , the previous attachment, if present, is not changed. If this is builtins.None , then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.\nattachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the attachments to set on the message. If hikari.undefined.UNDEFINED , the previous attachments, if present, are not changed. If this is builtins.None , then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.\ncomponent : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder] If provided, builder object of the component to set for this message. This component will replace any previously set components and passing builtins.None will remove all components.\ncomponents : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing builtins.None or an empty sequence will remove all components.\nembed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.\nembeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed If provided, the embeds to set on the message. If hikari.undefined.UNDEFINED , the previous embed(s) are not changed. If this is builtins.None then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.\nreplace_attachments: bool Whether to replace the attachments with the provided ones. Defaults to builtins.False . Note this will also overwrite the embed attachments.\nmentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for @everyone mentions. If hikari.undefined.UNDEFINED , then the previous setting is not changed. If builtins.True , then @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat.\nuser_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool If provided, and builtins.True , all user mentions will be detected. If provided, and builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.users.PartialUser derivatives to enforce mentioning specific users.\nrole_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool If provided, and builtins.True , all role mentions will be detected. If provided, and builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of hikari.snowflakes.Snowflake , or hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however. ! warning If you specify a non-embed content , mentions_everyone , mentions_reply , user_mentions , and role_mentions will default to builtins.False as the message will be re-parsed for mentions. This is a limitation of Discord's design. If in doubt, specify all three of them each time. ! warning If you specify one of mentions_everyone , mentions_reply , user_mentions , or role_mentions , then all others will default to builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time. Returns hikari.messages.Message The edited message. Raises builtins.ValueError If more than 100 unique objects/entities are passed for role_mentions or user_mentions or token is not available.\nbuiltins.TypeError If both attachment and attachments are specified or if both embed and embeds are specified.\nhikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; too many components.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.webhooks.IncomingWebhook.delete_message", "u": 85, "d": "Delete a given message in a given channel. Parameters message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises builtins.ValueError If token is not available.\nhikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token).\nhikari.errors.NotFoundError If the webhook or the message are not found.\nhikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than max_rate_limit when making a request.\nhikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.\nhikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.", "f": 1}, {"r": "hikari.stickers", "u": 86, "d": "Application and entities that are used to describe stickers on Discord."}, {"r": "hikari.stickers.StickerType", "u": 86, "d": "The sticker type."}, {"r": "hikari.stickers.StickerType.name", "u": 86, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.stickers.StickerType.value", "u": 86, "d": "Return the value of the enum member."}, {"r": "hikari.stickers.StickerType.STANDARD", "u": 86, "d": "An official sticker in a pack, part of Nitro or in a removed purchasable pack."}, {"r": "hikari.stickers.StickerType.GUILD", "u": 86, "d": "A sticker uploaded to a guild."}, {"r": "hikari.stickers.StickerFormatType", "u": 86, "d": "The formats types of a sticker's asset."}, {"r": "hikari.stickers.StickerFormatType.name", "u": 86, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.stickers.StickerFormatType.value", "u": 86, "d": "Return the value of the enum member."}, {"r": "hikari.stickers.StickerFormatType.PNG", "u": 86, "d": "A PNG sticker."}, {"r": "hikari.stickers.StickerFormatType.APNG", "u": 86, "d": "A animated PNG sticker."}, {"r": "hikari.stickers.StickerFormatType.LOTTIE", "u": 86, "d": "A lottie sticker. More information can be found here: https: airbnb.io/lottie/"}, {"r": "hikari.stickers.PartialSticker", "u": 86, "d": "Represents the partial stickers found attached to messages on Discord. Method generated by attrs for class PartialSticker."}, {"r": "hikari.stickers.PartialSticker.image_url", "u": 86, "d": "URL for the image. The extension will be based on format_type . If format_type is StickerFormatType.LOTTIE ,\nthen the extension will be .json . Otherwise, it will be .png ."}, {"r": "hikari.stickers.PartialSticker.format_type", "u": 86, "d": "The format of this sticker's asset."}, {"r": "hikari.stickers.PartialSticker.id", "u": 86, "d": "The ID of this entity."}, {"r": "hikari.stickers.PartialSticker.name", "u": 86, "d": "The name of the sticker."}, {"r": "hikari.stickers.PartialSticker.created_at", "u": 86, "d": "When the object was created."}, {"r": "hikari.stickers.GuildSticker", "u": 86, "d": "Represents a Discord sticker that belongs to a guild. Method generated by attrs for class GuildSticker."}, {"r": "hikari.stickers.GuildSticker.description", "u": 86, "d": "The description of this sticker."}, {"r": "hikari.stickers.GuildSticker.guild_id", "u": 86, "d": "The guild this sticker belongs to"}, {"r": "hikari.stickers.GuildSticker.is_available", "u": 86, "d": "Whether the sticker can be used."}, {"r": "hikari.stickers.GuildSticker.tag", "u": 86, "d": "This sticker's tag."}, {"r": "hikari.stickers.GuildSticker.type", "u": 86, "d": "The sticker type."}, {"r": "hikari.stickers.GuildSticker.user", "u": 86, "d": "The user that uploaded this sticker. This will only available if you have the MANAGE_EMOJIS_AND_STICKERS permission."}, {"r": "hikari.stickers.GuildSticker.image_url", "u": 86, "d": "URL for the image. The extension will be based on format_type . If format_type is StickerFormatType.LOTTIE ,\nthen the extension will be .json . Otherwise, it will be .png ."}, {"r": "hikari.stickers.GuildSticker.format_type", "u": 86, "d": "The format of this sticker's asset."}, {"r": "hikari.stickers.GuildSticker.id", "u": 86, "d": "The ID of this entity."}, {"r": "hikari.stickers.GuildSticker.name", "u": 86, "d": "The name of the sticker."}, {"r": "hikari.stickers.GuildSticker.created_at", "u": 86, "d": "When the object was created."}, {"r": "hikari.stickers.StandardSticker", "u": 86, "d": "Represents a standard Discord sticker that belongs to a pack. Method generated by attrs for class StandardSticker."}, {"r": "hikari.stickers.StandardSticker.description", "u": 86, "d": "The description of this sticker."}, {"r": "hikari.stickers.StandardSticker.pack_id", "u": 86, "d": "ID of the package this sticker belongs to."}, {"r": "hikari.stickers.StandardSticker.sort_value", "u": 86, "d": "The sort value for the sticker in its pack."}, {"r": "hikari.stickers.StandardSticker.tags", "u": 86, "d": "A sequence of this sticker's tags."}, {"r": "hikari.stickers.StandardSticker.type", "u": 86, "d": "The sticker type."}, {"r": "hikari.stickers.StandardSticker.image_url", "u": 86, "d": "URL for the image. The extension will be based on format_type . If format_type is StickerFormatType.LOTTIE ,\nthen the extension will be .json . Otherwise, it will be .png ."}, {"r": "hikari.stickers.StandardSticker.format_type", "u": 86, "d": "The format of this sticker's asset."}, {"r": "hikari.stickers.StandardSticker.id", "u": 86, "d": "The ID of this entity."}, {"r": "hikari.stickers.StandardSticker.name", "u": 86, "d": "The name of the sticker."}, {"r": "hikari.stickers.StandardSticker.created_at", "u": 86, "d": "When the object was created."}, {"r": "hikari.stickers.StickerPack", "u": 86, "d": "Represents a sticker pack on Discord. Method generated by attrs for class StickerPack."}, {"r": "hikari.stickers.StickerPack.banner_url", "u": 86, "d": "Banner URL for the pack."}, {"r": "hikari.stickers.StickerPack.make_banner_url", "u": 86, "d": "Generate the pack's banner image URL. Parameters ext : builtins.str The extension to use for this URL, defaults to png . Supports png , jpeg , jpg and webp .\nsize : builtins.int The size to set for the URL, defaults to 4096 . Can be any power of two between 16 and 4096. Returns hikari.files.URL The URL of the banner. Raises builtins.ValueError If size is not a power of two or not between 16 and 4096.", "f": 1}, {"r": "hikari.stickers.StickerPack.banner_hash", "u": 86, "d": "The hash for the pack's banner."}, {"r": "hikari.stickers.StickerPack.cover_sticker_id", "u": 86, "d": "The ID of a sticker in the pack which is shown as the pack's icon"}, {"r": "hikari.stickers.StickerPack.description", "u": 86, "d": "The description of the pack."}, {"r": "hikari.stickers.StickerPack.id", "u": 86, "d": "The ID of this entity."}, {"r": "hikari.stickers.StickerPack.name", "u": 86, "d": "The name of the pack."}, {"r": "hikari.stickers.StickerPack.sku_id", "u": 86, "d": "The ID of the packs SKU."}, {"r": "hikari.stickers.StickerPack.stickers", "u": 86, "d": "The stickers that belong to this pack."}, {"r": "hikari.stickers.StickerPack.created_at", "u": 86, "d": "When the object was created."}, {"r": "hikari.undefined", "u": 87, "d": "Singleton used throughout the library to denote values that are not present."}, {"r": "hikari.undefined.UNDEFINED", "u": 87, "d": "A sentinel singleton that denotes a missing or omitted value."}, {"r": "hikari.undefined.UndefinedNoneOr", "u": 87, "d": "Type hint for a value that may be undefined.UNDEFINED , or builtins.None . UndefinedNoneOr[T] is simply an alias for UndefinedOr[typing.Optional[T  , which would expand to typing.Union[UndefinedType, T, None] ."}, {"r": "hikari.undefined.UndefinedOr", "u": 87, "d": "Type hint to mark a type as being semantically optional. NOTE THAT THIS IS NOT THE SAME AS typing.Optional BY DEFINITION . If you see a type with this marker, it may be UNDEFINED or the value it wraps.\nFor example, UndefinedOr[float] would mean the value could be a builtins.float , or the literal UNDEFINED value. On the other hand, typing.Optional[float] would mean the value could be\na builtins.float , or the literal builtins.None value. The reason for using this is in some places, there is a semantic difference\nbetween specifying something as being builtins.None , i.e. \"no value\", and\nhaving a default to specify that the value has just not been mentioned. The\nmain example of this is in edit endpoints where the contents will only be\nchanged if they are explicitly mentioned in the call. Editing a message content\nand setting it to builtins.None would be expected to clear the content,\nwhereas setting it to UNDEFINED would be expected to leave the value as it\nis without changing it. Consider UndefinedOr[T] semantically equivalent to undefined versus null in JavaScript, or Optional<T> versus null in Java and C . If in doubt, remember: - UNDEFINED means there is no value present, or that it has been left to the default value.\n- builtins.None means the value is present and explicitly empty/null/void, where this has a deterministic documented behaviour and no differentiation is made between a builtins.None value, and one that has been omitted."}, {"r": "hikari.undefined.UndefinedType", "u": 87, "d": "The type of the UNDEFINED singleton sentinel value."}, {"r": "hikari.undefined.all_undefined", "u": 87, "d": "Get if all of the provided items are UNDEFINED .", "f": 1}, {"r": "hikari.undefined.any_undefined", "u": 87, "d": "Get if any of the provided items are UNDEFINED .", "f": 1}, {"r": "hikari.undefined.count", "u": 87, "d": "Count the number of items that are provided that are UNDEFINED .", "f": 1}, {"r": "hikari.errors", "u": 88, "d": "Exceptions and warnings that can be thrown by this library."}, {"r": "hikari.errors.HikariError", "u": 88, "d": "Base for an error raised by this API. Any exceptions should derive from this. ! note You should never initialize this exception directly."}, {"r": "hikari.errors.HikariWarning", "u": 88, "d": "Base for a warning raised by this API. Any warnings should derive from this. ! note You should never initialize this warning directly."}, {"r": "hikari.errors.HikariInterrupt", "u": 88, "d": "Exception raised when a kill signal is handled internally. Method generated by attrs for class HikariInterrupt."}, {"r": "hikari.errors.HikariInterrupt.signame", "u": 88, "d": "The signal name that was raised."}, {"r": "hikari.errors.HikariInterrupt.signum", "u": 88, "d": "The signal number that was raised."}, {"r": "hikari.errors.ComponentStateConflictError", "u": 88, "d": "Exception thrown when an action cannot be executed in the component's current state. Dependent on context this will be thrown for components which are already\nrunning or haven't been started yet. Method generated by attrs for class ComponentStateConflictError."}, {"r": "hikari.errors.ComponentStateConflictError.reason", "u": 88, "d": "A string to explain the issue."}, {"r": "hikari.errors.UnrecognisedEntityError", "u": 88, "d": "An exception thrown when an unrecognised entity is found. Method generated by attrs for class UnrecognisedEntityError."}, {"r": "hikari.errors.UnrecognisedEntityError.reason", "u": 88, "d": "A string to explain the issue."}, {"r": "hikari.errors.NotFoundError", "u": 88, "d": "Raised when something is not found. Method generated by attrs for class NotFoundError."}, {"r": "hikari.errors.NotFoundError.status", "u": 88, "d": "The HTTP status code for the response."}, {"r": "hikari.errors.NotFoundError.url", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.NotFoundError.headers", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.NotFoundError.raw_body", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.NotFoundError.message", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.NotFoundError.code", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.RateLimitedError", "u": 88, "d": "Raised when a non-global rate limit that cannot be handled occurs. If you receive one of these, you should NOT try again until the given\ntime has passed, either discarding the operation you performed, or waiting\nuntil the given time has passed first. Note that it may still be valid to\nsend requests with different attributes in them. A use case for this by Discord appears to be to stop abuse from bots that\nchange channel names, etc, regularly. This kind of action allegedly causes\na fair amount of overhead internally for Discord. In the case you encounter\nthis, you may be able to send different requests that manipulate the same\nentities (in this case editing the same channel) that do not use the same\ncollection of attributes as the previous request. Method generated by attrs for class RateLimitedError."}, {"r": "hikari.errors.RateLimitedError.status", "u": 88, "d": "The HTTP status code for the response."}, {"r": "hikari.errors.RateLimitedError.message", "u": 88, "d": "The error message."}, {"r": "hikari.errors.RateLimitedError.retry_after", "u": 88, "d": "How many seconds to wait before you can reuse the route with the specific request."}, {"r": "hikari.errors.RateLimitedError.route", "u": 88, "d": "The route that produced this error."}, {"r": "hikari.errors.RateLimitedError.url", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.RateLimitedError.headers", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.RateLimitedError.raw_body", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.RateLimitedError.code", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.RateLimitTooLongError", "u": 88, "d": "Internal error raised if the wait for a rate limit is too long. This is similar to asyncio.TimeoutError in the way that it is used,\nbut this will be raised pre-emptively and immediately if the period\nof time needed to wait is greater than a user-defined limit. This will almost always be route-specific. If you receive this, it is\nunlikely that performing the same call for a different channel/guild/user\nwill also have this rate limit. Method generated by attrs for class RateLimitTooLongError."}, {"r": "hikari.errors.RateLimitTooLongError.remaining", "u": 88, "d": "The number of requests remaining in this window. This will always be 0 symbolically. Returns builtins.int The number of requests remaining. Always 0 ."}, {"r": "hikari.errors.RateLimitTooLongError.message", "u": 88, "d": "The error message."}, {"r": "hikari.errors.RateLimitTooLongError.limit", "u": 88, "d": "The maximum number of calls per window for this rate limit."}, {"r": "hikari.errors.RateLimitTooLongError.max_retry_after", "u": 88, "d": "How long the client is allowed to wait for at a maximum before raising."}, {"r": "hikari.errors.RateLimitTooLongError.period", "u": 88, "d": "How long the rate limit window lasts for from start to end."}, {"r": "hikari.errors.RateLimitTooLongError.reset_at", "u": 88, "d": "UNIX timestamp of when this limit will be lifted."}, {"r": "hikari.errors.RateLimitTooLongError.retry_after", "u": 88, "d": "How many seconds to wait before you can retry this specific request."}, {"r": "hikari.errors.RateLimitTooLongError.route", "u": 88, "d": "The route that produced this error."}, {"r": "hikari.errors.UnauthorizedError", "u": 88, "d": "Raised when you are not authorized to access a specific resource. Method generated by attrs for class UnauthorizedError."}, {"r": "hikari.errors.UnauthorizedError.status", "u": 88, "d": "The HTTP status code for the response."}, {"r": "hikari.errors.UnauthorizedError.url", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.UnauthorizedError.headers", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.UnauthorizedError.raw_body", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.UnauthorizedError.message", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.UnauthorizedError.code", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ForbiddenError", "u": 88, "d": "Raised when you are not allowed to access a specific resource. This means you lack the permissions to do something, either because of\npermissions set in a guild, or because your application is not whitelisted\nto use a specific endpoint. Method generated by attrs for class ForbiddenError."}, {"r": "hikari.errors.ForbiddenError.status", "u": 88, "d": "The HTTP status code for the response."}, {"r": "hikari.errors.ForbiddenError.url", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ForbiddenError.headers", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ForbiddenError.raw_body", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ForbiddenError.message", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ForbiddenError.code", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.BadRequestError", "u": 88, "d": "Raised when you send an invalid request somehow. Method generated by attrs for class BadRequestError."}, {"r": "hikari.errors.BadRequestError.status", "u": 88, "d": "The HTTP status code for the response."}, {"r": "hikari.errors.BadRequestError.errors", "u": 88, "d": "Dict of top level field names to field specific error paths. For more information, this error format is loosely defined at\nhttps: discord.com/developers/docs/reference error-messages and is commonly\nreturned for 50035 errors."}, {"r": "hikari.errors.BadRequestError.url", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.BadRequestError.headers", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.BadRequestError.raw_body", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.BadRequestError.message", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.BadRequestError.code", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.RESTErrorCode", "u": 88, "d": "Non-exhaustive enum of error codes provided as further info on errors returned by the REST API."}, {"r": "hikari.errors.RESTErrorCode.name", "u": 88, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.errors.RESTErrorCode.value", "u": 88, "d": "Return the value of the enum member."}, {"r": "hikari.errors.RESTErrorCode.GENERAL_ERROR", "u": 88, "d": "A general error, no further info provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_APPLICATION", "u": 88, "d": "Unknown application provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_CHANNEL", "u": 88, "d": "Unknown channel provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_GUILD", "u": 88, "d": "Unknown guild provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_INTEGRATION", "u": 88, "d": "Unknown integration provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_INVITE", "u": 88, "d": "Unknown invite provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_MEMBER", "u": 88, "d": "Unknown member provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_MESSAGE", "u": 88, "d": "Unknown message provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_PERMISSION_OVERWRITE", "u": 88, "d": "Unknown permission overwrite provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_ROLE", "u": 88, "d": "Unknown role provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_USER", "u": 88, "d": "Unknown user provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_EMOJI", "u": 88, "d": "Unknown emoji provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_WEBHOOK", "u": 88, "d": "Unknown webhook provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_BAN", "u": 88, "d": "Unknown ban provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_GUILD_TEMPLATE", "u": 88, "d": "Unknown guild template provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_STICKER", "u": 88, "d": "Unknown sticker provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_INTERACTION", "u": 88, "d": "Unknown interaction provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_APPLICATION_COMMAND", "u": 88, "d": "Unknown application command provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_APPLICATION_COMMAND_PERMISSIONS", "u": 88, "d": "Unknown application command permissions provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_STAGE_INSTANCE", "u": 88, "d": "Unknown stage instance provided."}, {"r": "hikari.errors.RESTErrorCode.UNKNOWN_GUILD_WELCOME_SCREEN", "u": 88, "d": "Unknown guild welcome screen provided."}, {"r": "hikari.errors.RESTErrorCode.EXPLICIT_CONTENT_BLOCKED", "u": 88, "d": "Explicit content cannot be sent to the desired recipient(s)."}, {"r": "hikari.errors.RESTErrorCode.ANNOUNCEMENT_LIMIT_HIT", "u": 88, "d": "Message can not be edited due to announcement rate limits."}, {"r": "hikari.errors.RESTErrorCode.WRITE_LIMIT_HIT", "u": 88, "d": "The global write limit on a channel has been hit."}, {"r": "hikari.errors.RESTErrorCode.DISALLOWED_WORDS_FOR_PUBLIC_STAGES", "u": 88, "d": "The guild contains disallowed words for public stages. This may include guild name, guild description or channel names."}, {"r": "hikari.errors.RESTErrorCode.GUILD_PREMIUM_LEVEL_TOO_LOW", "u": 88, "d": "The guilds premium level is too low."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_GUILDS", "u": 88, "d": "Maximum number of guilds reached (100)."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_PINS", "u": 88, "d": "Maximum number of pins reached for the channel (50)."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_RECIPIENTS", "u": 88, "d": "Maximum number of recipients reached (10)."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_ROLES", "u": 88, "d": "Maximum number of guild roles reached (250)."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_WEBHOOKS", "u": 88, "d": "Maximum number of webhooks in a channel reached (10)."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_EMOJIS", "u": 88, "d": "Maximum number of emojis reached."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_REACTIONS", "u": 88, "d": "Maximum number of reactions on a message reached (20)."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_CHANNELS", "u": 88, "d": "Maximum number of guild channels reached (500)."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_INVITES", "u": 88, "d": "Maximum number of invites reached (1000)."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_ANIMATED_EMOJIS", "u": 88, "d": "Maximum number of animated emojis reached."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_NUMBER_OF_GUILD_MEMBERS_REACHED", "u": 88, "d": "Maximum number of guild members reached."}, {"r": "hikari.errors.RESTErrorCode.GUILD_ALREADY_HAS_TEMPLATE", "u": 88, "d": "Guild already has a template."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_NUMBER_OF_THREAD_PARTICIPANTS_REACHED", "u": 88, "d": "Maximum number of thread participants reached."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_BANS_FOR_NON_GUILD_MEMBERS", "u": 88, "d": "Maximum number of bans for non-guild members reached."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_NUMBER_OF_STICKERS_REACHED", "u": 88, "d": "Maximum number of stickers reached."}, {"r": "hikari.errors.RESTErrorCode.MAXIMUM_PRUNE_REQUESTS_REACHED", "u": 88, "d": "Maximum number of prune requests has been reached. Try again later."}, {"r": "hikari.errors.RESTErrorCode.REQUEST_TOO_LARGE", "u": 88, "d": "Request too large. Try sending something smaller in size."}, {"r": "hikari.errors.RESTErrorCode.TEMPORARILY_DISABLED", "u": 88, "d": "This feature has been temporarily disabled server-side."}, {"r": "hikari.errors.RESTErrorCode.USER_BANNED", "u": 88, "d": "The user is banned from this guild."}, {"r": "hikari.errors.RESTErrorCode.ALREADY_CROSSPOSTED", "u": 88, "d": "This message has already been crossposted."}, {"r": "hikari.errors.RESTErrorCode.APPLICATION_COMMAND_ALREADY_EXISTS", "u": 88, "d": "An application command with that name already exists."}, {"r": "hikari.errors.RESTErrorCode.INVALID_ACCOUNT_TYPE", "u": 88, "d": "Invalid account type."}, {"r": "hikari.errors.RESTErrorCode.PROHIBITED_ON_DM", "u": 88, "d": "Cannot execute action on a DM channel."}, {"r": "hikari.errors.RESTErrorCode.GUILD_WIDGET_DISABLED", "u": 88, "d": "Guild widget disabled."}, {"r": "hikari.errors.RESTErrorCode.NOT_MESSAGE_AUTHOR", "u": 88, "d": "Cannot edit a message created by another user."}, {"r": "hikari.errors.RESTErrorCode.EMPTY_MESSAGE", "u": 88, "d": "Cannot send an empty message."}, {"r": "hikari.errors.RESTErrorCode.USER_DM_CLOSED", "u": 88, "d": "Cannot send messages to this user."}, {"r": "hikari.errors.RESTErrorCode.MESSAGE_IN_VC", "u": 88, "d": "Cannot send messages in a voice channel."}, {"r": "hikari.errors.RESTErrorCode.PINS_ONLY_ON_ORIGIN_CHANNEL", "u": 88, "d": "A message can only be pinned to the channel it was sent in."}, {"r": "hikari.errors.RESTErrorCode.INVALID_INVITE_CODE", "u": 88, "d": "Invite code was either invalid or taken."}, {"r": "hikari.errors.RESTErrorCode.PROHIBITED_ON_SYSTEM_MESSAGE", "u": 88, "d": "Cannot execute action on a system message."}, {"r": "hikari.errors.RESTErrorCode.PROHIBITED_ON_CHANNEL_TYPE", "u": 88, "d": "Cannot execute action on this channel type."}, {"r": "hikari.errors.RESTErrorCode.INVALID_OAUTH2_TOKEN", "u": 88, "d": "Invalid OAuth2 access token provided."}, {"r": "hikari.errors.RESTErrorCode.MISSING_REQUIRED_OAUTH2_SCOPE", "u": 88, "d": "Missing required OAuth2 scope."}, {"r": "hikari.errors.RESTErrorCode.INVALID_ROLE", "u": 88, "d": "Invalid role."}, {"r": "hikari.errors.RESTErrorCode.INVALID_RECIPIENTS", "u": 88, "d": "Invalid recipients."}, {"r": "hikari.errors.RESTErrorCode.MESSAGE_TOO_OLD", "u": 88, "d": "A message provided was too old to bulk delete."}, {"r": "hikari.errors.RESTErrorCode.REQUIRED_CHANNEL", "u": 88, "d": "Cannot delete a channel required for community guilds."}, {"r": "hikari.errors.RESTErrorCode.NO_USERS_WITH_TAG", "u": 88, "d": "No users with this tag exist."}, {"r": "hikari.errors.RESTErrorCode.REACTION_BLOCKED", "u": 88, "d": "The reaction was blocked."}, {"r": "hikari.errors.RESTErrorCode.TWO_FACTOR_AUTHENTICATION_REQUIRED", "u": 88, "d": "2FA is required to use this endpoint."}, {"r": "hikari.errors.RESTErrorCode.SYSTEM_OVERLOADED", "u": 88, "d": "API resource is currently overloaded. Try again a little later."}, {"r": "hikari.errors.RESTErrorCode.STAGE_ALREADY_OPEN", "u": 88, "d": "The stage channel is already open."}, {"r": "hikari.errors.HTTPError", "u": 88, "d": "Base exception raised if an HTTP error occurs while making a request. Method generated by attrs for class HTTPError."}, {"r": "hikari.errors.HTTPError.message", "u": 88, "d": "The error message."}, {"r": "hikari.errors.HTTPResponseError", "u": 88, "d": "Base exception for an erroneous HTTP response. Method generated by attrs for class HTTPResponseError."}, {"r": "hikari.errors.HTTPResponseError.message", "u": 88, "d": "The error message."}, {"r": "hikari.errors.HTTPResponseError.code", "u": 88, "d": "The error code."}, {"r": "hikari.errors.HTTPResponseError.headers", "u": 88, "d": "The headers received in the error response."}, {"r": "hikari.errors.HTTPResponseError.raw_body", "u": 88, "d": "The response body."}, {"r": "hikari.errors.HTTPResponseError.status", "u": 88, "d": "The HTTP status code for the response."}, {"r": "hikari.errors.HTTPResponseError.url", "u": 88, "d": "The URL that produced this error message."}, {"r": "hikari.errors.ClientHTTPResponseError", "u": 88, "d": "Base exception for an erroneous HTTP response that is a client error. All exceptions derived from this base should be treated as 4xx client\nerrors when encountered. Method generated by attrs for class ClientHTTPResponseError."}, {"r": "hikari.errors.ClientHTTPResponseError.url", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ClientHTTPResponseError.status", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ClientHTTPResponseError.headers", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ClientHTTPResponseError.raw_body", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ClientHTTPResponseError.message", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ClientHTTPResponseError.code", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.InternalServerError", "u": 88, "d": "Base exception for an erroneous HTTP response that is a server error. All exceptions derived from this base should be treated as 5xx server\nerrors when encountered. If you get one of these, it is not your fault! Method generated by attrs for class InternalServerError."}, {"r": "hikari.errors.InternalServerError.url", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.InternalServerError.status", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.InternalServerError.headers", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.InternalServerError.raw_body", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.InternalServerError.message", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.InternalServerError.code", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.ShardCloseCode", "u": 88, "d": "Reasons for a shard connection closure."}, {"r": "hikari.errors.ShardCloseCode.name", "u": 88, "d": "Return the name of the enum member as a builtins.str ."}, {"r": "hikari.errors.ShardCloseCode.value", "u": 88, "d": "Return the value of the enum member."}, {"r": "hikari.errors.ShardCloseCode.is_standard", "u": 88, "d": "Return builtins.True if this is a standard code."}, {"r": "hikari.errors.ShardCloseCode.NORMAL_CLOSURE", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.GOING_AWAY", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.PROTOCOL_ERROR", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.TYPE_ERROR", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.ENCODING_ERROR", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.POLICY_VIOLATION", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.TOO_BIG", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.UNEXPECTED_CONDITION", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.UNKNOWN_ERROR", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.UNKNOWN_OPCODE", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.DECODE_ERROR", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.NOT_AUTHENTICATED", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.AUTHENTICATION_FAILED", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.ALREADY_AUTHENTICATED", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.INVALID_SEQ", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.RATE_LIMITED", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.SESSION_TIMEOUT", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.INVALID_SHARD", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.SHARDING_REQUIRED", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.INVALID_VERSION", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.INVALID_INTENT", "u": 88, "d": ""}, {"r": "hikari.errors.ShardCloseCode.DISALLOWED_INTENT", "u": 88, "d": ""}, {"r": "hikari.errors.GatewayConnectionError", "u": 88, "d": "An exception thrown if a connection issue occurs. Method generated by attrs for class GatewayConnectionError."}, {"r": "hikari.errors.GatewayConnectionError.reason", "u": 88, "d": "Return an attribute of instance, which is of type owner."}, {"r": "hikari.errors.GatewayServerClosedConnectionError", "u": 88, "d": "An exception raised when the server closes the connection. Method generated by attrs for class GatewayServerClosedConnectionError."}, {"r": "hikari.errors.GatewayServerClosedConnectionError.can_reconnect", "u": 88, "d": "Return builtins.True if we can recover from this closure. If builtins.True , it will try to reconnect after this is raised rather\nthan it being propagated to the caller. If builtins.False , this will\nbe raised, thus stopping the application unless handled explicitly by the\nuser. Returns builtins.bool Whether the closure can be recovered from via a reconnect."}, {"r": "hikari.errors.GatewayServerClosedConnectionError.code", "u": 88, "d": "Return the close code that was received, if there is one. Returns typing.Union[ShardCloseCode, builtins.int, builtins.None] The shard close code if there was one. Will be a ShardCloseCode if the definition is known. Undocumented close codes may instead be an builtins.int instead. If no close code was received, this will be builtins.None ."}, {"r": "hikari.errors.GatewayServerClosedConnectionError.reason", "u": 88, "d": "A string to explain the issue."}, {"r": "hikari.errors.GatewayError", "u": 88, "d": "A base exception type for anything that can be thrown by the Gateway. Method generated by attrs for class GatewayError."}, {"r": "hikari.errors.GatewayError.reason", "u": 88, "d": "A string to explain the issue."}, {"r": "hikari.errors.MissingIntentWarning", "u": 88, "d": "Warning raised when subscribing to an event that cannot be fired. This is caused by your application missing certain intents."}, {"r": "hikari.errors.MissingIntentError", "u": 88, "d": "Error raised when you try to perform an action without an intent. This is usually raised when querying the cache for something that is\nunavailable due to certain intents being disabled. Method generated by attrs for class MissingIntentError."}, {"r": "hikari.errors.MissingIntentError.intents", "u": 88, "d": "The combination of intents that are missing."}, {"r": "hikari.errors.BulkDeleteError", "u": 88, "d": "Exception raised when a bulk delete fails midway through a call. This will contain the list of message items that failed to be deleted,\nand will have a cause containing the initial exception. Method generated by attrs for class BulkDeleteError."}, {"r": "hikari.errors.BulkDeleteError.percentage_completion", "u": 88, "d": "Return the percentage completion of the bulk delete before it failed. Returns builtins.float A percentage completion between 0 and 100 inclusive."}, {"r": "hikari.errors.BulkDeleteError.messages_deleted", "u": 88, "d": "Any message objects that were deleted before an exception occurred."}, {"r": "hikari.errors.BulkDeleteError.messages_skipped", "u": 88, "d": "Any message objects that were skipped due to an exception."}, {"r": "hikari.errors.VoiceError", "u": 88, "d": "Error raised when a problem occurs with the voice subsystem."}]}