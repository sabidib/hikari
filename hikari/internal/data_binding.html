<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.internal.data_binding API documentation</title>
<meta name="description" content="Data binding utilities.">
<meta property="og:title" content="hikari.internal.data_binding module list">
<meta property="og:type" content="website">
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png">
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions">
<meta property="theme-color" content="#ff029a">
<link rel="shortcut icon" type="image/png" href="../../logo.png">
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
text-indent: 100%;
white-space: nowrap;
overflow: hidden;
}
small.smaller {
font-size: 0.50em;
}
html {
height: 100%;
scroll-behavior: smooth;
scrollbar-color: #202324 #454a4d;
}
body {
background-color: #181A1B;
color: #C9C5C0;
height: fit-content;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.container > li {
margin-left: 1em;
margin-top: 2.5em;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
.anchor:target {
background-color: var(--dark);
}
@media screen and (max-width: 990px) {
.anchor:target {
margin-left: -2em;
padding-left: 2em;
}
}
@media screen and (min-width: 990px) {
.anchor:target {
border-radius: 0.5em; !important
margin-right: -2em;
padding-right: 2em;
margin-top: -1em;
padding-top: 1em;
}
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="../../logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small class="smaller">2.0.0.dev102</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
<li class="nav-item"><a class="nav-link active" href="../../hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" action="../../hikari/search.html">
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search" name="q"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.internal -- Package containing internal utilities used within this API." href="index.html"
>internal</a></li>
<li class="breadcrumb-item active"><a href="#">data_binding</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Data binding utilities.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="Headers -- Type hint for HTTP headers." href="#hikari.internal.data_binding.Headers"
>Headers</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="JSONArray -- Type hint for a JSON-decoded array representation as a sequence." href="#hikari.internal.data_binding.JSONArray"
>JSONArray</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="JSONObject -- Type hint for a JSON-decoded object representation as a mapping." href="#hikari.internal.data_binding.JSONObject"
>JSONObject</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="JSONish -- Type hint for any valid JSON-decoded type." href="#hikari.internal.data_binding.JSONish"
>JSONish</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="Query -- Type hint for HTTP query string." href="#hikari.internal.data_binding.Query"
>Query</a></li>
</ul>
<ul class="list-unstyled text-truncate">
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="dump_json -- Serialize ``obj`` to a JSON formatted ``str`` …" href="#hikari.internal.data_binding.dump_json"
>dump_json</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="load_json -- Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
containing a JSON document) to a Python object …" href="#hikari.internal.data_binding.load_json"
>load_json</a></li>
</ul>
<ul class="list-unstyled text-truncate">
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="URLEncodedForm -- Helper class for multipart/form-data and
application/x-www-form-urlencoded body generation." href="#hikari.internal.data_binding.FormData"
>URLEncodedForm</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="add_field -- " href="#hikari.internal.data_binding.FormData.add_field"
>add_field</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="add_fields -- " href="#hikari.internal.data_binding.FormData.add_fields"
>add_fields</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_multipart -- " href="#hikari.internal.data_binding.FormData.is_multipart"
>is_multipart</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python Exception that can be raised and caught.'>exception</abbr></em></small> <a title="JSONDecodeError -- Subclass of ValueError with the following additional properties: …" href="#hikari.internal.data_binding.JSONDecodeError"
>JSONDecodeError</a>
<ul class="list-unstyled nested text-truncate">
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="JSONObjectBuilder -- Helper class used to quickly build JSON objects from various values …" href="#hikari.internal.data_binding.JSONObjectBuilder"
>JSONObjectBuilder</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="put -- Put a JSON value …" href="#hikari.internal.data_binding.JSONObjectBuilder.put"
>put</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="put_array -- Put a JSON array …" href="#hikari.internal.data_binding.JSONObjectBuilder.put_array"
>put_array</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="put_snowflake -- Put a key with a snowflake value into the builder …" href="#hikari.internal.data_binding.JSONObjectBuilder.put_snowflake"
>put_snowflake</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="put_snowflake_array -- Put an array of snowflakes with the given key into this builder …" href="#hikari.internal.data_binding.JSONObjectBuilder.put_snowflake_array"
>put_snowflake_array</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/internal/data_binding.py#L1-L362" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
# Copyright (c) 2021 davfsa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Data binding utilities.&#34;&#34;&#34;
from __future__ import annotations

__all__: typing.List[str] = [
    &#34;Headers&#34;,
    &#34;Query&#34;,
    &#34;JSONObject&#34;,
    &#34;JSONArray&#34;,
    &#34;JSONish&#34;,
    &#34;URLEncodedForm&#34;,
    &#34;dump_json&#34;,
    &#34;load_json&#34;,
    &#34;JSONDecodeError&#34;,
    &#34;JSONObjectBuilder&#34;,
]

import typing

import aiohttp
import multidict

from hikari import snowflakes
from hikari import undefined

if typing.TYPE_CHECKING:
    T = typing.TypeVar(&#34;T&#34;, covariant=True)

Headers = typing.Mapping[str, str]
&#34;&#34;&#34;Type hint for HTTP headers.&#34;&#34;&#34;

Query = typing.Union[typing.Dict[str, str], multidict.MultiDict[str]]
&#34;&#34;&#34;Type hint for HTTP query string.&#34;&#34;&#34;

URLEncodedForm = aiohttp.FormData
&#34;&#34;&#34;Type hint for content of type application/x-www-form-encoded.&#34;&#34;&#34;

# MyPy does not support recursive types yet. This has been ongoing for a long time, unfortunately.
# See https://github.com/python/typing/issues/182

JSONObject = typing.Dict[str, typing.Any]
&#34;&#34;&#34;Type hint for a JSON-decoded object representation as a mapping.&#34;&#34;&#34;

JSONArray = typing.List[typing.Any]
&#34;&#34;&#34;Type hint for a JSON-decoded array representation as a sequence.&#34;&#34;&#34;

JSONish = typing.Union[str, int, float, bool, None, JSONArray, JSONObject]
&#34;&#34;&#34;Type hint for any valid JSON-decoded type.&#34;&#34;&#34;

Stringish = typing.Union[str, int, bool, undefined.UndefinedType, None, snowflakes.Unique]
&#34;&#34;&#34;Type hint for any valid that can be put in a StringMapBuilder&#34;&#34;&#34;

_StringMapBuilderArg = typing.Union[
    typing.Mapping[str, str],
    typing.Dict[str, str],
    multidict.MultiMapping[str],
    typing.Iterable[typing.Tuple[str, str]],
]

if typing.TYPE_CHECKING:
    JSONDecodeError: typing.Type[Exception] = Exception
    &#34;&#34;&#34;Exception raised when loading an invalid JSON string&#34;&#34;&#34;

    def dump_json(_: typing.Union[JSONArray, JSONObject], /, *, indent: int = ...) -&gt; str:
        &#34;&#34;&#34;Convert a Python type to a JSON string.&#34;&#34;&#34;

    def load_json(_: typing.AnyStr, /) -&gt; typing.Union[JSONArray, JSONObject]:
        &#34;&#34;&#34;Convert a JSON string to a Python type.&#34;&#34;&#34;


else:
    import json

    dump_json = json.dumps
    &#34;&#34;&#34;Convert a Python type to a JSON string.&#34;&#34;&#34;

    load_json = json.loads
    &#34;&#34;&#34;Convert a JSON string to a Python type.&#34;&#34;&#34;

    JSONDecodeError = json.JSONDecodeError
    &#34;&#34;&#34;Exception raised when loading an invalid JSON string&#34;&#34;&#34;


@typing.final
class StringMapBuilder(multidict.MultiDict[str]):
    &#34;&#34;&#34;Helper class used to quickly build query strings or header maps.

    This will consume any items that are not `hikari.undefined.UNDEFINED`.
    If a value _is_ unspecified, it will be ignored when inserting it. This reduces
    the amount of boilerplate needed for generating the headers and query strings for
    low-level HTTP API interaction, amongst other things.

    !!! warning
        Because this subclasses `builtins.dict`, you should not use the
        index operator to set items on this object. Doing so will skip any
        form of validation on the type. Use the `put*` methods instead.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def __init__(self, arg: _StringMapBuilderArg = (), **kwargs: str) -&gt; None:
        # We have to allow arguments to be passed to the init here otherwise the inherited copy behaviour from
        # multidict.MultiDict fails.
        super().__init__(arg, **kwargs)

    @typing.overload
    def put(
        self,
        key: str,
        value: Stringish,
        /,
    ) -&gt; None:
        ...

    @typing.overload
    def put(
        self,
        key: str,
        value: undefined.UndefinedOr[T],
        /,
        *,
        conversion: typing.Callable[[T], Stringish],
    ) -&gt; None:
        ...

    def put(
        self,
        key: str,
        value: undefined.UndefinedOr[typing.Any],
        /,
        *,
        conversion: typing.Optional[typing.Callable[[typing.Any], typing.Any]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add a key and value to the string map.

        Parameters
        ----------
        key : builtins.str
            The string key.
        value : hikari.undefined.UndefinedOr[typing.Any]
            The value to set.

        Other Parameters
        ----------------
        conversion : typing.Optional[typing.Callable[[typing.Any], typing.Any]]
            An optional conversion to perform.

        !!! note
            The value will always be cast to a `builtins.str` before inserting it.

            `builtins.True` will be translated to `&#34;true&#34;`, `builtins.False`
            ill be translated to `&#34;false&#34;`, and `builtins.None` will be
            translated to `&#34;null&#34;`.
        &#34;&#34;&#34;
        if value is not undefined.UNDEFINED:
            if conversion is not None:
                value = conversion(value)

            if value is True:
                value = &#34;true&#34;
            elif value is False:
                value = &#34;false&#34;
            elif value is None:
                value = &#34;null&#34;
            elif isinstance(value, snowflakes.Unique):
                value = str(value.id)
            else:
                value = str(value)

            # __setitem__ just overwrites the previous value.
            self.add(key, value)


@typing.final
class JSONObjectBuilder(typing.Dict[str, JSONish]):
    &#34;&#34;&#34;Helper class used to quickly build JSON objects from various values.

    If provided with any values that are `hikari.undefined.UNDEFINED`,
    then these values will be ignored.

    This speeds up generation of JSON payloads for low level HTTP and websocket
    API interaction.

    !!! warning
        Because this subclasses `builtins.dict`, you should not use the
        index operator to set items on this object. Doing so will skip any
        form of validation on the type. Use the `put*` methods instead.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def __init__(self) -&gt; None:
        # Only allow use of empty constructor here.
        super().__init__()

    @typing.overload
    def put(self, key: str, value: undefined.UndefinedNoneOr[JSONish], /) -&gt; None:
        ...

    @typing.overload
    def put(
        self,
        key: str,
        value: undefined.UndefinedNoneOr[T],
        /,
        *,
        conversion: typing.Callable[[T], JSONish],
    ) -&gt; None:
        ...

    def put(
        self,
        key: str,
        value: undefined.UndefinedNoneOr[typing.Any],
        /,
        *,
        conversion: typing.Optional[typing.Callable[[typing.Any], JSONish]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Put a JSON value.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        value : hikari.undefined.UndefinedOr[typing.Any]
            The JSON type to put. This may be a non-JSON type if a conversion
            is also specified. This may alternatively be undefined. In the latter
            case, nothing is performed.

        Other Parameters
        ----------------
        conversion : typing.Optional[typing.Callable[[typing.Any], JSONish]]
            The optional conversion to apply.
        &#34;&#34;&#34;
        if value is undefined.UNDEFINED:
            return

        if conversion is not None:
            self[key] = conversion(value)
        else:
            self[key] = value

    @typing.overload
    def put_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[JSONish]],
        /,
    ) -&gt; None:
        ...

    @typing.overload
    def put_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[T]],
        /,
        *,
        conversion: typing.Callable[[T], JSONish],
    ) -&gt; None:
        ...

    def put_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[typing.Any]],
        /,
        *,
        conversion: typing.Optional[typing.Callable[[typing.Any], JSONish]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Put a JSON array.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        If provided, a conversion will be applied to each item.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        values : hikari.undefined.UndefinedOr[typing.Iterable[T]]
            The JSON types to put. This may be an iterable of non-JSON types if
            a conversion is also specified. This may alternatively be undefined.
            In the latter case, nothing is performed.

        Other Parameters
        ----------------
        conversion : typing.Optional[typing.Callable[[typing.Any], JSONType]]
            The optional conversion to apply.
        &#34;&#34;&#34;
        if values is not undefined.UNDEFINED:
            if conversion is not None:
                self[key] = [conversion(value) for value in values]
            else:
                self[key] = list(values)

    def put_snowflake(
        self, key: str, value: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[snowflakes.Unique]], /
    ) -&gt; None:
        &#34;&#34;&#34;Put a key with a snowflake value into the builder.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        value : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]
            The JSON type to put. This may alternatively be undefined, in this
            case, nothing is performed. This may also be `builtins.None`, in this
            case the value isn&#39;t cast.
        &#34;&#34;&#34;
        if value is not undefined.UNDEFINED and value is not None:
            self[key] = str(int(value))
        elif value is None:
            self[key] = value

    def put_snowflake_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[snowflakes.SnowflakeishOr[snowflakes.Unique]]],
        /,
    ) -&gt; None:
        &#34;&#34;&#34;Put an array of snowflakes with the given key into this builder.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Each snowflake should be castable to an `builtins.int`.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        values : hikari.undefined.UndefinedOr[typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]]
            The JSON snowflakes to put. This may alternatively be undefined.
            In the latter case, nothing is performed.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        if values is not undefined.UNDEFINED:
            self[key] = [str(int(value)) for value in values]</code></pre>
</details>
</div>
</div>
<h2 id="variables-heading">Variables and Type Hints</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.internal.data_binding.Headers" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="Headers -- Type hint for HTTP headers." href="#hikari.internal.data_binding.Headers"  >Headers</a> = typing.Mapping[str, str]</code></pre>
</dt>
<dd><p>Type hint for HTTP headers.</p></dd>
</div>
<div id="hikari.internal.data_binding.JSONArray" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="JSONArray -- Type hint for a JSON-decoded array representation as a sequence." href="#hikari.internal.data_binding.JSONArray"  >JSONArray</a> = typing.List[typing.Any]</code></pre>
</dt>
<dd><p>Type hint for a JSON-decoded array representation as a sequence.</p></dd>
</div>
<div id="hikari.internal.data_binding.JSONObject" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="JSONObject -- Type hint for a JSON-decoded object representation as a mapping." href="#hikari.internal.data_binding.JSONObject"  >JSONObject</a> = typing.Dict[str, typing.Any]</code></pre>
</dt>
<dd><p>Type hint for a JSON-decoded object representation as a mapping.</p></dd>
</div>
<div id="hikari.internal.data_binding.JSONish" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="JSONish -- Type hint for any valid JSON-decoded type." href="#hikari.internal.data_binding.JSONish"  >JSONish</a> = typing.Union[str, int, float, bool, NoneType, typing.List[typing.Any], typing.Dict[str, typing.Any]]</code></pre>
</dt>
<dd><p>Type hint for any valid JSON-decoded type.</p></dd>
</div>
<div id="hikari.internal.data_binding.Query" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr></em></small> <a title="Query -- Type hint for HTTP query string." href="#hikari.internal.data_binding.Query"  >Query</a> = typing.Union[typing.Dict[str, str], multidict._multidict.MultiDict]</code></pre>
</dt>
<dd><p>Type hint for HTTP query string.</p></dd>
</div>
</dl>
</section>
<h2 id="functions-heading">Functions</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.internal.data_binding.dump_json" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="dump_json" href="#hikari.internal.data_binding.dump_json" id="hikari.internal.data_binding.dump_json">dump_json</a>(
    obj,
    *,
    skipkeys=False,
    ensure_ascii=True,
    check_circular=True,
    allow_nan=True,
    cls=None,
    indent=None,
    separators=None,
    default=None,
    sort_keys=False,
    **kw,
): ...</code></pre>
</dt>
<dd>
<p>Serialize <code>obj</code> to a JSON formatted <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If <code>skipkeys</code> is true then <code><a href='https://docs.python.org/3/library/stdtypes.html#dict'>dict</a></code> keys that are not basic types
(<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>, <code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code>, <code><a href='https://docs.python.org/3/library/functions.html#float'>float</a></code>, <code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code>, <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>) will be skipped
instead of raising a <code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code>.</p>
<p>If <code>ensure_ascii</code> is false, then the return value can contain non-ASCII
characters if they appear in strings contained in <code>obj</code>. Otherwise, all
such characters are escaped in JSON strings.</p>
<p>If <code>check_circular</code> is false, then the circular reference check
for container types will be skipped and a circular reference will
result in an <code><a href='https://docs.python.org/3/library/exceptions.html#OverflowError'>OverflowError</a></code> (or worse).</p>
<p>If <code>allow_nan</code> is false, then it will be a <code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code> to
serialize out of range <code><a href='https://docs.python.org/3/library/functions.html#float'>float</a></code> values (<code><a href='https://docs.python.org/3/library/functions.html#grammar-token-nan'>nan</a></code>, <code>inf</code>, <code>-inf</code>) in
strict compliance of the JSON specification, instead of using the
JavaScript equivalents (<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>).</p>
<p>If <code>indent</code> is a non-negative integer, then JSON array elements and
object members will be pretty-printed with that indent level. An indent
level of 0 will only insert newlines. <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> is the most compact
representation.</p>
<p>If specified, <code>separators</code> should be an <code>(item_separator, key_separator)</code>
tuple.
The default is <code>(', ', ': ')</code> if <em>indent</em> is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> and
<code>(',', ': ')</code> otherwise.
To get the most compact JSON representation,
you should specify <code>(',', ':')</code> to eliminate whitespace.</p>
<p><code>default(obj)</code> is a function that should return a serializable version
of obj or raise TypeError. The default simply raises TypeError.</p>
<p>If <em>sort_keys</em> is true (default: <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>), then the output of
dictionaries will be sorted by key.</p>
<p>To use a custom <code>JSONEncoder</code> subclass (e.g. one that overrides the
<code>.default()</code> method to serialize additional types), specify it with
the <code>cls</code> kwarg; otherwise <code>JSONEncoder</code> is used.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,
        allow_nan=True, cls=None, indent=None, separators=None,
        default=None, sort_keys=False, **kw):
    &#34;&#34;&#34;Serialize ``obj`` to a JSON formatted ``str``.

    If ``skipkeys`` is true then ``dict`` keys that are not basic types
    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
    instead of raising a ``TypeError``.

    If ``ensure_ascii`` is false, then the return value can contain non-ASCII
    characters if they appear in strings contained in ``obj``. Otherwise, all
    such characters are escaped in JSON strings.

    If ``check_circular`` is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``OverflowError`` (or worse).

    If ``allow_nan`` is false, then it will be a ``ValueError`` to
    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in
    strict compliance of the JSON specification, instead of using the
    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).

    If ``indent`` is a non-negative integer, then JSON array elements and
    object members will be pretty-printed with that indent level. An indent
    level of 0 will only insert newlines. ``None`` is the most compact
    representation.

    If specified, ``separators`` should be an ``(item_separator, key_separator)``
    tuple.  The default is ``(&#39;, &#39;, &#39;: &#39;)`` if *indent* is ``None`` and
    ``(&#39;,&#39;, &#39;: &#39;)`` otherwise.  To get the most compact JSON representation,
    you should specify ``(&#39;,&#39;, &#39;:&#39;)`` to eliminate whitespace.

    ``default(obj)`` is a function that should return a serializable version
    of obj or raise TypeError. The default simply raises TypeError.

    If *sort_keys* is true (default: ``False``), then the output of
    dictionaries will be sorted by key.

    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.

    &#34;&#34;&#34;
    # cached encoder
    if (not skipkeys and ensure_ascii and
        check_circular and allow_nan and
        cls is None and indent is None and separators is None and
        default is None and not sort_keys and not kw):
        return _default_encoder.encode(obj)
    if cls is None:
        cls = JSONEncoder
    return cls(
        skipkeys=skipkeys, ensure_ascii=ensure_ascii,
        check_circular=check_circular, allow_nan=allow_nan, indent=indent,
        separators=separators, default=default, sort_keys=sort_keys,
        **kw).encode(obj)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.internal.data_binding.load_json" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="load_json" href="#hikari.internal.data_binding.load_json" id="hikari.internal.data_binding.load_json">load_json</a>(
    s,
    *,
    cls=None,
    object_hook=None,
    parse_float=None,
    parse_int=None,
    parse_constant=None,
    object_pairs_hook=None,
    **kw,
): ...</code></pre>
</dt>
<dd>
<p>Deserialize <code>s</code> (a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>, <code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code> or <code><a href='https://docs.python.org/3/library/stdtypes.html#bytearray'>bytearray</a></code> instance
containing a JSON document) to a Python object.</p>
<p><code>object_hook</code> is an optional function that will be called with the
result of any object literal decode (a <code><a href='https://docs.python.org/3/library/stdtypes.html#dict'>dict</a></code>). The return value of
<code>object_hook</code> will be used instead of the <code><a href='https://docs.python.org/3/library/stdtypes.html#dict'>dict</a></code>. This feature
can be used to implement custom decoders (e.g. JSON-RPC class hinting).</p>
<p><code>object_pairs_hook</code> is an optional function that will be called with the
result of any object literal decoded with an ordered list of pairs.
The
return value of <code>object_pairs_hook</code> will be used instead of the <code><a href='https://docs.python.org/3/library/stdtypes.html#dict'>dict</a></code>.
This feature can be used to implement custom decoders.
If <code>object_hook</code>
is also defined, the <code>object_pairs_hook</code> takes priority.</p>
<p><code>parse_float</code>, if specified, will be called with the string
of every JSON float to be decoded. By default this is equivalent to
float(num_str). This can be used to use another datatype or parser
for JSON floats (e.g. decimal.Decimal).</p>
<p><code>parse_int</code>, if specified, will be called with the string
of every JSON int to be decoded. By default this is equivalent to
int(num_str). This can be used to use another datatype or parser
for JSON integers (e.g. float).</p>
<p><code>parse_constant</code>, if specified, will be called with one of the
following strings: -Infinity, Infinity, NaN.
This can be used to raise an exception if invalid JSON numbers
are encountered.</p>
<p>To use a custom <code>JSONDecoder</code> subclass, specify it with the <code>cls</code>
kwarg; otherwise <code>JSONDecoder</code> is used.</p>
<p>The <code>encoding</code> argument is ignored and deprecated since Python 3.1.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loads(s, *, cls=None, object_hook=None, parse_float=None,
        parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):
    &#34;&#34;&#34;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
    containing a JSON document) to a Python object.

    ``object_hook`` is an optional function that will be called with the
    result of any object literal decode (a ``dict``). The return value of
    ``object_hook`` will be used instead of the ``dict``. This feature
    can be used to implement custom decoders (e.g. JSON-RPC class hinting).

    ``object_pairs_hook`` is an optional function that will be called with the
    result of any object literal decoded with an ordered list of pairs.  The
    return value of ``object_pairs_hook`` will be used instead of the ``dict``.
    This feature can be used to implement custom decoders.  If ``object_hook``
    is also defined, the ``object_pairs_hook`` takes priority.

    ``parse_float``, if specified, will be called with the string
    of every JSON float to be decoded. By default this is equivalent to
    float(num_str). This can be used to use another datatype or parser
    for JSON floats (e.g. decimal.Decimal).

    ``parse_int``, if specified, will be called with the string
    of every JSON int to be decoded. By default this is equivalent to
    int(num_str). This can be used to use another datatype or parser
    for JSON integers (e.g. float).

    ``parse_constant``, if specified, will be called with one of the
    following strings: -Infinity, Infinity, NaN.
    This can be used to raise an exception if invalid JSON numbers
    are encountered.

    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
    kwarg; otherwise ``JSONDecoder`` is used.

    The ``encoding`` argument is ignored and deprecated since Python 3.1.
    &#34;&#34;&#34;
    if isinstance(s, str):
        if s.startswith(&#39;\ufeff&#39;):
            raise JSONDecodeError(&#34;Unexpected UTF-8 BOM (decode using utf-8-sig)&#34;,
                                  s, 0)
    else:
        if not isinstance(s, (bytes, bytearray)):
            raise TypeError(f&#39;the JSON object must be str, bytes or bytearray, &#39;
                            f&#39;not {s.__class__.__name__}&#39;)
        s = s.decode(detect_encoding(s), &#39;surrogatepass&#39;)

    if &#34;encoding&#34; in kw:
        import warnings
        warnings.warn(
            &#34;&#39;encoding&#39; is ignored and deprecated. It will be removed in Python 3.9&#34;,
            DeprecationWarning,
            stacklevel=2
        )
        del kw[&#39;encoding&#39;]

    if (cls is None and object_hook is None and
            parse_int is None and parse_float is None and
            parse_constant is None and object_pairs_hook is None and not kw):
        return _default_decoder.decode(s)
    if cls is None:
        cls = JSONDecoder
    if object_hook is not None:
        kw[&#39;object_hook&#39;] = object_hook
    if object_pairs_hook is not None:
        kw[&#39;object_pairs_hook&#39;] = object_pairs_hook
    if parse_float is not None:
        kw[&#39;parse_float&#39;] = parse_float
    if parse_int is not None:
        kw[&#39;parse_int&#39;] = parse_int
    if parse_constant is not None:
        kw[&#39;parse_constant&#39;] = parse_constant
    return cls(**kw).decode(s)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
</section>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.internal.data_binding.FormData" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="URLEncodedForm -- Helper class for multipart/form-data and
application/x-www-form-urlencoded body generation." href="#hikari.internal.data_binding.FormData"
>URLEncodedForm</a></h4>
</dt>
<dd>
<pre><code id="hikari.internal.data_binding.FormData" class="hljs python"><abbr title='A standard Python type.'>class</abbr> URLEncodedForm (
    fields: Iterable[Any] = (),
    quote_fields: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = True,
    charset: Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
): ...</code></pre>
<p>Helper class for multipart/form-data and
application/x-www-form-urlencoded body generation.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/.nox/pages/lib/python3.8/site-packages/aiohttp/formdata.py#L14-L170" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class FormData:
    &#34;&#34;&#34;Helper class for multipart/form-data and
    application/x-www-form-urlencoded body generation.&#34;&#34;&#34;

    def __init__(
        self,
        fields: Iterable[Any] = (),
        quote_fields: bool = True,
        charset: Optional[str] = None,
    ) -&gt; None:
        self._writer = multipart.MultipartWriter(&#34;form-data&#34;)
        self._fields = []  # type: List[Any]
        self._is_multipart = False
        self._is_processed = False
        self._quote_fields = quote_fields
        self._charset = charset

        if isinstance(fields, dict):
            fields = list(fields.items())
        elif not isinstance(fields, (list, tuple)):
            fields = (fields,)
        self.add_fields(*fields)

    @property
    def is_multipart(self) -&gt; bool:
        return self._is_multipart

    def add_field(
        self,
        name: str,
        value: Any,
        *,
        content_type: Optional[str] = None,
        filename: Optional[str] = None,
        content_transfer_encoding: Optional[str] = None
    ) -&gt; None:

        if isinstance(value, io.IOBase):
            self._is_multipart = True
        elif isinstance(value, (bytes, bytearray, memoryview)):
            if filename is None and content_transfer_encoding is None:
                filename = name

        type_options = MultiDict({&#34;name&#34;: name})  # type: MultiDict[str]
        if filename is not None and not isinstance(filename, str):
            raise TypeError(
                &#34;filename must be an instance of str. &#34; &#34;Got: %s&#34; % filename
            )
        if filename is None and isinstance(value, io.IOBase):
            filename = guess_filename(value, name)
        if filename is not None:
            type_options[&#34;filename&#34;] = filename
            self._is_multipart = True

        headers = {}
        if content_type is not None:
            if not isinstance(content_type, str):
                raise TypeError(
                    &#34;content_type must be an instance of str. &#34; &#34;Got: %s&#34; % content_type
                )
            headers[hdrs.CONTENT_TYPE] = content_type
            self._is_multipart = True
        if content_transfer_encoding is not None:
            if not isinstance(content_transfer_encoding, str):
                raise TypeError(
                    &#34;content_transfer_encoding must be an instance&#34;
                    &#34; of str. Got: %s&#34; % content_transfer_encoding
                )
            headers[hdrs.CONTENT_TRANSFER_ENCODING] = content_transfer_encoding
            self._is_multipart = True

        self._fields.append((type_options, headers, value))

    def add_fields(self, *fields: Any) -&gt; None:
        to_add = list(fields)

        while to_add:
            rec = to_add.pop(0)

            if isinstance(rec, io.IOBase):
                k = guess_filename(rec, &#34;unknown&#34;)
                self.add_field(k, rec)  # type: ignore

            elif isinstance(rec, (MultiDictProxy, MultiDict)):
                to_add.extend(rec.items())

            elif isinstance(rec, (list, tuple)) and len(rec) == 2:
                k, fp = rec
                self.add_field(k, fp)  # type: ignore

            else:
                raise TypeError(
                    &#34;Only io.IOBase, multidict and (name, file) &#34;
                    &#34;pairs allowed, use .add_field() for passing &#34;
                    &#34;more complex parameters, got {!r}&#34;.format(rec)
                )

    def _gen_form_urlencoded(self) -&gt; payload.BytesPayload:
        # form data (x-www-form-urlencoded)
        data = []
        for type_options, _, value in self._fields:
            data.append((type_options[&#34;name&#34;], value))

        charset = self._charset if self._charset is not None else &#34;utf-8&#34;

        if charset == &#34;utf-8&#34;:
            content_type = &#34;application/x-www-form-urlencoded&#34;
        else:
            content_type = &#34;application/x-www-form-urlencoded; &#34; &#34;charset=%s&#34; % charset

        return payload.BytesPayload(
            urlencode(data, doseq=True, encoding=charset).encode(),
            content_type=content_type,
        )

    def _gen_form_data(self) -&gt; multipart.MultipartWriter:
        &#34;&#34;&#34;Encode a list of fields using the multipart/form-data MIME format&#34;&#34;&#34;
        if self._is_processed:
            raise RuntimeError(&#34;Form data has been processed already&#34;)
        for dispparams, headers, value in self._fields:
            try:
                if hdrs.CONTENT_TYPE in headers:
                    part = payload.get_payload(
                        value,
                        content_type=headers[hdrs.CONTENT_TYPE],
                        headers=headers,
                        encoding=self._charset,
                    )
                else:
                    part = payload.get_payload(
                        value, headers=headers, encoding=self._charset
                    )
            except Exception as exc:
                raise TypeError(
                    &#34;Can not serialize value type: %r\n &#34;
                    &#34;headers: %r\n value: %r&#34; % (type(value), headers, value)
                ) from exc

            if dispparams:
                part.set_content_disposition(
                    &#34;form-data&#34;, quote_fields=self._quote_fields, **dispparams
                )
                # FIXME cgi.FieldStorage doesn&#39;t likes body parts with
                # Content-Length which were sent via chunked transfer encoding
                assert part.headers is not None
                part.headers.popall(hdrs.CONTENT_LENGTH, None)

            self._writer.append_payload(part)

        self._is_processed = True
        return self._writer

    def __call__(self) -&gt; Payload:
        if self._is_multipart:
            return self._gen_form_data()
        else:
            return self._gen_form_urlencoded()</code></pre>
</details>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.internal.data_binding.FormData.is_multipart" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_multipart -- " href="#hikari.internal.data_binding.FormData.is_multipart"  >is_multipart</a> : <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></pre>
</dt>
<dd></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.internal.data_binding.FormData.add_field" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="add_field" href="#hikari.internal.data_binding.FormData.add_field" id="hikari.internal.data_binding.FormData.add_field">add_field</a>(
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    value: Any,
    *,
    content_type: Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
    filename: Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
    content_transfer_encoding: Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = None,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/.nox/pages/lib/python3.8/site-packages/aiohttp/formdata.py#L41-L85" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def add_field(
    self,
    name: str,
    value: Any,
    *,
    content_type: Optional[str] = None,
    filename: Optional[str] = None,
    content_transfer_encoding: Optional[str] = None
) -&gt; None:

    if isinstance(value, io.IOBase):
        self._is_multipart = True
    elif isinstance(value, (bytes, bytearray, memoryview)):
        if filename is None and content_transfer_encoding is None:
            filename = name

    type_options = MultiDict({&#34;name&#34;: name})  # type: MultiDict[str]
    if filename is not None and not isinstance(filename, str):
        raise TypeError(
            &#34;filename must be an instance of str. &#34; &#34;Got: %s&#34; % filename
        )
    if filename is None and isinstance(value, io.IOBase):
        filename = guess_filename(value, name)
    if filename is not None:
        type_options[&#34;filename&#34;] = filename
        self._is_multipart = True

    headers = {}
    if content_type is not None:
        if not isinstance(content_type, str):
            raise TypeError(
                &#34;content_type must be an instance of str. &#34; &#34;Got: %s&#34; % content_type
            )
        headers[hdrs.CONTENT_TYPE] = content_type
        self._is_multipart = True
    if content_transfer_encoding is not None:
        if not isinstance(content_transfer_encoding, str):
            raise TypeError(
                &#34;content_transfer_encoding must be an instance&#34;
                &#34; of str. Got: %s&#34; % content_transfer_encoding
            )
        headers[hdrs.CONTENT_TRANSFER_ENCODING] = content_transfer_encoding
        self._is_multipart = True

    self._fields.append((type_options, headers, value))</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.internal.data_binding.FormData.add_fields" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="add_fields" href="#hikari.internal.data_binding.FormData.add_fields" id="hikari.internal.data_binding.FormData.add_fields">add_fields</a>(
    *fields: Any,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/.nox/pages/lib/python3.8/site-packages/aiohttp/formdata.py#L87-L109" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def add_fields(self, *fields: Any) -&gt; None:
    to_add = list(fields)

    while to_add:
        rec = to_add.pop(0)

        if isinstance(rec, io.IOBase):
            k = guess_filename(rec, &#34;unknown&#34;)
            self.add_field(k, rec)  # type: ignore

        elif isinstance(rec, (MultiDictProxy, MultiDict)):
            to_add.extend(rec.items())

        elif isinstance(rec, (list, tuple)) and len(rec) == 2:
            k, fp = rec
            self.add_field(k, fp)  # type: ignore

        else:
            raise TypeError(
                &#34;Only io.IOBase, multidict and (name, file) &#34;
                &#34;pairs allowed, use .add_field() for passing &#34;
                &#34;more complex parameters, got {!r}&#34;.format(rec)
            )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.internal.data_binding.JSONDecodeError" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python Exception that can be raised and caught.'>exception</abbr></em></small> <a title="JSONDecodeError -- Subclass of ValueError with the following additional properties: …" href="#hikari.internal.data_binding.JSONDecodeError"
>JSONDecodeError</a></h4>
</dt>
<dd>
<pre><code id="hikari.internal.data_binding.JSONDecodeError" class="hljs python"><abbr title='A standard Python type.'>class</abbr> JSONDecodeError (
    msg,
    doc,
    pos,
): ...</code></pre>
<p>Subclass of ValueError with the following additional properties:</p>
<p>msg: The unformatted error message
doc: The JSON document being parsed
pos: The start index of doc where parsing failed
lineno: The line corresponding to pos
colno: The column corresponding to pos</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONDecodeError(ValueError):
    &#34;&#34;&#34;Subclass of ValueError with the following additional properties:

    msg: The unformatted error message
    doc: The JSON document being parsed
    pos: The start index of doc where parsing failed
    lineno: The line corresponding to pos
    colno: The column corresponding to pos

    &#34;&#34;&#34;
    # Note that this exception is used from _json
    def __init__(self, msg, doc, pos):
        lineno = doc.count(&#39;\n&#39;, 0, pos) + 1
        colno = pos - doc.rfind(&#39;\n&#39;, 0, pos)
        errmsg = &#39;%s: line %d column %d (char %d)&#39; % (msg, lineno, colno, pos)
        ValueError.__init__(self, errmsg)
        self.msg = msg
        self.doc = doc
        self.pos = pos
        self.lineno = lineno
        self.colno = colno

    def __reduce__(self):
        return self.__class__, (self.msg, self.doc, self.pos)</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python Exception that can be raised and caught.'>exception</abbr></em></small> <a title="JSONDecodeError -- Subclass of ValueError with the following additional properties: …" href="#hikari.internal.data_binding.JSONDecodeError"
>JSONDecodeError</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="builtins.ValueError -- Inappropriate argument value (of correct type)." href="https://docs.python.org/3/library/exceptions.html#ValueError"
>ValueError</a></dt>
<dd class="nested"><p>Inappropriate argument value (of correct type).</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="builtins.Exception -- Common base class for all non-exit exceptions." href="https://docs.python.org/3/library/exceptions.html#Exception"
>Exception</a></dt>
<dd class="nested"><p>Common base class for all non-exit exceptions.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="builtins.BaseException -- Common base class for all exceptions" href="https://docs.python.org/3/library/exceptions.html#BaseException"
>BaseException</a></dt>
<dd class="nested"><p>Common base class for all exceptions</p></dd>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.internal.data_binding.JSONObjectBuilder" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="JSONObjectBuilder -- Helper class used to quickly build JSON objects from various values …" href="#hikari.internal.data_binding.JSONObjectBuilder"
>JSONObjectBuilder</a></h4>
</dt>
<dd>
<pre><code id="hikari.internal.data_binding.JSONObjectBuilder" class="hljs python"><abbr title='A standard Python type.'>class</abbr> JSONObjectBuilder: ...</code></pre>
<p>Helper class used to quickly build JSON objects from various values.</p>
<p>If provided with any values that are <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>,
then these values will be ignored.</p>
<p>This speeds up generation of JSON payloads for low level HTTP and websocket
API interaction.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Because this subclasses <code><a href='https://docs.python.org/3/library/stdtypes.html#dict'>dict</a></code>, you should not use the
index operator to set items on this object. Doing so will skip any
form of validation on the type. Use the <code>put*</code> methods instead.</p>
</div>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/internal/data_binding.py#L196-L362" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class JSONObjectBuilder(typing.Dict[str, JSONish]):
    &#34;&#34;&#34;Helper class used to quickly build JSON objects from various values.

    If provided with any values that are `hikari.undefined.UNDEFINED`,
    then these values will be ignored.

    This speeds up generation of JSON payloads for low level HTTP and websocket
    API interaction.

    !!! warning
        Because this subclasses `builtins.dict`, you should not use the
        index operator to set items on this object. Doing so will skip any
        form of validation on the type. Use the `put*` methods instead.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def __init__(self) -&gt; None:
        # Only allow use of empty constructor here.
        super().__init__()

    @typing.overload
    def put(self, key: str, value: undefined.UndefinedNoneOr[JSONish], /) -&gt; None:
        ...

    @typing.overload
    def put(
        self,
        key: str,
        value: undefined.UndefinedNoneOr[T],
        /,
        *,
        conversion: typing.Callable[[T], JSONish],
    ) -&gt; None:
        ...

    def put(
        self,
        key: str,
        value: undefined.UndefinedNoneOr[typing.Any],
        /,
        *,
        conversion: typing.Optional[typing.Callable[[typing.Any], JSONish]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Put a JSON value.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        value : hikari.undefined.UndefinedOr[typing.Any]
            The JSON type to put. This may be a non-JSON type if a conversion
            is also specified. This may alternatively be undefined. In the latter
            case, nothing is performed.

        Other Parameters
        ----------------
        conversion : typing.Optional[typing.Callable[[typing.Any], JSONish]]
            The optional conversion to apply.
        &#34;&#34;&#34;
        if value is undefined.UNDEFINED:
            return

        if conversion is not None:
            self[key] = conversion(value)
        else:
            self[key] = value

    @typing.overload
    def put_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[JSONish]],
        /,
    ) -&gt; None:
        ...

    @typing.overload
    def put_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[T]],
        /,
        *,
        conversion: typing.Callable[[T], JSONish],
    ) -&gt; None:
        ...

    def put_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[typing.Any]],
        /,
        *,
        conversion: typing.Optional[typing.Callable[[typing.Any], JSONish]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Put a JSON array.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        If provided, a conversion will be applied to each item.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        values : hikari.undefined.UndefinedOr[typing.Iterable[T]]
            The JSON types to put. This may be an iterable of non-JSON types if
            a conversion is also specified. This may alternatively be undefined.
            In the latter case, nothing is performed.

        Other Parameters
        ----------------
        conversion : typing.Optional[typing.Callable[[typing.Any], JSONType]]
            The optional conversion to apply.
        &#34;&#34;&#34;
        if values is not undefined.UNDEFINED:
            if conversion is not None:
                self[key] = [conversion(value) for value in values]
            else:
                self[key] = list(values)

    def put_snowflake(
        self, key: str, value: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[snowflakes.Unique]], /
    ) -&gt; None:
        &#34;&#34;&#34;Put a key with a snowflake value into the builder.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        value : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]
            The JSON type to put. This may alternatively be undefined, in this
            case, nothing is performed. This may also be `builtins.None`, in this
            case the value isn&#39;t cast.
        &#34;&#34;&#34;
        if value is not undefined.UNDEFINED and value is not None:
            self[key] = str(int(value))
        elif value is None:
            self[key] = value

    def put_snowflake_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[snowflakes.SnowflakeishOr[snowflakes.Unique]]],
        /,
    ) -&gt; None:
        &#34;&#34;&#34;Put an array of snowflakes with the given key into this builder.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Each snowflake should be castable to an `builtins.int`.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        values : hikari.undefined.UndefinedOr[typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]]
            The JSON snowflakes to put. This may alternatively be undefined.
            In the latter case, nothing is performed.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        if values is not undefined.UNDEFINED:
            self[key] = [str(int(value)) for value in values]</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="JSONObjectBuilder -- Helper class used to quickly build JSON objects from various values …" href="#hikari.internal.data_binding.JSONObjectBuilder"
>JSONObjectBuilder</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="builtins.dict -- dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -> new …" href="https://docs.python.org/3/library/stdtypes.html#dict"
>dict</a></dt>
<dd class="nested"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.internal.data_binding.JSONObjectBuilder.put" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="put" href="#hikari.internal.data_binding.JSONObjectBuilder.put" id="hikari.internal.data_binding.JSONObjectBuilder.put">put</a>(
    key: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    value: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>],
    /,
    *,
    conversion: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='#hikari.internal.data_binding.JSONish'>JSONish</a>]] = None,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Put a JSON value.</p>
<p>If the value is <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> it will not be stored.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The key to give the element.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>The JSON type to put. This may be a non-JSON type if a conversion
is also specified. This may alternatively be undefined. In the latter
case, nothing is performed.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>conversion</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='#hikari.internal.data_binding.JSONish'>JSONish</a>]]</code></dt>
<dd>The optional conversion to apply.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/internal/data_binding.py#L232-L264" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def put(
    self,
    key: str,
    value: undefined.UndefinedNoneOr[typing.Any],
    /,
    *,
    conversion: typing.Optional[typing.Callable[[typing.Any], JSONish]] = None,
) -&gt; None:
    &#34;&#34;&#34;Put a JSON value.

    If the value is `hikari.undefined.UNDEFINED` it will not be stored.

    Parameters
    ----------
    key : builtins.str
        The key to give the element.
    value : hikari.undefined.UndefinedOr[typing.Any]
        The JSON type to put. This may be a non-JSON type if a conversion
        is also specified. This may alternatively be undefined. In the latter
        case, nothing is performed.

    Other Parameters
    ----------------
    conversion : typing.Optional[typing.Callable[[typing.Any], JSONish]]
        The optional conversion to apply.
    &#34;&#34;&#34;
    if value is undefined.UNDEFINED:
        return

    if conversion is not None:
        self[key] = conversion(value)
    else:
        self[key] = value</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.internal.data_binding.JSONObjectBuilder.put_array" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="put_array" href="#hikari.internal.data_binding.JSONObjectBuilder.put_array" id="hikari.internal.data_binding.JSONObjectBuilder.put_array">put_array</a>(
    key: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    values: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]],
    /,
    *,
    conversion: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='#hikari.internal.data_binding.JSONish'>JSONish</a>]] = None,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Put a JSON array.</p>
<p>If the value is <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> it will not be stored.</p>
<p>If provided, a conversion will be applied to each item.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The key to give the element.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[T]]</code></dt>
<dd>The JSON types to put. This may be an iterable of non-JSON types if
a conversion is also specified. This may alternatively be undefined.
In the latter case, nothing is performed.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>conversion</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], JSONType]]</code></dt>
<dd>The optional conversion to apply.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/internal/data_binding.py#L286-L318" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def put_array(
    self,
    key: str,
    values: undefined.UndefinedOr[typing.Iterable[typing.Any]],
    /,
    *,
    conversion: typing.Optional[typing.Callable[[typing.Any], JSONish]] = None,
) -&gt; None:
    &#34;&#34;&#34;Put a JSON array.

    If the value is `hikari.undefined.UNDEFINED` it will not be stored.

    If provided, a conversion will be applied to each item.

    Parameters
    ----------
    key : builtins.str
        The key to give the element.
    values : hikari.undefined.UndefinedOr[typing.Iterable[T]]
        The JSON types to put. This may be an iterable of non-JSON types if
        a conversion is also specified. This may alternatively be undefined.
        In the latter case, nothing is performed.

    Other Parameters
    ----------------
    conversion : typing.Optional[typing.Callable[[typing.Any], JSONType]]
        The optional conversion to apply.
    &#34;&#34;&#34;
    if values is not undefined.UNDEFINED:
        if conversion is not None:
            self[key] = [conversion(value) for value in values]
        else:
            self[key] = list(values)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.internal.data_binding.JSONObjectBuilder.put_snowflake" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="put_snowflake" href="#hikari.internal.data_binding.JSONObjectBuilder.put_snowflake" id="hikari.internal.data_binding.JSONObjectBuilder.put_snowflake">put_snowflake</a>(
    key: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    value: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]],
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Put a key with a snowflake value into the builder.</p>
<p>If the value is <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> it will not be stored.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The key to give the element.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>The JSON type to put. This may alternatively be undefined, in this
case, nothing is performed. This may also be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, in this
case the value isn't cast.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/internal/data_binding.py#L320-L339" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def put_snowflake(
    self, key: str, value: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[snowflakes.Unique]], /
) -&gt; None:
    &#34;&#34;&#34;Put a key with a snowflake value into the builder.

    If the value is `hikari.undefined.UNDEFINED` it will not be stored.

    Parameters
    ----------
    key : builtins.str
        The key to give the element.
    value : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]
        The JSON type to put. This may alternatively be undefined, in this
        case, nothing is performed. This may also be `builtins.None`, in this
        case the value isn&#39;t cast.
    &#34;&#34;&#34;
    if value is not undefined.UNDEFINED and value is not None:
        self[key] = str(int(value))
    elif value is None:
        self[key] = value</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.internal.data_binding.JSONObjectBuilder.put_snowflake_array" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="put_snowflake_array" href="#hikari.internal.data_binding.JSONObjectBuilder.put_snowflake_array" id="hikari.internal.data_binding.JSONObjectBuilder.put_snowflake_array">put_snowflake_array</a>(
    key: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    values: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]]],
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Put an array of snowflakes with the given key into this builder.</p>
<p>If the value is <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> it will not be stored.</p>
<p>Each snowflake should be castable to an <code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The key to give the element.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]]</code></dt>
<dd>The JSON snowflakes to put. This may alternatively be undefined.
In the latter case, nothing is performed.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/internal/data_binding.py#L341-L362" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def put_snowflake_array(
    self,
    key: str,
    values: undefined.UndefinedOr[typing.Iterable[snowflakes.SnowflakeishOr[snowflakes.Unique]]],
    /,
) -&gt; None:
    &#34;&#34;&#34;Put an array of snowflakes with the given key into this builder.

    If the value is `hikari.undefined.UNDEFINED` it will not be stored.

    Each snowflake should be castable to an `builtins.int`.

    Parameters
    ----------
    key : builtins.str
        The key to give the element.
    values : hikari.undefined.UndefinedOr[typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]]
        The JSON snowflakes to put. This may alternatively be undefined.
        In the latter case, nothing is performed.
    &#34;&#34;&#34;  # noqa: E501 - Line too long
    if values is not undefined.UNDEFINED:
        self[key] = [str(int(value)) for value in values]</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
</dl>
</section>
</div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>