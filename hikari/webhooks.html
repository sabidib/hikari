<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.webhooks API documentation</title>
<meta name="description" content="Application and entities that are used to describe webhooks on Discord.">
<meta property="og:title" content="hikari.webhooks module list">
<meta property="og:type" content="website">
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png">
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions">
<meta property="theme-color" content="#ff029a">
<link rel="shortcut icon" type="image/png" href="../logo.png">
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
text-indent: 100%;
white-space: nowrap;
overflow: hidden;
}
small.smaller {
font-size: 0.50em;
}
html {
height: 100%;
scroll-behavior: smooth;
scrollbar-color: #202324 #454a4d;
}
body {
background-color: #181A1B;
color: #C9C5C0;
height: fit-content;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.container > li {
margin-left: 1em;
margin-top: 2.5em;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
.anchor:target {
background-color: var(--dark);
}
@media screen and (max-width: 990px) {
.anchor:target {
margin-left: -2em;
padding-left: 2em;
}
}
@media screen and (min-width: 990px) {
.anchor:target {
border-radius: 0.5em; !important
margin-right: -2em;
padding-right: 2em;
margin-top: -1em;
padding-top: 1em;
}
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="../logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small class="smaller">2.0.0.dev102</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../index.html">Home</a></li>
<li class="nav-item"><a class="nav-link active" href="../hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" action="../hikari/search.html">
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search" name="q"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="index.html"
>hikari</a></li>
<li class="breadcrumb-item active"><a href="#">webhooks</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Application and entities that are used to describe webhooks on Discord.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ApplicationWebhook -- Represents an application webhook object on Discord …" href="#hikari.webhooks.ApplicationWebhook"
>ApplicationWebhook</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- The client application that models may use for procedures." href="#hikari.webhooks.ApplicationWebhook.app"
>app</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="application_id -- Return an attribute of instance, which is of type owner." href="#hikari.webhooks.ApplicationWebhook.application_id"
>application_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_hash -- The avatar hash of the webhook." href="#hikari.webhooks.ApplicationWebhook.avatar_hash"
>avatar_hash</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_url -- URL for this webhook's avatar, if set …" href="#hikari.webhooks.PartialWebhook.avatar_url"
>avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="created_at -- When the object was created." href="snowflakes.html#hikari.snowflakes.Unique.created_at"
>created_at</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="default_avatar_url -- Avatar URL for the user, if they have one set …" href="#hikari.webhooks.PartialWebhook.default_avatar_url"
>default_avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="id -- The ID of this entity." href="#hikari.webhooks.ApplicationWebhook.id"
>id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="make_avatar_url -- Generate the avatar URL for this webhook's custom avatar if set …" href="#hikari.webhooks.PartialWebhook.make_avatar_url"
>make_avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mention -- Return a raw mention string for the given webhook's user …" href="#hikari.webhooks.PartialWebhook.mention"
>mention</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="name -- The name of the webhook." href="#hikari.webhooks.ApplicationWebhook.name"
>name</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="type -- The type of the webhook." href="#hikari.webhooks.ApplicationWebhook.type"
>type</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ChannelFollowerWebhook -- Represents a channel follower webhook object on Discord …" href="#hikari.webhooks.ChannelFollowerWebhook"
>ChannelFollowerWebhook</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- The client application that models may use for procedures." href="#hikari.webhooks.ChannelFollowerWebhook.app"
>app</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="application_id -- The ID of the application that created this webhook." href="#hikari.webhooks.ChannelFollowerWebhook.application_id"
>application_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="author -- The user that created the webhook …" href="#hikari.webhooks.ChannelFollowerWebhook.author"
>author</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_hash -- The avatar hash of the webhook." href="#hikari.webhooks.ChannelFollowerWebhook.avatar_hash"
>avatar_hash</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_url -- URL for this webhook's avatar, if set …" href="#hikari.webhooks.PartialWebhook.avatar_url"
>avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="channel_id -- The channel ID this webhook is for." href="#hikari.webhooks.ChannelFollowerWebhook.channel_id"
>channel_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="created_at -- When the object was created." href="snowflakes.html#hikari.snowflakes.Unique.created_at"
>created_at</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="default_avatar_url -- Avatar URL for the user, if they have one set …" href="#hikari.webhooks.PartialWebhook.default_avatar_url"
>default_avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete -- Delete this webhook …" href="#hikari.webhooks.ChannelFollowerWebhook.delete"
>delete</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit -- Edit this webhook …" href="#hikari.webhooks.ChannelFollowerWebhook.edit"
>edit</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel -- Fetch the channel this webhook is for …" href="#hikari.webhooks.ChannelFollowerWebhook.fetch_channel"
>fetch_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_self -- Fetch this webhook …" href="#hikari.webhooks.ChannelFollowerWebhook.fetch_self"
>fetch_self</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="guild_id -- The guild ID of the webhook." href="#hikari.webhooks.ChannelFollowerWebhook.guild_id"
>guild_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="id -- The ID of this entity." href="#hikari.webhooks.ChannelFollowerWebhook.id"
>id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="make_avatar_url -- Generate the avatar URL for this webhook's custom avatar if set …" href="#hikari.webhooks.PartialWebhook.make_avatar_url"
>make_avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mention -- Return a raw mention string for the given webhook's user …" href="#hikari.webhooks.PartialWebhook.mention"
>mention</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="name -- The name of the webhook." href="#hikari.webhooks.ChannelFollowerWebhook.name"
>name</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="source_channel -- The partial object of the channel this webhook is following." href="#hikari.webhooks.ChannelFollowerWebhook.source_channel"
>source_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="source_guild -- The partial object of the guild this webhook is following." href="#hikari.webhooks.ChannelFollowerWebhook.source_guild"
>source_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="type -- The type of the webhook." href="#hikari.webhooks.ChannelFollowerWebhook.type"
>type</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="ExecutableWebhook -- An abstract class with logic for executing entities as webhooks." href="#hikari.webhooks.ExecutableWebhook"
>ExecutableWebhook</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- Client application that models may use for procedures …" href="#hikari.webhooks.ExecutableWebhook.app"
>app</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_message -- Delete a given message in a given channel …" href="#hikari.webhooks.ExecutableWebhook.delete_message"
>delete_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_message -- Edit a message sent by a webhook …" href="#hikari.webhooks.ExecutableWebhook.edit_message"
>edit_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="execute -- Execute the webhook to create a message …" href="#hikari.webhooks.ExecutableWebhook.execute"
>execute</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_message -- Fetch an old message sent by the webhook …" href="#hikari.webhooks.ExecutableWebhook.fetch_message"
>fetch_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="token -- Webhook's token …" href="#hikari.webhooks.ExecutableWebhook.token"
>token</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="webhook_id -- ID used to execute this entity as a webhook …" href="#hikari.webhooks.ExecutableWebhook.webhook_id"
>webhook_id</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="IncomingWebhook -- Represents an incoming webhook object on Discord …" href="#hikari.webhooks.IncomingWebhook"
>IncomingWebhook</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- The client application that models may use for procedures." href="#hikari.webhooks.IncomingWebhook.app"
>app</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="application_id -- The ID of the application that created this webhook." href="#hikari.webhooks.IncomingWebhook.application_id"
>application_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="author -- The user that created the webhook …" href="#hikari.webhooks.IncomingWebhook.author"
>author</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_hash -- The avatar hash of the webhook." href="#hikari.webhooks.IncomingWebhook.avatar_hash"
>avatar_hash</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_url -- URL for this webhook's avatar, if set …" href="#hikari.webhooks.PartialWebhook.avatar_url"
>avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="channel_id -- The channel ID this webhook is for." href="#hikari.webhooks.IncomingWebhook.channel_id"
>channel_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="created_at -- When the object was created." href="snowflakes.html#hikari.snowflakes.Unique.created_at"
>created_at</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="default_avatar_url -- Avatar URL for the user, if they have one set …" href="#hikari.webhooks.PartialWebhook.default_avatar_url"
>default_avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete -- Delete this webhook …" href="#hikari.webhooks.IncomingWebhook.delete"
>delete</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_message -- Delete a given message in a given channel …" href="#hikari.webhooks.ExecutableWebhook.delete_message"
>delete_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit -- Edit this webhook …" href="#hikari.webhooks.IncomingWebhook.edit"
>edit</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_message -- Edit a message sent by a webhook …" href="#hikari.webhooks.ExecutableWebhook.edit_message"
>edit_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="execute -- Execute the webhook to create a message …" href="#hikari.webhooks.ExecutableWebhook.execute"
>execute</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel -- Fetch the channel this webhook is for …" href="#hikari.webhooks.IncomingWebhook.fetch_channel"
>fetch_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_message -- Fetch an old message sent by the webhook …" href="#hikari.webhooks.ExecutableWebhook.fetch_message"
>fetch_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_self -- Fetch this webhook …" href="#hikari.webhooks.IncomingWebhook.fetch_self"
>fetch_self</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="guild_id -- The guild ID of the webhook." href="#hikari.webhooks.IncomingWebhook.guild_id"
>guild_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="id -- The ID of this entity." href="#hikari.webhooks.IncomingWebhook.id"
>id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="make_avatar_url -- Generate the avatar URL for this webhook's custom avatar if set …" href="#hikari.webhooks.PartialWebhook.make_avatar_url"
>make_avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mention -- Return a raw mention string for the given webhook's user …" href="#hikari.webhooks.PartialWebhook.mention"
>mention</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="name -- The name of the webhook." href="#hikari.webhooks.IncomingWebhook.name"
>name</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="token -- The token for the webhook …" href="#hikari.webhooks.IncomingWebhook.token"
>token</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="type -- The type of the webhook." href="#hikari.webhooks.IncomingWebhook.type"
>type</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="webhook_id -- ID used to execute this entity as a webhook …" href="#hikari.webhooks.IncomingWebhook.webhook_id"
>webhook_id</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="PartialWebhook -- Base class for all webhook implementations …" href="#hikari.webhooks.PartialWebhook"
>PartialWebhook</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- The client application that models may use for procedures." href="#hikari.webhooks.PartialWebhook.app"
>app</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="application_id -- The ID of the application that created this webhook." href="#hikari.webhooks.PartialWebhook.application_id"
>application_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_hash -- The avatar hash of the webhook." href="#hikari.webhooks.PartialWebhook.avatar_hash"
>avatar_hash</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_url -- URL for this webhook's avatar, if set …" href="#hikari.webhooks.PartialWebhook.avatar_url"
>avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="created_at -- When the object was created." href="snowflakes.html#hikari.snowflakes.Unique.created_at"
>created_at</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="default_avatar_url -- Avatar URL for the user, if they have one set …" href="#hikari.webhooks.PartialWebhook.default_avatar_url"
>default_avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="id -- The ID of this entity." href="#hikari.webhooks.PartialWebhook.id"
>id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="make_avatar_url -- Generate the avatar URL for this webhook's custom avatar if set …" href="#hikari.webhooks.PartialWebhook.make_avatar_url"
>make_avatar_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mention -- Return a raw mention string for the given webhook's user …" href="#hikari.webhooks.PartialWebhook.mention"
>mention</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="name -- The name of the webhook." href="#hikari.webhooks.PartialWebhook.name"
>name</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="type -- The type of the webhook." href="#hikari.webhooks.PartialWebhook.type"
>type</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python enum type. This contains one or more discrete "constant" values.'>enum</abbr></em></small> <a title="WebhookType -- Types of webhook." href="#hikari.webhooks.WebhookType"
>WebhookType</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A variable that should be considered to be a constant value.'>const</abbr></em></small> <a title="APPLICATION -- Application webhook (from the interactions flow)." href="#hikari.webhooks.WebhookType.APPLICATION"
>APPLICATION</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A variable that should be considered to be a constant value.'>const</abbr></em></small> <a title="CHANNEL_FOLLOWER -- Channel Follower webhook." href="#hikari.webhooks.WebhookType.CHANNEL_FOLLOWER"
>CHANNEL_FOLLOWER</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A variable that should be considered to be a constant value.'>const</abbr></em></small> <a title="INCOMING -- Incoming webhook." href="#hikari.webhooks.WebhookType.INCOMING"
>INCOMING</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="name -- Return the name of the enum member as a `builtins.str`." href="internal/enums.html#hikari.internal.enums.Enum.name"
>name</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="value -- Return the value of the enum member." href="internal/enums.html#hikari.internal.enums.Enum.value"
>value</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L1-L1058" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
# Copyright (c) 2021 davfsa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Application and entities that are used to describe webhooks on Discord.&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.List[str] = [
    &#34;ApplicationWebhook&#34;,
    &#34;ChannelFollowerWebhook&#34;,
    &#34;ExecutableWebhook&#34;,
    &#34;PartialWebhook&#34;,
    &#34;WebhookType&#34;,
    &#34;IncomingWebhook&#34;,
]

import abc
import typing

import attr

from hikari import channels as channels_
from hikari import snowflakes
from hikari import undefined
from hikari import urls
from hikari.internal import attr_extensions
from hikari.internal import enums
from hikari.internal import routes

if typing.TYPE_CHECKING:
    from hikari import embeds as embeds_
    from hikari import files
    from hikari import files as files_
    from hikari import guilds as guilds_
    from hikari import messages as messages_
    from hikari import traits
    from hikari import users as users_
    from hikari.api import special_endpoints


@typing.final
class WebhookType(int, enums.Enum):
    &#34;&#34;&#34;Types of webhook.&#34;&#34;&#34;

    INCOMING = 1
    &#34;&#34;&#34;Incoming webhook.&#34;&#34;&#34;

    CHANNEL_FOLLOWER = 2
    &#34;&#34;&#34;Channel Follower webhook.&#34;&#34;&#34;

    APPLICATION = 3
    &#34;&#34;&#34;Application webhook (from the interactions flow).&#34;&#34;&#34;


class ExecutableWebhook(abc.ABC):
    &#34;&#34;&#34;An abstract class with logic for executing entities as webhooks.&#34;&#34;&#34;

    # This is a mixin, do not add slotted fields.
    __slots__: typing.Sequence[str] = ()

    @property
    @abc.abstractmethod
    def app(self) -&gt; traits.RESTAware:
        &#34;&#34;&#34;Client application that models may use for procedures.

        Returns
        -------
        hikari.traits.RESTAware
            The client application that models may use for procedures.
        &#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def webhook_id(self) -&gt; snowflakes.Snowflake:
        &#34;&#34;&#34;ID used to execute this entity as a webhook.

        Returns
        -------
        hikari.snowflakes.Snowflake
            The ID used to execute this entity as a webhook.
        &#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def token(self) -&gt; typing.Optional[str]:
        &#34;&#34;&#34;Webhook&#39;s token.

        !!! info
            If this is `builtins.None` then the methods provided by `ExecutableWebhook`
            will always raise a `builtins.ValueError`.

        Returns
        -------
        typing.Optional[builtins.str]
            The token for the webhook if known, else `builtins.None`.
        &#34;&#34;&#34;

    async def execute(
        self,
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files_.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files_.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users_.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds_.PartialRole], bool]
        ] = undefined.UNDEFINED,
        flags: typing.Union[undefined.UndefinedType, int, messages_.MessageFlag] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Execute the webhook to create a message.

        Parameters
        ----------
        content : hikari.undefined.UndefinedOr[typing.Any]
            If provided, the message contents. If
            `hikari.undefined.UNDEFINED`, then nothing will be sent
            in the content. Any other value here will be cast to a
            `builtins.str`.

            If this is a `hikari.embeds.Embed` and no `embed` kwarg is
            provided, then this will instead update the embed. This allows for
            simpler syntax when sending an embed alone.

            Likewise, if this is a `hikari.files.Resource`, then the
            content is instead treated as an attachment if no `attachment` and
            no `attachments` kwargs are provided.

        Other Parameters
        ----------------
        username : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the username to override the webhook&#39;s username
            for this request.
        avatar_url : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the url of an image to override the webhook&#39;s
            avatar with for this request.
        tts : hikari.undefined.UndefinedOr[bool]
            If provided, whether the message will be sent as a TTS message.
        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
            If provided, the message attachment. This can be a resource,
            or string of a path on your computer or a URL.
        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]
            If provided, the message attachments. These can be resources, or
            strings consisting of paths on your computer or URLs.
        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]
            If provided, builder object of the component to include in this message.
        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]
            If provided, a sequence of the component builder objects to include
            in this message.
        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
            If provided, the message embed.
        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]
            If provided, the message embeds.
        mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the message should parse @everyone/@here
            mentions.
        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool]]
            If provided, and `builtins.True`, all mentions will be parsed.
            If provided, and `builtins.False`, no mentions will be parsed.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.users.PartialUser` derivatives to enforce mentioning
            specific users.
        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool]]
            If provided, and `builtins.True`, all mentions will be parsed.
            If provided, and `builtins.False`, no mentions will be parsed.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.guilds.PartialRole` derivatives to enforce mentioning
            specific roles.
        flags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag]
            The flags to set for this webhook message.

            !!! warning
                As of writing this can only be set for interaction webhooks
                and the only settable flag is EPHEMERAL; this field is just
                ignored for non-interaction webhooks.

        !!! warning
            As of writing, `username` and `avatar_url` are ignored for
            interaction webhooks.

        Returns
        -------
        hikari.messages.Message
            The created message object.

        Raises
        ------
        hikari.errors.NotFoundError
            If the current webhook is not found.
        hikari.errors.BadRequestError
            This can be raised if the file is too large; if the embed exceeds
            the defined limits; if the message content is specified only and
            empty or greater than `2000` characters; if neither content, file
            or embeds are specified.
            If any invalid snowflake IDs are passed; a snowflake may be invalid
            due to it being outside of the range of a 64 bit integer.
        hikari.errors.UnauthorizedError
            If you pass a token that&#39;s invalid for the target webhook.
        builtins.ValueError
            If either `ExecutableWebhook.token` is `builtins.None` or more than 100 unique
            objects/entities are passed for `role_mentions` or `user_mentions or
            if `token` is not available.
        builtins.TypeError
            If both `attachment` and `attachments` are specified.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        if not self.token:
            raise ValueError(&#34;Cannot send a message using a webhook where we don&#39;t know the token&#34;)

        return await self.app.rest.execute_webhook(
            webhook=self.webhook_id,
            token=self.token,
            content=content,
            username=username,
            avatar_url=avatar_url,
            tts=tts,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            mentions_everyone=mentions_everyone,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
            flags=flags,
        )

    async def fetch_message(self, message: snowflakes.SnowflakeishOr[messages_.Message]) -&gt; messages_.Message:
        &#34;&#34;&#34;Fetch an old message sent by the webhook.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to fetch. This may be the object or the ID of an
            existing channel.

        Returns
        -------
        hikari.messages.Message
            The requested message.

        Raises
        ------
        builtins.ValueError
            If `token` is not available.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhook is not found or the webhook&#39;s message wasn&#39;t found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        if self.token is None:
            raise ValueError(&#34;Cannot fetch a message using a webhook where we don&#39;t know the token&#34;)

        return await self.app.rest.fetch_webhook_message(self.webhook_id, token=self.token, message=message)

    async def edit_message(
        self,
        message: snowflakes.SnowflakeishOr[messages_.Message],
        content: undefined.UndefinedNoneOr[typing.Any] = undefined.UNDEFINED,
        *,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedNoneOr[
            typing.Sequence[special_endpoints.ComponentBuilder]
        ] = undefined.UNDEFINED,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        replace_attachments: bool = False,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users_.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds_.PartialRole], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Edit a message sent by a webhook.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete. This may be the object or the ID of
            an existing message.
        content : hikari.undefined.UndefinedNoneOr[typing.Any]
            If provided, the message contents. If
            `hikari.undefined.UNDEFINED`, then nothing will be sent
            in the content. Any other value here will be cast to a
            `builtins.str`.

            If this is a `hikari.embeds.Embed` and no `embed` nor
            no `embeds` kwarg is provided, then this will instead
            update the embed. This allows for simpler syntax when
            sending an embed alone.

            Likewise, if this is a `hikari.files.Resource`, then the
            content is instead treated as an attachment if no `attachment` and
            no `attachments` kwargs are provided.

        Other Parameters
        ----------------
        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
            If provided, the attachment to set on the message. If
            `hikari.undefined.UNDEFINED`, the previous attachment, if
            present, is not changed. If this is `builtins.None`, then the
            attachment is removed, if present. Otherwise, the new attachment
            that was provided will be attached.
        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]
            If provided, the attachments to set on the message. If
            `hikari.undefined.UNDEFINED`, the previous attachments, if
            present, are not changed. If this is `builtins.None`, then the
            attachments is removed, if present. Otherwise, the new attachments
            that were provided will be attached.
        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]
            If provided, builder object of the component to set for this message.
            This component will replace any previously set components and passing
            `builtins.None` will remove all components.
        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]
            If provided, a sequence of the component builder objects set for
            this message. These components will replace any previously set
            components and passing `builtins.None` or an empty sequence will
            remove all components.
        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]
            If provided, the embed to set on the message. If
            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.
            If this is `builtins.None` then any present embeds are removed.
            Otherwise, the new embed that was provided will be used as the
            replacement.
        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]
            If provided, the embeds to set on the message. If
            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.
            If this is `builtins.None` then any present embeds are removed.
            Otherwise, the new embeds that were provided will be used as the
            replacement.
        replace_attachments: bool
            Whether to replace the attachments with the provided ones. Defaults
            to `builtins.False`.

            Note this will also overwrite the embed attachments.
        mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, sanitation for `@everyone` mentions. If
            `hikari.undefined.UNDEFINED`, then the previous setting is
            not changed. If `builtins.True`, then `@everyone`/`@here` mentions
            in the message content will show up as mentioning everyone that can
            view the chat.
        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool]]
            If provided, and `builtins.True`, all user mentions will be detected.
            If provided, and `builtins.False`, all user mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.users.PartialUser` derivatives to enforce mentioning
            specific users.
        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool]]
            If provided, and `builtins.True`, all role mentions will be detected.
            If provided, and `builtins.False`, all role mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.guilds.PartialRole` derivatives to enforce mentioning
            specific roles.

        !!! note
            Mentioning everyone, roles, or users in message edits currently
            will not send a push notification showing a new mention to people
            on Discord. It will still highlight in their chat as if they
            were mentioned, however.

        !!! warning
            If you specify a non-embed `content`, `mentions_everyone`,
            `mentions_reply`, `user_mentions`, and `role_mentions` will default
            to `builtins.False` as the message will be re-parsed for mentions.

            This is a limitation of Discord&#39;s design. If in doubt, specify all
            three of them each time.

        !!! warning
            If you specify one of `mentions_everyone`, `mentions_reply`,
            `user_mentions`, or `role_mentions`, then all others will default to
            `builtins.False`, even if they were enabled previously.

            This is a limitation of Discord&#39;s design. If in doubt, specify all
            three of them each time.

        Returns
        -------
        hikari.messages.Message
            The edited message.

        Raises
        ------
        builtins.ValueError
            If more than 100 unique objects/entities are passed for
            `role_mentions` or `user_mentions` or `token` is not available.
        builtins.TypeError
            If both `attachment` and `attachments` are specified or if both
            `embed` and `embeds` are specified.
        hikari.errors.BadRequestError
            This may be raised in several discrete situations, such as messages
            being empty with no attachments or embeds; messages with more than
            2000 characters in them, embeds that exceed one of the many embed
            limits; too many attachments; attachments that are too large;
            too many components.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhook or the message are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        if self.token is None:
            raise ValueError(&#34;Cannot edit a message using a webhook where we don&#39;t know the token&#34;)

        return await self.app.rest.edit_webhook_message(
            self.webhook_id,
            token=self.token,
            message=message,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            replace_attachments=replace_attachments,
            mentions_everyone=mentions_everyone,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
        )

    async def delete_message(self, message: snowflakes.SnowflakeishOr[messages_.Message]) -&gt; None:
        &#34;&#34;&#34;Delete a given message in a given channel.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete. This may be the object or the ID of
            an existing message.

        Raises
        ------
        builtins.ValueError
            If `token` is not available.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhook or the message are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        if self.token is None:
            raise ValueError(&#34;Cannot delete a message using a webhook where we don&#39;t know the token&#34;)

        await self.app.rest.delete_webhook_message(self.webhook_id, token=self.token, message=message)


@attr_extensions.with_copy
@attr.define(hash=True, kw_only=True, weakref_slot=False)
class PartialWebhook(snowflakes.Unique):
    &#34;&#34;&#34;Base class for all webhook implementations.&#34;&#34;&#34;

    app: traits.RESTAware = attr.field(
        repr=False, eq=False, hash=False, metadata={attr_extensions.SKIP_DEEP_COPY: True}
    )
    &#34;&#34;&#34;The client application that models may use for procedures.&#34;&#34;&#34;

    id: snowflakes.Snowflake = attr.field(hash=True, repr=True)
    &#34;&#34;&#34;The ID of this entity.&#34;&#34;&#34;

    type: typing.Union[WebhookType, int] = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The type of the webhook.&#34;&#34;&#34;

    name: str = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The name of the webhook.&#34;&#34;&#34;

    avatar_hash: typing.Optional[str] = attr.field(eq=False, hash=False, repr=False)
    &#34;&#34;&#34;The avatar hash of the webhook.&#34;&#34;&#34;

    application_id: typing.Optional[snowflakes.Snowflake] = attr.field(eq=False, hash=False, repr=False)
    &#34;&#34;&#34;The ID of the application that created this webhook.&#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return self.name if self.name is not None else f&#34;Unnamed webhook ID {self.id}&#34;

    @property
    def mention(self) -&gt; str:
        &#34;&#34;&#34;Return a raw mention string for the given webhook&#39;s user.

        !!! note
            This exists purely for consistency. Webhooks do not receive events
            from the gateway, and without some bot backend to support it, will
            not be able to detect mentions of their webhook.

        Example
        -------

        ```py
        &gt;&gt;&gt; some_webhook.mention
        &#39;&lt;@123456789123456789&gt;&#39;
        ```

        Returns
        -------
        builtins.str
            The mention string to use.
        &#34;&#34;&#34;
        return f&#34;&lt;@{self.id}&gt;&#34;

    @property
    def avatar_url(self) -&gt; typing.Optional[files_.URL]:
        &#34;&#34;&#34;URL for this webhook&#39;s avatar, if set.

        May be `builtins.None` if no avatar is set. In this case, you should use
        `default_avatar_url` instead.
        &#34;&#34;&#34;
        return self.make_avatar_url()

    @property
    def default_avatar_url(self) -&gt; files_.URL:
        &#34;&#34;&#34;Avatar URL for the user, if they have one set.

        May be `builtins.None` if no custom avatar is set. In this case, you
        should use `default_avatar_url` instead.
        &#34;&#34;&#34;
        return routes.CDN_DEFAULT_USER_AVATAR.compile_to_file(
            urls.CDN_URL,
            discriminator=0,
            file_format=&#34;png&#34;,
        )

    def make_avatar_url(self, ext: str = &#34;png&#34;, size: int = 4096) -&gt; typing.Optional[files_.URL]:
        &#34;&#34;&#34;Generate the avatar URL for this webhook&#39;s custom avatar if set.

        If no avatar is specified, return `None`. In this case, you should
        use `default_avatar` instead.

        Parameters
        ----------
        ext : builtins.str
            The extension to use for this URL, defaults to `png`.
            Supports `png`, `jpeg`, `jpg` and `webp`.
        size : builtins.int
            The size to set for the URL, defaults to `4096`.
            Can be any power of two between 16 and 4096.
            Will be ignored for default avatars.

        Returns
        -------
        typing.Optional[hikari.files.URL]
            The URL of the resource. `builtins.None` if no avatar is set (in
            this case, use the `default_avatar` instead).

        Raises
        ------
        builtins.ValueError
            If `size` is not a power of two between 16 and 4096 (inclusive).
        &#34;&#34;&#34;
        if self.avatar_hash is None:
            return None

        return routes.CDN_USER_AVATAR.compile_to_file(
            urls.CDN_URL,
            user_id=self.id,
            hash=self.avatar_hash,
            size=size,
            file_format=ext,
        )


@attr.define(hash=True, kw_only=True, weakref_slot=False)
class IncomingWebhook(PartialWebhook, ExecutableWebhook):
    &#34;&#34;&#34;Represents an incoming webhook object on Discord.

    This is an endpoint that can have messages sent to it using standard
    HTTP requests, which enables external services that are not bots to
    send informational messages to specific channels.
    &#34;&#34;&#34;

    channel_id: snowflakes.Snowflake = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The channel ID this webhook is for.&#34;&#34;&#34;

    guild_id: snowflakes.Snowflake = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The guild ID of the webhook.&#34;&#34;&#34;

    author: typing.Optional[users_.User] = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The user that created the webhook

    !!! info
        This will be `builtins.None` when fetched with the webhook&#39;s token
        rather than bot authorization or when received within audit logs.
    &#34;&#34;&#34;

    token: typing.Optional[str] = attr.field(eq=False, hash=False, repr=False)
    &#34;&#34;&#34;The token for the webhook.

    !!! info
        This is only available for incoming webhooks that are created in the
        channel settings.
    &#34;&#34;&#34;

    @property
    def webhook_id(self) -&gt; snowflakes.Snowflake:
        # &lt;&lt;inherited docstring from ExecutableWebhook&gt;&gt;.
        return self.id

    async def delete(self, *, use_token: undefined.UndefinedOr[bool] = undefined.UNDEFINED) -&gt; None:
        &#34;&#34;&#34;Delete this webhook.

        Other Parameters
        ----------------
        use_token : hikari.undefined.UndefinedOr[builtins.bool]
            If set to `builtins.True` then the webhook&#39;s token will be used for
            this request; if set to `builtins.False` then bot authorization will
            be used; if not specified then the webhook&#39;s token will be used for
            the request if it&#39;s set else bot authorization.

        Raises
        ------
        hikari.errors.NotFoundError
            If this webhook is not found.
        hikari.errors.ForbiddenError
            If you either lack the `MANAGE_WEBHOOKS` permission or
            are not a member of the guild this webhook belongs to.
        builtins.ValueError
            If `use_token` is passed as `builtins.True` when `IncomingWebhook.token` is
            `builtins.None`.
        &#34;&#34;&#34;
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED
        if use_token:
            if self.token is None:
                raise ValueError(&#34;This webhook&#39;s token is unknown, so cannot be used&#34;)
            token = self.token

        elif use_token is undefined.UNDEFINED and self.token:
            token = self.token

        await self.app.rest.delete_webhook(self.id, token=token)

    async def edit(
        self,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files_.Resource[files_.AsyncReader]] = undefined.UNDEFINED,
        channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.WebhookChannelT]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        use_token: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; IncomingWebhook:
        &#34;&#34;&#34;Edit this webhook.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new name string.
        avatar : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
            If provided, the new avatar image. If `builtins.None`, then
            it is removed. If not specified, nothing is changed.
        channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]]
            If provided, the object or ID of the new channel the given
            webhook should be moved to.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the audit log reason explaining why the operation
            was performed. This field will be used when using the webhook&#39;s
            token rather than bot authorization.
        use_token : hikari.undefined.UndefinedOr[builtins.bool]
            If set to `builtins.True` then the webhook&#39;s token will be used for
            this request; if set to `builtins.False` then bot authorization will
            be used; if not specified then the webhook&#39;s token will be used for
            the request if it&#39;s set else bot authorization.

        Returns
        -------
        IncomingWebhook
            The updated webhook object.

        Raises
        ------
        builtins.ValueError
            If `use_token` is passed as `builtins.True` when `IncomingWebhook.token` is `builtins.None`.
        hikari.errors.BadRequestError
            If any invalid snowflake IDs are passed; a snowflake may be invalid
            due to it being outside of the range of a 64 bit integer.
        hikari.errors.NotFoundError
            If either the webhook or the channel are not found.
        hikari.errors.ForbiddenError
            If you either lack the `MANAGE_WEBHOOKS` permission or
            are not a member of the guild this webhook belongs to.
        hikari.errors.UnauthorizedError
            If you pass a token that&#39;s invalid for the target webhook.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED
        if use_token:
            if self.token is None:
                raise ValueError(&#34;This webhook&#39;s token is unknown, so cannot be used&#34;)
            token = self.token

        elif use_token is undefined.UNDEFINED and self.token:
            token = self.token

        webhook = await self.app.rest.edit_webhook(
            self.id,
            token=token,
            name=name,
            avatar=avatar,
            channel=channel,
            reason=reason,
        )
        assert isinstance(webhook, IncomingWebhook)
        return webhook

    async def fetch_channel(self) -&gt; channels_.WebhookChannelT:
        &#34;&#34;&#34;Fetch the channel this webhook is for.

        Returns
        -------
        hikari.channels.WebhookChannelT
            The object of the channel this webhook targets.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you don&#39;t have access to the channel this webhook belongs to.
        hikari.errors.NotFoundError
            If the channel this message was created in does not exist.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        channel = await self.app.rest.fetch_channel(self.channel_id)
        assert isinstance(channel, channels_.WebhookChannelTypes)
        return channel

    async def fetch_self(self, *, use_token: undefined.UndefinedOr[bool] = undefined.UNDEFINED) -&gt; IncomingWebhook:
        &#34;&#34;&#34;Fetch this webhook.

        Other Parameters
        ----------------
        use_token : hikari.undefined.UndefinedOr[builtins.bool]
            If set to `builtins.True` then the webhook&#39;s token will be used for
            this request; if set to `builtins.False` then bot authorization will
            be used; if not specified then the webhook&#39;s token will be used for
            the request if it&#39;s set else bot authorization.

        Returns
        -------
        IncomingWebhook
            The requested webhook object.

        Raises
        ------
        builtins.ValueError
            If `use_token` is passed as `builtins.True` when `Webhook.token`
            is `builtins.None`.
        hikari.errors.ForbiddenError
            If you&#39;re not in the guild that owns this webhook or
            lack the `MANAGE_WEBHOOKS` permission.
        hikari.errors.NotFoundError
            If the webhook is not found.
        hikari.errors.UnauthorizedError
            If you pass a token that&#39;s invalid for the target webhook.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED
        if use_token:
            if self.token is None:
                raise ValueError(&#34;This webhook&#39;s token is unknown, so cannot be used&#34;)
            token = self.token

        elif use_token is undefined.UNDEFINED and self.token:
            token = self.token

        webhook = await self.app.rest.fetch_webhook(self.id, token=token)
        assert isinstance(webhook, IncomingWebhook)
        return webhook


@attr.define(hash=True, kw_only=True, weakref_slot=False)
class ChannelFollowerWebhook(PartialWebhook):
    &#34;&#34;&#34;Represents a channel follower webhook object on Discord.&#34;&#34;&#34;

    channel_id: snowflakes.Snowflake = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The channel ID this webhook is for.&#34;&#34;&#34;

    guild_id: snowflakes.Snowflake = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The guild ID of the webhook.&#34;&#34;&#34;

    author: typing.Optional[users_.User] = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The user that created the webhook

    !!! info
        This will be `builtins.None` when received within an audit log.
    &#34;&#34;&#34;

    source_channel: channels_.PartialChannel = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The partial object of the channel this webhook is following.&#34;&#34;&#34;

    source_guild: guilds_.PartialGuild = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The partial object of the guild this webhook is following.&#34;&#34;&#34;

    async def delete(self) -&gt; None:
        &#34;&#34;&#34;Delete this webhook.

        Raises
        ------
        hikari.errors.NotFoundError
            If this webhook is not found.
        hikari.errors.ForbiddenError
            If you either lack the `MANAGE_WEBHOOKS` permission or
            are not a member of the guild this webhook belongs to.
        &#34;&#34;&#34;
        await self.app.rest.delete_webhook(self.id)

    async def edit(
        self,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files_.Resource[files_.AsyncReader]] = undefined.UNDEFINED,
        channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.WebhookChannelT]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; ChannelFollowerWebhook:
        &#34;&#34;&#34;Edit this webhook.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new name string.
        avatar : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
            If provided, the new avatar image. If `builtins.None`, then
            it is removed. If not specified, nothing is changed.
        channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]]
            If provided, the object or ID of the new channel the given
            webhook should be moved to.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the audit log reason explaining why the operation
            was performed. This field will be used when using the webhook&#39;s
            token rather than bot authorization.

        Returns
        -------
        hikari.webhooks.ChannelFollowerWebhook
            The updated webhook object.

        Raises
        ------
        hikari.errors.BadRequestError
            If any invalid snowflake IDs are passed; a snowflake may be invalid
            due to it being outside of the range of a 64 bit integer.
        hikari.errors.NotFoundError
            If either the webhook or the channel are not found.
        hikari.errors.ForbiddenError
            If you either lack the `MANAGE_WEBHOOKS` permission or
            are not a member of the guild this webhook belongs to.
        hikari.errors.UnauthorizedError
            If you pass a token that&#39;s invalid for the target webhook.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        webhook = await self.app.rest.edit_webhook(
            self.id,
            name=name,
            avatar=avatar,
            channel=channel,
            reason=reason,
        )
        assert isinstance(webhook, ChannelFollowerWebhook)
        return webhook

    async def fetch_channel(self) -&gt; channels_.WebhookChannelT:
        &#34;&#34;&#34;Fetch the channel this webhook is for.

        Returns
        -------
        hikari.channels.WebhookChannelT
            The object of the channel this webhook targets.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you don&#39;t have access to the channel this webhook belongs to.
        hikari.errors.NotFoundError
            If the channel this message was created in does not exist.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        channel = await self.app.rest.fetch_channel(self.channel_id)
        assert isinstance(channel, channels_.WebhookChannelTypes)
        return channel

    async def fetch_self(self) -&gt; ChannelFollowerWebhook:
        &#34;&#34;&#34;Fetch this webhook.

        Returns
        -------
        hikari.webhooks.ChannelFollowerWebhook
            The requested webhook object.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you&#39;re not in the guild that owns this webhook or
            lack the `MANAGE_WEBHOOKS` permission.
        hikari.errors.NotFoundError
            If the webhook is not found.
        hikari.errors.UnauthorizedError
            If you pass a token that&#39;s invalid for the target webhook.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        webhook = await self.app.rest.fetch_webhook(self.id)
        assert isinstance(webhook, ChannelFollowerWebhook)
        return webhook


@attr.define(hash=True, kw_only=True, weakref_slot=False)
class ApplicationWebhook(PartialWebhook):
    &#34;&#34;&#34;Represents an application webhook object on Discord.

    This is from the interactions flow.
    &#34;&#34;&#34;

    application_id: snowflakes.Snowflake = attr.ib()
    # &lt;&lt;inherited docstring from PartialWebhook&gt;&gt;.</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.webhooks.ApplicationWebhook" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ApplicationWebhook -- Represents an application webhook object on Discord …" href="#hikari.webhooks.ApplicationWebhook"
>ApplicationWebhook</a></h4>
</dt>
<dd>
<pre><code id="hikari.webhooks.ApplicationWebhook" class="hljs python"><abbr title='A standard Python type.'>class</abbr> ApplicationWebhook (
    *,
    app: <a href='traits.html#hikari.traits.RESTAware'>traits.RESTAware</a>,
    id: <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    type: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='#hikari.webhooks.WebhookType'>WebhookType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    avatar_hash: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    application_id: <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
): ...</code></pre>
<p>Represents an application webhook object on Discord.</p>
<p>This is from the interactions flow.</p>
<p>Method generated by attrs for class ApplicationWebhook.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L1051-L1058" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class ApplicationWebhook(PartialWebhook):
    &#34;&#34;&#34;Represents an application webhook object on Discord.

    This is from the interactions flow.
    &#34;&#34;&#34;

    application_id: snowflakes.Snowflake = attr.ib()
    # &lt;&lt;inherited docstring from PartialWebhook&gt;&gt;.</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ApplicationWebhook -- Represents an application webhook object on Discord …" href="#hikari.webhooks.ApplicationWebhook"
>ApplicationWebhook</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="PartialWebhook -- Base class for all webhook implementations …" href="#hikari.webhooks.PartialWebhook"
>PartialWebhook</a></dt>
<dd class="nested"><p>Base class for all webhook implementations …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Unique -- Mixin for a class that enforces uniqueness by a snowflake ID." href="snowflakes.html#hikari.snowflakes.Unique"
>Unique</a></dt>
<dd class="nested"><p>Mixin for a class that enforces uniqueness by a snowflake ID.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.webhooks.ApplicationWebhook.app" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- The client application that models may use for procedures." href="#hikari.webhooks.ApplicationWebhook.app"  >app</a> : <a href='traits.html#hikari.traits.RESTAware'>traits.RESTAware</a></code></pre>
</dt>
<dd><p>The client application that models may use for procedures.</p></dd>
</div>
<div id="hikari.webhooks.ApplicationWebhook.application_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="application_id -- Return an attribute of instance, which is of type owner." href="#hikari.webhooks.ApplicationWebhook.application_id"  >application_id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>Return an attribute of instance, which is of type owner.</p></dd>
</div>
<div id="hikari.webhooks.ApplicationWebhook.avatar_hash" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_hash -- The avatar hash of the webhook." href="#hikari.webhooks.ApplicationWebhook.avatar_hash"  >avatar_hash</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>The avatar hash of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.ApplicationWebhook.avatar_url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_url -- URL for this webhook's avatar, if set …" href="#hikari.webhooks.PartialWebhook.avatar_url"  >avatar_url</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>files_.URL</a>]</code></pre>
</dt>
<dd><p>URL for this webhook's avatar, if set.</p>
<p>May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no avatar is set. In this case, you should use
<code>default_avatar_url</code> instead.</p></dd>
</div>
<div id="hikari.webhooks.ApplicationWebhook.created_at" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="created_at -- When the object was created." href="snowflakes.html#hikari.snowflakes.Unique.created_at"  >created_at</a> : <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code></pre>
</dt>
<dd><p>When the object was created.</p></dd>
</div>
<div id="hikari.webhooks.ApplicationWebhook.default_avatar_url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="default_avatar_url -- Avatar URL for the user, if they have one set …" href="#hikari.webhooks.PartialWebhook.default_avatar_url"  >default_avatar_url</a> : <a href='files.html#hikari.files.URL'>files_.URL</a></code></pre>
</dt>
<dd><p>Avatar URL for the user, if they have one set.</p>
<p>May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no custom avatar is set. In this case, you
should use <code>default_avatar_url</code> instead.</p></dd>
</div>
<div id="hikari.webhooks.ApplicationWebhook.id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="id -- The ID of this entity." href="#hikari.webhooks.ApplicationWebhook.id"  >id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>The ID of this entity.</p></dd>
</div>
<div id="hikari.webhooks.ApplicationWebhook.mention" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mention -- Return a raw mention string for the given webhook's user …" href="#hikari.webhooks.PartialWebhook.mention"  >mention</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Return a raw mention string for the given webhook's user.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This exists purely for consistency. Webhooks do not receive events
from the gateway, and without some bot backend to support it, will
not be able to detect mentions of their webhook.</p>
</div>
<h2 id="example">Example</h2>
<pre><code class="language-py">&gt;&gt;&gt; some_webhook.mention
'&lt;@123456789123456789&gt;'
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The mention string to use.</dd>
</dl></dd>
</div>
<div id="hikari.webhooks.ApplicationWebhook.name" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="name -- The name of the webhook." href="#hikari.webhooks.ApplicationWebhook.name"  >name</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>The name of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.ApplicationWebhook.type" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="type -- The type of the webhook." href="#hikari.webhooks.ApplicationWebhook.type"  >type</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='#hikari.webhooks.WebhookType'>WebhookType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></pre>
</dt>
<dd><p>The type of the webhook.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.webhooks.ApplicationWebhook.make_avatar_url" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="make_avatar_url" href="#hikari.webhooks.PartialWebhook.make_avatar_url" id="hikari.webhooks.ApplicationWebhook.make_avatar_url">make_avatar_url</a>(
    ext: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a> = 'png',
    size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 4096,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>files_.URL</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="PartialWebhook -- Base class for all webhook implementations …" href="#hikari.webhooks.PartialWebhook"
>PartialWebhook</a></code>.<code><a title="make_avatar_url -- Generate the avatar URL for this webhook's custom avatar if set …" href="#hikari.webhooks.PartialWebhook.make_avatar_url"
>make_avatar_url</a></code>
</p>
<p>Generate the avatar URL for this webhook's custom avatar if set.</p>
<p>If no avatar is specified, return <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>. In this case, you should
use <code>default_avatar</code> instead.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ext</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The extension to use for this URL, defaults to <code>png</code>.
Supports <code>png</code>, <code>jpeg</code>, <code>jpg</code> and <code>webp</code>.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The size to set for the URL, defaults to <code>4096</code>.
Can be any power of two between 16 and 4096.
Will be ignored for default avatars.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>URL</a>]</code></dt>
<dd>The URL of the resource. <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no avatar is set (in
this case, use the <code>default_avatar</code> instead).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code>size</code> is not a power of two between 16 and 4096 (inclusive).</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ChannelFollowerWebhook -- Represents a channel follower webhook object on Discord …" href="#hikari.webhooks.ChannelFollowerWebhook"
>ChannelFollowerWebhook</a></h4>
</dt>
<dd>
<pre><code id="hikari.webhooks.ChannelFollowerWebhook" class="hljs python"><abbr title='A standard Python type.'>class</abbr> ChannelFollowerWebhook (
    *,
    app: <a href='traits.html#hikari.traits.RESTAware'>traits.RESTAware</a>,
    id: <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    type: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='#hikari.webhooks.WebhookType'>WebhookType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    avatar_hash: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    application_id: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>],
    channel_id: <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    guild_id: <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    author: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='users.html#hikari.users.User'>users_.User</a>],
    source_channel: <a href='channels.html#hikari.channels.PartialChannel'>channels_.PartialChannel</a>,
    source_guild: <a href='guilds.html#hikari.guilds.PartialGuild'>guilds_.PartialGuild</a>,
): ...</code></pre>
<p>Represents a channel follower webhook object on Discord.</p>
<p>Method generated by attrs for class ChannelFollowerWebhook.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L879-L1047" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class ChannelFollowerWebhook(PartialWebhook):
    &#34;&#34;&#34;Represents a channel follower webhook object on Discord.&#34;&#34;&#34;

    channel_id: snowflakes.Snowflake = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The channel ID this webhook is for.&#34;&#34;&#34;

    guild_id: snowflakes.Snowflake = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The guild ID of the webhook.&#34;&#34;&#34;

    author: typing.Optional[users_.User] = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The user that created the webhook

    !!! info
        This will be `builtins.None` when received within an audit log.
    &#34;&#34;&#34;

    source_channel: channels_.PartialChannel = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The partial object of the channel this webhook is following.&#34;&#34;&#34;

    source_guild: guilds_.PartialGuild = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The partial object of the guild this webhook is following.&#34;&#34;&#34;

    async def delete(self) -&gt; None:
        &#34;&#34;&#34;Delete this webhook.

        Raises
        ------
        hikari.errors.NotFoundError
            If this webhook is not found.
        hikari.errors.ForbiddenError
            If you either lack the `MANAGE_WEBHOOKS` permission or
            are not a member of the guild this webhook belongs to.
        &#34;&#34;&#34;
        await self.app.rest.delete_webhook(self.id)

    async def edit(
        self,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files_.Resource[files_.AsyncReader]] = undefined.UNDEFINED,
        channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.WebhookChannelT]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; ChannelFollowerWebhook:
        &#34;&#34;&#34;Edit this webhook.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new name string.
        avatar : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
            If provided, the new avatar image. If `builtins.None`, then
            it is removed. If not specified, nothing is changed.
        channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]]
            If provided, the object or ID of the new channel the given
            webhook should be moved to.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the audit log reason explaining why the operation
            was performed. This field will be used when using the webhook&#39;s
            token rather than bot authorization.

        Returns
        -------
        hikari.webhooks.ChannelFollowerWebhook
            The updated webhook object.

        Raises
        ------
        hikari.errors.BadRequestError
            If any invalid snowflake IDs are passed; a snowflake may be invalid
            due to it being outside of the range of a 64 bit integer.
        hikari.errors.NotFoundError
            If either the webhook or the channel are not found.
        hikari.errors.ForbiddenError
            If you either lack the `MANAGE_WEBHOOKS` permission or
            are not a member of the guild this webhook belongs to.
        hikari.errors.UnauthorizedError
            If you pass a token that&#39;s invalid for the target webhook.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        webhook = await self.app.rest.edit_webhook(
            self.id,
            name=name,
            avatar=avatar,
            channel=channel,
            reason=reason,
        )
        assert isinstance(webhook, ChannelFollowerWebhook)
        return webhook

    async def fetch_channel(self) -&gt; channels_.WebhookChannelT:
        &#34;&#34;&#34;Fetch the channel this webhook is for.

        Returns
        -------
        hikari.channels.WebhookChannelT
            The object of the channel this webhook targets.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you don&#39;t have access to the channel this webhook belongs to.
        hikari.errors.NotFoundError
            If the channel this message was created in does not exist.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        channel = await self.app.rest.fetch_channel(self.channel_id)
        assert isinstance(channel, channels_.WebhookChannelTypes)
        return channel

    async def fetch_self(self) -&gt; ChannelFollowerWebhook:
        &#34;&#34;&#34;Fetch this webhook.

        Returns
        -------
        hikari.webhooks.ChannelFollowerWebhook
            The requested webhook object.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you&#39;re not in the guild that owns this webhook or
            lack the `MANAGE_WEBHOOKS` permission.
        hikari.errors.NotFoundError
            If the webhook is not found.
        hikari.errors.UnauthorizedError
            If you pass a token that&#39;s invalid for the target webhook.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        webhook = await self.app.rest.fetch_webhook(self.id)
        assert isinstance(webhook, ChannelFollowerWebhook)
        return webhook</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ChannelFollowerWebhook -- Represents a channel follower webhook object on Discord …" href="#hikari.webhooks.ChannelFollowerWebhook"
>ChannelFollowerWebhook</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="PartialWebhook -- Base class for all webhook implementations …" href="#hikari.webhooks.PartialWebhook"
>PartialWebhook</a></dt>
<dd class="nested"><p>Base class for all webhook implementations …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Unique -- Mixin for a class that enforces uniqueness by a snowflake ID." href="snowflakes.html#hikari.snowflakes.Unique"
>Unique</a></dt>
<dd class="nested"><p>Mixin for a class that enforces uniqueness by a snowflake ID.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.webhooks.ChannelFollowerWebhook.app" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- The client application that models may use for procedures." href="#hikari.webhooks.ChannelFollowerWebhook.app"  >app</a> : <a href='traits.html#hikari.traits.RESTAware'>traits.RESTAware</a></code></pre>
</dt>
<dd><p>The client application that models may use for procedures.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.application_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="application_id -- The ID of the application that created this webhook." href="#hikari.webhooks.ChannelFollowerWebhook.application_id"  >application_id</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>]</code></pre>
</dt>
<dd><p>The ID of the application that created this webhook.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.author" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="author -- The user that created the webhook …" href="#hikari.webhooks.ChannelFollowerWebhook.author"  >author</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='users.html#hikari.users.User'>users_.User</a>]</code></pre>
</dt>
<dd><p>The user that created the webhook</p>
<div class="alert alert-primary">
<p class="admonition-title">Info</p>
<p>This will be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> when received within an audit log.</p>
</div></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.avatar_hash" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_hash -- The avatar hash of the webhook." href="#hikari.webhooks.ChannelFollowerWebhook.avatar_hash"  >avatar_hash</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>The avatar hash of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.avatar_url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_url -- URL for this webhook's avatar, if set …" href="#hikari.webhooks.PartialWebhook.avatar_url"  >avatar_url</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>files_.URL</a>]</code></pre>
</dt>
<dd><p>URL for this webhook's avatar, if set.</p>
<p>May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no avatar is set. In this case, you should use
<code>default_avatar_url</code> instead.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.channel_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="channel_id -- The channel ID this webhook is for." href="#hikari.webhooks.ChannelFollowerWebhook.channel_id"  >channel_id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>The channel ID this webhook is for.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.created_at" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="created_at -- When the object was created." href="snowflakes.html#hikari.snowflakes.Unique.created_at"  >created_at</a> : <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code></pre>
</dt>
<dd><p>When the object was created.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.default_avatar_url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="default_avatar_url -- Avatar URL for the user, if they have one set …" href="#hikari.webhooks.PartialWebhook.default_avatar_url"  >default_avatar_url</a> : <a href='files.html#hikari.files.URL'>files_.URL</a></code></pre>
</dt>
<dd><p>Avatar URL for the user, if they have one set.</p>
<p>May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no custom avatar is set. In this case, you
should use <code>default_avatar_url</code> instead.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.guild_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="guild_id -- The guild ID of the webhook." href="#hikari.webhooks.ChannelFollowerWebhook.guild_id"  >guild_id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>The guild ID of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="id -- The ID of this entity." href="#hikari.webhooks.ChannelFollowerWebhook.id"  >id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>The ID of this entity.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.mention" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mention -- Return a raw mention string for the given webhook's user …" href="#hikari.webhooks.PartialWebhook.mention"  >mention</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Return a raw mention string for the given webhook's user.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This exists purely for consistency. Webhooks do not receive events
from the gateway, and without some bot backend to support it, will
not be able to detect mentions of their webhook.</p>
</div>
<h2 id="example">Example</h2>
<pre><code class="language-py">&gt;&gt;&gt; some_webhook.mention
'&lt;@123456789123456789&gt;'
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The mention string to use.</dd>
</dl></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.name" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="name -- The name of the webhook." href="#hikari.webhooks.ChannelFollowerWebhook.name"  >name</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>The name of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.source_channel" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="source_channel -- The partial object of the channel this webhook is following." href="#hikari.webhooks.ChannelFollowerWebhook.source_channel"  >source_channel</a> : <a href='channels.html#hikari.channels.PartialChannel'>channels_.PartialChannel</a></code></pre>
</dt>
<dd><p>The partial object of the channel this webhook is following.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.source_guild" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="source_guild -- The partial object of the guild this webhook is following." href="#hikari.webhooks.ChannelFollowerWebhook.source_guild"  >source_guild</a> : <a href='guilds.html#hikari.guilds.PartialGuild'>guilds_.PartialGuild</a></code></pre>
</dt>
<dd><p>The partial object of the guild this webhook is following.</p></dd>
</div>
<div id="hikari.webhooks.ChannelFollowerWebhook.type" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="type -- The type of the webhook." href="#hikari.webhooks.ChannelFollowerWebhook.type"  >type</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='#hikari.webhooks.WebhookType'>WebhookType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></pre>
</dt>
<dd><p>The type of the webhook.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.webhooks.ChannelFollowerWebhook.delete" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete" href="#hikari.webhooks.ChannelFollowerWebhook.delete" id="hikari.webhooks.ChannelFollowerWebhook.delete">delete</a>() -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete this webhook.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If this webhook is not found.</dd>
<dt><code><a href='errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you either lack the <code>MANAGE_WEBHOOKS</code> permission or
are not a member of the guild this webhook belongs to.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L901-L912" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete(self) -&gt; None:
    &#34;&#34;&#34;Delete this webhook.

    Raises
    ------
    hikari.errors.NotFoundError
        If this webhook is not found.
    hikari.errors.ForbiddenError
        If you either lack the `MANAGE_WEBHOOKS` permission or
        are not a member of the guild this webhook belongs to.
    &#34;&#34;&#34;
    await self.app.rest.delete_webhook(self.id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.ChannelFollowerWebhook.edit" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit" href="#hikari.webhooks.ChannelFollowerWebhook.edit" id="hikari.webhooks.ChannelFollowerWebhook.edit">edit</a>(
    *,
    name: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='files.html#hikari.files.Resource'>files_.Resource</a>[<a href='files.html#hikari.files.AsyncReader'>files_.AsyncReader</a>]] = UNDEFINED,
    channel: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='channels.html#hikari.channels.WebhookChannelT'>channels_.WebhookChannelT</a>]] = UNDEFINED,
    reason: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='#hikari.webhooks.ChannelFollowerWebhook'>ChannelFollowerWebhook</a>: ...</code></pre>
</dt>
<dd>
<p>Edit this webhook.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new name string.</dd>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new avatar image. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then
it is removed. If not specified, nothing is changed.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='channels.html#hikari.channels.WebhookChannelT'>WebhookChannelT</a>]]</code></dt>
<dd>If provided, the object or ID of the new channel the given
webhook should be moved to.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the audit log reason explaining why the operation
was performed. This field will be used when using the webhook's
token rather than bot authorization.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.webhooks.ChannelFollowerWebhook'>ChannelFollowerWebhook</a></code></dt>
<dd>The updated webhook object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any invalid snowflake IDs are passed; a snowflake may be invalid
due to it being outside of the range of a 64 bit integer.</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If either the webhook or the channel are not found.</dd>
<dt><code><a href='errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you either lack the <code>MANAGE_WEBHOOKS</code> permission or
are not a member of the guild this webhook belongs to.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you pass a token that's invalid for the target webhook.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L914-L978" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit(
    self,
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar: undefined.UndefinedNoneOr[files_.Resource[files_.AsyncReader]] = undefined.UNDEFINED,
    channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.WebhookChannelT]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; ChannelFollowerWebhook:
    &#34;&#34;&#34;Edit this webhook.

    Other Parameters
    ----------------
    name : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the new name string.
    avatar : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
        If provided, the new avatar image. If `builtins.None`, then
        it is removed. If not specified, nothing is changed.
    channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]]
        If provided, the object or ID of the new channel the given
        webhook should be moved to.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the audit log reason explaining why the operation
        was performed. This field will be used when using the webhook&#39;s
        token rather than bot authorization.

    Returns
    -------
    hikari.webhooks.ChannelFollowerWebhook
        The updated webhook object.

    Raises
    ------
    hikari.errors.BadRequestError
        If any invalid snowflake IDs are passed; a snowflake may be invalid
        due to it being outside of the range of a 64 bit integer.
    hikari.errors.NotFoundError
        If either the webhook or the channel are not found.
    hikari.errors.ForbiddenError
        If you either lack the `MANAGE_WEBHOOKS` permission or
        are not a member of the guild this webhook belongs to.
    hikari.errors.UnauthorizedError
        If you pass a token that&#39;s invalid for the target webhook.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long
    webhook = await self.app.rest.edit_webhook(
        self.id,
        name=name,
        avatar=avatar,
        channel=channel,
        reason=reason,
    )
    assert isinstance(webhook, ChannelFollowerWebhook)
    return webhook</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.ChannelFollowerWebhook.fetch_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel" href="#hikari.webhooks.ChannelFollowerWebhook.fetch_channel" id="hikari.webhooks.ChannelFollowerWebhook.fetch_channel">fetch_channel</a>() -> Union[<a href='channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a>, <a href='channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the channel this webhook is for.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='channels.html#hikari.channels.WebhookChannelT'>WebhookChannelT</a></code></dt>
<dd>The object of the channel this webhook targets.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you don't have access to the channel this webhook belongs to.</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel this message was created in does not exist.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L980-L1012" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel(self) -&gt; channels_.WebhookChannelT:
    &#34;&#34;&#34;Fetch the channel this webhook is for.

    Returns
    -------
    hikari.channels.WebhookChannelT
        The object of the channel this webhook targets.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you don&#39;t have access to the channel this webhook belongs to.
    hikari.errors.NotFoundError
        If the channel this message was created in does not exist.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;
    channel = await self.app.rest.fetch_channel(self.channel_id)
    assert isinstance(channel, channels_.WebhookChannelTypes)
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.ChannelFollowerWebhook.fetch_self" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_self" href="#hikari.webhooks.ChannelFollowerWebhook.fetch_self" id="hikari.webhooks.ChannelFollowerWebhook.fetch_self">fetch_self</a>() -> <a href='#hikari.webhooks.ChannelFollowerWebhook'>ChannelFollowerWebhook</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch this webhook.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.webhooks.ChannelFollowerWebhook'>ChannelFollowerWebhook</a></code></dt>
<dd>The requested webhook object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you're not in the guild that owns this webhook or
lack the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you pass a token that's invalid for the target webhook.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L1014-L1047" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_self(self) -&gt; ChannelFollowerWebhook:
    &#34;&#34;&#34;Fetch this webhook.

    Returns
    -------
    hikari.webhooks.ChannelFollowerWebhook
        The requested webhook object.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you&#39;re not in the guild that owns this webhook or
        lack the `MANAGE_WEBHOOKS` permission.
    hikari.errors.NotFoundError
        If the webhook is not found.
    hikari.errors.UnauthorizedError
        If you pass a token that&#39;s invalid for the target webhook.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;
    webhook = await self.app.rest.fetch_webhook(self.id)
    assert isinstance(webhook, ChannelFollowerWebhook)
    return webhook</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.ChannelFollowerWebhook.make_avatar_url" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="make_avatar_url" href="#hikari.webhooks.PartialWebhook.make_avatar_url" id="hikari.webhooks.ChannelFollowerWebhook.make_avatar_url">make_avatar_url</a>(
    ext: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a> = 'png',
    size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 4096,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>files_.URL</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="PartialWebhook -- Base class for all webhook implementations …" href="#hikari.webhooks.PartialWebhook"
>PartialWebhook</a></code>.<code><a title="make_avatar_url -- Generate the avatar URL for this webhook's custom avatar if set …" href="#hikari.webhooks.PartialWebhook.make_avatar_url"
>make_avatar_url</a></code>
</p>
<p>Generate the avatar URL for this webhook's custom avatar if set.</p>
<p>If no avatar is specified, return <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>. In this case, you should
use <code>default_avatar</code> instead.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ext</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The extension to use for this URL, defaults to <code>png</code>.
Supports <code>png</code>, <code>jpeg</code>, <code>jpg</code> and <code>webp</code>.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The size to set for the URL, defaults to <code>4096</code>.
Can be any power of two between 16 and 4096.
Will be ignored for default avatars.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>URL</a>]</code></dt>
<dd>The URL of the resource. <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no avatar is set (in
this case, use the <code>default_avatar</code> instead).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code>size</code> is not a power of two between 16 and 4096 (inclusive).</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.webhooks.ExecutableWebhook" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="ExecutableWebhook -- An abstract class with logic for executing entities as webhooks." href="#hikari.webhooks.ExecutableWebhook"
>ExecutableWebhook</a></h4>
</dt>
<dd>
<pre><code id="hikari.webhooks.ExecutableWebhook" class="hljs python"><abbr title='A standard Python type.'>class</abbr> ExecutableWebhook: ...</code></pre>
<p>An abstract class with logic for executing entities as webhooks.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L74-L519" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class ExecutableWebhook(abc.ABC):
    &#34;&#34;&#34;An abstract class with logic for executing entities as webhooks.&#34;&#34;&#34;

    # This is a mixin, do not add slotted fields.
    __slots__: typing.Sequence[str] = ()

    @property
    @abc.abstractmethod
    def app(self) -&gt; traits.RESTAware:
        &#34;&#34;&#34;Client application that models may use for procedures.

        Returns
        -------
        hikari.traits.RESTAware
            The client application that models may use for procedures.
        &#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def webhook_id(self) -&gt; snowflakes.Snowflake:
        &#34;&#34;&#34;ID used to execute this entity as a webhook.

        Returns
        -------
        hikari.snowflakes.Snowflake
            The ID used to execute this entity as a webhook.
        &#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def token(self) -&gt; typing.Optional[str]:
        &#34;&#34;&#34;Webhook&#39;s token.

        !!! info
            If this is `builtins.None` then the methods provided by `ExecutableWebhook`
            will always raise a `builtins.ValueError`.

        Returns
        -------
        typing.Optional[builtins.str]
            The token for the webhook if known, else `builtins.None`.
        &#34;&#34;&#34;

    async def execute(
        self,
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files_.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files_.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users_.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds_.PartialRole], bool]
        ] = undefined.UNDEFINED,
        flags: typing.Union[undefined.UndefinedType, int, messages_.MessageFlag] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Execute the webhook to create a message.

        Parameters
        ----------
        content : hikari.undefined.UndefinedOr[typing.Any]
            If provided, the message contents. If
            `hikari.undefined.UNDEFINED`, then nothing will be sent
            in the content. Any other value here will be cast to a
            `builtins.str`.

            If this is a `hikari.embeds.Embed` and no `embed` kwarg is
            provided, then this will instead update the embed. This allows for
            simpler syntax when sending an embed alone.

            Likewise, if this is a `hikari.files.Resource`, then the
            content is instead treated as an attachment if no `attachment` and
            no `attachments` kwargs are provided.

        Other Parameters
        ----------------
        username : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the username to override the webhook&#39;s username
            for this request.
        avatar_url : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the url of an image to override the webhook&#39;s
            avatar with for this request.
        tts : hikari.undefined.UndefinedOr[bool]
            If provided, whether the message will be sent as a TTS message.
        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
            If provided, the message attachment. This can be a resource,
            or string of a path on your computer or a URL.
        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]
            If provided, the message attachments. These can be resources, or
            strings consisting of paths on your computer or URLs.
        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]
            If provided, builder object of the component to include in this message.
        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]
            If provided, a sequence of the component builder objects to include
            in this message.
        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
            If provided, the message embed.
        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]
            If provided, the message embeds.
        mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the message should parse @everyone/@here
            mentions.
        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool]]
            If provided, and `builtins.True`, all mentions will be parsed.
            If provided, and `builtins.False`, no mentions will be parsed.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.users.PartialUser` derivatives to enforce mentioning
            specific users.
        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool]]
            If provided, and `builtins.True`, all mentions will be parsed.
            If provided, and `builtins.False`, no mentions will be parsed.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.guilds.PartialRole` derivatives to enforce mentioning
            specific roles.
        flags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag]
            The flags to set for this webhook message.

            !!! warning
                As of writing this can only be set for interaction webhooks
                and the only settable flag is EPHEMERAL; this field is just
                ignored for non-interaction webhooks.

        !!! warning
            As of writing, `username` and `avatar_url` are ignored for
            interaction webhooks.

        Returns
        -------
        hikari.messages.Message
            The created message object.

        Raises
        ------
        hikari.errors.NotFoundError
            If the current webhook is not found.
        hikari.errors.BadRequestError
            This can be raised if the file is too large; if the embed exceeds
            the defined limits; if the message content is specified only and
            empty or greater than `2000` characters; if neither content, file
            or embeds are specified.
            If any invalid snowflake IDs are passed; a snowflake may be invalid
            due to it being outside of the range of a 64 bit integer.
        hikari.errors.UnauthorizedError
            If you pass a token that&#39;s invalid for the target webhook.
        builtins.ValueError
            If either `ExecutableWebhook.token` is `builtins.None` or more than 100 unique
            objects/entities are passed for `role_mentions` or `user_mentions or
            if `token` is not available.
        builtins.TypeError
            If both `attachment` and `attachments` are specified.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        if not self.token:
            raise ValueError(&#34;Cannot send a message using a webhook where we don&#39;t know the token&#34;)

        return await self.app.rest.execute_webhook(
            webhook=self.webhook_id,
            token=self.token,
            content=content,
            username=username,
            avatar_url=avatar_url,
            tts=tts,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            mentions_everyone=mentions_everyone,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
            flags=flags,
        )

    async def fetch_message(self, message: snowflakes.SnowflakeishOr[messages_.Message]) -&gt; messages_.Message:
        &#34;&#34;&#34;Fetch an old message sent by the webhook.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to fetch. This may be the object or the ID of an
            existing channel.

        Returns
        -------
        hikari.messages.Message
            The requested message.

        Raises
        ------
        builtins.ValueError
            If `token` is not available.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhook is not found or the webhook&#39;s message wasn&#39;t found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        if self.token is None:
            raise ValueError(&#34;Cannot fetch a message using a webhook where we don&#39;t know the token&#34;)

        return await self.app.rest.fetch_webhook_message(self.webhook_id, token=self.token, message=message)

    async def edit_message(
        self,
        message: snowflakes.SnowflakeishOr[messages_.Message],
        content: undefined.UndefinedNoneOr[typing.Any] = undefined.UNDEFINED,
        *,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
        components: undefined.UndefinedNoneOr[
            typing.Sequence[special_endpoints.ComponentBuilder]
        ] = undefined.UNDEFINED,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        replace_attachments: bool = False,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[users_.PartialUser], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[snowflakes.SnowflakeishSequence[guilds_.PartialRole], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Edit a message sent by a webhook.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete. This may be the object or the ID of
            an existing message.
        content : hikari.undefined.UndefinedNoneOr[typing.Any]
            If provided, the message contents. If
            `hikari.undefined.UNDEFINED`, then nothing will be sent
            in the content. Any other value here will be cast to a
            `builtins.str`.

            If this is a `hikari.embeds.Embed` and no `embed` nor
            no `embeds` kwarg is provided, then this will instead
            update the embed. This allows for simpler syntax when
            sending an embed alone.

            Likewise, if this is a `hikari.files.Resource`, then the
            content is instead treated as an attachment if no `attachment` and
            no `attachments` kwargs are provided.

        Other Parameters
        ----------------
        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
            If provided, the attachment to set on the message. If
            `hikari.undefined.UNDEFINED`, the previous attachment, if
            present, is not changed. If this is `builtins.None`, then the
            attachment is removed, if present. Otherwise, the new attachment
            that was provided will be attached.
        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]
            If provided, the attachments to set on the message. If
            `hikari.undefined.UNDEFINED`, the previous attachments, if
            present, are not changed. If this is `builtins.None`, then the
            attachments is removed, if present. Otherwise, the new attachments
            that were provided will be attached.
        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]
            If provided, builder object of the component to set for this message.
            This component will replace any previously set components and passing
            `builtins.None` will remove all components.
        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]
            If provided, a sequence of the component builder objects set for
            this message. These components will replace any previously set
            components and passing `builtins.None` or an empty sequence will
            remove all components.
        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]
            If provided, the embed to set on the message. If
            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.
            If this is `builtins.None` then any present embeds are removed.
            Otherwise, the new embed that was provided will be used as the
            replacement.
        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]
            If provided, the embeds to set on the message. If
            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.
            If this is `builtins.None` then any present embeds are removed.
            Otherwise, the new embeds that were provided will be used as the
            replacement.
        replace_attachments: bool
            Whether to replace the attachments with the provided ones. Defaults
            to `builtins.False`.

            Note this will also overwrite the embed attachments.
        mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, sanitation for `@everyone` mentions. If
            `hikari.undefined.UNDEFINED`, then the previous setting is
            not changed. If `builtins.True`, then `@everyone`/`@here` mentions
            in the message content will show up as mentioning everyone that can
            view the chat.
        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool]]
            If provided, and `builtins.True`, all user mentions will be detected.
            If provided, and `builtins.False`, all user mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.users.PartialUser` derivatives to enforce mentioning
            specific users.
        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool]]
            If provided, and `builtins.True`, all role mentions will be detected.
            If provided, and `builtins.False`, all role mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.guilds.PartialRole` derivatives to enforce mentioning
            specific roles.

        !!! note
            Mentioning everyone, roles, or users in message edits currently
            will not send a push notification showing a new mention to people
            on Discord. It will still highlight in their chat as if they
            were mentioned, however.

        !!! warning
            If you specify a non-embed `content`, `mentions_everyone`,
            `mentions_reply`, `user_mentions`, and `role_mentions` will default
            to `builtins.False` as the message will be re-parsed for mentions.

            This is a limitation of Discord&#39;s design. If in doubt, specify all
            three of them each time.

        !!! warning
            If you specify one of `mentions_everyone`, `mentions_reply`,
            `user_mentions`, or `role_mentions`, then all others will default to
            `builtins.False`, even if they were enabled previously.

            This is a limitation of Discord&#39;s design. If in doubt, specify all
            three of them each time.

        Returns
        -------
        hikari.messages.Message
            The edited message.

        Raises
        ------
        builtins.ValueError
            If more than 100 unique objects/entities are passed for
            `role_mentions` or `user_mentions` or `token` is not available.
        builtins.TypeError
            If both `attachment` and `attachments` are specified or if both
            `embed` and `embeds` are specified.
        hikari.errors.BadRequestError
            This may be raised in several discrete situations, such as messages
            being empty with no attachments or embeds; messages with more than
            2000 characters in them, embeds that exceed one of the many embed
            limits; too many attachments; attachments that are too large;
            too many components.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhook or the message are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        if self.token is None:
            raise ValueError(&#34;Cannot edit a message using a webhook where we don&#39;t know the token&#34;)

        return await self.app.rest.edit_webhook_message(
            self.webhook_id,
            token=self.token,
            message=message,
            content=content,
            attachment=attachment,
            attachments=attachments,
            component=component,
            components=components,
            embed=embed,
            embeds=embeds,
            replace_attachments=replace_attachments,
            mentions_everyone=mentions_everyone,
            user_mentions=user_mentions,
            role_mentions=role_mentions,
        )

    async def delete_message(self, message: snowflakes.SnowflakeishOr[messages_.Message]) -&gt; None:
        &#34;&#34;&#34;Delete a given message in a given channel.

        Parameters
        ----------
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete. This may be the object or the ID of
            an existing message.

        Raises
        ------
        builtins.ValueError
            If `token` is not available.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhook or the message are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        if self.token is None:
            raise ValueError(&#34;Cannot delete a message using a webhook where we don&#39;t know the token&#34;)

        await self.app.rest.delete_webhook_message(self.webhook_id, token=self.token, message=message)</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="PartialInteraction -- The base model for all interaction models …" href="interactions/base_interactions.html#hikari.interactions.base_interactions.PartialInteraction"
>PartialInteraction</a></dt>
<dd class="nested"><p>The base model for all interaction models …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="IncomingWebhook -- Represents an incoming webhook object on Discord …" href="#hikari.webhooks.IncomingWebhook"
>IncomingWebhook</a></dt>
<dd class="nested"><p>Represents an incoming webhook object on Discord …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="ExecutableWebhook -- An abstract class with logic for executing entities as webhooks." href="#hikari.webhooks.ExecutableWebhook"
>ExecutableWebhook</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.webhooks.ExecutableWebhook.app" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- Client application that models may use for procedures …" href="#hikari.webhooks.ExecutableWebhook.app"  >app</a> : <a href='traits.html#hikari.traits.RESTAware'>traits.RESTAware</a></code></pre>
</dt>
<dd><p>Client application that models may use for procedures.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='traits.html#hikari.traits.RESTAware'>RESTAware</a></code></dt>
<dd>The client application that models may use for procedures.</dd>
</dl></dd>
</div>
<div id="hikari.webhooks.ExecutableWebhook.token" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="token -- Webhook's token …" href="#hikari.webhooks.ExecutableWebhook.token"  >token</a> : Optional[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>Webhook's token.</p>
<div class="alert alert-primary">
<p class="admonition-title">Info</p>
<p>If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then the methods provided by <code><a href='#hikari.webhooks.ExecutableWebhook'>ExecutableWebhook</a></code>
will always raise a <code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code>.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The token for the webhook if known, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl></dd>
</div>
<div id="hikari.webhooks.ExecutableWebhook.webhook_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="webhook_id -- ID used to execute this entity as a webhook …" href="#hikari.webhooks.ExecutableWebhook.webhook_id"  >webhook_id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></pre>
</dt>
<dd><p>ID used to execute this entity as a webhook.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID used to execute this entity as a webhook.</dd>
</dl></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.webhooks.ExecutableWebhook.delete_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_message" href="#hikari.webhooks.ExecutableWebhook.delete_message" id="hikari.webhooks.ExecutableWebhook.delete_message">delete_message</a>(
    message: <a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete a given message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete. This may be the object or the ID of
an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code> is not available.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook or the message are not found.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L485-L519" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete_message(self, message: snowflakes.SnowflakeishOr[messages_.Message]) -&gt; None:
    &#34;&#34;&#34;Delete a given message in a given channel.

    Parameters
    ----------
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to delete. This may be the object or the ID of
        an existing message.

    Raises
    ------
    builtins.ValueError
        If `token` is not available.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the webhook or the message are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;
    if self.token is None:
        raise ValueError(&#34;Cannot delete a message using a webhook where we don&#39;t know the token&#34;)

    await self.app.rest.delete_webhook_message(self.webhook_id, token=self.token, message=message)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.ExecutableWebhook.edit_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_message" href="#hikari.webhooks.ExecutableWebhook.edit_message" id="hikari.webhooks.ExecutableWebhook.edit_message">edit_message</a>(
    message: <a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='messages.html#hikari.messages.Message'>messages_.Message</a>],
    content: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    attachment: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    component: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>special_endpoints.ComponentBuilder</a>] = UNDEFINED,
    components: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>special_endpoints.ComponentBuilder</a>]] = UNDEFINED,
    embed: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    replace_attachments: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
    mentions_everyone: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='users.html#hikari.users.PartialUser'>users_.PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='guilds.html#hikari.guilds.PartialRole'>guilds_.PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
) -> <a href='messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p>Edit a message sent by a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete. This may be the object or the ID of
an existing message.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message contents. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> nor
no <code>embeds</code> kwarg is provided, then this will instead
update the embed. This allows for simpler syntax when
sending an embed alone.</p>
<p>Likewise, if this is a <code><a href='files.html#hikari.files.Resource'>Resource</a></code>, then the
content is instead treated as an attachment if no <code>attachment</code> and
no <code>attachments</code> kwargs are provided.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the attachment to set on the message. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous attachment, if
present, is not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the
attachment is removed, if present. Otherwise, the new attachment
that was provided will be attached.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='files.html#hikari.files.Resourceish'>Resourceish</a>]]</code></dt>
<dd>If provided, the attachments to set on the message. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous attachments, if
present, are not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the
attachments is removed, if present. Otherwise, the new attachments
that were provided will be attached.</dd>
<dt><strong><code>component</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]</code></dt>
<dd>If provided, builder object of the component to set for this message.
This component will replace any previously set components and passing
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> will remove all components.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]]</code></dt>
<dd>If provided, a sequence of the component builder objects set for
this message. These components will replace any previously set
components and passing <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> or an empty sequence will
remove all components.</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the embed to set on the message. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed(s) are not changed.
If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then any present embeds are removed.
Otherwise, the new embed that was provided will be used as the
replacement.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='embeds.html#hikari.embeds.Embed'>Embed</a>]]</code></dt>
<dd>If provided, the embeds to set on the message. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed(s) are not changed.
If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then any present embeds are removed.
Otherwise, the new embeds that were provided will be used as the
replacement.</dd>
<dt><strong><code>replace_attachments</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>
<p>Whether to replace the attachments with the provided ones. Defaults
to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</p>
<p>Note this will also overwrite the embed attachments.</p>
</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, sanitation for <code>@everyone</code> mentions. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, then <code>@everyone</code>/<code>@here</code> mentions
in the message content will show up as mentioning everyone that can
view the chat.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='users.html#hikari.users.PartialUser'>PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all user mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all user mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='guilds.html#hikari.guilds.PartialRole'>PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all role mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all role mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Mentioning everyone, roles, or users in message edits currently
will not send a push notification showing a new mention to people
on Discord. It will still highlight in their chat as if they
were mentioned, however.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify a non-embed <code>content</code>, <code>mentions_everyone</code>,
<code>mentions_reply</code>, <code>user_mentions</code>, and <code>role_mentions</code> will default
to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> as the message will be re-parsed for mentions.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all
three of them each time.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify one of <code>mentions_everyone</code>, <code>mentions_reply</code>,
<code>user_mentions</code>, or <code>role_mentions</code>, then all others will default to
<code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, even if they were enabled previously.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all
three of them each time.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The edited message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If more than 100 unique objects/entities are passed for
<code>role_mentions</code> or <code>user_mentions</code> or <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code> is not available.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code> are specified or if both
<code>embed</code> and <code>embeds</code> are specified.</dd>
<dt><code><a href='errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no attachments or embeds; messages with more than
2000 characters in them, embeds that exceed one of the many embed
limits; too many attachments; attachments that are too large;
too many components.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook or the message are not found.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L299-L483" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit_message(
    self,
    message: snowflakes.SnowflakeishOr[messages_.Message],
    content: undefined.UndefinedNoneOr[typing.Any] = undefined.UNDEFINED,
    *,
    attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
    component: undefined.UndefinedNoneOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
    components: undefined.UndefinedNoneOr[
        typing.Sequence[special_endpoints.ComponentBuilder]
    ] = undefined.UNDEFINED,
    embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
    embeds: undefined.UndefinedNoneOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
    replace_attachments: bool = False,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[users_.PartialUser], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[guilds_.PartialRole], bool]
    ] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    &#34;&#34;&#34;Edit a message sent by a webhook.

    Parameters
    ----------
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to delete. This may be the object or the ID of
        an existing message.
    content : hikari.undefined.UndefinedNoneOr[typing.Any]
        If provided, the message contents. If
        `hikari.undefined.UNDEFINED`, then nothing will be sent
        in the content. Any other value here will be cast to a
        `builtins.str`.

        If this is a `hikari.embeds.Embed` and no `embed` nor
        no `embeds` kwarg is provided, then this will instead
        update the embed. This allows for simpler syntax when
        sending an embed alone.

        Likewise, if this is a `hikari.files.Resource`, then the
        content is instead treated as an attachment if no `attachment` and
        no `attachments` kwargs are provided.

    Other Parameters
    ----------------
    attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
        If provided, the attachment to set on the message. If
        `hikari.undefined.UNDEFINED`, the previous attachment, if
        present, is not changed. If this is `builtins.None`, then the
        attachment is removed, if present. Otherwise, the new attachment
        that was provided will be attached.
    attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]
        If provided, the attachments to set on the message. If
        `hikari.undefined.UNDEFINED`, the previous attachments, if
        present, are not changed. If this is `builtins.None`, then the
        attachments is removed, if present. Otherwise, the new attachments
        that were provided will be attached.
    component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]
        If provided, builder object of the component to set for this message.
        This component will replace any previously set components and passing
        `builtins.None` will remove all components.
    components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]
        If provided, a sequence of the component builder objects set for
        this message. These components will replace any previously set
        components and passing `builtins.None` or an empty sequence will
        remove all components.
    embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]
        If provided, the embed to set on the message. If
        `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.
        If this is `builtins.None` then any present embeds are removed.
        Otherwise, the new embed that was provided will be used as the
        replacement.
    embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]
        If provided, the embeds to set on the message. If
        `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.
        If this is `builtins.None` then any present embeds are removed.
        Otherwise, the new embeds that were provided will be used as the
        replacement.
    replace_attachments: bool
        Whether to replace the attachments with the provided ones. Defaults
        to `builtins.False`.

        Note this will also overwrite the embed attachments.
    mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, sanitation for `@everyone` mentions. If
        `hikari.undefined.UNDEFINED`, then the previous setting is
        not changed. If `builtins.True`, then `@everyone`/`@here` mentions
        in the message content will show up as mentioning everyone that can
        view the chat.
    user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool]]
        If provided, and `builtins.True`, all user mentions will be detected.
        If provided, and `builtins.False`, all user mentions will be ignored
        if appearing in the message body.
        Alternatively this may be a collection of
        `hikari.snowflakes.Snowflake`, or
        `hikari.users.PartialUser` derivatives to enforce mentioning
        specific users.
    role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool]]
        If provided, and `builtins.True`, all role mentions will be detected.
        If provided, and `builtins.False`, all role mentions will be ignored
        if appearing in the message body.
        Alternatively this may be a collection of
        `hikari.snowflakes.Snowflake`, or
        `hikari.guilds.PartialRole` derivatives to enforce mentioning
        specific roles.

    !!! note
        Mentioning everyone, roles, or users in message edits currently
        will not send a push notification showing a new mention to people
        on Discord. It will still highlight in their chat as if they
        were mentioned, however.

    !!! warning
        If you specify a non-embed `content`, `mentions_everyone`,
        `mentions_reply`, `user_mentions`, and `role_mentions` will default
        to `builtins.False` as the message will be re-parsed for mentions.

        This is a limitation of Discord&#39;s design. If in doubt, specify all
        three of them each time.

    !!! warning
        If you specify one of `mentions_everyone`, `mentions_reply`,
        `user_mentions`, or `role_mentions`, then all others will default to
        `builtins.False`, even if they were enabled previously.

        This is a limitation of Discord&#39;s design. If in doubt, specify all
        three of them each time.

    Returns
    -------
    hikari.messages.Message
        The edited message.

    Raises
    ------
    builtins.ValueError
        If more than 100 unique objects/entities are passed for
        `role_mentions` or `user_mentions` or `token` is not available.
    builtins.TypeError
        If both `attachment` and `attachments` are specified or if both
        `embed` and `embeds` are specified.
    hikari.errors.BadRequestError
        This may be raised in several discrete situations, such as messages
        being empty with no attachments or embeds; messages with more than
        2000 characters in them, embeds that exceed one of the many embed
        limits; too many attachments; attachments that are too large;
        too many components.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the webhook or the message are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long
    if self.token is None:
        raise ValueError(&#34;Cannot edit a message using a webhook where we don&#39;t know the token&#34;)

    return await self.app.rest.edit_webhook_message(
        self.webhook_id,
        token=self.token,
        message=message,
        content=content,
        attachment=attachment,
        attachments=attachments,
        component=component,
        components=components,
        embed=embed,
        embeds=embeds,
        replace_attachments=replace_attachments,
        mentions_everyone=mentions_everyone,
        user_mentions=user_mentions,
        role_mentions=role_mentions,
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.ExecutableWebhook.execute" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="execute" href="#hikari.webhooks.ExecutableWebhook.execute" id="hikari.webhooks.ExecutableWebhook.execute">execute</a>(
    content: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    username: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar_url: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    tts: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    attachment: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='files.html#hikari.files.Resourceish'>files_.Resourceish</a>] = UNDEFINED,
    attachments: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='files.html#hikari.files.Resourceish'>files_.Resourceish</a>]] = UNDEFINED,
    component: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>special_endpoints.ComponentBuilder</a>] = UNDEFINED,
    components: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>special_endpoints.ComponentBuilder</a>]] = UNDEFINED,
    embed: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    mentions_everyone: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='users.html#hikari.users.PartialUser'>users_.PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='guilds.html#hikari.guilds.PartialRole'>guilds_.PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    flags: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='undefined.html#hikari.undefined.UndefinedType'>undefined.UndefinedType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='messages.html#hikari.messages.MessageFlag'>messages_.MessageFlag</a>] = UNDEFINED,
) -> <a href='messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p>Execute the webhook to create a message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message contents. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> kwarg is
provided, then this will instead update the embed. This allows for
simpler syntax when sending an embed alone.</p>
<p>Likewise, if this is a <code><a href='files.html#hikari.files.Resource'>Resource</a></code>, then the
content is instead treated as an attachment if no <code>attachment</code> and
no <code>attachments</code> kwargs are provided.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the username to override the webhook's username
for this request.</dd>
<dt><strong><code>avatar_url</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the url of an image to override the webhook's
avatar with for this request.</dd>
<dt><strong><code>tts</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message will be sent as a TTS message.</dd>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the message attachment. This can be a resource,
or string of a path on your computer or a URL.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='files.html#hikari.files.Resourceish'>Resourceish</a>]]</code></dt>
<dd>If provided, the message attachments. These can be resources, or
strings consisting of paths on your computer or URLs.</dd>
<dt><strong><code>component</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]</code></dt>
<dd>If provided, builder object of the component to include in this message.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]]</code></dt>
<dd>If provided, a sequence of the component builder objects to include
in this message.</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the message embed.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='embeds.html#hikari.embeds.Embed'>Embed</a>]]</code></dt>
<dd>If provided, the message embeds.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message should parse @everyone/@here
mentions.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='users.html#hikari.users.PartialUser'>PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all mentions will be parsed.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, no mentions will be parsed.
Alternatively this may be a collection of
<code><a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='guilds.html#hikari.guilds.PartialRole'>PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all mentions will be parsed.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, no mentions will be parsed.
Alternatively this may be a collection of
<code><a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='undefined.html#hikari.undefined.UndefinedType'>UndefinedType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='messages.html#hikari.messages.MessageFlag'>MessageFlag</a>]</code></dt>
<dd>
<p>The flags to set for this webhook message.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>As of writing this can only be set for interaction webhooks
and the only settable flag is EPHEMERAL; this field is just
ignored for non-interaction webhooks.</p>
</div>
</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>As of writing, <code>username</code> and <code>avatar_url</code> are ignored for
interaction webhooks.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The created message object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the current webhook is not found.</dd>
<dt><code><a href='errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This can be raised if the file is too large; if the embed exceeds
the defined limits; if the message content is specified only and
empty or greater than <code>2000</code> characters; if neither content, file
or embeds are specified.
If any invalid snowflake IDs are passed; a snowflake may be invalid
due to it being outside of the range of a 64 bit integer.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you pass a token that's invalid for the target webhook.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If either <code><a href='#hikari.webhooks.ExecutableWebhook.token'>token</a></code> is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> or more than 100 unique
objects/entities are passed for <code>role_mentions</code> or `user_mentions or
if <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code> is not available.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code> are specified.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L117-L256" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def execute(
    self,
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    attachment: undefined.UndefinedOr[files_.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files_.Resourceish]] = undefined.UNDEFINED,
    component: undefined.UndefinedOr[special_endpoints.ComponentBuilder] = undefined.UNDEFINED,
    components: undefined.UndefinedOr[typing.Sequence[special_endpoints.ComponentBuilder]] = undefined.UNDEFINED,
    embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
    embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[users_.PartialUser], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[snowflakes.SnowflakeishSequence[guilds_.PartialRole], bool]
    ] = undefined.UNDEFINED,
    flags: typing.Union[undefined.UndefinedType, int, messages_.MessageFlag] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    &#34;&#34;&#34;Execute the webhook to create a message.

    Parameters
    ----------
    content : hikari.undefined.UndefinedOr[typing.Any]
        If provided, the message contents. If
        `hikari.undefined.UNDEFINED`, then nothing will be sent
        in the content. Any other value here will be cast to a
        `builtins.str`.

        If this is a `hikari.embeds.Embed` and no `embed` kwarg is
        provided, then this will instead update the embed. This allows for
        simpler syntax when sending an embed alone.

        Likewise, if this is a `hikari.files.Resource`, then the
        content is instead treated as an attachment if no `attachment` and
        no `attachments` kwargs are provided.

    Other Parameters
    ----------------
    username : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the username to override the webhook&#39;s username
        for this request.
    avatar_url : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the url of an image to override the webhook&#39;s
        avatar with for this request.
    tts : hikari.undefined.UndefinedOr[bool]
        If provided, whether the message will be sent as a TTS message.
    attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
        If provided, the message attachment. This can be a resource,
        or string of a path on your computer or a URL.
    attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]
        If provided, the message attachments. These can be resources, or
        strings consisting of paths on your computer or URLs.
    component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]
        If provided, builder object of the component to include in this message.
    components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]
        If provided, a sequence of the component builder objects to include
        in this message.
    embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
        If provided, the message embed.
    embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]
        If provided, the message embeds.
    mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether the message should parse @everyone/@here
        mentions.
    user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], builtins.bool]]
        If provided, and `builtins.True`, all mentions will be parsed.
        If provided, and `builtins.False`, no mentions will be parsed.
        Alternatively this may be a collection of
        `hikari.snowflakes.Snowflake`, or
        `hikari.users.PartialUser` derivatives to enforce mentioning
        specific users.
    role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], builtins.bool]]
        If provided, and `builtins.True`, all mentions will be parsed.
        If provided, and `builtins.False`, no mentions will be parsed.
        Alternatively this may be a collection of
        `hikari.snowflakes.Snowflake`, or
        `hikari.guilds.PartialRole` derivatives to enforce mentioning
        specific roles.
    flags : typing.Union[hikari.undefined.UndefinedType, builtins.int, hikari.messages.MessageFlag]
        The flags to set for this webhook message.

        !!! warning
            As of writing this can only be set for interaction webhooks
            and the only settable flag is EPHEMERAL; this field is just
            ignored for non-interaction webhooks.

    !!! warning
        As of writing, `username` and `avatar_url` are ignored for
        interaction webhooks.

    Returns
    -------
    hikari.messages.Message
        The created message object.

    Raises
    ------
    hikari.errors.NotFoundError
        If the current webhook is not found.
    hikari.errors.BadRequestError
        This can be raised if the file is too large; if the embed exceeds
        the defined limits; if the message content is specified only and
        empty or greater than `2000` characters; if neither content, file
        or embeds are specified.
        If any invalid snowflake IDs are passed; a snowflake may be invalid
        due to it being outside of the range of a 64 bit integer.
    hikari.errors.UnauthorizedError
        If you pass a token that&#39;s invalid for the target webhook.
    builtins.ValueError
        If either `ExecutableWebhook.token` is `builtins.None` or more than 100 unique
        objects/entities are passed for `role_mentions` or `user_mentions or
        if `token` is not available.
    builtins.TypeError
        If both `attachment` and `attachments` are specified.
    &#34;&#34;&#34;  # noqa: E501 - Line too long
    if not self.token:
        raise ValueError(&#34;Cannot send a message using a webhook where we don&#39;t know the token&#34;)

    return await self.app.rest.execute_webhook(
        webhook=self.webhook_id,
        token=self.token,
        content=content,
        username=username,
        avatar_url=avatar_url,
        tts=tts,
        attachment=attachment,
        attachments=attachments,
        component=component,
        components=components,
        embed=embed,
        embeds=embeds,
        mentions_everyone=mentions_everyone,
        user_mentions=user_mentions,
        role_mentions=role_mentions,
        flags=flags,
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.ExecutableWebhook.fetch_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_message" href="#hikari.webhooks.ExecutableWebhook.fetch_message" id="hikari.webhooks.ExecutableWebhook.fetch_message">fetch_message</a>(
    message: <a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch an old message sent by the webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to fetch. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The requested message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code> is not available.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found or the webhook's message wasn't found.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L258-L297" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_message(self, message: snowflakes.SnowflakeishOr[messages_.Message]) -&gt; messages_.Message:
    &#34;&#34;&#34;Fetch an old message sent by the webhook.

    Parameters
    ----------
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to fetch. This may be the object or the ID of an
        existing channel.

    Returns
    -------
    hikari.messages.Message
        The requested message.

    Raises
    ------
    builtins.ValueError
        If `token` is not available.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the webhook is not found or the webhook&#39;s message wasn&#39;t found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;
    if self.token is None:
        raise ValueError(&#34;Cannot fetch a message using a webhook where we don&#39;t know the token&#34;)

    return await self.app.rest.fetch_webhook_message(self.webhook_id, token=self.token, message=message)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.webhooks.IncomingWebhook" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="IncomingWebhook -- Represents an incoming webhook object on Discord …" href="#hikari.webhooks.IncomingWebhook"
>IncomingWebhook</a></h4>
</dt>
<dd>
<pre><code id="hikari.webhooks.IncomingWebhook" class="hljs python"><abbr title='A standard Python type.'>class</abbr> IncomingWebhook (
    *,
    app: <a href='traits.html#hikari.traits.RESTAware'>traits.RESTAware</a>,
    id: <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    type: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='#hikari.webhooks.WebhookType'>WebhookType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    avatar_hash: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    application_id: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>],
    channel_id: <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    guild_id: <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    author: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='users.html#hikari.users.User'>users_.User</a>],
    token: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
): ...</code></pre>
<p>Represents an incoming webhook object on Discord.</p>
<p>This is an endpoint that can have messages sent to it using standard
HTTP requests, which enables external services that are not bots to
send informational messages to specific channels.</p>
<p>Method generated by attrs for class IncomingWebhook.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L636-L875" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class IncomingWebhook(PartialWebhook, ExecutableWebhook):
    &#34;&#34;&#34;Represents an incoming webhook object on Discord.

    This is an endpoint that can have messages sent to it using standard
    HTTP requests, which enables external services that are not bots to
    send informational messages to specific channels.
    &#34;&#34;&#34;

    channel_id: snowflakes.Snowflake = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The channel ID this webhook is for.&#34;&#34;&#34;

    guild_id: snowflakes.Snowflake = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The guild ID of the webhook.&#34;&#34;&#34;

    author: typing.Optional[users_.User] = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The user that created the webhook

    !!! info
        This will be `builtins.None` when fetched with the webhook&#39;s token
        rather than bot authorization or when received within audit logs.
    &#34;&#34;&#34;

    token: typing.Optional[str] = attr.field(eq=False, hash=False, repr=False)
    &#34;&#34;&#34;The token for the webhook.

    !!! info
        This is only available for incoming webhooks that are created in the
        channel settings.
    &#34;&#34;&#34;

    @property
    def webhook_id(self) -&gt; snowflakes.Snowflake:
        # &lt;&lt;inherited docstring from ExecutableWebhook&gt;&gt;.
        return self.id

    async def delete(self, *, use_token: undefined.UndefinedOr[bool] = undefined.UNDEFINED) -&gt; None:
        &#34;&#34;&#34;Delete this webhook.

        Other Parameters
        ----------------
        use_token : hikari.undefined.UndefinedOr[builtins.bool]
            If set to `builtins.True` then the webhook&#39;s token will be used for
            this request; if set to `builtins.False` then bot authorization will
            be used; if not specified then the webhook&#39;s token will be used for
            the request if it&#39;s set else bot authorization.

        Raises
        ------
        hikari.errors.NotFoundError
            If this webhook is not found.
        hikari.errors.ForbiddenError
            If you either lack the `MANAGE_WEBHOOKS` permission or
            are not a member of the guild this webhook belongs to.
        builtins.ValueError
            If `use_token` is passed as `builtins.True` when `IncomingWebhook.token` is
            `builtins.None`.
        &#34;&#34;&#34;
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED
        if use_token:
            if self.token is None:
                raise ValueError(&#34;This webhook&#39;s token is unknown, so cannot be used&#34;)
            token = self.token

        elif use_token is undefined.UNDEFINED and self.token:
            token = self.token

        await self.app.rest.delete_webhook(self.id, token=token)

    async def edit(
        self,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files_.Resource[files_.AsyncReader]] = undefined.UNDEFINED,
        channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.WebhookChannelT]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        use_token: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; IncomingWebhook:
        &#34;&#34;&#34;Edit this webhook.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new name string.
        avatar : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
            If provided, the new avatar image. If `builtins.None`, then
            it is removed. If not specified, nothing is changed.
        channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]]
            If provided, the object or ID of the new channel the given
            webhook should be moved to.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the audit log reason explaining why the operation
            was performed. This field will be used when using the webhook&#39;s
            token rather than bot authorization.
        use_token : hikari.undefined.UndefinedOr[builtins.bool]
            If set to `builtins.True` then the webhook&#39;s token will be used for
            this request; if set to `builtins.False` then bot authorization will
            be used; if not specified then the webhook&#39;s token will be used for
            the request if it&#39;s set else bot authorization.

        Returns
        -------
        IncomingWebhook
            The updated webhook object.

        Raises
        ------
        builtins.ValueError
            If `use_token` is passed as `builtins.True` when `IncomingWebhook.token` is `builtins.None`.
        hikari.errors.BadRequestError
            If any invalid snowflake IDs are passed; a snowflake may be invalid
            due to it being outside of the range of a 64 bit integer.
        hikari.errors.NotFoundError
            If either the webhook or the channel are not found.
        hikari.errors.ForbiddenError
            If you either lack the `MANAGE_WEBHOOKS` permission or
            are not a member of the guild this webhook belongs to.
        hikari.errors.UnauthorizedError
            If you pass a token that&#39;s invalid for the target webhook.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED
        if use_token:
            if self.token is None:
                raise ValueError(&#34;This webhook&#39;s token is unknown, so cannot be used&#34;)
            token = self.token

        elif use_token is undefined.UNDEFINED and self.token:
            token = self.token

        webhook = await self.app.rest.edit_webhook(
            self.id,
            token=token,
            name=name,
            avatar=avatar,
            channel=channel,
            reason=reason,
        )
        assert isinstance(webhook, IncomingWebhook)
        return webhook

    async def fetch_channel(self) -&gt; channels_.WebhookChannelT:
        &#34;&#34;&#34;Fetch the channel this webhook is for.

        Returns
        -------
        hikari.channels.WebhookChannelT
            The object of the channel this webhook targets.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you don&#39;t have access to the channel this webhook belongs to.
        hikari.errors.NotFoundError
            If the channel this message was created in does not exist.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        channel = await self.app.rest.fetch_channel(self.channel_id)
        assert isinstance(channel, channels_.WebhookChannelTypes)
        return channel

    async def fetch_self(self, *, use_token: undefined.UndefinedOr[bool] = undefined.UNDEFINED) -&gt; IncomingWebhook:
        &#34;&#34;&#34;Fetch this webhook.

        Other Parameters
        ----------------
        use_token : hikari.undefined.UndefinedOr[builtins.bool]
            If set to `builtins.True` then the webhook&#39;s token will be used for
            this request; if set to `builtins.False` then bot authorization will
            be used; if not specified then the webhook&#39;s token will be used for
            the request if it&#39;s set else bot authorization.

        Returns
        -------
        IncomingWebhook
            The requested webhook object.

        Raises
        ------
        builtins.ValueError
            If `use_token` is passed as `builtins.True` when `Webhook.token`
            is `builtins.None`.
        hikari.errors.ForbiddenError
            If you&#39;re not in the guild that owns this webhook or
            lack the `MANAGE_WEBHOOKS` permission.
        hikari.errors.NotFoundError
            If the webhook is not found.
        hikari.errors.UnauthorizedError
            If you pass a token that&#39;s invalid for the target webhook.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED
        if use_token:
            if self.token is None:
                raise ValueError(&#34;This webhook&#39;s token is unknown, so cannot be used&#34;)
            token = self.token

        elif use_token is undefined.UNDEFINED and self.token:
            token = self.token

        webhook = await self.app.rest.fetch_webhook(self.id, token=token)
        assert isinstance(webhook, IncomingWebhook)
        return webhook</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="IncomingWebhook -- Represents an incoming webhook object on Discord …" href="#hikari.webhooks.IncomingWebhook"
>IncomingWebhook</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="PartialWebhook -- Base class for all webhook implementations …" href="#hikari.webhooks.PartialWebhook"
>PartialWebhook</a></dt>
<dd class="nested"><p>Base class for all webhook implementations …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Unique -- Mixin for a class that enforces uniqueness by a snowflake ID." href="snowflakes.html#hikari.snowflakes.Unique"
>Unique</a></dt>
<dd class="nested"><p>Mixin for a class that enforces uniqueness by a snowflake ID.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="ExecutableWebhook -- An abstract class with logic for executing entities as webhooks." href="#hikari.webhooks.ExecutableWebhook"
>ExecutableWebhook</a></dt>
<dd class="nested"><p>An abstract class with logic for executing entities as webhooks.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.webhooks.IncomingWebhook.app" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- The client application that models may use for procedures." href="#hikari.webhooks.IncomingWebhook.app"  >app</a> : <a href='traits.html#hikari.traits.RESTAware'>traits.RESTAware</a></code></pre>
</dt>
<dd><p>The client application that models may use for procedures.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.application_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="application_id -- The ID of the application that created this webhook." href="#hikari.webhooks.IncomingWebhook.application_id"  >application_id</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>]</code></pre>
</dt>
<dd><p>The ID of the application that created this webhook.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.author" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="author -- The user that created the webhook …" href="#hikari.webhooks.IncomingWebhook.author"  >author</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='users.html#hikari.users.User'>users_.User</a>]</code></pre>
</dt>
<dd><p>The user that created the webhook</p>
<div class="alert alert-primary">
<p class="admonition-title">Info</p>
<p>This will be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> when fetched with the webhook's token
rather than bot authorization or when received within audit logs.</p>
</div></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.avatar_hash" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_hash -- The avatar hash of the webhook." href="#hikari.webhooks.IncomingWebhook.avatar_hash"  >avatar_hash</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>The avatar hash of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.avatar_url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_url -- URL for this webhook's avatar, if set …" href="#hikari.webhooks.PartialWebhook.avatar_url"  >avatar_url</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>files_.URL</a>]</code></pre>
</dt>
<dd><p>URL for this webhook's avatar, if set.</p>
<p>May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no avatar is set. In this case, you should use
<code>default_avatar_url</code> instead.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.channel_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="channel_id -- The channel ID this webhook is for." href="#hikari.webhooks.IncomingWebhook.channel_id"  >channel_id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>The channel ID this webhook is for.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.created_at" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="created_at -- When the object was created." href="snowflakes.html#hikari.snowflakes.Unique.created_at"  >created_at</a> : <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code></pre>
</dt>
<dd><p>When the object was created.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.default_avatar_url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="default_avatar_url -- Avatar URL for the user, if they have one set …" href="#hikari.webhooks.PartialWebhook.default_avatar_url"  >default_avatar_url</a> : <a href='files.html#hikari.files.URL'>files_.URL</a></code></pre>
</dt>
<dd><p>Avatar URL for the user, if they have one set.</p>
<p>May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no custom avatar is set. In this case, you
should use <code>default_avatar_url</code> instead.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.guild_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="guild_id -- The guild ID of the webhook." href="#hikari.webhooks.IncomingWebhook.guild_id"  >guild_id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>The guild ID of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="id -- The ID of this entity." href="#hikari.webhooks.IncomingWebhook.id"  >id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>The ID of this entity.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.mention" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mention -- Return a raw mention string for the given webhook's user …" href="#hikari.webhooks.PartialWebhook.mention"  >mention</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Return a raw mention string for the given webhook's user.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This exists purely for consistency. Webhooks do not receive events
from the gateway, and without some bot backend to support it, will
not be able to detect mentions of their webhook.</p>
</div>
<h2 id="example">Example</h2>
<pre><code class="language-py">&gt;&gt;&gt; some_webhook.mention
'&lt;@123456789123456789&gt;'
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The mention string to use.</dd>
</dl></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.name" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="name -- The name of the webhook." href="#hikari.webhooks.IncomingWebhook.name"  >name</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>The name of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.token" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="token -- The token for the webhook …" href="#hikari.webhooks.IncomingWebhook.token"  >token</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>The token for the webhook.</p>
<div class="alert alert-primary">
<p class="admonition-title">Info</p>
<p>This is only available for incoming webhooks that are created in the
channel settings.</p>
</div></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.type" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="type -- The type of the webhook." href="#hikari.webhooks.IncomingWebhook.type"  >type</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='#hikari.webhooks.WebhookType'>WebhookType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></pre>
</dt>
<dd><p>The type of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.IncomingWebhook.webhook_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="webhook_id -- ID used to execute this entity as a webhook …" href="#hikari.webhooks.IncomingWebhook.webhook_id"  >webhook_id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></pre>
</dt>
<dd><p>ID used to execute this entity as a webhook.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID used to execute this entity as a webhook.</dd>
</dl></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.webhooks.IncomingWebhook.delete" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete" href="#hikari.webhooks.IncomingWebhook.delete" id="hikari.webhooks.IncomingWebhook.delete">delete</a>(
    *,
    use_token: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete this webhook.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>use_token</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If set to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> then the webhook's token will be used for
this request; if set to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> then bot authorization will
be used; if not specified then the webhook's token will be used for
the request if it's set else bot authorization.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If this webhook is not found.</dd>
<dt><code><a href='errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you either lack the <code>MANAGE_WEBHOOKS</code> permission or
are not a member of the guild this webhook belongs to.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code>use_token</code> is passed as <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> when <code><a href='#hikari.webhooks.IncomingWebhook.token'>token</a></code> is
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L671-L702" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def delete(self, *, use_token: undefined.UndefinedOr[bool] = undefined.UNDEFINED) -&gt; None:
    &#34;&#34;&#34;Delete this webhook.

    Other Parameters
    ----------------
    use_token : hikari.undefined.UndefinedOr[builtins.bool]
        If set to `builtins.True` then the webhook&#39;s token will be used for
        this request; if set to `builtins.False` then bot authorization will
        be used; if not specified then the webhook&#39;s token will be used for
        the request if it&#39;s set else bot authorization.

    Raises
    ------
    hikari.errors.NotFoundError
        If this webhook is not found.
    hikari.errors.ForbiddenError
        If you either lack the `MANAGE_WEBHOOKS` permission or
        are not a member of the guild this webhook belongs to.
    builtins.ValueError
        If `use_token` is passed as `builtins.True` when `IncomingWebhook.token` is
        `builtins.None`.
    &#34;&#34;&#34;
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED
    if use_token:
        if self.token is None:
            raise ValueError(&#34;This webhook&#39;s token is unknown, so cannot be used&#34;)
        token = self.token

    elif use_token is undefined.UNDEFINED and self.token:
        token = self.token

    await self.app.rest.delete_webhook(self.id, token=token)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.IncomingWebhook.delete_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_message" href="#hikari.webhooks.ExecutableWebhook.delete_message" id="hikari.webhooks.IncomingWebhook.delete_message">delete_message</a>(
    message: <a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="ExecutableWebhook -- An abstract class with logic for executing entities as webhooks." href="#hikari.webhooks.ExecutableWebhook"
>ExecutableWebhook</a></code>.<code><a title="delete_message -- Delete a given message in a given channel …" href="#hikari.webhooks.ExecutableWebhook.delete_message"
>delete_message</a></code>
</p>
<p>Delete a given message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete. This may be the object or the ID of
an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code> is not available.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook or the message are not found.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.IncomingWebhook.edit" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit" href="#hikari.webhooks.IncomingWebhook.edit" id="hikari.webhooks.IncomingWebhook.edit">edit</a>(
    *,
    name: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='files.html#hikari.files.Resource'>files_.Resource</a>[<a href='files.html#hikari.files.AsyncReader'>files_.AsyncReader</a>]] = UNDEFINED,
    channel: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='channels.html#hikari.channels.WebhookChannelT'>channels_.WebhookChannelT</a>]] = UNDEFINED,
    reason: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    use_token: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
) -> <a href='#hikari.webhooks.IncomingWebhook'>IncomingWebhook</a>: ...</code></pre>
</dt>
<dd>
<p>Edit this webhook.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new name string.</dd>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new avatar image. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then
it is removed. If not specified, nothing is changed.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='channels.html#hikari.channels.WebhookChannelT'>WebhookChannelT</a>]]</code></dt>
<dd>If provided, the object or ID of the new channel the given
webhook should be moved to.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the audit log reason explaining why the operation
was performed. This field will be used when using the webhook's
token rather than bot authorization.</dd>
<dt><strong><code>use_token</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If set to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> then the webhook's token will be used for
this request; if set to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> then bot authorization will
be used; if not specified then the webhook's token will be used for
the request if it's set else bot authorization.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.webhooks.IncomingWebhook'>IncomingWebhook</a></code></dt>
<dd>The updated webhook object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code>use_token</code> is passed as <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> when <code><a href='#hikari.webhooks.IncomingWebhook.token'>token</a></code> is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
<dt><code><a href='errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any invalid snowflake IDs are passed; a snowflake may be invalid
due to it being outside of the range of a 64 bit integer.</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If either the webhook or the channel are not found.</dd>
<dt><code><a href='errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you either lack the <code>MANAGE_WEBHOOKS</code> permission or
are not a member of the guild this webhook belongs to.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you pass a token that's invalid for the target webhook.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L704-L786" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def edit(
    self,
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar: undefined.UndefinedNoneOr[files_.Resource[files_.AsyncReader]] = undefined.UNDEFINED,
    channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels_.WebhookChannelT]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    use_token: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
) -&gt; IncomingWebhook:
    &#34;&#34;&#34;Edit this webhook.

    Other Parameters
    ----------------
    name : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the new name string.
    avatar : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
        If provided, the new avatar image. If `builtins.None`, then
        it is removed. If not specified, nothing is changed.
    channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]]
        If provided, the object or ID of the new channel the given
        webhook should be moved to.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the audit log reason explaining why the operation
        was performed. This field will be used when using the webhook&#39;s
        token rather than bot authorization.
    use_token : hikari.undefined.UndefinedOr[builtins.bool]
        If set to `builtins.True` then the webhook&#39;s token will be used for
        this request; if set to `builtins.False` then bot authorization will
        be used; if not specified then the webhook&#39;s token will be used for
        the request if it&#39;s set else bot authorization.

    Returns
    -------
    IncomingWebhook
        The updated webhook object.

    Raises
    ------
    builtins.ValueError
        If `use_token` is passed as `builtins.True` when `IncomingWebhook.token` is `builtins.None`.
    hikari.errors.BadRequestError
        If any invalid snowflake IDs are passed; a snowflake may be invalid
        due to it being outside of the range of a 64 bit integer.
    hikari.errors.NotFoundError
        If either the webhook or the channel are not found.
    hikari.errors.ForbiddenError
        If you either lack the `MANAGE_WEBHOOKS` permission or
        are not a member of the guild this webhook belongs to.
    hikari.errors.UnauthorizedError
        If you pass a token that&#39;s invalid for the target webhook.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED
    if use_token:
        if self.token is None:
            raise ValueError(&#34;This webhook&#39;s token is unknown, so cannot be used&#34;)
        token = self.token

    elif use_token is undefined.UNDEFINED and self.token:
        token = self.token

    webhook = await self.app.rest.edit_webhook(
        self.id,
        token=token,
        name=name,
        avatar=avatar,
        channel=channel,
        reason=reason,
    )
    assert isinstance(webhook, IncomingWebhook)
    return webhook</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.IncomingWebhook.edit_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_message" href="#hikari.webhooks.ExecutableWebhook.edit_message" id="hikari.webhooks.IncomingWebhook.edit_message">edit_message</a>(
    message: <a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='messages.html#hikari.messages.Message'>messages_.Message</a>],
    content: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    attachment: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    component: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>special_endpoints.ComponentBuilder</a>] = UNDEFINED,
    components: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>special_endpoints.ComponentBuilder</a>]] = UNDEFINED,
    embed: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    replace_attachments: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
    mentions_everyone: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='users.html#hikari.users.PartialUser'>users_.PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='guilds.html#hikari.guilds.PartialRole'>guilds_.PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
) -> <a href='messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="ExecutableWebhook -- An abstract class with logic for executing entities as webhooks." href="#hikari.webhooks.ExecutableWebhook"
>ExecutableWebhook</a></code>.<code><a title="edit_message -- Edit a message sent by a webhook …" href="#hikari.webhooks.ExecutableWebhook.edit_message"
>edit_message</a></code>
</p>
<p>Edit a message sent by a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete. This may be the object or the ID of
an existing message.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message contents. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> nor
no <code>embeds</code> kwarg is provided, then this will instead
update the embed. This allows for simpler syntax when
sending an embed alone.</p>
<p>Likewise, if this is a <code><a href='files.html#hikari.files.Resource'>Resource</a></code>, then the
content is instead treated as an attachment if no <code>attachment</code> and
no <code>attachments</code> kwargs are provided.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the attachment to set on the message. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous attachment, if
present, is not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the
attachment is removed, if present. Otherwise, the new attachment
that was provided will be attached.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='files.html#hikari.files.Resourceish'>Resourceish</a>]]</code></dt>
<dd>If provided, the attachments to set on the message. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous attachments, if
present, are not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the
attachments is removed, if present. Otherwise, the new attachments
that were provided will be attached.</dd>
<dt><strong><code>component</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]</code></dt>
<dd>If provided, builder object of the component to set for this message.
This component will replace any previously set components and passing
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> will remove all components.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]]</code></dt>
<dd>If provided, a sequence of the component builder objects set for
this message. These components will replace any previously set
components and passing <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> or an empty sequence will
remove all components.</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the embed to set on the message. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed(s) are not changed.
If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then any present embeds are removed.
Otherwise, the new embed that was provided will be used as the
replacement.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='embeds.html#hikari.embeds.Embed'>Embed</a>]]</code></dt>
<dd>If provided, the embeds to set on the message. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed(s) are not changed.
If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then any present embeds are removed.
Otherwise, the new embeds that were provided will be used as the
replacement.</dd>
<dt><strong><code>replace_attachments</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>
<p>Whether to replace the attachments with the provided ones. Defaults
to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</p>
<p>Note this will also overwrite the embed attachments.</p>
</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, sanitation for <code>@everyone</code> mentions. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, then <code>@everyone</code>/<code>@here</code> mentions
in the message content will show up as mentioning everyone that can
view the chat.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='users.html#hikari.users.PartialUser'>PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all user mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all user mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='guilds.html#hikari.guilds.PartialRole'>PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all role mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all role mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Mentioning everyone, roles, or users in message edits currently
will not send a push notification showing a new mention to people
on Discord. It will still highlight in their chat as if they
were mentioned, however.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify a non-embed <code>content</code>, <code>mentions_everyone</code>,
<code>mentions_reply</code>, <code>user_mentions</code>, and <code>role_mentions</code> will default
to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> as the message will be re-parsed for mentions.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all
three of them each time.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify one of <code>mentions_everyone</code>, <code>mentions_reply</code>,
<code>user_mentions</code>, or <code>role_mentions</code>, then all others will default to
<code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, even if they were enabled previously.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all
three of them each time.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The edited message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If more than 100 unique objects/entities are passed for
<code>role_mentions</code> or <code>user_mentions</code> or <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code> is not available.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code> are specified or if both
<code>embed</code> and <code>embeds</code> are specified.</dd>
<dt><code><a href='errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no attachments or embeds; messages with more than
2000 characters in them, embeds that exceed one of the many embed
limits; too many attachments; attachments that are too large;
too many components.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook or the message are not found.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.IncomingWebhook.execute" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="execute" href="#hikari.webhooks.ExecutableWebhook.execute" id="hikari.webhooks.IncomingWebhook.execute">execute</a>(
    content: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    username: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar_url: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    tts: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    attachment: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='files.html#hikari.files.Resourceish'>files_.Resourceish</a>] = UNDEFINED,
    attachments: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='files.html#hikari.files.Resourceish'>files_.Resourceish</a>]] = UNDEFINED,
    component: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>special_endpoints.ComponentBuilder</a>] = UNDEFINED,
    components: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>special_endpoints.ComponentBuilder</a>]] = UNDEFINED,
    embed: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    mentions_everyone: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='users.html#hikari.users.PartialUser'>users_.PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>snowflakes.SnowflakeishSequence</a>[<a href='guilds.html#hikari.guilds.PartialRole'>guilds_.PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    flags: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='undefined.html#hikari.undefined.UndefinedType'>undefined.UndefinedType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='messages.html#hikari.messages.MessageFlag'>messages_.MessageFlag</a>] = UNDEFINED,
) -> <a href='messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="ExecutableWebhook -- An abstract class with logic for executing entities as webhooks." href="#hikari.webhooks.ExecutableWebhook"
>ExecutableWebhook</a></code>.<code><a title="execute -- Execute the webhook to create a message …" href="#hikari.webhooks.ExecutableWebhook.execute"
>execute</a></code>
</p>
<p>Execute the webhook to create a message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message contents. If
<code><a href='undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> kwarg is
provided, then this will instead update the embed. This allows for
simpler syntax when sending an embed alone.</p>
<p>Likewise, if this is a <code><a href='files.html#hikari.files.Resource'>Resource</a></code>, then the
content is instead treated as an attachment if no <code>attachment</code> and
no <code>attachments</code> kwargs are provided.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the username to override the webhook's username
for this request.</dd>
<dt><strong><code>avatar_url</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the url of an image to override the webhook's
avatar with for this request.</dd>
<dt><strong><code>tts</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message will be sent as a TTS message.</dd>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the message attachment. This can be a resource,
or string of a path on your computer or a URL.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='files.html#hikari.files.Resourceish'>Resourceish</a>]]</code></dt>
<dd>If provided, the message attachments. These can be resources, or
strings consisting of paths on your computer or URLs.</dd>
<dt><strong><code>component</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]</code></dt>
<dd>If provided, builder object of the component to include in this message.</dd>
<dt><strong><code>components</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='api/special_endpoints.html#hikari.api.special_endpoints.ComponentBuilder'>ComponentBuilder</a>]]</code></dt>
<dd>If provided, a sequence of the component builder objects to include
in this message.</dd>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the message embed.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='embeds.html#hikari.embeds.Embed'>Embed</a>]]</code></dt>
<dd>If provided, the message embeds.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message should parse @everyone/@here
mentions.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='users.html#hikari.users.PartialUser'>PartialUser</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all mentions will be parsed.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, no mentions will be parsed.
Alternatively this may be a collection of
<code><a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='snowflakes.html#hikari.snowflakes.SnowflakeishSequence'>SnowflakeishSequence</a>[<a href='guilds.html#hikari.guilds.PartialRole'>PartialRole</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all mentions will be parsed.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, no mentions will be parsed.
Alternatively this may be a collection of
<code><a href='snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='undefined.html#hikari.undefined.UndefinedType'>UndefinedType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='messages.html#hikari.messages.MessageFlag'>MessageFlag</a>]</code></dt>
<dd>
<p>The flags to set for this webhook message.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>As of writing this can only be set for interaction webhooks
and the only settable flag is EPHEMERAL; this field is just
ignored for non-interaction webhooks.</p>
</div>
</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>As of writing, <code>username</code> and <code>avatar_url</code> are ignored for
interaction webhooks.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The created message object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the current webhook is not found.</dd>
<dt><code><a href='errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This can be raised if the file is too large; if the embed exceeds
the defined limits; if the message content is specified only and
empty or greater than <code>2000</code> characters; if neither content, file
or embeds are specified.
If any invalid snowflake IDs are passed; a snowflake may be invalid
due to it being outside of the range of a 64 bit integer.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you pass a token that's invalid for the target webhook.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If either <code><a href='#hikari.webhooks.ExecutableWebhook.token'>token</a></code> is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> or more than 100 unique
objects/entities are passed for <code>role_mentions</code> or `user_mentions or
if <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code> is not available.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code> are specified.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.IncomingWebhook.fetch_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel" href="#hikari.webhooks.IncomingWebhook.fetch_channel" id="hikari.webhooks.IncomingWebhook.fetch_channel">fetch_channel</a>() -> Union[<a href='channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a>, <a href='channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the channel this webhook is for.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='channels.html#hikari.channels.WebhookChannelT'>WebhookChannelT</a></code></dt>
<dd>The object of the channel this webhook targets.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you don't have access to the channel this webhook belongs to.</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel this message was created in does not exist.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L788-L820" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel(self) -&gt; channels_.WebhookChannelT:
    &#34;&#34;&#34;Fetch the channel this webhook is for.

    Returns
    -------
    hikari.channels.WebhookChannelT
        The object of the channel this webhook targets.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you don&#39;t have access to the channel this webhook belongs to.
    hikari.errors.NotFoundError
        If the channel this message was created in does not exist.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;
    channel = await self.app.rest.fetch_channel(self.channel_id)
    assert isinstance(channel, channels_.WebhookChannelTypes)
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.IncomingWebhook.fetch_message" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_message" href="#hikari.webhooks.ExecutableWebhook.fetch_message" id="hikari.webhooks.IncomingWebhook.fetch_message">fetch_message</a>(
    message: <a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='messages.html#hikari.messages.Message'>messages_.Message</a>],
) -> <a href='messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="ExecutableWebhook -- An abstract class with logic for executing entities as webhooks." href="#hikari.webhooks.ExecutableWebhook"
>ExecutableWebhook</a></code>.<code><a title="fetch_message -- Fetch an old message sent by the webhook …" href="#hikari.webhooks.ExecutableWebhook.fetch_message"
>fetch_message</a></code>
</p>
<p>Fetch an old message sent by the webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to fetch. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The requested message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/library/token.html#module-token'>token</a></code> is not available.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found or the webhook's message wasn't found.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.IncomingWebhook.fetch_self" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_self" href="#hikari.webhooks.IncomingWebhook.fetch_self" id="hikari.webhooks.IncomingWebhook.fetch_self">fetch_self</a>(
    *,
    use_token: <a href='undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
) -> <a href='#hikari.webhooks.IncomingWebhook'>IncomingWebhook</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch this webhook.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>use_token</code></strong> :&ensp;<code><a href='undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If set to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> then the webhook's token will be used for
this request; if set to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> then bot authorization will
be used; if not specified then the webhook's token will be used for
the request if it's set else bot authorization.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.webhooks.IncomingWebhook'>IncomingWebhook</a></code></dt>
<dd>The requested webhook object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code>use_token</code> is passed as <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> when <code>Webhook.token</code>
is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
<dt><code><a href='errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you're not in the guild that owns this webhook or
lack the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found.</dd>
<dt><code><a href='errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you pass a token that's invalid for the target webhook.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L822-L875" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_self(self, *, use_token: undefined.UndefinedOr[bool] = undefined.UNDEFINED) -&gt; IncomingWebhook:
    &#34;&#34;&#34;Fetch this webhook.

    Other Parameters
    ----------------
    use_token : hikari.undefined.UndefinedOr[builtins.bool]
        If set to `builtins.True` then the webhook&#39;s token will be used for
        this request; if set to `builtins.False` then bot authorization will
        be used; if not specified then the webhook&#39;s token will be used for
        the request if it&#39;s set else bot authorization.

    Returns
    -------
    IncomingWebhook
        The requested webhook object.

    Raises
    ------
    builtins.ValueError
        If `use_token` is passed as `builtins.True` when `Webhook.token`
        is `builtins.None`.
    hikari.errors.ForbiddenError
        If you&#39;re not in the guild that owns this webhook or
        lack the `MANAGE_WEBHOOKS` permission.
    hikari.errors.NotFoundError
        If the webhook is not found.
    hikari.errors.UnauthorizedError
        If you pass a token that&#39;s invalid for the target webhook.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED
    if use_token:
        if self.token is None:
            raise ValueError(&#34;This webhook&#39;s token is unknown, so cannot be used&#34;)
        token = self.token

    elif use_token is undefined.UNDEFINED and self.token:
        token = self.token

    webhook = await self.app.rest.fetch_webhook(self.id, token=token)
    assert isinstance(webhook, IncomingWebhook)
    return webhook</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.webhooks.IncomingWebhook.make_avatar_url" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="make_avatar_url" href="#hikari.webhooks.PartialWebhook.make_avatar_url" id="hikari.webhooks.IncomingWebhook.make_avatar_url">make_avatar_url</a>(
    ext: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a> = 'png',
    size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 4096,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>files_.URL</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="PartialWebhook -- Base class for all webhook implementations …" href="#hikari.webhooks.PartialWebhook"
>PartialWebhook</a></code>.<code><a title="make_avatar_url -- Generate the avatar URL for this webhook's custom avatar if set …" href="#hikari.webhooks.PartialWebhook.make_avatar_url"
>make_avatar_url</a></code>
</p>
<p>Generate the avatar URL for this webhook's custom avatar if set.</p>
<p>If no avatar is specified, return <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>. In this case, you should
use <code>default_avatar</code> instead.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ext</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The extension to use for this URL, defaults to <code>png</code>.
Supports <code>png</code>, <code>jpeg</code>, <code>jpg</code> and <code>webp</code>.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The size to set for the URL, defaults to <code>4096</code>.
Can be any power of two between 16 and 4096.
Will be ignored for default avatars.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>URL</a>]</code></dt>
<dd>The URL of the resource. <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no avatar is set (in
this case, use the <code>default_avatar</code> instead).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code>size</code> is not a power of two between 16 and 4096 (inclusive).</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.webhooks.PartialWebhook" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="PartialWebhook -- Base class for all webhook implementations …" href="#hikari.webhooks.PartialWebhook"
>PartialWebhook</a></h4>
</dt>
<dd>
<pre><code id="hikari.webhooks.PartialWebhook" class="hljs python"><abbr title='A standard Python type.'>class</abbr> PartialWebhook (
    *,
    app: <a href='traits.html#hikari.traits.RESTAware'>traits.RESTAware</a>,
    id: <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    type: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='#hikari.webhooks.WebhookType'>WebhookType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    avatar_hash: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    application_id: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>],
): ...</code></pre>
<p>Base class for all webhook implementations.</p>
<p>Method generated by attrs for class PartialWebhook.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L524-L632" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class PartialWebhook(snowflakes.Unique):
    &#34;&#34;&#34;Base class for all webhook implementations.&#34;&#34;&#34;

    app: traits.RESTAware = attr.field(
        repr=False, eq=False, hash=False, metadata={attr_extensions.SKIP_DEEP_COPY: True}
    )
    &#34;&#34;&#34;The client application that models may use for procedures.&#34;&#34;&#34;

    id: snowflakes.Snowflake = attr.field(hash=True, repr=True)
    &#34;&#34;&#34;The ID of this entity.&#34;&#34;&#34;

    type: typing.Union[WebhookType, int] = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The type of the webhook.&#34;&#34;&#34;

    name: str = attr.field(eq=False, hash=False, repr=True)
    &#34;&#34;&#34;The name of the webhook.&#34;&#34;&#34;

    avatar_hash: typing.Optional[str] = attr.field(eq=False, hash=False, repr=False)
    &#34;&#34;&#34;The avatar hash of the webhook.&#34;&#34;&#34;

    application_id: typing.Optional[snowflakes.Snowflake] = attr.field(eq=False, hash=False, repr=False)
    &#34;&#34;&#34;The ID of the application that created this webhook.&#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return self.name if self.name is not None else f&#34;Unnamed webhook ID {self.id}&#34;

    @property
    def mention(self) -&gt; str:
        &#34;&#34;&#34;Return a raw mention string for the given webhook&#39;s user.

        !!! note
            This exists purely for consistency. Webhooks do not receive events
            from the gateway, and without some bot backend to support it, will
            not be able to detect mentions of their webhook.

        Example
        -------

        ```py
        &gt;&gt;&gt; some_webhook.mention
        &#39;&lt;@123456789123456789&gt;&#39;
        ```

        Returns
        -------
        builtins.str
            The mention string to use.
        &#34;&#34;&#34;
        return f&#34;&lt;@{self.id}&gt;&#34;

    @property
    def avatar_url(self) -&gt; typing.Optional[files_.URL]:
        &#34;&#34;&#34;URL for this webhook&#39;s avatar, if set.

        May be `builtins.None` if no avatar is set. In this case, you should use
        `default_avatar_url` instead.
        &#34;&#34;&#34;
        return self.make_avatar_url()

    @property
    def default_avatar_url(self) -&gt; files_.URL:
        &#34;&#34;&#34;Avatar URL for the user, if they have one set.

        May be `builtins.None` if no custom avatar is set. In this case, you
        should use `default_avatar_url` instead.
        &#34;&#34;&#34;
        return routes.CDN_DEFAULT_USER_AVATAR.compile_to_file(
            urls.CDN_URL,
            discriminator=0,
            file_format=&#34;png&#34;,
        )

    def make_avatar_url(self, ext: str = &#34;png&#34;, size: int = 4096) -&gt; typing.Optional[files_.URL]:
        &#34;&#34;&#34;Generate the avatar URL for this webhook&#39;s custom avatar if set.

        If no avatar is specified, return `None`. In this case, you should
        use `default_avatar` instead.

        Parameters
        ----------
        ext : builtins.str
            The extension to use for this URL, defaults to `png`.
            Supports `png`, `jpeg`, `jpg` and `webp`.
        size : builtins.int
            The size to set for the URL, defaults to `4096`.
            Can be any power of two between 16 and 4096.
            Will be ignored for default avatars.

        Returns
        -------
        typing.Optional[hikari.files.URL]
            The URL of the resource. `builtins.None` if no avatar is set (in
            this case, use the `default_avatar` instead).

        Raises
        ------
        builtins.ValueError
            If `size` is not a power of two between 16 and 4096 (inclusive).
        &#34;&#34;&#34;
        if self.avatar_hash is None:
            return None

        return routes.CDN_USER_AVATAR.compile_to_file(
            urls.CDN_URL,
            user_id=self.id,
            hash=self.avatar_hash,
            size=size,
            file_format=ext,
        )</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ApplicationWebhook -- Represents an application webhook object on Discord …" href="#hikari.webhooks.ApplicationWebhook"
>ApplicationWebhook</a></dt>
<dd class="nested"><p>Represents an application webhook object on Discord …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ChannelFollowerWebhook -- Represents a channel follower webhook object on Discord …" href="#hikari.webhooks.ChannelFollowerWebhook"
>ChannelFollowerWebhook</a></dt>
<dd class="nested"><p>Represents a channel follower webhook object on Discord …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="IncomingWebhook -- Represents an incoming webhook object on Discord …" href="#hikari.webhooks.IncomingWebhook"
>IncomingWebhook</a></dt>
<dd class="nested"><p>Represents an incoming webhook object on Discord …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="PartialWebhook -- Base class for all webhook implementations …" href="#hikari.webhooks.PartialWebhook"
>PartialWebhook</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Unique -- Mixin for a class that enforces uniqueness by a snowflake ID." href="snowflakes.html#hikari.snowflakes.Unique"
>Unique</a></dt>
<dd class="nested"><p>Mixin for a class that enforces uniqueness by a snowflake ID.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.webhooks.PartialWebhook.app" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- The client application that models may use for procedures." href="#hikari.webhooks.PartialWebhook.app"  >app</a> : <a href='traits.html#hikari.traits.RESTAware'>traits.RESTAware</a></code></pre>
</dt>
<dd><p>The client application that models may use for procedures.</p></dd>
</div>
<div id="hikari.webhooks.PartialWebhook.application_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="application_id -- The ID of the application that created this webhook." href="#hikari.webhooks.PartialWebhook.application_id"  >application_id</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>]</code></pre>
</dt>
<dd><p>The ID of the application that created this webhook.</p></dd>
</div>
<div id="hikari.webhooks.PartialWebhook.avatar_hash" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_hash -- The avatar hash of the webhook." href="#hikari.webhooks.PartialWebhook.avatar_hash"  >avatar_hash</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></pre>
</dt>
<dd><p>The avatar hash of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.PartialWebhook.avatar_url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="avatar_url -- URL for this webhook's avatar, if set …" href="#hikari.webhooks.PartialWebhook.avatar_url"  >avatar_url</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>files_.URL</a>]</code></pre>
</dt>
<dd><p>URL for this webhook's avatar, if set.</p>
<p>May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no avatar is set. In this case, you should use
<code>default_avatar_url</code> instead.</p></dd>
</div>
<div id="hikari.webhooks.PartialWebhook.created_at" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="created_at -- When the object was created." href="snowflakes.html#hikari.snowflakes.Unique.created_at"  >created_at</a> : <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code></pre>
</dt>
<dd><p>When the object was created.</p></dd>
</div>
<div id="hikari.webhooks.PartialWebhook.default_avatar_url" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="default_avatar_url -- Avatar URL for the user, if they have one set …" href="#hikari.webhooks.PartialWebhook.default_avatar_url"  >default_avatar_url</a> : <a href='files.html#hikari.files.URL'>files_.URL</a></code></pre>
</dt>
<dd><p>Avatar URL for the user, if they have one set.</p>
<p>May be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no custom avatar is set. In this case, you
should use <code>default_avatar_url</code> instead.</p></dd>
</div>
<div id="hikari.webhooks.PartialWebhook.id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="id -- The ID of this entity." href="#hikari.webhooks.PartialWebhook.id"  >id</a> : <a href='snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>The ID of this entity.</p></dd>
</div>
<div id="hikari.webhooks.PartialWebhook.mention" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="mention -- Return a raw mention string for the given webhook's user …" href="#hikari.webhooks.PartialWebhook.mention"  >mention</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Return a raw mention string for the given webhook's user.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This exists purely for consistency. Webhooks do not receive events
from the gateway, and without some bot backend to support it, will
not be able to detect mentions of their webhook.</p>
</div>
<h2 id="example">Example</h2>
<pre><code class="language-py">&gt;&gt;&gt; some_webhook.mention
'&lt;@123456789123456789&gt;'
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The mention string to use.</dd>
</dl></dd>
</div>
<div id="hikari.webhooks.PartialWebhook.name" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="name -- The name of the webhook." href="#hikari.webhooks.PartialWebhook.name"  >name</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>The name of the webhook.</p></dd>
</div>
<div id="hikari.webhooks.PartialWebhook.type" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="type -- The type of the webhook." href="#hikari.webhooks.PartialWebhook.type"  >type</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='#hikari.webhooks.WebhookType'>WebhookType</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></pre>
</dt>
<dd><p>The type of the webhook.</p></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.webhooks.PartialWebhook.make_avatar_url" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="make_avatar_url" href="#hikari.webhooks.PartialWebhook.make_avatar_url" id="hikari.webhooks.PartialWebhook.make_avatar_url">make_avatar_url</a>(
    ext: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a> = 'png',
    size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 4096,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>files_.URL</a>]: ...</code></pre>
</dt>
<dd>
<p>Generate the avatar URL for this webhook's custom avatar if set.</p>
<p>If no avatar is specified, return <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>. In this case, you should
use <code>default_avatar</code> instead.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ext</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The extension to use for this URL, defaults to <code>png</code>.
Supports <code>png</code>, <code>jpeg</code>, <code>jpg</code> and <code>webp</code>.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The size to set for the URL, defaults to <code>4096</code>.
Can be any power of two between 16 and 4096.
Will be ignored for default avatars.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='files.html#hikari.files.URL'>URL</a>]</code></dt>
<dd>The URL of the resource. <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no avatar is set (in
this case, use the <code>default_avatar</code> instead).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If <code>size</code> is not a power of two between 16 and 4096 (inclusive).</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L596-L632" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def make_avatar_url(self, ext: str = &#34;png&#34;, size: int = 4096) -&gt; typing.Optional[files_.URL]:
    &#34;&#34;&#34;Generate the avatar URL for this webhook&#39;s custom avatar if set.

    If no avatar is specified, return `None`. In this case, you should
    use `default_avatar` instead.

    Parameters
    ----------
    ext : builtins.str
        The extension to use for this URL, defaults to `png`.
        Supports `png`, `jpeg`, `jpg` and `webp`.
    size : builtins.int
        The size to set for the URL, defaults to `4096`.
        Can be any power of two between 16 and 4096.
        Will be ignored for default avatars.

    Returns
    -------
    typing.Optional[hikari.files.URL]
        The URL of the resource. `builtins.None` if no avatar is set (in
        this case, use the `default_avatar` instead).

    Raises
    ------
    builtins.ValueError
        If `size` is not a power of two between 16 and 4096 (inclusive).
    &#34;&#34;&#34;
    if self.avatar_hash is None:
        return None

    return routes.CDN_USER_AVATAR.compile_to_file(
        urls.CDN_URL,
        user_id=self.id,
        hash=self.avatar_hash,
        size=size,
        file_format=ext,
    )</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.webhooks.WebhookType" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python enum type. This contains one or more discrete "constant" values.'>enum</abbr></em></small> <a title="WebhookType -- Types of webhook." href="#hikari.webhooks.WebhookType"
>WebhookType</a></h4>
</dt>
<dd>
<pre><code id="hikari.webhooks.WebhookType" class="hljs python"><abbr title='A standard Python type.'>class</abbr> WebhookType (
    value: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
): ...</code></pre>
<p>Types of webhook.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/webhooks.py#L61-L71" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class WebhookType(int, enums.Enum):
    &#34;&#34;&#34;Types of webhook.&#34;&#34;&#34;

    INCOMING = 1
    &#34;&#34;&#34;Incoming webhook.&#34;&#34;&#34;

    CHANNEL_FOLLOWER = 2
    &#34;&#34;&#34;Channel Follower webhook.&#34;&#34;&#34;

    APPLICATION = 3
    &#34;&#34;&#34;Application webhook (from the interactions flow).&#34;&#34;&#34;</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python enum type. This contains one or more discrete "constant" values.'>enum</abbr></em></small> <a title="WebhookType -- Types of webhook." href="#hikari.webhooks.WebhookType"
>WebhookType</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="builtins.int -- int([x]) -> integer
int(x, base=10) -> integer …" href="https://docs.python.org/3/library/functions.html#int"
>int</a></dt>
<dd class="nested"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python enum type. This contains one or more discrete "constant" values.'>enum</abbr></em></small> <a title="Enum -- Clone of Python's `enum.Enum` implementation …" href="internal/enums.html#hikari.internal.enums.Enum"
>Enum</a></dt>
<dd class="nested"><p>Clone of Python's <code><a href='https://docs.python.org/3/library/enum.html#enum.Enum'>enum.Enum</a></code> implementation …</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.webhooks.WebhookType.name" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="name -- Return the name of the enum member as a `builtins.str`." href="internal/enums.html#hikari.internal.enums.Enum.name"  >name</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Return the name of the enum member as a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p></dd>
</div>
<div id="hikari.webhooks.WebhookType.value" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="value -- Return the value of the enum member." href="internal/enums.html#hikari.internal.enums.Enum.value"  >value</a></code></pre>
</dt>
<dd><p>Return the value of the enum member.</p></dd>
</div>
<div id="hikari.webhooks.WebhookType.APPLICATION" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A variable that should be considered to be a constant value.'>const</abbr></em></small> <a title="APPLICATION -- Application webhook (from the interactions flow)." href="#hikari.webhooks.WebhookType.APPLICATION"  >APPLICATION</a> = 3</code></pre>
</dt>
<dd><p>Application webhook (from the interactions flow).</p></dd>
</div>
<div id="hikari.webhooks.WebhookType.CHANNEL_FOLLOWER" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A variable that should be considered to be a constant value.'>const</abbr></em></small> <a title="CHANNEL_FOLLOWER -- Channel Follower webhook." href="#hikari.webhooks.WebhookType.CHANNEL_FOLLOWER"  >CHANNEL_FOLLOWER</a> = 2</code></pre>
</dt>
<dd><p>Channel Follower webhook.</p></dd>
</div>
<div id="hikari.webhooks.WebhookType.INCOMING" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A variable that should be considered to be a constant value.'>const</abbr></em></small> <a title="INCOMING -- Incoming webhook." href="#hikari.webhooks.WebhookType.INCOMING"  >INCOMING</a> = 1</code></pre>
</dt>
<dd><p>Incoming webhook.</p></dd>
</div>
</dl>
<div class="sep"></div>
</dd>
</div>
</dl>
</section>
</div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>