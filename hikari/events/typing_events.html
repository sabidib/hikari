<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.events.typing_events API documentation</title>
<meta name="description" content="Events fired when users begin typing in channels.">
<meta property="og:title" content="hikari.events.typing_events module list">
<meta property="og:type" content="website">
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png">
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions">
<meta property="theme-color" content="#ff029a">
<link rel="shortcut icon" type="image/png" href="../../logo.png">
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
text-indent: 100%;
white-space: nowrap;
overflow: hidden;
}
small.smaller {
font-size: 0.50em;
}
html {
height: 100%;
scroll-behavior: smooth;
scrollbar-color: #202324 #454a4d;
}
body {
background-color: #181A1B;
color: #C9C5C0;
height: fit-content;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.container > li {
margin-left: 1em;
margin-top: 2.5em;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
.anchor:target {
background-color: var(--dark);
}
@media screen and (max-width: 990px) {
.anchor:target {
margin-left: -2em;
padding-left: 2em;
}
}
@media screen and (min-width: 990px) {
.anchor:target {
border-radius: 0.5em; !important
margin-right: -2em;
padding-right: 2em;
margin-top: -1em;
padding-top: 1em;
}
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="../../logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small class="smaller">2.0.0.dev102</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
<li class="nav-item"><a class="nav-link active" href="../../hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" action="../../hikari/search.html">
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search" name="q"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.events -- Events that can be fired by Hikari's gateway implementation." href="index.html"
>events</a></li>
<li class="breadcrumb-item active"><a href="#">typing_events</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Events fired when users begin typing in channels.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="DMTypingEvent -- Event fired when a user starts typing in a guild channel …" href="#hikari.events.typing_events.DMTypingEvent"
>DMTypingEvent</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- App instance for this application …" href="#hikari.events.typing_events.DMTypingEvent.app"
>app</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="channel_id -- ID of the channel that this event concerns …" href="#hikari.events.typing_events.DMTypingEvent.channel_id"
>channel_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel -- Perform an API call to fetch an up-to-date image of this channel …" href="#hikari.events.typing_events.DMTypingEvent.fetch_channel"
>fetch_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_user -- Perform an API call to fetch an up-to-date image of this user …" href="#hikari.events.typing_events.TypingEvent.fetch_user"
>fetch_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_user -- Get the cached user that is typing, if known …" href="#hikari.events.typing_events.TypingEvent.get_user"
>get_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="shard -- Shard that received this event …" href="#hikari.events.typing_events.DMTypingEvent.shard"
>shard</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="timestamp -- Timestamp of when this typing event started …" href="#hikari.events.typing_events.DMTypingEvent.timestamp"
>timestamp</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="trigger_typing -- Return a typing indicator for this channel that can be awaited …" href="#hikari.events.typing_events.TypingEvent.trigger_typing"
>trigger_typing</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="user_id -- ID of the user who triggered this typing event …" href="#hikari.events.typing_events.DMTypingEvent.user_id"
>user_id</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="GuildTypingEvent -- Event fired when a user starts typing in a guild channel …" href="#hikari.events.typing_events.GuildTypingEvent"
>GuildTypingEvent</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- App instance for this application …" href="#hikari.events.typing_events.GuildTypingEvent.app"
>app</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="channel_id -- ID of the channel that this event concerns …" href="#hikari.events.typing_events.GuildTypingEvent.channel_id"
>channel_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel -- Perform an API call to fetch an up-to-date image of this channel …" href="#hikari.events.typing_events.GuildTypingEvent.fetch_channel"
>fetch_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild -- Perform an API call to fetch an up-to-date image of this guild …" href="#hikari.events.typing_events.GuildTypingEvent.fetch_guild"
>fetch_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_preview -- Perform an API call to fetch an up-to-date preview of this guild …" href="#hikari.events.typing_events.GuildTypingEvent.fetch_guild_preview"
>fetch_guild_preview</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_member -- Perform an API call to fetch an up-to-date image of this event's member …" href="#hikari.events.typing_events.GuildTypingEvent.fetch_member"
>fetch_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_user -- Perform an API call to fetch an up-to-date image of this user …" href="#hikari.events.typing_events.TypingEvent.fetch_user"
>fetch_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_channel -- Get the cached channel object this typing event occurred in …" href="#hikari.events.typing_events.GuildTypingEvent.get_channel"
>get_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_guild -- Get the cached object of the guild this typing event occurred in …" href="#hikari.events.typing_events.GuildTypingEvent.get_guild"
>get_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_user -- Get the cached user that is typing, if known …" href="#hikari.events.typing_events.TypingEvent.get_user"
>get_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="guild_id -- ID of the guild that this event relates to …" href="#hikari.events.typing_events.GuildTypingEvent.guild_id"
>guild_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="member -- Object of the member who triggered this typing event …" href="#hikari.events.typing_events.GuildTypingEvent.member"
>member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="shard -- Shard that received this event …" href="#hikari.events.typing_events.GuildTypingEvent.shard"
>shard</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="timestamp -- Timestamp of when this typing event started …" href="#hikari.events.typing_events.GuildTypingEvent.timestamp"
>timestamp</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="trigger_typing -- Return a typing indicator for this channel that can be awaited …" href="#hikari.events.typing_events.TypingEvent.trigger_typing"
>trigger_typing</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="user_id -- ID of the user who triggered this typing event …" href="#hikari.events.typing_events.GuildTypingEvent.user_id"
>user_id</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- App instance for this application …" href="base_events.html#hikari.events.base_events.Event.app"
>app</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="channel_id -- ID of the channel that this event concerns …" href="#hikari.events.typing_events.TypingEvent.channel_id"
>channel_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel -- Perform an API call to fetch an up-to-date image of this channel …" href="#hikari.events.typing_events.TypingEvent.fetch_channel"
>fetch_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_user -- Perform an API call to fetch an up-to-date image of this user …" href="#hikari.events.typing_events.TypingEvent.fetch_user"
>fetch_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_user -- Get the cached user that is typing, if known …" href="#hikari.events.typing_events.TypingEvent.get_user"
>get_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="shard -- Shard that received this event …" href="shard_events.html#hikari.events.shard_events.ShardEvent.shard"
>shard</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="timestamp -- Timestamp of when this typing event started …" href="#hikari.events.typing_events.TypingEvent.timestamp"
>timestamp</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="trigger_typing -- Return a typing indicator for this channel that can be awaited …" href="#hikari.events.typing_events.TypingEvent.trigger_typing"
>trigger_typing</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="user_id -- ID of the user who triggered this typing event …" href="#hikari.events.typing_events.TypingEvent.user_id"
>user_id</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L1-L336" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
# Copyright (c) 2021 davfsa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Events fired when users begin typing in channels.&#34;&#34;&#34;
from __future__ import annotations

__all__: typing.List[str] = [
    &#34;TypingEvent&#34;,
    &#34;GuildTypingEvent&#34;,
    &#34;DMTypingEvent&#34;,
]

import abc
import typing

import attr

from hikari import channels
from hikari import intents
from hikari import traits
from hikari.api import special_endpoints
from hikari.events import base_events
from hikari.events import shard_events
from hikari.internal import attr_extensions

if typing.TYPE_CHECKING:
    import datetime

    from hikari import guilds
    from hikari import snowflakes
    from hikari import users
    from hikari.api import shard as gateway_shard


@base_events.requires_intents(intents.Intents.GUILD_MESSAGE_TYPING, intents.Intents.DM_MESSAGE_TYPING)
class TypingEvent(shard_events.ShardEvent, abc.ABC):
    &#34;&#34;&#34;Base event fired when a user begins typing in a channel.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @property
    @abc.abstractmethod
    def channel_id(self) -&gt; snowflakes.Snowflake:
        &#34;&#34;&#34;ID of the channel that this event concerns.

        Returns
        -------
        hikari.snowflakes.Snowflake
            The ID of the channel that this event concerns.
        &#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def user_id(self) -&gt; snowflakes.Snowflake:
        &#34;&#34;&#34;ID of the user who triggered this typing event.

        Returns
        -------
        hikari.snowflakes.Snowflake
            ID of the user who is typing.
        &#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def timestamp(self) -&gt; datetime.datetime:
        &#34;&#34;&#34;Timestamp of when this typing event started.

        Returns
        -------
        datetime.datetime
            UTC timestamp of when the user started typing.
        &#34;&#34;&#34;

    async def fetch_channel(self) -&gt; channels.TextableChannel:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this channel.

        Returns
        -------
        hikari.channels.TextableChannel
            The channel.
        &#34;&#34;&#34;
        channel = await self.app.rest.fetch_channel(self.channel_id)
        assert isinstance(channel, channels.TextableChannel)
        return channel

    def get_user(self) -&gt; typing.Optional[users.User]:
        &#34;&#34;&#34;Get the cached user that is typing, if known.

        Returns
        -------
        typing.Optional[hikari.users.User]
            The user, if known.
        &#34;&#34;&#34;
        if isinstance(self.app, traits.CacheAware):
            return self.app.cache.get_user(self.user_id)

        return None

    async def fetch_user(self) -&gt; users.User:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this user.

        Returns
        -------
        hikari.users.User
            The user.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the user is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        return await self.app.rest.fetch_user(self.user_id)

    def trigger_typing(self) -&gt; special_endpoints.TypingIndicator:
        &#34;&#34;&#34;Return a typing indicator for this channel that can be awaited.

        Returns
        -------
        hikari.api.special_endpoints.TypingIndicator
            A typing indicator context manager and awaitable to trigger typing
            in a channel with.
        &#34;&#34;&#34;
        return self.app.rest.trigger_typing(self.channel_id)


@base_events.requires_intents(intents.Intents.GUILD_MESSAGE_TYPING)
@attr_extensions.with_copy
@attr.define(kw_only=True, weakref_slot=False)
class GuildTypingEvent(TypingEvent):
    &#34;&#34;&#34;Event fired when a user starts typing in a guild channel.&#34;&#34;&#34;

    shard: gateway_shard.GatewayShard = attr.field(metadata={attr_extensions.SKIP_DEEP_COPY: True})
    # &lt;&lt;inherited docstring from ShardEvent&gt;&gt;.

    channel_id: snowflakes.Snowflake = attr.field()
    # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.

    timestamp: datetime.datetime = attr.field(repr=False)
    # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.

    guild_id: snowflakes.Snowflake = attr.field()
    &#34;&#34;&#34;ID of the guild that this event relates to.

    Returns
    -------
    hikari.snowflakes.Snowflake
        The ID of the guild that relates to this event.
    &#34;&#34;&#34;

    member: guilds.Member = attr.field(repr=False)
    &#34;&#34;&#34;Object of the member who triggered this typing event.

    Returns
    -------
    hikari.guilds.Member
        Object of the member who triggered this typing event.
    &#34;&#34;&#34;

    @property
    def app(self) -&gt; traits.RESTAware:
        # &lt;&lt;inherited docstring from Event&gt;&gt;.
        return self.member.app

    @property
    def user_id(self) -&gt; snowflakes.Snowflake:
        # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.
        return self.member.id

    async def fetch_channel(self) -&gt; typing.Union[channels.TextableGuildChannel]:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this channel.

        Returns
        -------
        typing.Union[hikari.channels.TextableGuildChannel]
            The channel.
        &#34;&#34;&#34;
        channel = await super().fetch_channel()
        assert isinstance(
            channel, channels.TextableGuildChannel
        ), f&#34;expected TextableGuildChannel from API, got {channel}&#34;
        return channel

    async def fetch_guild(self) -&gt; guilds.Guild:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this guild.

        Returns
        -------
        hikari.guilds.Guild
            The guild.
        &#34;&#34;&#34;
        return await self.app.rest.fetch_guild(self.guild_id)

    async def fetch_guild_preview(self) -&gt; guilds.GuildPreview:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date preview of this guild.

        Returns
        -------
        hikari.guilds.GuildPreview
            The guild.
        &#34;&#34;&#34;
        return await self.app.rest.fetch_guild_preview(self.guild_id)

    async def fetch_member(self) -&gt; guilds.Member:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this event&#39;s member.

        Returns
        -------
        hikari.guilds.Member
            The member.
        &#34;&#34;&#34;
        return await self.app.rest.fetch_member(self.guild_id, self.user_id)

    def get_channel(self) -&gt; typing.Optional[channels.TextableGuildChannel]:
        &#34;&#34;&#34;Get the cached channel object this typing event occurred in.

        Returns
        -------
        typing.Optional[hikari.channels.TextableGuildChannel]
            The channel.
        &#34;&#34;&#34;
        if not isinstance(self.app, traits.CacheAware):
            return None

        channel = self.app.cache.get_guild_channel(self.channel_id)
        assert channel is None or isinstance(
            channel, channels.TextableGuildChannel
        ), f&#34;expected TextableGuildChannel from cache, got {channel}&#34;
        return channel

    def get_guild(self) -&gt; typing.Optional[guilds.GatewayGuild]:
        &#34;&#34;&#34;Get the cached object of the guild this typing event occurred in.

        If the guild is not found then this will return `builtins.None`.

        Returns
        -------
        typing.Optional[hikari.guilds.GatewayGuild]
            The object of the gateway guild if found else `builtins.None`.
        &#34;&#34;&#34;
        if not isinstance(self.app, traits.CacheAware):
            return None

        return self.app.cache.get_available_guild(self.guild_id) or self.app.cache.get_unavailable_guild(self.guild_id)


@base_events.requires_intents(intents.Intents.DM_MESSAGES)
@attr_extensions.with_copy
@attr.define(kw_only=True, weakref_slot=False)
class DMTypingEvent(TypingEvent):
    &#34;&#34;&#34;Event fired when a user starts typing in a guild channel.&#34;&#34;&#34;

    app: traits.RESTAware = attr.field(metadata={attr_extensions.SKIP_DEEP_COPY: True})
    # &lt;&lt;inherited docstring from Event&gt;&gt;.

    shard: gateway_shard.GatewayShard = attr.field(metadata={attr_extensions.SKIP_DEEP_COPY: True})
    # &lt;&lt;inherited docstring from ShardEvent&gt;&gt;.

    channel_id: snowflakes.Snowflake = attr.field()
    # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.

    user_id: snowflakes.Snowflake = attr.field(repr=True)
    # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.

    timestamp: datetime.datetime = attr.field(repr=False)
    # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.

    async def fetch_channel(self) -&gt; channels.DMChannel:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this channel.

        Returns
        -------
        hikari.channels.DMChannel
            The channel.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `READ_MESSAGES` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        channel = await super().fetch_channel()
        assert isinstance(channel, channels.DMChannel), f&#34;expected DMChannel from API, got {channel}&#34;
        return channel</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.events.typing_events.DMTypingEvent" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="DMTypingEvent -- Event fired when a user starts typing in a guild channel …" href="#hikari.events.typing_events.DMTypingEvent"
>DMTypingEvent</a></h4>
</dt>
<dd>
<pre><code id="hikari.events.typing_events.DMTypingEvent" class="hljs python"><abbr title='A standard Python type.'>class</abbr> DMTypingEvent (
    *,
    app: <a href='../traits.html#hikari.traits.RESTAware'>traits.RESTAware</a>,
    shard: <a href='../api/shard.html#hikari.api.shard.GatewayShard'>gateway_shard.GatewayShard</a>,
    channel_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    user_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    timestamp: <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a>,
): ...</code></pre>
<p>Event fired when a user starts typing in a guild channel.</p>
<p>This requires one of the following combinations of intents in order to be dispatched:</p>
<ul>
<li><code><a href='../intents.html#hikari.intents.Intents.DM_MESSAGES'>DM_MESSAGES</a></code></li>
</ul>
<p>Method generated by attrs for class DMTypingEvent.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L283-L336" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class DMTypingEvent(TypingEvent):
    &#34;&#34;&#34;Event fired when a user starts typing in a guild channel.&#34;&#34;&#34;

    app: traits.RESTAware = attr.field(metadata={attr_extensions.SKIP_DEEP_COPY: True})
    # &lt;&lt;inherited docstring from Event&gt;&gt;.

    shard: gateway_shard.GatewayShard = attr.field(metadata={attr_extensions.SKIP_DEEP_COPY: True})
    # &lt;&lt;inherited docstring from ShardEvent&gt;&gt;.

    channel_id: snowflakes.Snowflake = attr.field()
    # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.

    user_id: snowflakes.Snowflake = attr.field(repr=True)
    # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.

    timestamp: datetime.datetime = attr.field(repr=False)
    # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.

    async def fetch_channel(self) -&gt; channels.DMChannel:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this channel.

        Returns
        -------
        hikari.channels.DMChannel
            The channel.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `READ_MESSAGES` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        channel = await super().fetch_channel()
        assert isinstance(channel, channels.DMChannel), f&#34;expected DMChannel from API, got {channel}&#34;
        return channel</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="DMTypingEvent -- Event fired when a user starts typing in a guild channel …" href="#hikari.events.typing_events.DMTypingEvent"
>DMTypingEvent</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a></dt>
<dd class="nested"><p>Base event fired when a user begins typing in a channel …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="ShardEvent -- Base class for any event that was shard-specific." href="shard_events.html#hikari.events.shard_events.ShardEvent"
>ShardEvent</a></dt>
<dd class="nested"><p>Base class for any event that was shard-specific.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Event -- Base event type that all Hikari events should subclass." href="base_events.html#hikari.events.base_events.Event"
>Event</a></dt>
<dd class="nested"><p>Base event type that all Hikari events should subclass.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.events.typing_events.DMTypingEvent.app" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- App instance for this application …" href="#hikari.events.typing_events.DMTypingEvent.app"  >app</a> : <a href='../traits.html#hikari.traits.RESTAware'>traits.RESTAware</a></code></pre>
</dt>
<dd><p>App instance for this application.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../traits.html#hikari.traits.RESTAware'>RESTAware</a></code></dt>
<dd>The REST-aware app trait.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.DMTypingEvent.channel_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="channel_id -- ID of the channel that this event concerns …" href="#hikari.events.typing_events.DMTypingEvent.channel_id"  >channel_id</a> : <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>ID of the channel that this event concerns.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the channel that this event concerns.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.DMTypingEvent.shard" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="shard -- Shard that received this event …" href="#hikari.events.typing_events.DMTypingEvent.shard"  >shard</a> : <a href='../api/shard.html#hikari.api.shard.GatewayShard'>gateway_shard.GatewayShard</a></code></pre>
</dt>
<dd><p>Shard that received this event.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/shard.html#hikari.api.shard.GatewayShard'>GatewayShard</a></code></dt>
<dd>The shard that triggered the event.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.DMTypingEvent.timestamp" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="timestamp -- Timestamp of when this typing event started …" href="#hikari.events.typing_events.DMTypingEvent.timestamp"  >timestamp</a> : <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code></pre>
</dt>
<dd><p>Timestamp of when this typing event started.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code></dt>
<dd>UTC timestamp of when the user started typing.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.DMTypingEvent.user_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="user_id -- ID of the user who triggered this typing event …" href="#hikari.events.typing_events.DMTypingEvent.user_id"  >user_id</a> : <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>ID of the user who triggered this typing event.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>ID of the user who is typing.</dd>
</dl></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.events.typing_events.DMTypingEvent.fetch_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel" href="#hikari.events.typing_events.DMTypingEvent.fetch_channel" id="hikari.events.typing_events.DMTypingEvent.fetch_channel">fetch_channel</a>() -> <a href='../channels.html#hikari.channels.DMChannel'>DMChannel</a>: ...</code></pre>
</dt>
<dd>
<p>Perform an API call to fetch an up-to-date image of this channel.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.DMChannel'>DMChannel</a></code></dt>
<dd>The channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGES</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L301-L336" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel(self) -&gt; channels.DMChannel:
    &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this channel.

    Returns
    -------
    hikari.channels.DMChannel
        The channel.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `READ_MESSAGES` permission in the channel.
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;
    channel = await super().fetch_channel()
    assert isinstance(channel, channels.DMChannel), f&#34;expected DMChannel from API, got {channel}&#34;
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.DMTypingEvent.fetch_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_user" href="#hikari.events.typing_events.TypingEvent.fetch_user" id="hikari.events.typing_events.DMTypingEvent.fetch_user">fetch_user</a>() -> <a href='../users.html#hikari.users.User'>users.User</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a></code>.<code><a title="fetch_user -- Perform an API call to fetch an up-to-date image of this user …" href="#hikari.events.typing_events.TypingEvent.fetch_user"
>fetch_user</a></code>
</p>
<p>Perform an API call to fetch an up-to-date image of this user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.User'>User</a></code></dt>
<dd>The user.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.DMTypingEvent.get_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_user" href="#hikari.events.typing_events.TypingEvent.get_user" id="hikari.events.typing_events.DMTypingEvent.get_user">get_user</a>() -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>users.User</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a></code>.<code><a title="get_user -- Get the cached user that is typing, if known …" href="#hikari.events.typing_events.TypingEvent.get_user"
>get_user</a></code>
</p>
<p>Get the cached user that is typing, if known.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>The user, if known.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.DMTypingEvent.trigger_typing" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="trigger_typing" href="#hikari.events.typing_events.TypingEvent.trigger_typing" id="hikari.events.typing_events.DMTypingEvent.trigger_typing">trigger_typing</a>() -> <a href='../api/special_endpoints.html#hikari.api.special_endpoints.TypingIndicator'>TypingIndicator</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a></code>.<code><a title="trigger_typing -- Return a typing indicator for this channel that can be awaited …" href="#hikari.events.typing_events.TypingEvent.trigger_typing"
>trigger_typing</a></code>
</p>
<p>Return a typing indicator for this channel that can be awaited.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.TypingIndicator'>TypingIndicator</a></code></dt>
<dd>A typing indicator context manager and awaitable to trigger typing
in a channel with.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.events.typing_events.GuildTypingEvent" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="GuildTypingEvent -- Event fired when a user starts typing in a guild channel …" href="#hikari.events.typing_events.GuildTypingEvent"
>GuildTypingEvent</a></h4>
</dt>
<dd>
<pre><code id="hikari.events.typing_events.GuildTypingEvent" class="hljs python"><abbr title='A standard Python type.'>class</abbr> GuildTypingEvent (
    *,
    shard: <a href='../api/shard.html#hikari.api.shard.GatewayShard'>gateway_shard.GatewayShard</a>,
    channel_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    timestamp: <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a>,
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    member: <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>,
): ...</code></pre>
<p>Event fired when a user starts typing in a guild channel.</p>
<p>This requires one of the following combinations of intents in order to be dispatched:</p>
<ul>
<li><code><a href='../intents.html#hikari.intents.Intents.GUILD_MESSAGE_TYPING'>GUILD_MESSAGE_TYPING</a></code></li>
</ul>
<p>Method generated by attrs for class GuildTypingEvent.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L163-L277" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class GuildTypingEvent(TypingEvent):
    &#34;&#34;&#34;Event fired when a user starts typing in a guild channel.&#34;&#34;&#34;

    shard: gateway_shard.GatewayShard = attr.field(metadata={attr_extensions.SKIP_DEEP_COPY: True})
    # &lt;&lt;inherited docstring from ShardEvent&gt;&gt;.

    channel_id: snowflakes.Snowflake = attr.field()
    # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.

    timestamp: datetime.datetime = attr.field(repr=False)
    # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.

    guild_id: snowflakes.Snowflake = attr.field()
    &#34;&#34;&#34;ID of the guild that this event relates to.

    Returns
    -------
    hikari.snowflakes.Snowflake
        The ID of the guild that relates to this event.
    &#34;&#34;&#34;

    member: guilds.Member = attr.field(repr=False)
    &#34;&#34;&#34;Object of the member who triggered this typing event.

    Returns
    -------
    hikari.guilds.Member
        Object of the member who triggered this typing event.
    &#34;&#34;&#34;

    @property
    def app(self) -&gt; traits.RESTAware:
        # &lt;&lt;inherited docstring from Event&gt;&gt;.
        return self.member.app

    @property
    def user_id(self) -&gt; snowflakes.Snowflake:
        # &lt;&lt;inherited docstring from TypingEvent&gt;&gt;.
        return self.member.id

    async def fetch_channel(self) -&gt; typing.Union[channels.TextableGuildChannel]:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this channel.

        Returns
        -------
        typing.Union[hikari.channels.TextableGuildChannel]
            The channel.
        &#34;&#34;&#34;
        channel = await super().fetch_channel()
        assert isinstance(
            channel, channels.TextableGuildChannel
        ), f&#34;expected TextableGuildChannel from API, got {channel}&#34;
        return channel

    async def fetch_guild(self) -&gt; guilds.Guild:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this guild.

        Returns
        -------
        hikari.guilds.Guild
            The guild.
        &#34;&#34;&#34;
        return await self.app.rest.fetch_guild(self.guild_id)

    async def fetch_guild_preview(self) -&gt; guilds.GuildPreview:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date preview of this guild.

        Returns
        -------
        hikari.guilds.GuildPreview
            The guild.
        &#34;&#34;&#34;
        return await self.app.rest.fetch_guild_preview(self.guild_id)

    async def fetch_member(self) -&gt; guilds.Member:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this event&#39;s member.

        Returns
        -------
        hikari.guilds.Member
            The member.
        &#34;&#34;&#34;
        return await self.app.rest.fetch_member(self.guild_id, self.user_id)

    def get_channel(self) -&gt; typing.Optional[channels.TextableGuildChannel]:
        &#34;&#34;&#34;Get the cached channel object this typing event occurred in.

        Returns
        -------
        typing.Optional[hikari.channels.TextableGuildChannel]
            The channel.
        &#34;&#34;&#34;
        if not isinstance(self.app, traits.CacheAware):
            return None

        channel = self.app.cache.get_guild_channel(self.channel_id)
        assert channel is None or isinstance(
            channel, channels.TextableGuildChannel
        ), f&#34;expected TextableGuildChannel from cache, got {channel}&#34;
        return channel

    def get_guild(self) -&gt; typing.Optional[guilds.GatewayGuild]:
        &#34;&#34;&#34;Get the cached object of the guild this typing event occurred in.

        If the guild is not found then this will return `builtins.None`.

        Returns
        -------
        typing.Optional[hikari.guilds.GatewayGuild]
            The object of the gateway guild if found else `builtins.None`.
        &#34;&#34;&#34;
        if not isinstance(self.app, traits.CacheAware):
            return None

        return self.app.cache.get_available_guild(self.guild_id) or self.app.cache.get_unavailable_guild(self.guild_id)</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="GuildTypingEvent -- Event fired when a user starts typing in a guild channel …" href="#hikari.events.typing_events.GuildTypingEvent"
>GuildTypingEvent</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a></dt>
<dd class="nested"><p>Base event fired when a user begins typing in a channel …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="ShardEvent -- Base class for any event that was shard-specific." href="shard_events.html#hikari.events.shard_events.ShardEvent"
>ShardEvent</a></dt>
<dd class="nested"><p>Base class for any event that was shard-specific.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Event -- Base event type that all Hikari events should subclass." href="base_events.html#hikari.events.base_events.Event"
>Event</a></dt>
<dd class="nested"><p>Base event type that all Hikari events should subclass.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.events.typing_events.GuildTypingEvent.app" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- App instance for this application …" href="#hikari.events.typing_events.GuildTypingEvent.app"  >app</a> : <a href='../traits.html#hikari.traits.RESTAware'>RESTAware</a></code></pre>
</dt>
<dd><p>App instance for this application.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../traits.html#hikari.traits.RESTAware'>RESTAware</a></code></dt>
<dd>The REST-aware app trait.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.GuildTypingEvent.channel_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="channel_id -- ID of the channel that this event concerns …" href="#hikari.events.typing_events.GuildTypingEvent.channel_id"  >channel_id</a> : <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>ID of the channel that this event concerns.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the channel that this event concerns.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.GuildTypingEvent.guild_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="guild_id -- ID of the guild that this event relates to …" href="#hikari.events.typing_events.GuildTypingEvent.guild_id"  >guild_id</a> : <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>ID of the guild that this event relates to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild that relates to this event.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.GuildTypingEvent.member" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="member -- Object of the member who triggered this typing event …" href="#hikari.events.typing_events.GuildTypingEvent.member"  >member</a> : <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a></code></pre>
</dt>
<dd><p>Object of the member who triggered this typing event.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code></dt>
<dd>Object of the member who triggered this typing event.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.GuildTypingEvent.shard" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="shard -- Shard that received this event …" href="#hikari.events.typing_events.GuildTypingEvent.shard"  >shard</a> : <a href='../api/shard.html#hikari.api.shard.GatewayShard'>gateway_shard.GatewayShard</a></code></pre>
</dt>
<dd><p>Shard that received this event.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/shard.html#hikari.api.shard.GatewayShard'>GatewayShard</a></code></dt>
<dd>The shard that triggered the event.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.GuildTypingEvent.timestamp" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="timestamp -- Timestamp of when this typing event started …" href="#hikari.events.typing_events.GuildTypingEvent.timestamp"  >timestamp</a> : <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code></pre>
</dt>
<dd><p>Timestamp of when this typing event started.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code></dt>
<dd>UTC timestamp of when the user started typing.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.GuildTypingEvent.user_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="user_id -- ID of the user who triggered this typing event …" href="#hikari.events.typing_events.GuildTypingEvent.user_id"  >user_id</a> : <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>ID of the user who triggered this typing event.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>ID of the user who is typing.</dd>
</dl></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.events.typing_events.GuildTypingEvent.fetch_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel" href="#hikari.events.typing_events.GuildTypingEvent.fetch_channel" id="hikari.events.typing_events.GuildTypingEvent.fetch_channel">fetch_channel</a>() -> <a href='../channels.html#hikari.channels.TextableGuildChannel'>TextableGuildChannel</a>: ...</code></pre>
</dt>
<dd>
<p>Perform an API call to fetch an up-to-date image of this channel.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.TextableGuildChannel'>TextableGuildChannel</a>]</code></dt>
<dd>The channel.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L203-L215" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel(self) -&gt; typing.Union[channels.TextableGuildChannel]:
    &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this channel.

    Returns
    -------
    typing.Union[hikari.channels.TextableGuildChannel]
        The channel.
    &#34;&#34;&#34;
    channel = await super().fetch_channel()
    assert isinstance(
        channel, channels.TextableGuildChannel
    ), f&#34;expected TextableGuildChannel from API, got {channel}&#34;
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.GuildTypingEvent.fetch_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild" href="#hikari.events.typing_events.GuildTypingEvent.fetch_guild" id="hikari.events.typing_events.GuildTypingEvent.fetch_guild">fetch_guild</a>() -> <a href='../guilds.html#hikari.guilds.Guild'>guilds.Guild</a>: ...</code></pre>
</dt>
<dd>
<p>Perform an API call to fetch an up-to-date image of this guild.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.Guild'>Guild</a></code></dt>
<dd>The guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L217-L225" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild(self) -&gt; guilds.Guild:
    &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this guild.

    Returns
    -------
    hikari.guilds.Guild
        The guild.
    &#34;&#34;&#34;
    return await self.app.rest.fetch_guild(self.guild_id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.GuildTypingEvent.fetch_guild_preview" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_preview" href="#hikari.events.typing_events.GuildTypingEvent.fetch_guild_preview" id="hikari.events.typing_events.GuildTypingEvent.fetch_guild_preview">fetch_guild_preview</a>() -> <a href='../guilds.html#hikari.guilds.GuildPreview'>guilds.GuildPreview</a>: ...</code></pre>
</dt>
<dd>
<p>Perform an API call to fetch an up-to-date preview of this guild.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.GuildPreview'>GuildPreview</a></code></dt>
<dd>The guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L227-L235" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_guild_preview(self) -&gt; guilds.GuildPreview:
    &#34;&#34;&#34;Perform an API call to fetch an up-to-date preview of this guild.

    Returns
    -------
    hikari.guilds.GuildPreview
        The guild.
    &#34;&#34;&#34;
    return await self.app.rest.fetch_guild_preview(self.guild_id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.GuildTypingEvent.fetch_member" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_member" href="#hikari.events.typing_events.GuildTypingEvent.fetch_member" id="hikari.events.typing_events.GuildTypingEvent.fetch_member">fetch_member</a>() -> <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>: ...</code></pre>
</dt>
<dd>
<p>Perform an API call to fetch an up-to-date image of this event's member.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code></dt>
<dd>The member.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L237-L245" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_member(self) -&gt; guilds.Member:
    &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this event&#39;s member.

    Returns
    -------
    hikari.guilds.Member
        The member.
    &#34;&#34;&#34;
    return await self.app.rest.fetch_member(self.guild_id, self.user_id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.GuildTypingEvent.fetch_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_user" href="#hikari.events.typing_events.TypingEvent.fetch_user" id="hikari.events.typing_events.GuildTypingEvent.fetch_user">fetch_user</a>() -> <a href='../users.html#hikari.users.User'>users.User</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a></code>.<code><a title="fetch_user -- Perform an API call to fetch an up-to-date image of this user …" href="#hikari.events.typing_events.TypingEvent.fetch_user"
>fetch_user</a></code>
</p>
<p>Perform an API call to fetch an up-to-date image of this user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.User'>User</a></code></dt>
<dd>The user.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.GuildTypingEvent.get_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_channel" href="#hikari.events.typing_events.GuildTypingEvent.get_channel" id="hikari.events.typing_events.GuildTypingEvent.get_channel">get_channel</a>() -> Optional[<a href='../channels.html#hikari.channels.TextableGuildChannel'>TextableGuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p>Get the cached channel object this typing event occurred in.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../channels.html#hikari.channels.TextableGuildChannel'>TextableGuildChannel</a>]</code></dt>
<dd>The channel.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L247-L262" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_channel(self) -&gt; typing.Optional[channels.TextableGuildChannel]:
    &#34;&#34;&#34;Get the cached channel object this typing event occurred in.

    Returns
    -------
    typing.Optional[hikari.channels.TextableGuildChannel]
        The channel.
    &#34;&#34;&#34;
    if not isinstance(self.app, traits.CacheAware):
        return None

    channel = self.app.cache.get_guild_channel(self.channel_id)
    assert channel is None or isinstance(
        channel, channels.TextableGuildChannel
    ), f&#34;expected TextableGuildChannel from cache, got {channel}&#34;
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.GuildTypingEvent.get_guild" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_guild" href="#hikari.events.typing_events.GuildTypingEvent.get_guild" id="hikari.events.typing_events.GuildTypingEvent.get_guild">get_guild</a>() -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p>Get the cached object of the guild this typing event occurred in.</p>
<p>If the guild is not found then this will return <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The object of the gateway guild if found else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L264-L277" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_guild(self) -&gt; typing.Optional[guilds.GatewayGuild]:
    &#34;&#34;&#34;Get the cached object of the guild this typing event occurred in.

    If the guild is not found then this will return `builtins.None`.

    Returns
    -------
    typing.Optional[hikari.guilds.GatewayGuild]
        The object of the gateway guild if found else `builtins.None`.
    &#34;&#34;&#34;
    if not isinstance(self.app, traits.CacheAware):
        return None

    return self.app.cache.get_available_guild(self.guild_id) or self.app.cache.get_unavailable_guild(self.guild_id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.GuildTypingEvent.get_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_user" href="#hikari.events.typing_events.TypingEvent.get_user" id="hikari.events.typing_events.GuildTypingEvent.get_user">get_user</a>() -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>users.User</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a></code>.<code><a title="get_user -- Get the cached user that is typing, if known …" href="#hikari.events.typing_events.TypingEvent.get_user"
>get_user</a></code>
</p>
<p>Get the cached user that is typing, if known.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>The user, if known.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.GuildTypingEvent.trigger_typing" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="trigger_typing" href="#hikari.events.typing_events.TypingEvent.trigger_typing" id="hikari.events.typing_events.GuildTypingEvent.trigger_typing">trigger_typing</a>() -> <a href='../api/special_endpoints.html#hikari.api.special_endpoints.TypingIndicator'>TypingIndicator</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a></code>.<code><a title="trigger_typing -- Return a typing indicator for this channel that can be awaited …" href="#hikari.events.typing_events.TypingEvent.trigger_typing"
>trigger_typing</a></code>
</p>
<p>Return a typing indicator for this channel that can be awaited.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.TypingIndicator'>TypingIndicator</a></code></dt>
<dd>A typing indicator context manager and awaitable to trigger typing
in a channel with.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.events.typing_events.TypingEvent" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a></h4>
</dt>
<dd>
<pre><code id="hikari.events.typing_events.TypingEvent" class="hljs python"><abbr title='A standard Python type.'>class</abbr> TypingEvent: ...</code></pre>
<p>Base event fired when a user begins typing in a channel.</p>
<p>This requires one of the following combinations of intents in order to be dispatched:</p>
<ul>
<li><code><a href='../intents.html#hikari.intents.Intents.GUILD_MESSAGE_TYPING'>GUILD_MESSAGE_TYPING</a></code></li>
<li><code><a href='../intents.html#hikari.intents.Intents.DM_MESSAGE_TYPING'>DM_MESSAGE_TYPING</a></code></li>
</ul>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L55-L157" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class TypingEvent(shard_events.ShardEvent, abc.ABC):
    &#34;&#34;&#34;Base event fired when a user begins typing in a channel.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @property
    @abc.abstractmethod
    def channel_id(self) -&gt; snowflakes.Snowflake:
        &#34;&#34;&#34;ID of the channel that this event concerns.

        Returns
        -------
        hikari.snowflakes.Snowflake
            The ID of the channel that this event concerns.
        &#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def user_id(self) -&gt; snowflakes.Snowflake:
        &#34;&#34;&#34;ID of the user who triggered this typing event.

        Returns
        -------
        hikari.snowflakes.Snowflake
            ID of the user who is typing.
        &#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def timestamp(self) -&gt; datetime.datetime:
        &#34;&#34;&#34;Timestamp of when this typing event started.

        Returns
        -------
        datetime.datetime
            UTC timestamp of when the user started typing.
        &#34;&#34;&#34;

    async def fetch_channel(self) -&gt; channels.TextableChannel:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this channel.

        Returns
        -------
        hikari.channels.TextableChannel
            The channel.
        &#34;&#34;&#34;
        channel = await self.app.rest.fetch_channel(self.channel_id)
        assert isinstance(channel, channels.TextableChannel)
        return channel

    def get_user(self) -&gt; typing.Optional[users.User]:
        &#34;&#34;&#34;Get the cached user that is typing, if known.

        Returns
        -------
        typing.Optional[hikari.users.User]
            The user, if known.
        &#34;&#34;&#34;
        if isinstance(self.app, traits.CacheAware):
            return self.app.cache.get_user(self.user_id)

        return None

    async def fetch_user(self) -&gt; users.User:
        &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this user.

        Returns
        -------
        hikari.users.User
            The user.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the user is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;
        return await self.app.rest.fetch_user(self.user_id)

    def trigger_typing(self) -&gt; special_endpoints.TypingIndicator:
        &#34;&#34;&#34;Return a typing indicator for this channel that can be awaited.

        Returns
        -------
        hikari.api.special_endpoints.TypingIndicator
            A typing indicator context manager and awaitable to trigger typing
            in a channel with.
        &#34;&#34;&#34;
        return self.app.rest.trigger_typing(self.channel_id)</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="DMTypingEvent -- Event fired when a user starts typing in a guild channel …" href="#hikari.events.typing_events.DMTypingEvent"
>DMTypingEvent</a></dt>
<dd class="nested"><p>Event fired when a user starts typing in a guild channel …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="GuildTypingEvent -- Event fired when a user starts typing in a guild channel …" href="#hikari.events.typing_events.GuildTypingEvent"
>GuildTypingEvent</a></dt>
<dd class="nested"><p>Event fired when a user starts typing in a guild channel …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="TypingEvent -- Base event fired when a user begins typing in a channel …" href="#hikari.events.typing_events.TypingEvent"
>TypingEvent</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="ShardEvent -- Base class for any event that was shard-specific." href="shard_events.html#hikari.events.shard_events.ShardEvent"
>ShardEvent</a></dt>
<dd class="nested"><p>Base class for any event that was shard-specific.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Event -- Base event type that all Hikari events should subclass." href="base_events.html#hikari.events.base_events.Event"
>Event</a></dt>
<dd class="nested"><p>Base event type that all Hikari events should subclass.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<div id="hikari.events.typing_events.TypingEvent.app" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- App instance for this application …" href="base_events.html#hikari.events.base_events.Event.app"  >app</a> : <a href='../traits.html#hikari.traits.RESTAware'>RESTAware</a></code></pre>
</dt>
<dd><p>App instance for this application.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../traits.html#hikari.traits.RESTAware'>RESTAware</a></code></dt>
<dd>The REST-aware app trait.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.TypingEvent.channel_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="channel_id -- ID of the channel that this event concerns …" href="#hikari.events.typing_events.TypingEvent.channel_id"  >channel_id</a> : <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>ID of the channel that this event concerns.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the channel that this event concerns.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.TypingEvent.shard" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="shard -- Shard that received this event …" href="shard_events.html#hikari.events.shard_events.ShardEvent.shard"  >shard</a> : <a href='../api/shard.html#hikari.api.shard.GatewayShard'>gateway_shard.GatewayShard</a></code></pre>
</dt>
<dd><p>Shard that received this event.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/shard.html#hikari.api.shard.GatewayShard'>GatewayShard</a></code></dt>
<dd>The shard that triggered the event.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.TypingEvent.timestamp" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="timestamp -- Timestamp of when this typing event started …" href="#hikari.events.typing_events.TypingEvent.timestamp"  >timestamp</a> : <a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code></pre>
</dt>
<dd><p>Timestamp of when this typing event started.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a></code></dt>
<dd>UTC timestamp of when the user started typing.</dd>
</dl></dd>
</div>
<div id="hikari.events.typing_events.TypingEvent.user_id" class="anchor">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="user_id -- ID of the user who triggered this typing event …" href="#hikari.events.typing_events.TypingEvent.user_id"  >user_id</a> : <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>ID of the user who triggered this typing event.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>ID of the user who is typing.</dd>
</dl></dd>
</div>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.events.typing_events.TypingEvent.fetch_channel" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel" href="#hikari.events.typing_events.TypingEvent.fetch_channel" id="hikari.events.typing_events.TypingEvent.fetch_channel">fetch_channel</a>() -> <a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a>: ...</code></pre>
</dt>
<dd>
<p>Perform an API call to fetch an up-to-date image of this channel.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.TextableChannel'>TextableChannel</a></code></dt>
<dd>The channel.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L93-L103" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_channel(self) -&gt; channels.TextableChannel:
    &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this channel.

    Returns
    -------
    hikari.channels.TextableChannel
        The channel.
    &#34;&#34;&#34;
    channel = await self.app.rest.fetch_channel(self.channel_id)
    assert isinstance(channel, channels.TextableChannel)
    return channel</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.TypingEvent.fetch_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_user" href="#hikari.events.typing_events.TypingEvent.fetch_user" id="hikari.events.typing_events.TypingEvent.fetch_user">fetch_user</a>() -> <a href='../users.html#hikari.users.User'>users.User</a>: ...</code></pre>
</dt>
<dd>
<p>Perform an API call to fetch an up-to-date image of this user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.User'>User</a></code></dt>
<dd>The user.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L118-L146" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def fetch_user(self) -&gt; users.User:
    &#34;&#34;&#34;Perform an API call to fetch an up-to-date image of this user.

    Returns
    -------
    hikari.users.User
        The user.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the user is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;
    return await self.app.rest.fetch_user(self.user_id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.TypingEvent.get_user" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_user" href="#hikari.events.typing_events.TypingEvent.get_user" id="hikari.events.typing_events.TypingEvent.get_user">get_user</a>() -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>users.User</a>]: ...</code></pre>
</dt>
<dd>
<p>Get the cached user that is typing, if known.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>The user, if known.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L105-L116" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_user(self) -&gt; typing.Optional[users.User]:
    &#34;&#34;&#34;Get the cached user that is typing, if known.

    Returns
    -------
    typing.Optional[hikari.users.User]
        The user, if known.
    &#34;&#34;&#34;
    if isinstance(self.app, traits.CacheAware):
        return self.app.cache.get_user(self.user_id)

    return None</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.events.typing_events.TypingEvent.trigger_typing" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="trigger_typing" href="#hikari.events.typing_events.TypingEvent.trigger_typing" id="hikari.events.typing_events.TypingEvent.trigger_typing">trigger_typing</a>() -> <a href='../api/special_endpoints.html#hikari.api.special_endpoints.TypingIndicator'>TypingIndicator</a>: ...</code></pre>
</dt>
<dd>
<p>Return a typing indicator for this channel that can be awaited.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../api/special_endpoints.html#hikari.api.special_endpoints.TypingIndicator'>TypingIndicator</a></code></dt>
<dd>A typing indicator context manager and awaitable to trigger typing
in a channel with.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/events/typing_events.py#L148-L157" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def trigger_typing(self) -&gt; special_endpoints.TypingIndicator:
    &#34;&#34;&#34;Return a typing indicator for this channel that can be awaited.

    Returns
    -------
    hikari.api.special_endpoints.TypingIndicator
        A typing indicator context manager and awaitable to trigger typing
        in a channel with.
    &#34;&#34;&#34;
    return self.app.rest.trigger_typing(self.channel_id)</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
</dl>
</section>
</div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>