<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.api.event_manager API documentation</title>
<meta name="description" content="Core interface for components that manage events in the library.">
<meta property="og:title" content="hikari.api.event_manager module list">
<meta property="og:type" content="website">
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png">
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions">
<meta property="theme-color" content="#ff029a">
<link rel="shortcut icon" type="image/png" href="../../logo.png">
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
text-indent: 100%;
white-space: nowrap;
overflow: hidden;
}
small.smaller {
font-size: 0.50em;
}
html {
height: 100%;
scroll-behavior: smooth;
scrollbar-color: #202324 #454a4d;
}
body {
background-color: #181A1B;
color: #C9C5C0;
height: fit-content;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.container > li {
margin-left: 1em;
margin-top: 2.5em;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
.anchor:target {
background-color: var(--dark);
}
@media screen and (max-width: 990px) {
.anchor:target {
margin-left: -2em;
padding-left: 2em;
}
}
@media screen and (min-width: 990px) {
.anchor:target {
border-radius: 0.5em; !important
margin-right: -2em;
padding-right: 2em;
margin-top: -1em;
padding-top: 1em;
}
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="../../logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small class="smaller">2.0.0.dev102</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
<li class="nav-item"><a class="nav-link active" href="../../hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" action="../../hikari/search.html">
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search" name="q"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.api -- Interfaces for components that make up Hikari applications …" href="index.html"
>api</a></li>
<li class="breadcrumb-item active"><a href="#">event_manager</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Core interface for components that manage events in the library.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventManager -- Base interface for event manager implementations …" href="#hikari.api.event_manager.EventManager"
>EventManager</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="consume_raw_event -- Consume a raw event …" href="#hikari.api.event_manager.EventManager.consume_raw_event"
>consume_raw_event</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="dispatch -- Dispatch an event …" href="#hikari.api.event_manager.EventManager.dispatch"
>dispatch</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_listeners -- Get the listeners for a given event type, if there are any …" href="#hikari.api.event_manager.EventManager.get_listeners"
>get_listeners</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="listen -- Generate a decorator to subscribe a callback to an event type …" href="#hikari.api.event_manager.EventManager.listen"
>listen</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="stream -- Return a stream iterator for the given event and sub-events …" href="#hikari.api.event_manager.EventManager.stream"
>stream</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="subscribe -- Subscribe a given callback to a given event type …" href="#hikari.api.event_manager.EventManager.subscribe"
>subscribe</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="unsubscribe -- Unsubscribe a given callback from a given event type, if present …" href="#hikari.api.event_manager.EventManager.unsubscribe"
>unsubscribe</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="wait_for -- Wait for a given event to occur once, then return the event …" href="#hikari.api.event_manager.EventManager.wait_for"
>wait_for</a>
</li>
<br />
</ul>
</li>
<li class="monospaced text-truncate">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventStream -- A base abstract class for all event streamers …" href="#hikari.api.event_manager.EventStream"
>EventStream</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="awaiting -- Await each item concurrently in a fixed size window …" href="../iterators.html#hikari.iterators.LazyIterator.awaiting"
>awaiting</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="chunk -- Return results in chunks of up to `chunk_size` amount of entries …" href="../iterators.html#hikari.iterators.LazyIterator.chunk"
>chunk</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="close -- Mark this streamer as closed to stop it from queueing and receiving events …" href="#hikari.api.event_manager.EventStream.close"
>close</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="collect -- Collect the results into a given type and return it …" href="../iterators.html#hikari.iterators.LazyIterator.collect"
>collect</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="count -- Count the number of results …" href="../iterators.html#hikari.iterators.LazyIterator.count"
>count</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="enumerate -- Enumerate the paginated results lazily …" href="../iterators.html#hikari.iterators.LazyIterator.enumerate"
>enumerate</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="filter -- Filter the items by one or more conditions …" href="../iterators.html#hikari.iterators.LazyIterator.filter"
>filter</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="flat_map -- Perform a flat mapping operation …" href="../iterators.html#hikari.iterators.LazyIterator.flat_map"
>flat_map</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="for_each -- Pass each value to a given consumer immediately." href="../iterators.html#hikari.iterators.LazyIterator.for_each"
>for_each</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="last -- Return the last element of this iterator only …" href="../iterators.html#hikari.iterators.LazyIterator.last"
>last</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="limit -- Limit the number of items you receive from this async iterator …" href="../iterators.html#hikari.iterators.LazyIterator.limit"
>limit</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="map -- Map the values to a different value …" href="../iterators.html#hikari.iterators.LazyIterator.map"
>map</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="next -- Return the next element of this iterator only …" href="../iterators.html#hikari.iterators.LazyIterator.next"
>next</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="open -- Mark this streamer as opened to let it start receiving and queueing events …" href="#hikari.api.event_manager.EventStream.open"
>open</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="reversed -- Return a lazy iterator of the remainder of this iterator's values reversed …" href="../iterators.html#hikari.iterators.LazyIterator.reversed"
>reversed</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip -- Drop the given number of items, then yield anything after …" href="../iterators.html#hikari.iterators.LazyIterator.skip"
>skip</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip_until -- Discard items while all conditions are False …" href="../iterators.html#hikari.iterators.LazyIterator.skip_until"
>skip_until</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="skip_while -- Discard items while all conditions are True …" href="../iterators.html#hikari.iterators.LazyIterator.skip_while"
>skip_while</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="sort -- Collect all results, then sort the collection before returning it." href="../iterators.html#hikari.iterators.LazyIterator.sort"
>sort</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="take_until -- Return each item until any conditions pass or the end is reached …" href="../iterators.html#hikari.iterators.LazyIterator.take_until"
>take_until</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="take_while -- Return each item until any conditions fail or the end is reached …" href="../iterators.html#hikari.iterators.LazyIterator.take_while"
>take_while</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L1-L493" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
# Copyright (c) 2021 davfsa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Core interface for components that manage events in the library.&#34;&#34;&#34;
from __future__ import annotations

__all__: typing.List[str] = [&#34;EventManager&#34;, &#34;EventStream&#34;]

import abc
import asyncio
import typing

from hikari import iterators

if typing.TYPE_CHECKING:
    import types

    from hikari.api import shard as gateway_shard
    from hikari.events import base_events
    from hikari.internal import data_binding

    EventT_co = typing.TypeVar(&#34;EventT_co&#34;, bound=base_events.Event, covariant=True)
    EventT_inv = typing.TypeVar(&#34;EventT_inv&#34;, bound=base_events.Event)
    PredicateT = typing.Callable[[EventT_co], bool]
    CallbackT = typing.Callable[[EventT_inv], typing.Coroutine[typing.Any, typing.Any, None]]
    ConsumerT = typing.Callable[
        [gateway_shard.GatewayShard, data_binding.JSONObject], typing.Coroutine[typing.Any, typing.Any, None]
    ]

EventT = typing.TypeVar(&#34;EventT&#34;, bound=&#34;base_events.Event&#34;)


class EventStream(iterators.LazyIterator[EventT], abc.ABC):
    &#34;&#34;&#34;A base abstract class for all event streamers.

    Unlike `hikari.iterators.LazyIterator` (which this extends), an event
    streamer must be started and closed.

    Examples
    --------
    A streamer may either be started and closed using `async with` syntax
    where `EventStream.open` and `EventStream.close` are implicitly called based on
    context.

    ```py
    async with EventStream(app, EventType, timeout=50) as stream:
        async for entry in stream:
            ...
    ```

    A streamer may also be directly started and closed using the `EventStream.close`
    and `EventStream.open`. Note that if you don&#39;t call `EventStream.close` after
    opening a streamer when you&#39;re finished with it then it may queue events
    events in memory indefinitely.

    ```py
    stream = EventStream(app, EventType, timeout=50)
    await stream.open()
    async for event in stream:
        ...

    await stream.close()
    ```

    See Also
    --------
    LazyIterator: `hikari.iterators.LazyIterator`
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Mark this streamer as closed to stop it from queueing and receiving events.

        If called on an already closed streamer then this will do nothing.

        !!! note
            `async with streamer` may be used as a short-cut for opening and
            closing a streamer.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def open(self) -&gt; None:
        &#34;&#34;&#34;Mark this streamer as opened to let it start receiving and queueing events.

        If called on an already started streamer then this will do nothing.

        !!! note
            `async with streamer` may be used as a short-cut for opening and
            closing a stream.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def __aenter__(self) -&gt; EventStream[EventT]:
        raise NotImplementedError

    @abc.abstractmethod
    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        raise NotImplementedError


class EventManager(abc.ABC):
    &#34;&#34;&#34;Base interface for event manager implementations.

    This is a listener of a `hikari.events.base_events.Event` object and
    consumer of raw event payloads, and is expected to invoke one or more
    corresponding event listeners where appropriate.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    def consume_raw_event(
        self, event_name: str, shard: gateway_shard.GatewayShard, payload: data_binding.JSONObject
    ) -&gt; None:
        &#34;&#34;&#34;Consume a raw event.

        Parameters
        ----------
        event_name : str
            The case-insensitive name of the event being triggered.
        shard : hikari.api.shard.GatewayShard
            Object of the shard that received this event.
        payload : hikari.internal.data_binding.JSONObject
            Payload of the event being triggered.

        Raises
        ------
        builtins.LookupError
            If there is no consumer for the event.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def dispatch(self, event: EventT_inv) -&gt; asyncio.Future[typing.Any]:
        &#34;&#34;&#34;Dispatch an event.

        Parameters
        ----------
        event : hikari.events.base_events.Event
            The event to dispatch.

        Example
        -------
        We can dispatch custom events by first defining a class that
        derives from `hikari.events.base_events.Event`.

        ```py
        import attr

        from hikari.traits import RESTAware
        from hikari.events.base_events import Event
        from hikari.users import User
        from hikari.snowflakes import Snowflake

        @attr.define()
        class EveryoneMentionedEvent(Event):
            app: RESTAware = attr.field()

            author: User = attr.field()
            &#39;&#39;&#39;The user who mentioned everyone.&#39;&#39;&#39;

            content: str = attr.field()
            &#39;&#39;&#39;The message that was sent.&#39;&#39;&#39;

            message_id: Snowflake = attr.field()
            &#39;&#39;&#39;The message ID.&#39;&#39;&#39;

            channel_id: Snowflake = attr.field()
            &#39;&#39;&#39;The channel ID.&#39;&#39;&#39;
        ```

        We can then dispatch our event as we see fit.

        ```py
        from hikari.events.messages import MessageCreateEvent

        @bot.listen(MessageCreateEvent)
        async def on_message(event):
            if &#34;@everyone&#34; in event.content or &#34;@here&#34; in event.content:
                event = EveryoneMentionedEvent(
                    author=event.author,
                    content=event.content,
                    message_id=event.id,
                    channel_id=event.channel_id,
                )

                bot.dispatch(event)
        ```

        This event can be listened to elsewhere by subscribing to it with
        `EventManager.subscribe`.

        ```py
        @bot.listen(EveryoneMentionedEvent)
        async def on_everyone_mentioned(event):
            print(event.user, &#34;just pinged everyone in&#34;, event.channel_id)
        ```

        Returns
        -------
        asyncio.Future[typing.Any]
            A future that can be optionally awaited. If awaited, the future
            will complete once all corresponding event listeners have been
            invoked. If not awaited, this will schedule the dispatch of the
            events in the background for later.

        See Also
        --------
        Subscribe: `hikari.api.event_manager.EventManager.subscribe`
        Stream: `hikari.api.event_manager.EventManager.stream`
        Wait for: `hikari.api.event_manager.EventManager.wait_for`
        &#34;&#34;&#34;

    # Yes, this is not generic. The reason for this is MyPy complains about
    # using ABCs that are not concrete in generic types passed to functions.
    # For the sake of UX, I will check this at runtime instead and let the
    # user use a static type checker.
    @abc.abstractmethod
    def subscribe(self, event_type: typing.Type[typing.Any], callback: CallbackT[typing.Any]) -&gt; None:
        &#34;&#34;&#34;Subscribe a given callback to a given event type.

        Parameters
        ----------
        event_type : typing.Type[T]
            The event type to listen for. This will also listen for any
            subclasses of the given type.
            `T` must be a subclass of `hikari.events.base_events.Event`.
        callback
            Must be a coroutine function to invoke. This should
            consume an instance of the given event, or an instance of a valid
            subclass if one exists. Any result is discarded.

        Example
        -------
        The following demonstrates subscribing a callback to message creation
        events.

        ```py
        from hikari.events.messages import MessageCreateEvent

        async def on_message(event):
            ...

        bot.subscribe(MessageCreateEvent, on_message)
        ```

        See Also
        --------
        Listen: `hikari.api.event_manager.EventManager.listen`
        Stream: `hikari.api.event_manager.EventManager.stream`
        Wait for: `hikari.api.event_manager.EventManager.wait_for`
        &#34;&#34;&#34;

    # Yes, this is not generic. The reason for this is MyPy complains about
    # using ABCs that are not concrete in generic types passed to functions.
    # For the sake of UX, I will check this at runtime instead and let the
    # user use a static type checker.
    @abc.abstractmethod
    def unsubscribe(self, event_type: typing.Type[typing.Any], callback: CallbackT[typing.Any]) -&gt; None:
        &#34;&#34;&#34;Unsubscribe a given callback from a given event type, if present.

        Parameters
        ----------
        event_type : typing.Type[T]
            The event type to unsubscribe from. This must be the same exact
            type as was originally subscribed with to be removed correctly.
            `T` must derive from `hikari.events.base_events.Event`.
        callback
            The callback to unsubscribe.

        Example
        -------
        The following demonstrates unsubscribing a callback from a message
        creation event.

        ```py
        from hikari.events.messages import MessageCreateEvent

        async def on_message(event):
            ...

        bot.unsubscribe(MessageCreateEvent, on_message)
        ```
        &#34;&#34;&#34;

    @abc.abstractmethod
    def get_listeners(
        self,
        event_type: typing.Type[EventT_co],
        /,
        *,
        polymorphic: bool = True,
    ) -&gt; typing.Collection[CallbackT[EventT_co]]:
        &#34;&#34;&#34;Get the listeners for a given event type, if there are any.

        Parameters
        ----------
        event_type : typing.Type[T]
            The event type to look for.
            `T` must be a subclass of `hikari.events.base_events.Event`.
        polymorphic : builtins.bool
            If `builtins.True`, this will also return the listeners of the
            subclasses of the given event type. If `builtins.False`, then
            only listeners for this class specifically are returned. The
            default is `builtins.True`.

        Returns
        -------
        typing.Collection[typing.Callable[[T], typing.Coroutine[typing.Any, typing.Any, builtins.None]]
            A copy of the collection of listeners for the event. Will return
            an empty collection if nothing is registered.

            `T` must be a subclass of `hikari.events.base_events.Event`.

        See Also
        --------
        Has listener: `hikari.api.event_manager.EventManager.has_listener`
        &#34;&#34;&#34;

    @abc.abstractmethod
    def listen(
        self,
        event_type: typing.Optional[typing.Type[EventT_co]] = None,
    ) -&gt; typing.Callable[[CallbackT[EventT_co]], CallbackT[EventT_co]]:
        &#34;&#34;&#34;Generate a decorator to subscribe a callback to an event type.

        This is a second-order decorator.

        Parameters
        ----------
        event_type : typing.Optional[typing.Type[T]]
            The event type to subscribe to. The implementation may allow this
            to be undefined. If this is the case, the event type will be inferred
            instead from the type hints on the function signature.

            `T` must be a subclass of `hikari.events.base_events.Event`.

        Returns
        -------
        typing.Callable[[T], T]
            A decorator for a coroutine function that passes it to
            `EventManager.subscribe` before returning the function
            reference.

        See Also
        --------
        Dispatch: `hikari.api.event_manager.EventManager.dispatch`
        Stream: `hikari.api.event_manager.EventManager.stream`
        Subscribe: `hikari.api.event_manager.EventManager.subscribe`
        Unsubscribe: `hikari.api.event_manager.EventManager.unsubscribe`
        Wait for: `hikari.api.event_manager.EventManager.wait_for`
        &#34;&#34;&#34;

    @abc.abstractmethod
    def stream(
        self,
        event_type: typing.Type[EventT_co],
        /,
        timeout: typing.Union[float, int, None],
        limit: typing.Optional[int] = None,
    ) -&gt; EventStream[EventT_co]:
        &#34;&#34;&#34;Return a stream iterator for the given event and sub-events.

        Parameters
        ----------
        event_type : typing.Type[hikari.events.base_events.Event]
            The event type to listen for. This will listen for subclasses of
            this type additionally.
        timeout : typing.Optional[builtins.int, builtins.float]
            How long this streamer should wait for the next event before
            ending the iteration. If `builtins.None` then this will continue
            until explicitly broken from.
        limit : typing.Optional[builtins.int]
            The limit for how many events this should queue at one time before
            dropping extra incoming events, leave this as `builtins.None` for
            the cache size to be unlimited.

        Returns
        -------
        EventStream[hikari.events.base_events.Event]
            The async iterator to handle streamed events. This must be started
            with `async with stream:` or `await stream.open()` before
            asynchronously iterating over it.

        !!! warning
            If you use `await stream.open()` to start the stream then you must
            also close it with `await stream.close()` otherwise it may queue
            events in memory indefinitely.

        Examples
        --------

        ```py
        async with bot.stream(events.ReactionAddEvent, timeout=30).filter((&#34;message_id&#34;, message.id)) as stream:
            async for user_id in stream.map(&#34;user_id&#34;).limit(50):
                ...
        ```

        or using await `open()` and await `close()`

        ```py
        stream = bot.stream(events.ReactionAddEvent, timeout=30).filter((&#34;message_id&#34;, message.id))
        await stream.open()

        async for user_id in stream.map(&#34;user_id&#34;).limit(50)
            ...

        await stream.close()
        ```

        See Also
        --------
        Dispatch: `hikari.api.event_manager.EventManager.dispatch`
        Listen: `hikari.api.event_manager.EventManager.listen`
        Subscribe: `hikari.api.event_manager.EventManager.subscribe`
        Unsubscribe: `hikari.api.event_manager.EventManager.unsubscribe`
        Wait for: `hikari.api.event_manager.EventManager.wait_for`
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def wait_for(
        self,
        event_type: typing.Type[EventT_co],
        /,
        timeout: typing.Union[float, int, None],
        predicate: typing.Optional[PredicateT[EventT_co]] = None,
    ) -&gt; EventT_co:
        &#34;&#34;&#34;Wait for a given event to occur once, then return the event.

        Parameters
        ----------
        event_type : typing.Type[hikari.events.base_events.Event]
            The event type to listen for. This will listen for subclasses of
            this type additionally.
        predicate
            A function taking the event as the single parameter.
            This should return `builtins.True` if the event is one you want to
            return, or `builtins.False` if the event should not be returned.
            If left as `None` (the default), then the first matching event type
            that the bot receives (or any subtype) will be the one returned.

            !!! warning
                Async predicates are not supported.
        timeout : typing.Union[builtins.float, builtins.int, builtins.None]
            The amount of time to wait before raising an `asyncio.TimeoutError`
            and giving up instead. This is measured in seconds. If
            `builtins.None`, then no timeout will be waited for (no timeout can
            result in &#34;leaking&#34; of coroutines that never complete if called in
            an uncontrolled way, so is not recommended).

        Returns
        -------
        hikari.events.base_events.Event
            The event that was provided.

        Raises
        ------
        asyncio.TimeoutError
            If the timeout is not `builtins.None` and is reached before an
            event is received that the predicate returns `builtins.True` for.

        See Also
        --------
        Listen: `hikari.api.event_manager.EventManager.listen`
        Stream: `hikari.api.event_manager.EventManager.stream`
        Subscribe: `hikari.api.event_manager.EventManager.subscribe`
        Dispatch: `hikari.api.event_manager.EventManager.dispatch`
        &#34;&#34;&#34;</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<div id="hikari.api.event_manager.EventManager" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventManager -- Base interface for event manager implementations …" href="#hikari.api.event_manager.EventManager"
>EventManager</a></h4>
</dt>
<dd>
<pre><code id="hikari.api.event_manager.EventManager" class="hljs python"><abbr title='A standard Python type.'>class</abbr> EventManager: ...</code></pre>
<p>Base interface for event manager implementations.</p>
<p>This is a listener of a <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code> object and
consumer of raw event payloads, and is expected to invoke one or more
corresponding event listeners where appropriate.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L127-L493" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class EventManager(abc.ABC):
    &#34;&#34;&#34;Base interface for event manager implementations.

    This is a listener of a `hikari.events.base_events.Event` object and
    consumer of raw event payloads, and is expected to invoke one or more
    corresponding event listeners where appropriate.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    def consume_raw_event(
        self, event_name: str, shard: gateway_shard.GatewayShard, payload: data_binding.JSONObject
    ) -&gt; None:
        &#34;&#34;&#34;Consume a raw event.

        Parameters
        ----------
        event_name : str
            The case-insensitive name of the event being triggered.
        shard : hikari.api.shard.GatewayShard
            Object of the shard that received this event.
        payload : hikari.internal.data_binding.JSONObject
            Payload of the event being triggered.

        Raises
        ------
        builtins.LookupError
            If there is no consumer for the event.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def dispatch(self, event: EventT_inv) -&gt; asyncio.Future[typing.Any]:
        &#34;&#34;&#34;Dispatch an event.

        Parameters
        ----------
        event : hikari.events.base_events.Event
            The event to dispatch.

        Example
        -------
        We can dispatch custom events by first defining a class that
        derives from `hikari.events.base_events.Event`.

        ```py
        import attr

        from hikari.traits import RESTAware
        from hikari.events.base_events import Event
        from hikari.users import User
        from hikari.snowflakes import Snowflake

        @attr.define()
        class EveryoneMentionedEvent(Event):
            app: RESTAware = attr.field()

            author: User = attr.field()
            &#39;&#39;&#39;The user who mentioned everyone.&#39;&#39;&#39;

            content: str = attr.field()
            &#39;&#39;&#39;The message that was sent.&#39;&#39;&#39;

            message_id: Snowflake = attr.field()
            &#39;&#39;&#39;The message ID.&#39;&#39;&#39;

            channel_id: Snowflake = attr.field()
            &#39;&#39;&#39;The channel ID.&#39;&#39;&#39;
        ```

        We can then dispatch our event as we see fit.

        ```py
        from hikari.events.messages import MessageCreateEvent

        @bot.listen(MessageCreateEvent)
        async def on_message(event):
            if &#34;@everyone&#34; in event.content or &#34;@here&#34; in event.content:
                event = EveryoneMentionedEvent(
                    author=event.author,
                    content=event.content,
                    message_id=event.id,
                    channel_id=event.channel_id,
                )

                bot.dispatch(event)
        ```

        This event can be listened to elsewhere by subscribing to it with
        `EventManager.subscribe`.

        ```py
        @bot.listen(EveryoneMentionedEvent)
        async def on_everyone_mentioned(event):
            print(event.user, &#34;just pinged everyone in&#34;, event.channel_id)
        ```

        Returns
        -------
        asyncio.Future[typing.Any]
            A future that can be optionally awaited. If awaited, the future
            will complete once all corresponding event listeners have been
            invoked. If not awaited, this will schedule the dispatch of the
            events in the background for later.

        See Also
        --------
        Subscribe: `hikari.api.event_manager.EventManager.subscribe`
        Stream: `hikari.api.event_manager.EventManager.stream`
        Wait for: `hikari.api.event_manager.EventManager.wait_for`
        &#34;&#34;&#34;

    # Yes, this is not generic. The reason for this is MyPy complains about
    # using ABCs that are not concrete in generic types passed to functions.
    # For the sake of UX, I will check this at runtime instead and let the
    # user use a static type checker.
    @abc.abstractmethod
    def subscribe(self, event_type: typing.Type[typing.Any], callback: CallbackT[typing.Any]) -&gt; None:
        &#34;&#34;&#34;Subscribe a given callback to a given event type.

        Parameters
        ----------
        event_type : typing.Type[T]
            The event type to listen for. This will also listen for any
            subclasses of the given type.
            `T` must be a subclass of `hikari.events.base_events.Event`.
        callback
            Must be a coroutine function to invoke. This should
            consume an instance of the given event, or an instance of a valid
            subclass if one exists. Any result is discarded.

        Example
        -------
        The following demonstrates subscribing a callback to message creation
        events.

        ```py
        from hikari.events.messages import MessageCreateEvent

        async def on_message(event):
            ...

        bot.subscribe(MessageCreateEvent, on_message)
        ```

        See Also
        --------
        Listen: `hikari.api.event_manager.EventManager.listen`
        Stream: `hikari.api.event_manager.EventManager.stream`
        Wait for: `hikari.api.event_manager.EventManager.wait_for`
        &#34;&#34;&#34;

    # Yes, this is not generic. The reason for this is MyPy complains about
    # using ABCs that are not concrete in generic types passed to functions.
    # For the sake of UX, I will check this at runtime instead and let the
    # user use a static type checker.
    @abc.abstractmethod
    def unsubscribe(self, event_type: typing.Type[typing.Any], callback: CallbackT[typing.Any]) -&gt; None:
        &#34;&#34;&#34;Unsubscribe a given callback from a given event type, if present.

        Parameters
        ----------
        event_type : typing.Type[T]
            The event type to unsubscribe from. This must be the same exact
            type as was originally subscribed with to be removed correctly.
            `T` must derive from `hikari.events.base_events.Event`.
        callback
            The callback to unsubscribe.

        Example
        -------
        The following demonstrates unsubscribing a callback from a message
        creation event.

        ```py
        from hikari.events.messages import MessageCreateEvent

        async def on_message(event):
            ...

        bot.unsubscribe(MessageCreateEvent, on_message)
        ```
        &#34;&#34;&#34;

    @abc.abstractmethod
    def get_listeners(
        self,
        event_type: typing.Type[EventT_co],
        /,
        *,
        polymorphic: bool = True,
    ) -&gt; typing.Collection[CallbackT[EventT_co]]:
        &#34;&#34;&#34;Get the listeners for a given event type, if there are any.

        Parameters
        ----------
        event_type : typing.Type[T]
            The event type to look for.
            `T` must be a subclass of `hikari.events.base_events.Event`.
        polymorphic : builtins.bool
            If `builtins.True`, this will also return the listeners of the
            subclasses of the given event type. If `builtins.False`, then
            only listeners for this class specifically are returned. The
            default is `builtins.True`.

        Returns
        -------
        typing.Collection[typing.Callable[[T], typing.Coroutine[typing.Any, typing.Any, builtins.None]]
            A copy of the collection of listeners for the event. Will return
            an empty collection if nothing is registered.

            `T` must be a subclass of `hikari.events.base_events.Event`.

        See Also
        --------
        Has listener: `hikari.api.event_manager.EventManager.has_listener`
        &#34;&#34;&#34;

    @abc.abstractmethod
    def listen(
        self,
        event_type: typing.Optional[typing.Type[EventT_co]] = None,
    ) -&gt; typing.Callable[[CallbackT[EventT_co]], CallbackT[EventT_co]]:
        &#34;&#34;&#34;Generate a decorator to subscribe a callback to an event type.

        This is a second-order decorator.

        Parameters
        ----------
        event_type : typing.Optional[typing.Type[T]]
            The event type to subscribe to. The implementation may allow this
            to be undefined. If this is the case, the event type will be inferred
            instead from the type hints on the function signature.

            `T` must be a subclass of `hikari.events.base_events.Event`.

        Returns
        -------
        typing.Callable[[T], T]
            A decorator for a coroutine function that passes it to
            `EventManager.subscribe` before returning the function
            reference.

        See Also
        --------
        Dispatch: `hikari.api.event_manager.EventManager.dispatch`
        Stream: `hikari.api.event_manager.EventManager.stream`
        Subscribe: `hikari.api.event_manager.EventManager.subscribe`
        Unsubscribe: `hikari.api.event_manager.EventManager.unsubscribe`
        Wait for: `hikari.api.event_manager.EventManager.wait_for`
        &#34;&#34;&#34;

    @abc.abstractmethod
    def stream(
        self,
        event_type: typing.Type[EventT_co],
        /,
        timeout: typing.Union[float, int, None],
        limit: typing.Optional[int] = None,
    ) -&gt; EventStream[EventT_co]:
        &#34;&#34;&#34;Return a stream iterator for the given event and sub-events.

        Parameters
        ----------
        event_type : typing.Type[hikari.events.base_events.Event]
            The event type to listen for. This will listen for subclasses of
            this type additionally.
        timeout : typing.Optional[builtins.int, builtins.float]
            How long this streamer should wait for the next event before
            ending the iteration. If `builtins.None` then this will continue
            until explicitly broken from.
        limit : typing.Optional[builtins.int]
            The limit for how many events this should queue at one time before
            dropping extra incoming events, leave this as `builtins.None` for
            the cache size to be unlimited.

        Returns
        -------
        EventStream[hikari.events.base_events.Event]
            The async iterator to handle streamed events. This must be started
            with `async with stream:` or `await stream.open()` before
            asynchronously iterating over it.

        !!! warning
            If you use `await stream.open()` to start the stream then you must
            also close it with `await stream.close()` otherwise it may queue
            events in memory indefinitely.

        Examples
        --------

        ```py
        async with bot.stream(events.ReactionAddEvent, timeout=30).filter((&#34;message_id&#34;, message.id)) as stream:
            async for user_id in stream.map(&#34;user_id&#34;).limit(50):
                ...
        ```

        or using await `open()` and await `close()`

        ```py
        stream = bot.stream(events.ReactionAddEvent, timeout=30).filter((&#34;message_id&#34;, message.id))
        await stream.open()

        async for user_id in stream.map(&#34;user_id&#34;).limit(50)
            ...

        await stream.close()
        ```

        See Also
        --------
        Dispatch: `hikari.api.event_manager.EventManager.dispatch`
        Listen: `hikari.api.event_manager.EventManager.listen`
        Subscribe: `hikari.api.event_manager.EventManager.subscribe`
        Unsubscribe: `hikari.api.event_manager.EventManager.unsubscribe`
        Wait for: `hikari.api.event_manager.EventManager.wait_for`
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def wait_for(
        self,
        event_type: typing.Type[EventT_co],
        /,
        timeout: typing.Union[float, int, None],
        predicate: typing.Optional[PredicateT[EventT_co]] = None,
    ) -&gt; EventT_co:
        &#34;&#34;&#34;Wait for a given event to occur once, then return the event.

        Parameters
        ----------
        event_type : typing.Type[hikari.events.base_events.Event]
            The event type to listen for. This will listen for subclasses of
            this type additionally.
        predicate
            A function taking the event as the single parameter.
            This should return `builtins.True` if the event is one you want to
            return, or `builtins.False` if the event should not be returned.
            If left as `None` (the default), then the first matching event type
            that the bot receives (or any subtype) will be the one returned.

            !!! warning
                Async predicates are not supported.
        timeout : typing.Union[builtins.float, builtins.int, builtins.None]
            The amount of time to wait before raising an `asyncio.TimeoutError`
            and giving up instead. This is measured in seconds. If
            `builtins.None`, then no timeout will be waited for (no timeout can
            result in &#34;leaking&#34; of coroutines that never complete if called in
            an uncontrolled way, so is not recommended).

        Returns
        -------
        hikari.events.base_events.Event
            The event that was provided.

        Raises
        ------
        asyncio.TimeoutError
            If the timeout is not `builtins.None` and is reached before an
            event is received that the predicate returns `builtins.True` for.

        See Also
        --------
        Listen: `hikari.api.event_manager.EventManager.listen`
        Stream: `hikari.api.event_manager.EventManager.stream`
        Subscribe: `hikari.api.event_manager.EventManager.subscribe`
        Dispatch: `hikari.api.event_manager.EventManager.dispatch`
        &#34;&#34;&#34;</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventManagerBase -- Provides functionality to consume and dispatch events …" href="../impl/event_manager_base.html#hikari.impl.event_manager_base.EventManagerBase"
>EventManagerBase</a></dt>
<dd class="nested"><p>Provides functionality to consume and dispatch events …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventManager -- Base interface for event manager implementations …" href="#hikari.api.event_manager.EventManager"
>EventManager</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.api.event_manager.EventManager.consume_raw_event" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="consume_raw_event" href="#hikari.api.event_manager.EventManager.consume_raw_event" id="hikari.api.event_manager.EventManager.consume_raw_event">consume_raw_event</a>(
    event_name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    shard: <a href='shard.html#hikari.api.shard.GatewayShard'>gateway_shard.GatewayShard</a>,
    payload: <a href='../internal/data_binding.html#hikari.internal.data_binding.JSONObject'>data_binding.JSONObject</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Consume a raw event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The case-insensitive name of the event being triggered.</dd>
<dt><strong><code>shard</code></strong> :&ensp;<code><a href='shard.html#hikari.api.shard.GatewayShard'>GatewayShard</a></code></dt>
<dd>Object of the shard that received this event.</dd>
<dt><strong><code>payload</code></strong> :&ensp;<code><a href='../internal/data_binding.html#hikari.internal.data_binding.JSONObject'>JSONObject</a></code></dt>
<dd>Payload of the event being triggered.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If there is no consumer for the event.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L137-L156" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def consume_raw_event(
    self, event_name: str, shard: gateway_shard.GatewayShard, payload: data_binding.JSONObject
) -&gt; None:
    &#34;&#34;&#34;Consume a raw event.

    Parameters
    ----------
    event_name : str
        The case-insensitive name of the event being triggered.
    shard : hikari.api.shard.GatewayShard
        Object of the shard that received this event.
    payload : hikari.internal.data_binding.JSONObject
        Payload of the event being triggered.

    Raises
    ------
    builtins.LookupError
        If there is no consumer for the event.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventManager.dispatch" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="dispatch" href="#hikari.api.event_manager.EventManager.dispatch" id="hikari.api.event_manager.EventManager.dispatch">dispatch</a>(
    event: EventT_inv,
) -> <a href='https://docs.python.org/3/library/asyncio-future.html#asyncio.Future'>Future</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]: ...</code></pre>
</dt>
<dd>
<p>Dispatch an event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code></dt>
<dd>The event to dispatch.</dd>
</dl>
<h2 id="example">Example</h2>
<p>We can dispatch custom events by first defining a class that
derives from <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</p>
<pre><code class="language-py">import attr

from hikari.traits import RESTAware
from hikari.events.base_events import Event
from hikari.users import User
from hikari.snowflakes import Snowflake

@attr.define()
class EveryoneMentionedEvent(Event):
    app: RESTAware = attr.field()

    author: User = attr.field()
    '''The user who mentioned everyone.'''

    content: str = attr.field()
    '''The message that was sent.'''

    message_id: Snowflake = attr.field()
    '''The message ID.'''

    channel_id: Snowflake = attr.field()
    '''The channel ID.'''
</code></pre>
<p>We can then dispatch our event as we see fit.</p>
<pre><code class="language-py">from hikari.events.messages import MessageCreateEvent

@bot.listen(MessageCreateEvent)
async def on_message(event):
    if &quot;@everyone&quot; in event.content or &quot;@here&quot; in event.content:
        event = EveryoneMentionedEvent(
            author=event.author,
            content=event.content,
            message_id=event.id,
            channel_id=event.channel_id,
        )

        bot.dispatch(event)
</code></pre>
<p>This event can be listened to elsewhere by subscribing to it with
<code><a href='#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code>.</p>
<pre><code class="language-py">@bot.listen(EveryoneMentionedEvent)
async def on_everyone_mentioned(event):
    print(event.user, &quot;just pinged everyone in&quot;, event.channel_id)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/asyncio-future.html#asyncio.Future'>Future</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>A future that can be optionally awaited. If awaited, the future
will complete once all corresponding event listeners have been
invoked. If not awaited, this will schedule the dispatch of the
events in the background for later.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Subscribe</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code></dd>
<dt><code>Stream</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.stream'>stream</a></code>
<code>Wait <a href='https://docs.python.org/3/reference/compound_stmts.html#for'>for</a>: </code>hikari.api.event_manager.EventManager.wait_for``</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L158-L237" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def dispatch(self, event: EventT_inv) -&gt; asyncio.Future[typing.Any]:
    &#34;&#34;&#34;Dispatch an event.

    Parameters
    ----------
    event : hikari.events.base_events.Event
        The event to dispatch.

    Example
    -------
    We can dispatch custom events by first defining a class that
    derives from `hikari.events.base_events.Event`.

    ```py
    import attr

    from hikari.traits import RESTAware
    from hikari.events.base_events import Event
    from hikari.users import User
    from hikari.snowflakes import Snowflake

    @attr.define()
    class EveryoneMentionedEvent(Event):
        app: RESTAware = attr.field()

        author: User = attr.field()
        &#39;&#39;&#39;The user who mentioned everyone.&#39;&#39;&#39;

        content: str = attr.field()
        &#39;&#39;&#39;The message that was sent.&#39;&#39;&#39;

        message_id: Snowflake = attr.field()
        &#39;&#39;&#39;The message ID.&#39;&#39;&#39;

        channel_id: Snowflake = attr.field()
        &#39;&#39;&#39;The channel ID.&#39;&#39;&#39;
    ```

    We can then dispatch our event as we see fit.

    ```py
    from hikari.events.messages import MessageCreateEvent

    @bot.listen(MessageCreateEvent)
    async def on_message(event):
        if &#34;@everyone&#34; in event.content or &#34;@here&#34; in event.content:
            event = EveryoneMentionedEvent(
                author=event.author,
                content=event.content,
                message_id=event.id,
                channel_id=event.channel_id,
            )

            bot.dispatch(event)
    ```

    This event can be listened to elsewhere by subscribing to it with
    `EventManager.subscribe`.

    ```py
    @bot.listen(EveryoneMentionedEvent)
    async def on_everyone_mentioned(event):
        print(event.user, &#34;just pinged everyone in&#34;, event.channel_id)
    ```

    Returns
    -------
    asyncio.Future[typing.Any]
        A future that can be optionally awaited. If awaited, the future
        will complete once all corresponding event listeners have been
        invoked. If not awaited, this will schedule the dispatch of the
        events in the background for later.

    See Also
    --------
    Subscribe: `hikari.api.event_manager.EventManager.subscribe`
    Stream: `hikari.api.event_manager.EventManager.stream`
    Wait for: `hikari.api.event_manager.EventManager.wait_for`
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventManager.get_listeners" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_listeners" href="#hikari.api.event_manager.EventManager.get_listeners" id="hikari.api.event_manager.EventManager.get_listeners">get_listeners</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[EventT_co],
    /,
    *,
    polymorphic: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = True,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[CallbackT[EventT_co]]: ...</code></pre>
</dt>
<dd>
<p>Get the listeners for a given event type, if there are any.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[T]</code></dt>
<dd>The event type to look for.
<code>T</code> must be a subclass of <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</dd>
<dt><strong><code>polymorphic</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, this will also return the listeners of the
subclasses of the given event type. If <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, then
only listeners for this class specifically are returned. The
default is <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[T], <a href='https://docs.python.org/3/library/typing.html#typing.Coroutine'>Coroutine</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>]]</code></dt>
<dd>
<p>A copy of the collection of listeners for the event. Will return
an empty collection if nothing is registered.</p>
<p><code>T</code> must be a subclass of <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</p>
</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>Has listener: </code>hikari.api.event_manager.EventManager.has_listener``</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L311-L343" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_listeners(
    self,
    event_type: typing.Type[EventT_co],
    /,
    *,
    polymorphic: bool = True,
) -&gt; typing.Collection[CallbackT[EventT_co]]:
    &#34;&#34;&#34;Get the listeners for a given event type, if there are any.

    Parameters
    ----------
    event_type : typing.Type[T]
        The event type to look for.
        `T` must be a subclass of `hikari.events.base_events.Event`.
    polymorphic : builtins.bool
        If `builtins.True`, this will also return the listeners of the
        subclasses of the given event type. If `builtins.False`, then
        only listeners for this class specifically are returned. The
        default is `builtins.True`.

    Returns
    -------
    typing.Collection[typing.Callable[[T], typing.Coroutine[typing.Any, typing.Any, builtins.None]]
        A copy of the collection of listeners for the event. Will return
        an empty collection if nothing is registered.

        `T` must be a subclass of `hikari.events.base_events.Event`.

    See Also
    --------
    Has listener: `hikari.api.event_manager.EventManager.has_listener`
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventManager.listen" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="listen" href="#hikari.api.event_manager.EventManager.listen" id="hikari.api.event_manager.EventManager.listen">listen</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[EventT_co]] = None,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[CallbackT[EventT_co]], CallbackT[EventT_co]]: ...</code></pre>
</dt>
<dd>
<p>Generate a decorator to subscribe a callback to an event type.</p>
<p>This is a second-order decorator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[T]]</code></dt>
<dd>
<p>The event type to subscribe to. The implementation may allow this
to be undefined. If this is the case, the event type will be inferred
instead from the type hints on the function signature.</p>
<p><code>T</code> must be a subclass of <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[T], T]</code></dt>
<dd>A decorator for a coroutine function that passes it to
<code><a href='#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code> before returning the function
reference.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Dispatch</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.dispatch'>dispatch</a></code></dd>
<dt><code>Stream</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.stream'>stream</a></code></dd>
<dt><code>Subscribe</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code></dd>
<dt><code>Unsubscribe</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.unsubscribe'>unsubscribe</a></code>
<code>Wait <a href='https://docs.python.org/3/reference/compound_stmts.html#for'>for</a>: </code>hikari.api.event_manager.EventManager.wait_for``</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L345-L377" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def listen(
    self,
    event_type: typing.Optional[typing.Type[EventT_co]] = None,
) -&gt; typing.Callable[[CallbackT[EventT_co]], CallbackT[EventT_co]]:
    &#34;&#34;&#34;Generate a decorator to subscribe a callback to an event type.

    This is a second-order decorator.

    Parameters
    ----------
    event_type : typing.Optional[typing.Type[T]]
        The event type to subscribe to. The implementation may allow this
        to be undefined. If this is the case, the event type will be inferred
        instead from the type hints on the function signature.

        `T` must be a subclass of `hikari.events.base_events.Event`.

    Returns
    -------
    typing.Callable[[T], T]
        A decorator for a coroutine function that passes it to
        `EventManager.subscribe` before returning the function
        reference.

    See Also
    --------
    Dispatch: `hikari.api.event_manager.EventManager.dispatch`
    Stream: `hikari.api.event_manager.EventManager.stream`
    Subscribe: `hikari.api.event_manager.EventManager.subscribe`
    Unsubscribe: `hikari.api.event_manager.EventManager.unsubscribe`
    Wait for: `hikari.api.event_manager.EventManager.wait_for`
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventManager.stream" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="stream" href="#hikari.api.event_manager.EventManager.stream" id="hikari.api.event_manager.EventManager.stream">stream</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[EventT_co],
    /,
    timeout: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>],
    limit: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = None,
) -> <a href='#hikari.api.event_manager.EventStream'>EventStream</a>[EventT_co]: ...</code></pre>
</dt>
<dd>
<p>Return a stream iterator for the given event and sub-events.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a>]</code></dt>
<dd>The event type to listen for. This will listen for subclasses of
this type additionally.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='https://docs.python.org/3/library/functions.html#float'>float</a>]</code></dt>
<dd>How long this streamer should wait for the next event before
ending the iteration. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then this will continue
until explicitly broken from.</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>The limit for how many events this should queue at one time before
dropping extra incoming events, leave this as <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> for
the cache size to be unlimited.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.api.event_manager.EventStream'>EventStream</a>[<a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a>]</code></dt>
<dd>The async iterator to handle streamed events. This must be started
with <code><a href='https://docs.python.org/3/reference/compound_stmts.html#async'>async</a> <a href='https://docs.python.org/3/reference/compound_stmts.html#with'>with</a> stream:</code> or <code><a href='https://docs.python.org/3/reference/expressions.html#await'>await</a> stream.open()</code> before
asynchronously iterating over it.</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you use <code><a href='https://docs.python.org/3/reference/expressions.html#await'>await</a> stream.open()</code> to start the stream then you must
also close it with <code><a href='https://docs.python.org/3/reference/expressions.html#await'>await</a> stream.close()</code> otherwise it may queue
events in memory indefinitely.</p>
</div>
<h2 id="examples">Examples</h2>
<pre><code class="language-py">async with bot.stream(events.ReactionAddEvent, timeout=30).filter((&quot;message_id&quot;, message.id)) as stream:
    async for user_id in stream.map(&quot;user_id&quot;).limit(50):
        ...
</code></pre>
<p>or using await <code><a href='https://docs.python.org/3/library/functions.html#open'>open</a>()</code> and await <code>close()</code></p>
<pre><code class="language-py">stream = bot.stream(events.ReactionAddEvent, timeout=30).filter((&quot;message_id&quot;, message.id))
await stream.open()

async for user_id in stream.map(&quot;user_id&quot;).limit(50)
    ...

await stream.close()
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Dispatch</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.dispatch'>dispatch</a></code></dd>
<dt><code>Listen</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.listen'>listen</a></code></dd>
<dt><code>Subscribe</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code></dd>
<dt><code>Unsubscribe</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.unsubscribe'>unsubscribe</a></code>
<code>Wait <a href='https://docs.python.org/3/reference/compound_stmts.html#for'>for</a>: </code>hikari.api.event_manager.EventManager.wait_for``</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L379-L443" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def stream(
    self,
    event_type: typing.Type[EventT_co],
    /,
    timeout: typing.Union[float, int, None],
    limit: typing.Optional[int] = None,
) -&gt; EventStream[EventT_co]:
    &#34;&#34;&#34;Return a stream iterator for the given event and sub-events.

    Parameters
    ----------
    event_type : typing.Type[hikari.events.base_events.Event]
        The event type to listen for. This will listen for subclasses of
        this type additionally.
    timeout : typing.Optional[builtins.int, builtins.float]
        How long this streamer should wait for the next event before
        ending the iteration. If `builtins.None` then this will continue
        until explicitly broken from.
    limit : typing.Optional[builtins.int]
        The limit for how many events this should queue at one time before
        dropping extra incoming events, leave this as `builtins.None` for
        the cache size to be unlimited.

    Returns
    -------
    EventStream[hikari.events.base_events.Event]
        The async iterator to handle streamed events. This must be started
        with `async with stream:` or `await stream.open()` before
        asynchronously iterating over it.

    !!! warning
        If you use `await stream.open()` to start the stream then you must
        also close it with `await stream.close()` otherwise it may queue
        events in memory indefinitely.

    Examples
    --------

    ```py
    async with bot.stream(events.ReactionAddEvent, timeout=30).filter((&#34;message_id&#34;, message.id)) as stream:
        async for user_id in stream.map(&#34;user_id&#34;).limit(50):
            ...
    ```

    or using await `open()` and await `close()`

    ```py
    stream = bot.stream(events.ReactionAddEvent, timeout=30).filter((&#34;message_id&#34;, message.id))
    await stream.open()

    async for user_id in stream.map(&#34;user_id&#34;).limit(50)
        ...

    await stream.close()
    ```

    See Also
    --------
    Dispatch: `hikari.api.event_manager.EventManager.dispatch`
    Listen: `hikari.api.event_manager.EventManager.listen`
    Subscribe: `hikari.api.event_manager.EventManager.subscribe`
    Unsubscribe: `hikari.api.event_manager.EventManager.unsubscribe`
    Wait for: `hikari.api.event_manager.EventManager.wait_for`
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventManager.subscribe" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="subscribe" href="#hikari.api.event_manager.EventManager.subscribe" id="hikari.api.event_manager.EventManager.subscribe">subscribe</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>],
    callback: CallbackT[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Subscribe a given callback to a given event type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[T]</code></dt>
<dd>The event type to listen for. This will also listen for any
subclasses of the given type.
<code>T</code> must be a subclass of <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</dd>
<dt><strong><code>callback</code></strong></dt>
<dd>Must be a coroutine function to invoke. This should
consume an instance of the given event, or an instance of a valid
subclass if one exists. Any result is discarded.</dd>
</dl>
<h2 id="example">Example</h2>
<p>The following demonstrates subscribing a callback to message creation
events.</p>
<pre><code class="language-py">from hikari.events.messages import MessageCreateEvent

async def on_message(event):
    ...

bot.subscribe(MessageCreateEvent, on_message)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Listen</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.listen'>listen</a></code></dd>
<dt><code>Stream</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.stream'>stream</a></code>
<code>Wait <a href='https://docs.python.org/3/reference/compound_stmts.html#for'>for</a>: </code>hikari.api.event_manager.EventManager.wait_for``</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L243-L277" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def subscribe(self, event_type: typing.Type[typing.Any], callback: CallbackT[typing.Any]) -&gt; None:
    &#34;&#34;&#34;Subscribe a given callback to a given event type.

    Parameters
    ----------
    event_type : typing.Type[T]
        The event type to listen for. This will also listen for any
        subclasses of the given type.
        `T` must be a subclass of `hikari.events.base_events.Event`.
    callback
        Must be a coroutine function to invoke. This should
        consume an instance of the given event, or an instance of a valid
        subclass if one exists. Any result is discarded.

    Example
    -------
    The following demonstrates subscribing a callback to message creation
    events.

    ```py
    from hikari.events.messages import MessageCreateEvent

    async def on_message(event):
        ...

    bot.subscribe(MessageCreateEvent, on_message)
    ```

    See Also
    --------
    Listen: `hikari.api.event_manager.EventManager.listen`
    Stream: `hikari.api.event_manager.EventManager.stream`
    Wait for: `hikari.api.event_manager.EventManager.wait_for`
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventManager.unsubscribe" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="unsubscribe" href="#hikari.api.event_manager.EventManager.unsubscribe" id="hikari.api.event_manager.EventManager.unsubscribe">unsubscribe</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>],
    callback: CallbackT[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Unsubscribe a given callback from a given event type, if present.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[T]</code></dt>
<dd>The event type to unsubscribe from. This must be the same exact
type as was originally subscribed with to be removed correctly.
<code>T</code> must derive from <code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code>.</dd>
<dt><strong><code>callback</code></strong></dt>
<dd>The callback to unsubscribe.</dd>
</dl>
<h2 id="example">Example</h2>
<p>The following demonstrates unsubscribing a callback from a message
creation event.</p>
<pre><code class="language-py">from hikari.events.messages import MessageCreateEvent

async def on_message(event):
    ...

bot.unsubscribe(MessageCreateEvent, on_message)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L283-L309" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def unsubscribe(self, event_type: typing.Type[typing.Any], callback: CallbackT[typing.Any]) -&gt; None:
    &#34;&#34;&#34;Unsubscribe a given callback from a given event type, if present.

    Parameters
    ----------
    event_type : typing.Type[T]
        The event type to unsubscribe from. This must be the same exact
        type as was originally subscribed with to be removed correctly.
        `T` must derive from `hikari.events.base_events.Event`.
    callback
        The callback to unsubscribe.

    Example
    -------
    The following demonstrates unsubscribing a callback from a message
    creation event.

    ```py
    from hikari.events.messages import MessageCreateEvent

    async def on_message(event):
        ...

    bot.unsubscribe(MessageCreateEvent, on_message)
    ```
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventManager.wait_for" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="wait_for" href="#hikari.api.event_manager.EventManager.wait_for" id="hikari.api.event_manager.EventManager.wait_for">wait_for</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[EventT_co],
    /,
    timeout: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>],
    predicate: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[PredicateT[EventT_co]] = None,
) -> EventT_co: ...</code></pre>
</dt>
<dd>
<p>Wait for a given event to occur once, then return the event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a>]</code></dt>
<dd>The event type to listen for. This will listen for subclasses of
this type additionally.</dd>
<dt><strong><code>predicate</code></strong></dt>
<dd>
<p>A function taking the event as the single parameter.
This should return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if the event is one you want to
return, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> if the event should not be returned.
If left as <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> (the default), then the first matching event type
that the bot receives (or any subtype) will be the one returned.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Async predicates are not supported.</p>
</div>
</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>]</code></dt>
<dd>The amount of time to wait before raising an <code><a href='https://docs.python.org/3/library/asyncio-exceptions.html#asyncio.TimeoutError'>TimeoutError</a></code>
and giving up instead. This is measured in seconds. If
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then no timeout will be waited for (no timeout can
result in "leaking" of coroutines that never complete if called in
an uncontrolled way, so is not recommended).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../events/base_events.html#hikari.events.base_events.Event'>Event</a></code></dt>
<dd>The event that was provided.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/asyncio-exceptions.html#asyncio.TimeoutError'>TimeoutError</a></code></dt>
<dd>If the timeout is not <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> and is reached before an
event is received that the predicate returns <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> for.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Listen</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.listen'>listen</a></code></dd>
<dt><code>Stream</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.stream'>stream</a></code></dd>
<dt><code>Subscribe</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.subscribe'>subscribe</a></code></dd>
<dt><code>Dispatch</code></dt>
<dd><code><a href='#hikari.api.event_manager.EventManager.dispatch'>dispatch</a></code></dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L445-L493" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def wait_for(
    self,
    event_type: typing.Type[EventT_co],
    /,
    timeout: typing.Union[float, int, None],
    predicate: typing.Optional[PredicateT[EventT_co]] = None,
) -&gt; EventT_co:
    &#34;&#34;&#34;Wait for a given event to occur once, then return the event.

    Parameters
    ----------
    event_type : typing.Type[hikari.events.base_events.Event]
        The event type to listen for. This will listen for subclasses of
        this type additionally.
    predicate
        A function taking the event as the single parameter.
        This should return `builtins.True` if the event is one you want to
        return, or `builtins.False` if the event should not be returned.
        If left as `None` (the default), then the first matching event type
        that the bot receives (or any subtype) will be the one returned.

        !!! warning
            Async predicates are not supported.
    timeout : typing.Union[builtins.float, builtins.int, builtins.None]
        The amount of time to wait before raising an `asyncio.TimeoutError`
        and giving up instead. This is measured in seconds. If
        `builtins.None`, then no timeout will be waited for (no timeout can
        result in &#34;leaking&#34; of coroutines that never complete if called in
        an uncontrolled way, so is not recommended).

    Returns
    -------
    hikari.events.base_events.Event
        The event that was provided.

    Raises
    ------
    asyncio.TimeoutError
        If the timeout is not `builtins.None` and is reached before an
        event is received that the predicate returns `builtins.True` for.

    See Also
    --------
    Listen: `hikari.api.event_manager.EventManager.listen`
    Stream: `hikari.api.event_manager.EventManager.stream`
    Subscribe: `hikari.api.event_manager.EventManager.subscribe`
    Dispatch: `hikari.api.event_manager.EventManager.dispatch`
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
<div id="hikari.api.event_manager.EventStream" class="anchor">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventStream -- A base abstract class for all event streamers …" href="#hikari.api.event_manager.EventStream"
>EventStream</a></h4>
</dt>
<dd>
<pre><code id="hikari.api.event_manager.EventStream" class="hljs python"><abbr title='A standard Python type.'>class</abbr> EventStream (
    *args,
    **kwds,
): ...</code></pre>
<p>A base abstract class for all event streamers.</p>
<p>Unlike <code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a></code> (which this extends), an event
streamer must be started and closed.</p>
<h2 id="examples">Examples</h2>
<p>A streamer may either be started and closed using <code><a href='https://docs.python.org/3/reference/compound_stmts.html#async'>async</a> <a href='https://docs.python.org/3/reference/compound_stmts.html#with'>with</a></code> syntax
where <code><a href='#hikari.api.event_manager.EventStream.open'>open</a></code> and <code><a href='#hikari.api.event_manager.EventStream.close'>close</a></code> are implicitly called based on
context.</p>
<pre><code class="language-py">async with EventStream(app, EventType, timeout=50) as stream:
    async for entry in stream:
        ...
</code></pre>
<p>A streamer may also be directly started and closed using the <code><a href='#hikari.api.event_manager.EventStream.close'>close</a></code>
and <code><a href='#hikari.api.event_manager.EventStream.open'>open</a></code>. Note that if you don't call <code><a href='#hikari.api.event_manager.EventStream.close'>close</a></code> after
opening a streamer when you're finished with it then it may queue events
events in memory indefinitely.</p>
<pre><code class="language-py">stream = EventStream(app, EventType, timeout=50)
await stream.open()
async for event in stream:
    ...

await stream.close()
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>LazyIterator</code></dt>
<dd><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a></code></dd>
</dl>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L52-L124" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class EventStream(iterators.LazyIterator[EventT], abc.ABC):
    &#34;&#34;&#34;A base abstract class for all event streamers.

    Unlike `hikari.iterators.LazyIterator` (which this extends), an event
    streamer must be started and closed.

    Examples
    --------
    A streamer may either be started and closed using `async with` syntax
    where `EventStream.open` and `EventStream.close` are implicitly called based on
    context.

    ```py
    async with EventStream(app, EventType, timeout=50) as stream:
        async for entry in stream:
            ...
    ```

    A streamer may also be directly started and closed using the `EventStream.close`
    and `EventStream.open`. Note that if you don&#39;t call `EventStream.close` after
    opening a streamer when you&#39;re finished with it then it may queue events
    events in memory indefinitely.

    ```py
    stream = EventStream(app, EventType, timeout=50)
    await stream.open()
    async for event in stream:
        ...

    await stream.close()
    ```

    See Also
    --------
    LazyIterator: `hikari.iterators.LazyIterator`
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Mark this streamer as closed to stop it from queueing and receiving events.

        If called on an already closed streamer then this will do nothing.

        !!! note
            `async with streamer` may be used as a short-cut for opening and
            closing a streamer.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def open(self) -&gt; None:
        &#34;&#34;&#34;Mark this streamer as opened to let it start receiving and queueing events.

        If called on an already started streamer then this will do nothing.

        !!! note
            `async with streamer` may be used as a short-cut for opening and
            closing a stream.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def __aenter__(self) -&gt; EventStream[EventT]:
        raise NotImplementedError

    @abc.abstractmethod
    async def __aexit__(
        self,
        exc_type: typing.Optional[typing.Type[BaseException]],
        exc: typing.Optional[BaseException],
        exc_tb: typing.Optional[types.TracebackType],
    ) -&gt; None:
        raise NotImplementedError</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventStream -- An implementation of an event `EventStream` class …" href="../impl/event_manager_base.html#hikari.impl.event_manager_base.EventStream"
>EventStream</a></dt>
<dd class="nested"><p>An implementation of an event <code><a href='#hikari.api.event_manager.EventStream'>EventStream</a></code> class …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="EventStream -- A base abstract class for all event streamers …" href="#hikari.api.event_manager.EventStream"
>EventStream</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></dt>
<dd class="nested"><p>A set of results that are fetched asynchronously from the API as needed …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<div id="hikari.api.event_manager.EventStream.awaiting" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="awaiting" href="../iterators.html#hikari.iterators.LazyIterator.awaiting" id="hikari.api.event_manager.EventStream.awaiting">awaiting</a>(
    window_size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 10,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="awaiting -- Await each item concurrently in a fixed size window …" href="../iterators.html#hikari.iterators.LazyIterator.awaiting"
>awaiting</a></code>
</p>
<p>Await each item concurrently in a fixed size window.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>window_size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The window size of how many tasks to await at once. You can set this
to <code>0</code> to await everything at once, but see the below warning.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>The new lazy iterator to return.</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Setting a large window size, or setting it to 0 to await everything
is a dangerous thing to do if you are making API calls. Some
endpoints will get ratelimited and cause a backup of waiting
tasks, others may begin to spam global rate limits instead
(the <code>fetch_user</code> endpoint seems to be notorious for doing this).</p>
</div>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This call assumes that the iterator contains awaitable values as
input. MyPy cannot detect this nicely, so any cast is forced
internally.</p>
<p>If the item is not awaitable, you will receive a
<code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code> instead.</p>
<p>You have been warned. You cannot escape the ways of the duck type
young grasshopper.</p>
</div>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.chunk" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="chunk" href="../iterators.html#hikari.iterators.LazyIterator.chunk" id="hikari.api.event_manager.EventStream.chunk">chunk</a>(
    chunk_size: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="chunk -- Return results in chunks of up to `chunk_size` amount of entries …" href="../iterators.html#hikari.iterators.LazyIterator.chunk"
>chunk</a></code>
</p>
<p>Return results in chunks of up to <code>chunk_size</code> amount of entries.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chunk_size</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The limit for how many results should be returned in each chunk.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[ValueT]]</code></dt>
<dd><code>LazyIterator</code> that emits each chunked sequence.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.close" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="close" href="#hikari.api.event_manager.EventStream.close" id="hikari.api.event_manager.EventStream.close">close</a>() -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Mark this streamer as closed to stop it from queueing and receiving events.</p>
<p>If called on an already closed streamer then this will do nothing.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p><code><a href='https://docs.python.org/3/reference/compound_stmts.html#async'>async</a> <a href='https://docs.python.org/3/reference/compound_stmts.html#with'>with</a> streamer</code> may be used as a short-cut for opening and
closing a streamer.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L91-L100" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def close(self) -&gt; None:
    &#34;&#34;&#34;Mark this streamer as closed to stop it from queueing and receiving events.

    If called on an already closed streamer then this will do nothing.

    !!! note
        `async with streamer` may be used as a short-cut for opening and
        closing a streamer.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.collect" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="collect" href="../iterators.html#hikari.iterators.LazyIterator.collect" id="hikari.api.event_manager.EventStream.collect">collect</a>(
    collector: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]], <a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='#hikari.iterators.ValueT'>ValueT</a>]],
) -> Collection[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="collect -- Collect the results into a given type and return it …" href="../iterators.html#hikari.iterators.LazyIterator.collect"
>collect</a></code>
</p>
<p>Collect the results into a given type and return it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>collector</code></strong></dt>
<dd>A function that consumes a sequence of values and returns a
collection.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.count" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="count" href="../iterators.html#hikari.iterators.LazyIterator.count" id="hikari.api.event_manager.EventStream.count">count</a>() -> <a href='https://docs.python.org/3/library/functions.html#int'>int</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="count -- Count the number of results …" href="../iterators.html#hikari.iterators.LazyIterator.count"
>count</a></code>
</p>
<p>Count the number of results.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Number of results found.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.enumerate" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="enumerate" href="../iterators.html#hikari.iterators.LazyIterator.enumerate" id="hikari.api.event_manager.EventStream.enumerate">enumerate</a>(
    *,
    start: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 0,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, ~<a href='#hikari.iterators.ValueT'>ValueT</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="enumerate -- Enumerate the paginated results lazily …" href="../iterators.html#hikari.iterators.LazyIterator.enumerate"
>enumerate</a></code>
</p>
<p>Enumerate the paginated results lazily.</p>
<p>This behaves as an asyncio-friendly version of <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code>
which uses much less memory than collecting all the results first and
calling <code><a href='https://docs.python.org/3/library/functions.html#enumerate'>enumerate</a></code> across them.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Optional int to start at. If omitted, this is <code>0</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; async for i, item in paginated_results.enumerate():
...    print(i, item)
(0, foo)
(1, bar)
(2, baz)
(3, bork)
(4, qux)

&gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9):
...    print(i, item)
(9, foo)
(10, bar)
(11, baz)
(12, bork)
(13, qux)

&gt;&gt;&gt; async for i, item in paginated_results.enumerate(start=9).limit(3):
...    print(i, item)
(9, foo)
(10, bar)
(11, baz)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, T]]</code></dt>
<dd>A paginated results view that asynchronously yields an increasing
counter in a tuple with each result, lazily.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.filter" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="filter" href="../iterators.html#hikari.iterators.LazyIterator.filter" id="hikari.api.event_manager.EventStream.filter">filter</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="filter -- Filter the items by one or more conditions …" href="../iterators.html#hikari.iterators.LazyIterator.filter"
>filter</a></code>
</p>
<p>Filter the items by one or more conditions.</p>
<p>Each condition is treated as a predicate, being called with each item
that this iterator would return when it is requested.</p>
<p>All conditions must evaluate to <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> for the item to be
returned. If this is not met, then the item is discarded and ignored,
the next matching item will be returned instead, if there is one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.filter(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd><code>LazyIterator</code> that only emits values where all conditions are
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.flat_map" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="flat_map" href="../iterators.html#hikari.iterators.LazyIterator.flat_map" id="hikari.api.event_manager.EventStream.flat_map">flat_map</a>(
    flattener: _FlattenerT[<a href='#hikari.iterators.ValueT'>ValueT</a>, <a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>],
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="flat_map -- Perform a flat mapping operation …" href="../iterators.html#hikari.iterators.LazyIterator.flat_map"
>flat_map</a></code>
</p>
<p>Perform a flat mapping operation.</p>
<p>This will pass each item in the iterator to the given <code><a href='https://docs.python.org/3/reference/compound_stmts.html#function'>function</a></code>
parameter, expecting a new <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code> or <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code>
to be returned as the result. This means you can map to a new
<code>LazyIterator</code>, <code><a href='https://docs.python.org/3/library/typing.html#typing.AsyncIterator'>AsyncIterator</a></code>, <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code>,
async generator, or generator.</p>
<p>Remember that <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterator'>Iterator</a></code> implicitly provides <code><a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a></code>
compatibility.</p>
<p>This is used to provide lazy conversions, and can be used to implement
reactive-like pipelines if desired.</p>
<p>All results are combined into one large lazy iterator and yielded
lazily.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flattener</code></strong></dt>
<dd>A function that returns either an async iterator or iterator of
new values. Could be an attribute name instead.</dd>
</dl>
<h2 id="example">Example</h2>
<p>The following example generates a distinct collection of all mentioned
users in the given channel from the past 500 messages.</p>
<pre><code class="language-py">def iter_mentioned_users(message: hikari.Message) -&gt; typing.Iterable[Snowflake]:
    for match in re.findall(r&quot;&lt;@!?(\d+)&gt;&quot;, message.content):
        yield Snowflake(match)

mentioned_users = await (
    channel
    .history()
    .limit(500)
    .map(&quot;.content&quot;)
    .flat_map(iter_mentioned_users)
    .distinct()
)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[AnotherValueT]</code></dt>
<dd>The new lazy iterator to return.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.for_each" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="for_each" href="../iterators.html#hikari.iterators.LazyIterator.for_each" id="hikari.api.event_manager.EventStream.for_each">for_each</a>(
    consumer: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="for_each -- Pass each value to a given consumer immediately." href="../iterators.html#hikari.iterators.LazyIterator.for_each"
>for_each</a></code>
</p>
<p>Pass each value to a given consumer immediately.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.last" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="last" href="../iterators.html#hikari.iterators.LazyIterator.last" id="hikari.api.event_manager.EventStream.last">last</a>() -> ~<a href='#hikari.iterators.ValueT'>ValueT</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="last -- Return the last element of this iterator only …" href="../iterators.html#hikari.iterators.LazyIterator.last"
>last</a></code>
</p>
<p>Return the last element of this iterator only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ValueT</code></dt>
<dd>The last result.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This method will consume the whole iterator if run.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If no result exists.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.limit" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="limit" href="../iterators.html#hikari.iterators.LazyIterator.limit" id="hikari.api.event_manager.EventStream.limit">limit</a>(
    limit: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="limit -- Limit the number of items you receive from this async iterator …" href="../iterators.html#hikari.iterators.LazyIterator.limit"
>limit</a></code>
</p>
<p>Limit the number of items you receive from this async iterator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The number of items to get. This must be greater than zero.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; async for item in paginated_results.limit(3):
...     print(item)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>A paginated results view that asynchronously yields a maximum
of the given number of items before completing.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.map" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="map" href="../iterators.html#hikari.iterators.LazyIterator.map" id="hikari.api.event_manager.EventStream.map">map</a>(
    transformation: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>], <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.AnotherValueT'>AnotherValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="map -- Map the values to a different value …" href="../iterators.html#hikari.iterators.LazyIterator.map"
>map</a></code>
</p>
<p>Map the values to a different value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transformation</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The function to use to map the attribute. This may alternatively
be a string attribute name to replace the input value with. You
can provide nested attributes using the <code>.</code> operator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[AnotherValueT]</code></dt>
<dd><code>LazyIterator</code> that maps each value to another value.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.next" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="next" href="../iterators.html#hikari.iterators.LazyIterator.next" id="hikari.api.event_manager.EventStream.next">next</a>() -> ~<a href='#hikari.iterators.ValueT'>ValueT</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="next -- Return the next element of this iterator only …" href="../iterators.html#hikari.iterators.LazyIterator.next"
>next</a></code>
</p>
<p>Return the next element of this iterator only.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ValueT</code></dt>
<dd>The next result.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#LookupError'>LookupError</a></code></dt>
<dd>If no more results exist.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.open" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="open" href="#hikari.api.event_manager.EventStream.open" id="hikari.api.event_manager.EventStream.open">open</a>() -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Mark this streamer as opened to let it start receiving and queueing events.</p>
<p>If called on an already started streamer then this will do nothing.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p><code><a href='https://docs.python.org/3/reference/compound_stmts.html#async'>async</a> <a href='https://docs.python.org/3/reference/compound_stmts.html#with'>with</a> streamer</code> may be used as a short-cut for opening and
closing a stream.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/3bdf1e44d6f73760631a8d27dd70a5783da80ceb/hikari/api/event_manager.py#L102-L111" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def open(self) -&gt; None:
    &#34;&#34;&#34;Mark this streamer as opened to let it start receiving and queueing events.

    If called on an already started streamer then this will do nothing.

    !!! note
        `async with streamer` may be used as a short-cut for opening and
        closing a stream.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.reversed" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="reversed" href="../iterators.html#hikari.iterators.LazyIterator.reversed" id="hikari.api.event_manager.EventStream.reversed">reversed</a>() -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="reversed -- Return a lazy iterator of the remainder of this iterator's values reversed …" href="../iterators.html#hikari.iterators.LazyIterator.reversed"
>reversed</a></code>
</p>
<p>Return a lazy iterator of the remainder of this iterator's values reversed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>The lazy iterator of this iterator's remaining values reversed.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.skip" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip" href="../iterators.html#hikari.iterators.LazyIterator.skip" id="hikari.api.event_manager.EventStream.skip">skip</a>(
    number: <a href='https://docs.python.org/3/library/functions.html#int'>int</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="skip -- Drop the given number of items, then yield anything after …" href="../iterators.html#hikari.iterators.LazyIterator.skip"
>skip</a></code>
</p>
<p>Drop the given number of items, then yield anything after.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The max number of items to drop before any items are yielded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>A paginated results view that asynchronously yields all items
AFTER the given number of items are discarded first.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.skip_until" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip_until" href="../iterators.html#hikari.iterators.LazyIterator.skip_until" id="hikari.api.event_manager.EventStream.skip_until">skip_until</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="skip_until -- Discard items while all conditions are False …" href="../iterators.html#hikari.iterators.LazyIterator.skip_until"
>skip_until</a></code>
</p>
<p>Discard items while all conditions are False.</p>
<p>Items after this will be yielded as normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes are
referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.skip_until(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>LazyIterator that only emits values once a condition has failed.
All items before this are discarded.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.skip_while" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="skip_while" href="../iterators.html#hikari.iterators.LazyIterator.skip_while" id="hikari.api.event_manager.EventStream.skip_while">skip_while</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="skip_while -- Discard items while all conditions are True …" href="../iterators.html#hikari.iterators.LazyIterator.skip_while"
>skip_while</a></code>
</p>
<p>Discard items while all conditions are True.</p>
<p>Items after this will be yielded as normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.skip_while(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>LazyIterator that only emits values once a condition has been met.
All items before this are discarded.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.sort" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="sort" href="../iterators.html#hikari.iterators.LazyIterator.sort" id="hikari.api.event_manager.EventStream.sort">sort</a>(
    *,
    key: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a> = None,
    reverse: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> Sequence[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="sort -- Collect all results, then sort the collection before returning it." href="../iterators.html#hikari.iterators.LazyIterator.sort"
>sort</a></code>
</p>
<p>Collect all results, then sort the collection before returning it.</p>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.take_until" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="take_until" href="../iterators.html#hikari.iterators.LazyIterator.take_until" id="hikari.api.event_manager.EventStream.take_until">take_until</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="take_until -- Return each item until any conditions pass or the end is reached …" href="../iterators.html#hikari.iterators.LazyIterator.take_until"
>take_until</a></code>
</p>
<p>Return each item until any conditions pass or the end is reached.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes are
referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.take_until(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>LazyIterator that only emits values until any conditions are
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
<div id="hikari.api.event_manager.EventStream.take_while" class="anchor">
<dt>
<pre><code class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="take_while" href="../iterators.html#hikari.iterators.LazyIterator.take_while" id="hikari.api.event_manager.EventStream.take_while">take_while</a>(
    *predicates: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.iterators.ValueT'>ValueT</a>], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]],
    **attrs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> <a href='#hikari.iterators.LazyIterator'>LazyIterator</a>[~<a href='#hikari.iterators.ValueT'>ValueT</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="LazyIterator -- A set of results that are fetched asynchronously from the API as needed …" href="../iterators.html#hikari.iterators.LazyIterator"
>LazyIterator</a></code>.<code><a title="take_while -- Return each item until any conditions fail or the end is reached …" href="../iterators.html#hikari.iterators.LazyIterator.take_while"
>take_while</a></code>
</p>
<p>Return each item until any conditions fail or the end is reached.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*predicates</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[ValueT], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]]</code></dt>
<dd>Predicates to invoke. These are functions that take a value and
return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if it is of interest, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>
otherwise. These may instead include 2-<code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a></code> objects
consisting of a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> attribute name (nested attributes
are referred to using the <code>.</code> operator), and values to compare for
equality. This allows you to specify conditions such as
<code>members.take_while(("user.bot", <a href='https://docs.python.org/3/library/constants.html#True'>True</a>))</code>.</dd>
<dt><strong><code>**attrs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Alternative to passing 2-tuples. Cannot specify nested attributes
using this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>LazyIterator[ValueT]</code></dt>
<dd>LazyIterator that only emits values until any conditions are not
matched.</dd>
</dl>
</dd>
</div>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</div>
</dl>
</section>
</div>
</div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>